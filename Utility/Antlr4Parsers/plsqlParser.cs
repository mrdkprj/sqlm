//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.3
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:\DevProjects\MasudaManager\MasudaManager\MasudaManager\Grammars\plsql.g4 by ANTLR 4.3

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591

namespace MasudaManager.Utility {
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using System.Collections.Generic;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.3")]
[System.CLSCompliant(false)]
public partial class plsqlParser : Parser {
	public const int
		T__0=1, A_LETTER=2, ADD=3, AFTER=4, AGENT=5, AGGREGATE=6, ALL=7, ALTER=8, 
		ANALYZE=9, AND=10, ANY=11, ARRAY=12, AS=13, ASC=14, ASSOCIATE=15, AT=16, 
		ATTRIBUTE=17, AUDIT=18, AUTHID=19, AUTO=20, AUTOMATIC=21, AUTONOMOUS_TRANSACTION=22, 
		BATCH=23, BEFORE=24, BEGIN=25, BETWEEN=26, BFILE=27, BINARY_DOUBLE=28, 
		BINARY_FLOAT=29, BINARY_INTEGER=30, BLOB=31, BLOCK=32, BODY=33, BOOLEAN=34, 
		BOTH=35, BREADTH=36, BULK=37, BY=38, BYTE=39, C_LETTER=40, CACHE=41, CALL=42, 
		CANONICAL=43, CASCADE=44, CASE=45, CAST=46, CHAR=47, CHAR_CS=48, CHARACTER=49, 
		CHECK=50, CHR=51, CLOB=52, CLOSE=53, CLUSTER=54, COALESCE=55, COLLECT=56, 
		COLUMNS=57, COMMENT=58, COMMIT=59, COMMITTED=60, COMPATIBILITY=61, COMPILE=62, 
		COMPOUND=63, CONNECT=64, CONNECT_BY_ROOT=65, CONSTANT=66, CONSTRAINT=67, 
		CONSTRAINTS=68, CONSTRUCTOR=69, CONTENT=70, CONTEXT=71, CONTINUE=72, CONVERT=73, 
		CORRUPT_XID=74, CORRUPT_XID_ALL=75, COST=76, COUNT=77, CREATE=78, CROSS=79, 
		CUBE=80, CURRENT=81, CURRENT_USER=82, CURSOR=83, CUSTOMDATUM=84, CYCLE=85, 
		DATA=86, DATABASE=87, DATE=88, DAY=89, DB_ROLE_CHANGE=90, DBTIMEZONE=91, 
		DDL=92, DEBUG=93, DEC=94, DECIMAL=95, DECLARE=96, DECOMPOSE=97, DECREMENT=98, 
		DEFAULT=99, DEFAULTS=100, DEFERRED=101, DEFINER=102, DELETE=103, DEPTH=104, 
		DESC=105, DETERMINISTIC=106, DIMENSION=107, DISABLE=108, DISASSOCIATE=109, 
		DISTINCT=110, DOCUMENT=111, DOUBLE=112, DROP=113, DSINTERVAL_UNCONSTRAINED=114, 
		EACH=115, ELEMENT=116, ELSE=117, ELSIF=118, EMPTY=119, ENABLE=120, ENCODING=121, 
		END=122, ENTITYESCAPING=123, ERR=124, ERRORS=125, ESCAPE=126, EVALNAME=127, 
		EXCEPTION=128, EXCEPTION_INIT=129, EXCEPTIONS=130, EXCLUDE=131, EXCLUSIVE=132, 
		EXECUTE=133, EXISTS=134, EXIT=135, EXPLAIN=136, EXTERNAL=137, EXTRACT=138, 
		FAILURE=139, FALSE=140, FETCH=141, FINAL=142, FIRST=143, FIRST_VALUE=144, 
		FLOAT=145, FOLLOWING=146, FOLLOWS=147, FOR=148, FORALL=149, FORCE=150, 
		FROM=151, FULL=152, FUNCTION=153, GOTO=154, GRANT=155, GROUP=156, GROUPING=157, 
		HASH=158, HAVING=159, HIDE=160, HOUR=161, IF=162, IGNORE=163, IMMEDIATE=164, 
		IN=165, INCLUDE=166, INCLUDING=167, INCREMENT=168, INDENT=169, INDEX=170, 
		INDEXED=171, INDICATOR=172, INDICES=173, INFINITE=174, INLINE=175, INNER=176, 
		INOUT=177, INSERT=178, INSTANTIABLE=179, INSTEAD=180, INT=181, INTEGER=182, 
		INTERSECT=183, INTERVAL=184, INTO=185, INVALIDATE=186, IS=187, ISOLATION=188, 
		ITERATE=189, JAVA=190, JOIN=191, KEEP=192, LANGUAGE=193, LAST=194, LAST_VALUE=195, 
		LEADING=196, LEFT=197, LEVEL=198, LIBRARY=199, LIKE=200, LIKE2=201, LIKE4=202, 
		LIKEC=203, LIMIT=204, LOCAL=205, LOCK=206, LOCKED=207, LOG=208, LOGOFF=209, 
		LOGON=210, LONG=211, LOOP=212, MAIN=213, MAP=214, MATCHED=215, MAXVALUE=216, 
		MEASURES=217, MEMBER=218, MERGE=219, MINUS=220, MINUTE=221, MINVALUE=222, 
		MLSLABEL=223, MODE=224, MODEL=225, MODIFY=226, MONTH=227, MULTISET=228, 
		NAME=229, NAN=230, NATURAL=231, NATURALN=232, NAV=233, NCHAR=234, NCHAR_CS=235, 
		NCLOB=236, NESTED=237, NEW=238, NO=239, NOAUDIT=240, NOCACHE=241, NOCOPY=242, 
		NOCYCLE=243, NOENTITYESCAPING=244, NOMAXVALUE=245, NOMINVALUE=246, NONE=247, 
		NOORDER=248, NOSCHEMACHECK=249, NOT=250, NOWAIT=251, NULL=252, NULLS=253, 
		NUMBER=254, NUMERIC=255, NVARCHAR2=256, OBJECT=257, OF=258, OFF=259, OID=260, 
		OLD=261, ON=262, ONLY=263, OPEN=264, OPTION=265, OR=266, ORADATA=267, 
		ORDER=268, ORDINALITY=269, OSERROR=270, OUT=271, OUTER=272, OVER=273, 
		OVERRIDING=274, PACKAGE=275, PARALLEL_ENABLE=276, PARAMETERS=277, PARENT=278, 
		PARTITION=279, PASSING=280, PATH=281, PERCENT_ISOPEN=282, PERCENT_FOUND=283, 
		PERCENT_NOTFOUND=284, PERCENT_ROWCOUNT=285, PERCENT_ROWTYPE=286, PERCENT_TYPE=287, 
		PIPELINED=288, PIVOT=289, PLAN=290, PLS_INTEGER=291, POSITIVE=292, POSITIVEN=293, 
		PRAGMA=294, PRECEDING=295, PRECISION=296, PRESENT=297, PRIOR=298, PROCEDURE=299, 
		RAISE=300, RANGE=301, RAW=302, READ=303, REAL=304, RECORD=305, REF=306, 
		REFERENCE=307, REFERENCING=308, REJECT=309, RELIES_ON=310, RENAME=311, 
		REPLACE=312, RESPECT=313, RESTRICT_REFERENCES=314, RESULT=315, RESULT_CACHE=316, 
		RETURN=317, RETURNING=318, REUSE=319, REVERSE=320, REVOKE=321, RIGHT=322, 
		ROLLBACK=323, ROLLUP=324, ROW=325, ROWID=326, ROWS=327, RULES=328, SAMPLE=329, 
		SAVE=330, SAVEPOINT=331, SCHEMA=332, SCHEMACHECK=333, SCN=334, SEARCH=335, 
		SECOND=336, SEED=337, SEGMENT=338, SELECT=339, SELF=340, SEQUENCE=341, 
		SEQUENTIAL=342, SERIALIZABLE=343, SERIALLY_REUSABLE=344, SERVERERROR=345, 
		SESSIONTIMEZONE=346, SET=347, SETS=348, SETTINGS=349, SHARE=350, SHOW=351, 
		SHUTDOWN=352, SIBLINGS=353, SIGNTYPE=354, SIMPLE_INTEGER=355, SINGLE=356, 
		SIZE=357, SKIP_=358, SMALLINT=359, SNAPSHOT=360, SOME=361, SPECIFICATION=362, 
		SQLDATA=363, SQLERROR=364, STANDALONE=365, START=366, STARTUP=367, STATEMENT=368, 
		STATEMENT_ID=369, STATIC=370, STATISTICS=371, STRING=372, SUBMULTISET=373, 
		SUBPARTITION=374, SUBSTITUTABLE=375, SUBTYPE=376, SUCCESS=377, SUSPEND=378, 
		TABLE=379, THE=380, THEN=381, TIME=382, TIMESTAMP=383, TIMESTAMP_LTZ_UNCONSTRAINED=384, 
		TIMESTAMP_TZ_UNCONSTRAINED=385, TIMESTAMP_UNCONSTRAINED=386, TIMEZONE_ABBR=387, 
		TIMEZONE_HOUR=388, TIMEZONE_MINUTE=389, TIMEZONE_REGION=390, TO=391, TRAILING=392, 
		TRANSACTION=393, TRANSLATE=394, TREAT=395, TRIGGER=396, TRUE=397, TRUNCATE=398, 
		TYPE=399, UNBOUNDED=400, UNDER=401, UNION=402, UNIQUE=403, UNLIMITED=404, 
		UNPIVOT=405, UNTIL=406, UPDATE=407, UPDATED=408, UPSERT=409, UROWID=410, 
		USE=411, USING=412, VALIDATE=413, VALUE=414, VALUES=415, VARCHAR=416, 
		VARCHAR2=417, VARIABLE=418, VARRAY=419, VARYING=420, VERSION=421, VERSIONS=422, 
		WAIT=423, WARNING=424, WELLFORMED=425, WHEN=426, WHENEVER=427, WHERE=428, 
		WHILE=429, WITH=430, WITHIN=431, WORK=432, WRITE=433, XML=434, XMLAGG=435, 
		XMLATTRIBUTES=436, XMLCAST=437, XMLCOLATTVAL=438, XMLELEMENT=439, XMLEXISTS=440, 
		XMLFOREST=441, XMLNAMESPACES=442, XMLPARSE=443, XMLPI=444, XMLQUERY=445, 
		XMLROOT=446, XMLSERIALIZE=447, XMLTABLE=448, YEAR=449, YES=450, YMINTERVAL_UNCONSTRAINED=451, 
		ZONE=452, PREDICTION=453, PREDICTION_BOUNDS=454, PREDICTION_COST=455, 
		PREDICTION_DETAILS=456, PREDICTION_PROBABILITY=457, PREDICTION_SET=458, 
		CUME_DIST=459, DENSE_RANK=460, LISTAGG=461, PERCENT_RANK=462, PERCENTILE_CONT=463, 
		PERCENTILE_DISC=464, RANK=465, AVG=466, CORR=467, COVAR_=468, DECODE=469, 
		LAG=470, LEAD=471, MAX=472, MEDIAN=473, MIN=474, NTILE=475, NVL=476, RATIO_TO_REPORT=477, 
		REGR_=478, ROUND=479, ROW_NUMBER=480, SUBSTR=481, TO_CHAR=482, TRIM=483, 
		SUM=484, STDDEV=485, VAR_=486, VARIANCE=487, NATIONAL_CHAR_STRING_LIT=488, 
		BIT_STRING_LIT=489, HEX_STRING_LIT=490, DOUBLE_PERIOD=491, PERIOD=492, 
		UNSIGNED_INTEGER=493, APPROXIMATE_NUM_LIT=494, CHAR_STRING=495, DELIMITED_ID=496, 
		PERCENT=497, AMPERSAND=498, LEFT_PAREN=499, RIGHT_PAREN=500, DOUBLE_ASTERISK=501, 
		ASTERISK=502, PLUS_SIGN=503, MINUS_SIGN=504, COMMA=505, SOLIDUS=506, AT_SIGN=507, 
		ASSIGN_OP=508, BINDVAR=509, COLON=510, SEMICOLON=511, LESS_THAN_OR_EQUALS_OP=512, 
		LESS_THAN_OP=513, GREATER_THAN_OR_EQUALS_OP=514, NOT_EQUAL_OP=515, CARRET_OPERATOR_PART=516, 
		TILDE_OPERATOR_PART=517, EXCLAMATION_OPERATOR_PART=518, GREATER_THAN_OP=519, 
		CONCATENATION_OP=520, VERTICAL_BAR=521, EQUALS_OP=522, LEFT_BRACKET=523, 
		RIGHT_BRACKET=524, INTRODUCER=525, SPACES=526, SINGLE_LINE_COMMENT=527, 
		MULTI_LINE_COMMENT=528, PROMPT=529, REGULAR_ID=530, ZV=531;
	public static readonly string[] tokenNames = {
		"<INVALID>", "'..'", "A_LETTER", "ADD", "AFTER", "AGENT", "AGGREGATE", 
		"ALL", "ALTER", "ANALYZE", "AND", "ANY", "ARRAY", "AS", "ASC", "ASSOCIATE", 
		"AT", "ATTRIBUTE", "AUDIT", "AUTHID", "AUTO", "AUTOMATIC", "AUTONOMOUS_TRANSACTION", 
		"BATCH", "BEFORE", "BEGIN", "BETWEEN", "BFILE", "BINARY_DOUBLE", "BINARY_FLOAT", 
		"BINARY_INTEGER", "BLOB", "BLOCK", "BODY", "BOOLEAN", "BOTH", "BREADTH", 
		"BULK", "BY", "BYTE", "C_LETTER", "CACHE", "CALL", "CANONICAL", "CASCADE", 
		"CASE", "CAST", "CHAR", "CHAR_CS", "CHARACTER", "CHECK", "CHR", "CLOB", 
		"CLOSE", "CLUSTER", "COALESCE", "COLLECT", "COLUMNS", "COMMENT", "COMMIT", 
		"COMMITTED", "COMPATIBILITY", "COMPILE", "COMPOUND", "CONNECT", "CONNECT_BY_ROOT", 
		"CONSTANT", "CONSTRAINT", "CONSTRAINTS", "CONSTRUCTOR", "CONTENT", "CONTEXT", 
		"CONTINUE", "CONVERT", "CORRUPT_XID", "CORRUPT_XID_ALL", "COST", "COUNT", 
		"CREATE", "CROSS", "CUBE", "CURRENT", "CURRENT_USER", "CURSOR", "CUSTOMDATUM", 
		"CYCLE", "DATA", "DATABASE", "DATE", "DAY", "DB_ROLE_CHANGE", "DBTIMEZONE", 
		"DDL", "DEBUG", "DEC", "DECIMAL", "DECLARE", "DECOMPOSE", "DECREMENT", 
		"DEFAULT", "DEFAULTS", "DEFERRED", "DEFINER", "DELETE", "DEPTH", "DESC", 
		"DETERMINISTIC", "DIMENSION", "DISABLE", "DISASSOCIATE", "DISTINCT", "DOCUMENT", 
		"DOUBLE", "DROP", "DSINTERVAL_UNCONSTRAINED", "EACH", "ELEMENT", "ELSE", 
		"ELSIF", "EMPTY", "ENABLE", "ENCODING", "END", "ENTITYESCAPING", "ERR", 
		"ERRORS", "ESCAPE", "EVALNAME", "EXCEPTION", "EXCEPTION_INIT", "EXCEPTIONS", 
		"EXCLUDE", "EXCLUSIVE", "EXECUTE", "EXISTS", "EXIT", "EXPLAIN", "EXTERNAL", 
		"EXTRACT", "FAILURE", "FALSE", "FETCH", "FINAL", "FIRST", "FIRST_VALUE", 
		"FLOAT", "FOLLOWING", "FOLLOWS", "FOR", "FORALL", "FORCE", "FROM", "FULL", 
		"FUNCTION", "GOTO", "GRANT", "GROUP", "GROUPING", "HASH", "HAVING", "HIDE", 
		"HOUR", "IF", "IGNORE", "IMMEDIATE", "IN", "INCLUDE", "INCLUDING", "INCREMENT", 
		"INDENT", "INDEX", "INDEXED", "INDICATOR", "INDICES", "INFINITE", "INLINE", 
		"INNER", "INOUT", "INSERT", "INSTANTIABLE", "INSTEAD", "INT", "INTEGER", 
		"INTERSECT", "INTERVAL", "INTO", "INVALIDATE", "IS", "ISOLATION", "ITERATE", 
		"JAVA", "JOIN", "KEEP", "LANGUAGE", "LAST", "LAST_VALUE", "LEADING", "LEFT", 
		"LEVEL", "LIBRARY", "LIKE", "LIKE2", "LIKE4", "LIKEC", "LIMIT", "LOCAL", 
		"LOCK", "LOCKED", "LOG", "LOGOFF", "LOGON", "LONG", "LOOP", "MAIN", "MAP", 
		"MATCHED", "MAXVALUE", "MEASURES", "MEMBER", "MERGE", "MINUS", "MINUTE", 
		"MINVALUE", "MLSLABEL", "MODE", "MODEL", "MODIFY", "MONTH", "MULTISET", 
		"NAME", "NAN", "NATURAL", "NATURALN", "NAV", "NCHAR", "NCHAR_CS", "NCLOB", 
		"NESTED", "NEW", "NO", "NOAUDIT", "NOCACHE", "NOCOPY", "NOCYCLE", "NOENTITYESCAPING", 
		"NOMAXVALUE", "NOMINVALUE", "NONE", "NOORDER", "NOSCHEMACHECK", "NOT", 
		"NOWAIT", "NULL", "NULLS", "NUMBER", "NUMERIC", "NVARCHAR2", "OBJECT", 
		"OF", "OFF", "OID", "OLD", "ON", "ONLY", "OPEN", "OPTION", "OR", "ORADATA", 
		"ORDER", "ORDINALITY", "OSERROR", "OUT", "OUTER", "OVER", "OVERRIDING", 
		"PACKAGE", "PARALLEL_ENABLE", "PARAMETERS", "PARENT", "PARTITION", "PASSING", 
		"PATH", "PERCENT_ISOPEN", "PERCENT_FOUND", "PERCENT_NOTFOUND", "PERCENT_ROWCOUNT", 
		"PERCENT_ROWTYPE", "PERCENT_TYPE", "PIPELINED", "PIVOT", "PLAN", "PLS_INTEGER", 
		"POSITIVE", "POSITIVEN", "PRAGMA", "PRECEDING", "PRECISION", "PRESENT", 
		"PRIOR", "PROCEDURE", "RAISE", "RANGE", "RAW", "READ", "REAL", "RECORD", 
		"REF", "REFERENCE", "REFERENCING", "REJECT", "RELIES_ON", "RENAME", "REPLACE", 
		"RESPECT", "RESTRICT_REFERENCES", "RESULT", "RESULT_CACHE", "RETURN", 
		"RETURNING", "REUSE", "REVERSE", "REVOKE", "RIGHT", "ROLLBACK", "ROLLUP", 
		"ROW", "ROWID", "ROWS", "RULES", "SAMPLE", "SAVE", "SAVEPOINT", "SCHEMA", 
		"SCHEMACHECK", "SCN", "SEARCH", "SECOND", "SEED", "SEGMENT", "SELECT", 
		"SELF", "SEQUENCE", "SEQUENTIAL", "SERIALIZABLE", "SERIALLY_REUSABLE", 
		"SERVERERROR", "SESSIONTIMEZONE", "SET", "SETS", "SETTINGS", "SHARE", 
		"SHOW", "SHUTDOWN", "SIBLINGS", "SIGNTYPE", "SIMPLE_INTEGER", "SINGLE", 
		"SIZE", "SKIP_", "SMALLINT", "SNAPSHOT", "SOME", "SPECIFICATION", "SQLDATA", 
		"SQLERROR", "STANDALONE", "START", "STARTUP", "STATEMENT", "STATEMENT_ID", 
		"STATIC", "STATISTICS", "STRING", "SUBMULTISET", "SUBPARTITION", "SUBSTITUTABLE", 
		"SUBTYPE", "SUCCESS", "SUSPEND", "TABLE", "THE", "THEN", "TIME", "TIMESTAMP", 
		"TIMESTAMP_LTZ_UNCONSTRAINED", "TIMESTAMP_TZ_UNCONSTRAINED", "TIMESTAMP_UNCONSTRAINED", 
		"TIMEZONE_ABBR", "TIMEZONE_HOUR", "TIMEZONE_MINUTE", "TIMEZONE_REGION", 
		"TO", "TRAILING", "TRANSACTION", "TRANSLATE", "TREAT", "TRIGGER", "TRUE", 
		"TRUNCATE", "TYPE", "UNBOUNDED", "UNDER", "UNION", "UNIQUE", "UNLIMITED", 
		"UNPIVOT", "UNTIL", "UPDATE", "UPDATED", "UPSERT", "UROWID", "USE", "USING", 
		"VALIDATE", "VALUE", "VALUES", "VARCHAR", "VARCHAR2", "VARIABLE", "VARRAY", 
		"VARYING", "VERSION", "VERSIONS", "WAIT", "WARNING", "WELLFORMED", "WHEN", 
		"WHENEVER", "WHERE", "WHILE", "WITH", "WITHIN", "WORK", "WRITE", "XML", 
		"XMLAGG", "XMLATTRIBUTES", "XMLCAST", "XMLCOLATTVAL", "XMLELEMENT", "XMLEXISTS", 
		"XMLFOREST", "XMLNAMESPACES", "XMLPARSE", "XMLPI", "XMLQUERY", "XMLROOT", 
		"XMLSERIALIZE", "XMLTABLE", "YEAR", "YES", "YMINTERVAL_UNCONSTRAINED", 
		"ZONE", "PREDICTION", "PREDICTION_BOUNDS", "PREDICTION_COST", "PREDICTION_DETAILS", 
		"PREDICTION_PROBABILITY", "PREDICTION_SET", "CUME_DIST", "DENSE_RANK", 
		"LISTAGG", "PERCENT_RANK", "PERCENTILE_CONT", "PERCENTILE_DISC", "RANK", 
		"AVG", "CORR", "COVAR_", "DECODE", "LAG", "LEAD", "MAX", "MEDIAN", "MIN", 
		"NTILE", "NVL", "RATIO_TO_REPORT", "REGR_", "ROUND", "ROW_NUMBER", "SUBSTR", 
		"TO_CHAR", "TRIM", "SUM", "STDDEV", "VAR_", "VARIANCE", "NATIONAL_CHAR_STRING_LIT", 
		"BIT_STRING_LIT", "HEX_STRING_LIT", "DOUBLE_PERIOD", "'.'", "UNSIGNED_INTEGER", 
		"APPROXIMATE_NUM_LIT", "CHAR_STRING", "DELIMITED_ID", "'%'", "'&'", "'('", 
		"')'", "'**'", "'*'", "'+'", "'-'", "','", "'/'", "'@'", "':='", "BINDVAR", 
		"':'", "';'", "'<='", "'<'", "'>='", "NOT_EQUAL_OP", "'^'", "'~'", "'!'", 
		"'>'", "'||'", "'|'", "'='", "'['", "']'", "'_'", "SPACES", "SINGLE_LINE_COMMENT", 
		"MULTI_LINE_COMMENT", "PROMPT", "REGULAR_ID", "'@!'"
	};
	public const int
		RULE_swallow_to_semi = 0, RULE_compilation_unit = 1, RULE_sql_script = 2, 
		RULE_unit_statement_list = 3, RULE_unit_statement = 4, RULE_drop_function = 5, 
		RULE_alter_function = 6, RULE_create_function_body = 7, RULE_parallel_enable_clause = 8, 
		RULE_partition_by_clause = 9, RULE_result_cache_clause = 10, RULE_relies_on_part = 11, 
		RULE_streaming_clause = 12, RULE_drop_package = 13, RULE_alter_package = 14, 
		RULE_create_package = 15, RULE_create_package_body = 16, RULE_package_obj_spec = 17, 
		RULE_procedure_spec = 18, RULE_function_spec = 19, RULE_package_obj_body = 20, 
		RULE_drop_procedure = 21, RULE_alter_procedure = 22, RULE_function_body = 23, 
		RULE_procedure_body = 24, RULE_create_procedure_body = 25, RULE_drop_trigger = 26, 
		RULE_alter_trigger = 27, RULE_create_trigger = 28, RULE_trigger_follows_clause = 29, 
		RULE_trigger_when_clause = 30, RULE_simple_dml_trigger = 31, RULE_for_each_row = 32, 
		RULE_compound_dml_trigger = 33, RULE_non_dml_trigger = 34, RULE_trigger_body = 35, 
		RULE_routine_clause = 36, RULE_compound_trigger_block = 37, RULE_timing_point_section = 38, 
		RULE_non_dml_event = 39, RULE_dml_event_clause = 40, RULE_dml_event_element = 41, 
		RULE_dml_event_nested_clause = 42, RULE_referencing_clause = 43, RULE_referencing_element = 44, 
		RULE_drop_type = 45, RULE_alter_type = 46, RULE_compile_type_clause = 47, 
		RULE_replace_type_clause = 48, RULE_alter_method_spec = 49, RULE_alter_method_element = 50, 
		RULE_alter_attribute_definition = 51, RULE_attribute_definition = 52, 
		RULE_alter_collection_clauses = 53, RULE_dependent_handling_clause = 54, 
		RULE_dependent_exceptions_part = 55, RULE_create_type = 56, RULE_type_definition = 57, 
		RULE_object_type_def = 58, RULE_object_as_part = 59, RULE_object_under_part = 60, 
		RULE_nested_table_type_def = 61, RULE_sqlj_object_type = 62, RULE_type_body = 63, 
		RULE_type_body_elements = 64, RULE_map_order_func_declaration = 65, RULE_subprog_decl_in_type = 66, 
		RULE_proc_decl_in_type = 67, RULE_func_decl_in_type = 68, RULE_constructor_declaration = 69, 
		RULE_modifier_clause = 70, RULE_object_member_spec = 71, RULE_sqlj_object_type_attr = 72, 
		RULE_element_spec = 73, RULE_element_spec_options = 74, RULE_subprogram_spec = 75, 
		RULE_type_procedure_spec = 76, RULE_type_function_spec = 77, RULE_constructor_spec = 78, 
		RULE_map_order_function_spec = 79, RULE_pragma_clause = 80, RULE_pragma_elements = 81, 
		RULE_type_elements_parameter = 82, RULE_drop_sequence = 83, RULE_alter_sequence = 84, 
		RULE_create_sequence = 85, RULE_sequence_spec = 86, RULE_sequence_start_clause = 87, 
		RULE_invoker_rights_clause = 88, RULE_compiler_parameters_clause = 89, 
		RULE_call_spec = 90, RULE_java_spec = 91, RULE_c_spec = 92, RULE_c_agent_in_clause = 93, 
		RULE_c_parameters_clause = 94, RULE_parameter = 95, RULE_default_value_part = 96, 
		RULE_declare_spec = 97, RULE_variable_declaration = 98, RULE_subtype_declaration = 99, 
		RULE_cursor_declaration = 100, RULE_parameter_spec = 101, RULE_exception_declaration = 102, 
		RULE_pragma_declaration = 103, RULE_record_type_def = 104, RULE_field_spec = 105, 
		RULE_ref_cursor_type_def = 106, RULE_type_declaration = 107, RULE_table_type_def = 108, 
		RULE_table_indexed_by_part = 109, RULE_varray_type_def = 110, RULE_seq_of_statements = 111, 
		RULE_label_declaration = 112, RULE_statement = 113, RULE_assignment_statement = 114, 
		RULE_continue_statement = 115, RULE_exit_statement = 116, RULE_goto_statement = 117, 
		RULE_if_statement = 118, RULE_elsif_part = 119, RULE_else_part = 120, 
		RULE_loop_statement = 121, RULE_cursor_loop_param = 122, RULE_forall_statement = 123, 
		RULE_bounds_clause = 124, RULE_between_bound = 125, RULE_lower_bound = 126, 
		RULE_upper_bound = 127, RULE_null_statement = 128, RULE_raise_statement = 129, 
		RULE_return_statement = 130, RULE_function_call = 131, RULE_body = 132, 
		RULE_exception_handler = 133, RULE_trigger_block = 134, RULE_block = 135, 
		RULE_sql_statement = 136, RULE_execute_immediate = 137, RULE_dynamic_returning_clause = 138, 
		RULE_data_manipulation_language_statements = 139, RULE_cursor_manipulation_statements = 140, 
		RULE_close_statement = 141, RULE_open_statement = 142, RULE_fetch_statement = 143, 
		RULE_open_for_statement = 144, RULE_transaction_control_statements = 145, 
		RULE_set_transaction_command = 146, RULE_set_constraint_command = 147, 
		RULE_commit_statement = 148, RULE_write_clause = 149, RULE_rollback_statement = 150, 
		RULE_savepoint_statement = 151, RULE_explain_statement = 152, RULE_select_statement = 153, 
		RULE_subquery_factoring_clause = 154, RULE_factoring_element = 155, RULE_search_clause = 156, 
		RULE_cycle_clause = 157, RULE_subquery = 158, RULE_subquery_operation_part = 159, 
		RULE_subquery_basic_elements = 160, RULE_query_block = 161, RULE_selected_element = 162, 
		RULE_from_clause = 163, RULE_select_list_elements = 164, RULE_table_ref_list = 165, 
		RULE_table_ref = 166, RULE_table_ref_aux = 167, RULE_table_ref_aux_internal = 168, 
		RULE_join_clause = 169, RULE_join_on_part = 170, RULE_join_using_part = 171, 
		RULE_outer_join_type = 172, RULE_query_partition_clause = 173, RULE_flashback_query_clause = 174, 
		RULE_pivot_clause = 175, RULE_pivot_element = 176, RULE_pivot_for_clause = 177, 
		RULE_pivot_in_clause = 178, RULE_pivot_in_clause_element = 179, RULE_pivot_in_clause_elements = 180, 
		RULE_unpivot_clause = 181, RULE_unpivot_in_clause = 182, RULE_unpivot_in_elements = 183, 
		RULE_hierarchical_query_clause = 184, RULE_start_part = 185, RULE_group_by_clause = 186, 
		RULE_group_by_elements = 187, RULE_rollup_cube_clause = 188, RULE_grouping_sets_clause = 189, 
		RULE_grouping_sets_elements = 190, RULE_having_clause = 191, RULE_model_clause = 192, 
		RULE_cell_reference_options = 193, RULE_return_rows_clause = 194, RULE_reference_model = 195, 
		RULE_main_model = 196, RULE_model_column_clauses = 197, RULE_model_column_partition_part = 198, 
		RULE_model_column_list = 199, RULE_model_column = 200, RULE_model_rules_clause = 201, 
		RULE_model_rules_part = 202, RULE_model_rules_element = 203, RULE_cell_assignment = 204, 
		RULE_model_iterate_clause = 205, RULE_until_part = 206, RULE_order_by_clause = 207, 
		RULE_order_by_elements = 208, RULE_for_update_clause = 209, RULE_for_update_of_part = 210, 
		RULE_for_update_options = 211, RULE_update_statement = 212, RULE_update_set_clause = 213, 
		RULE_column_based_update_set_clause = 214, RULE_delete_statement = 215, 
		RULE_insert_statement = 216, RULE_single_table_insert = 217, RULE_multi_table_insert = 218, 
		RULE_multi_table_element = 219, RULE_conditional_insert_clause = 220, 
		RULE_conditional_insert_when_part = 221, RULE_conditional_insert_else_part = 222, 
		RULE_insert_into_clause = 223, RULE_values_clause = 224, RULE_merge_statement = 225, 
		RULE_merge_update_clause = 226, RULE_merge_element = 227, RULE_merge_update_delete_part = 228, 
		RULE_merge_insert_clause = 229, RULE_selected_tableview = 230, RULE_lock_table_statement = 231, 
		RULE_wait_nowait_part = 232, RULE_lock_table_element = 233, RULE_lock_mode = 234, 
		RULE_general_table_ref = 235, RULE_static_returning_clause = 236, RULE_error_logging_clause = 237, 
		RULE_error_logging_into_part = 238, RULE_error_logging_reject_part = 239, 
		RULE_dml_table_expression_clause = 240, RULE_table_collection_expression = 241, 
		RULE_subquery_restriction_clause = 242, RULE_sample_clause = 243, RULE_seed_part = 244, 
		RULE_cursor_expression = 245, RULE_expression_list = 246, RULE_condition = 247, 
		RULE_expression = 248, RULE_logical_or_expression = 249, RULE_logical_and_expression = 250, 
		RULE_negated_expression = 251, RULE_equality_expression = 252, RULE_multiset_expression = 253, 
		RULE_multiset_type = 254, RULE_relational_expression = 255, RULE_compound_expression = 256, 
		RULE_relational_operator = 257, RULE_like_type = 258, RULE_like_escape_part = 259, 
		RULE_in_elements = 260, RULE_between_elements = 261, RULE_concatenation = 262, 
		RULE_additive_expression = 263, RULE_multiply_expression = 264, RULE_datetime_expression = 265, 
		RULE_interval_expression = 266, RULE_model_expression = 267, RULE_model_expression_element = 268, 
		RULE_single_column_for_loop = 269, RULE_for_like_part = 270, RULE_for_increment_decrement_type = 271, 
		RULE_multi_column_for_loop = 272, RULE_unary_expression = 273, RULE_case_statement = 274, 
		RULE_simple_case_statement = 275, RULE_simple_case_when_part = 276, RULE_searched_case_statement = 277, 
		RULE_searched_case_when_part = 278, RULE_case_else_part = 279, RULE_atom = 280, 
		RULE_expression_or_vector = 281, RULE_vector_expr = 282, RULE_quantified_expression = 283, 
		RULE_string_function = 284, RULE_standard_function = 285, RULE_numeric_function_wrapper = 286, 
		RULE_numeric_function = 287, RULE_other_function = 288, RULE_over_clause_keyword = 289, 
		RULE_within_or_over_clause_keyword = 290, RULE_standard_prediction_function_keyword = 291, 
		RULE_over_clause = 292, RULE_windowing_clause = 293, RULE_windowing_type = 294, 
		RULE_windowing_elements = 295, RULE_using_clause = 296, RULE_using_element = 297, 
		RULE_collect_order_by_part = 298, RULE_within_or_over_part = 299, RULE_cost_matrix_clause = 300, 
		RULE_xml_passing_clause = 301, RULE_xml_attributes_clause = 302, RULE_xml_namespaces_clause = 303, 
		RULE_xml_table_column = 304, RULE_xml_general_default_part = 305, RULE_xml_multiuse_expression_element = 306, 
		RULE_xmlroot_param_version_part = 307, RULE_xmlroot_param_standalone_part = 308, 
		RULE_xmlserialize_param_enconding_part = 309, RULE_xmlserialize_param_version_part = 310, 
		RULE_xmlserialize_param_ident_part = 311, RULE_sql_plus_command = 312, 
		RULE_whenever_command = 313, RULE_set_command = 314, RULE_exit_command = 315, 
		RULE_prompt_command = 316, RULE_show_errors_command = 317, RULE_partition_extension_clause = 318, 
		RULE_column_alias = 319, RULE_table_alias = 320, RULE_alias_quoted_string = 321, 
		RULE_where_clause = 322, RULE_current_of_clause = 323, RULE_into_clause = 324, 
		RULE_xml_column_name = 325, RULE_cost_class_name = 326, RULE_attribute_name = 327, 
		RULE_savepoint_name = 328, RULE_rollback_segment_name = 329, RULE_table_var_name = 330, 
		RULE_schema_name = 331, RULE_routine_name = 332, RULE_package_name = 333, 
		RULE_implementation_type_name = 334, RULE_parameter_name = 335, RULE_reference_model_name = 336, 
		RULE_main_model_name = 337, RULE_aggregate_function_name = 338, RULE_query_name = 339, 
		RULE_constraint_name = 340, RULE_label_name = 341, RULE_type_name = 342, 
		RULE_sequence_name = 343, RULE_exception_name = 344, RULE_function_name = 345, 
		RULE_procedure_name = 346, RULE_trigger_name = 347, RULE_variable_name = 348, 
		RULE_index_name = 349, RULE_cursor_name = 350, RULE_record_name = 351, 
		RULE_collection_name = 352, RULE_link_name = 353, RULE_column_name = 354, 
		RULE_tableview_name = 355, RULE_char_set_name = 356, RULE_keep_clause = 357, 
		RULE_function_argument = 358, RULE_function_argument_analytic = 359, RULE_function_argument_modeling = 360, 
		RULE_respect_or_ignore_nulls = 361, RULE_argument = 362, RULE_type_spec = 363, 
		RULE_datatype = 364, RULE_precision_part = 365, RULE_native_datatype_element = 366, 
		RULE_bind_variable = 367, RULE_general_element = 368, RULE_general_element_part = 369, 
		RULE_table_element = 370, RULE_constant = 371, RULE_numeric = 372, RULE_numeric_negative = 373, 
		RULE_quoted_string = 374, RULE_identifier = 375, RULE_id_expression = 376, 
		RULE_not_equal_op = 377, RULE_greater_than_or_equals_op = 378, RULE_less_than_or_equals_op = 379, 
		RULE_concatenation_op = 380, RULE_outer_join_sign = 381, RULE_regular_id = 382, 
		RULE_string_function_name = 383, RULE_numeric_function_name = 384;
	public static readonly string[] ruleNames = {
		"swallow_to_semi", "compilation_unit", "sql_script", "unit_statement_list", 
		"unit_statement", "drop_function", "alter_function", "create_function_body", 
		"parallel_enable_clause", "partition_by_clause", "result_cache_clause", 
		"relies_on_part", "streaming_clause", "drop_package", "alter_package", 
		"create_package", "create_package_body", "package_obj_spec", "procedure_spec", 
		"function_spec", "package_obj_body", "drop_procedure", "alter_procedure", 
		"function_body", "procedure_body", "create_procedure_body", "drop_trigger", 
		"alter_trigger", "create_trigger", "trigger_follows_clause", "trigger_when_clause", 
		"simple_dml_trigger", "for_each_row", "compound_dml_trigger", "non_dml_trigger", 
		"trigger_body", "routine_clause", "compound_trigger_block", "timing_point_section", 
		"non_dml_event", "dml_event_clause", "dml_event_element", "dml_event_nested_clause", 
		"referencing_clause", "referencing_element", "drop_type", "alter_type", 
		"compile_type_clause", "replace_type_clause", "alter_method_spec", "alter_method_element", 
		"alter_attribute_definition", "attribute_definition", "alter_collection_clauses", 
		"dependent_handling_clause", "dependent_exceptions_part", "create_type", 
		"type_definition", "object_type_def", "object_as_part", "object_under_part", 
		"nested_table_type_def", "sqlj_object_type", "type_body", "type_body_elements", 
		"map_order_func_declaration", "subprog_decl_in_type", "proc_decl_in_type", 
		"func_decl_in_type", "constructor_declaration", "modifier_clause", "object_member_spec", 
		"sqlj_object_type_attr", "element_spec", "element_spec_options", "subprogram_spec", 
		"type_procedure_spec", "type_function_spec", "constructor_spec", "map_order_function_spec", 
		"pragma_clause", "pragma_elements", "type_elements_parameter", "drop_sequence", 
		"alter_sequence", "create_sequence", "sequence_spec", "sequence_start_clause", 
		"invoker_rights_clause", "compiler_parameters_clause", "call_spec", "java_spec", 
		"c_spec", "c_agent_in_clause", "c_parameters_clause", "parameter", "default_value_part", 
		"declare_spec", "variable_declaration", "subtype_declaration", "cursor_declaration", 
		"parameter_spec", "exception_declaration", "pragma_declaration", "record_type_def", 
		"field_spec", "ref_cursor_type_def", "type_declaration", "table_type_def", 
		"table_indexed_by_part", "varray_type_def", "seq_of_statements", "label_declaration", 
		"statement", "assignment_statement", "continue_statement", "exit_statement", 
		"goto_statement", "if_statement", "elsif_part", "else_part", "loop_statement", 
		"cursor_loop_param", "forall_statement", "bounds_clause", "between_bound", 
		"lower_bound", "upper_bound", "null_statement", "raise_statement", "return_statement", 
		"function_call", "body", "exception_handler", "trigger_block", "block", 
		"sql_statement", "execute_immediate", "dynamic_returning_clause", "data_manipulation_language_statements", 
		"cursor_manipulation_statements", "close_statement", "open_statement", 
		"fetch_statement", "open_for_statement", "transaction_control_statements", 
		"set_transaction_command", "set_constraint_command", "commit_statement", 
		"write_clause", "rollback_statement", "savepoint_statement", "explain_statement", 
		"select_statement", "subquery_factoring_clause", "factoring_element", 
		"search_clause", "cycle_clause", "subquery", "subquery_operation_part", 
		"subquery_basic_elements", "query_block", "selected_element", "from_clause", 
		"select_list_elements", "table_ref_list", "table_ref", "table_ref_aux", 
		"table_ref_aux_internal", "join_clause", "join_on_part", "join_using_part", 
		"outer_join_type", "query_partition_clause", "flashback_query_clause", 
		"pivot_clause", "pivot_element", "pivot_for_clause", "pivot_in_clause", 
		"pivot_in_clause_element", "pivot_in_clause_elements", "unpivot_clause", 
		"unpivot_in_clause", "unpivot_in_elements", "hierarchical_query_clause", 
		"start_part", "group_by_clause", "group_by_elements", "rollup_cube_clause", 
		"grouping_sets_clause", "grouping_sets_elements", "having_clause", "model_clause", 
		"cell_reference_options", "return_rows_clause", "reference_model", "main_model", 
		"model_column_clauses", "model_column_partition_part", "model_column_list", 
		"model_column", "model_rules_clause", "model_rules_part", "model_rules_element", 
		"cell_assignment", "model_iterate_clause", "until_part", "order_by_clause", 
		"order_by_elements", "for_update_clause", "for_update_of_part", "for_update_options", 
		"update_statement", "update_set_clause", "column_based_update_set_clause", 
		"delete_statement", "insert_statement", "single_table_insert", "multi_table_insert", 
		"multi_table_element", "conditional_insert_clause", "conditional_insert_when_part", 
		"conditional_insert_else_part", "insert_into_clause", "values_clause", 
		"merge_statement", "merge_update_clause", "merge_element", "merge_update_delete_part", 
		"merge_insert_clause", "selected_tableview", "lock_table_statement", "wait_nowait_part", 
		"lock_table_element", "lock_mode", "general_table_ref", "static_returning_clause", 
		"error_logging_clause", "error_logging_into_part", "error_logging_reject_part", 
		"dml_table_expression_clause", "table_collection_expression", "subquery_restriction_clause", 
		"sample_clause", "seed_part", "cursor_expression", "expression_list", 
		"condition", "expression", "logical_or_expression", "logical_and_expression", 
		"negated_expression", "equality_expression", "multiset_expression", "multiset_type", 
		"relational_expression", "compound_expression", "relational_operator", 
		"like_type", "like_escape_part", "in_elements", "between_elements", "concatenation", 
		"additive_expression", "multiply_expression", "datetime_expression", "interval_expression", 
		"model_expression", "model_expression_element", "single_column_for_loop", 
		"for_like_part", "for_increment_decrement_type", "multi_column_for_loop", 
		"unary_expression", "case_statement", "simple_case_statement", "simple_case_when_part", 
		"searched_case_statement", "searched_case_when_part", "case_else_part", 
		"atom", "expression_or_vector", "vector_expr", "quantified_expression", 
		"string_function", "standard_function", "numeric_function_wrapper", "numeric_function", 
		"other_function", "over_clause_keyword", "within_or_over_clause_keyword", 
		"standard_prediction_function_keyword", "over_clause", "windowing_clause", 
		"windowing_type", "windowing_elements", "using_clause", "using_element", 
		"collect_order_by_part", "within_or_over_part", "cost_matrix_clause", 
		"xml_passing_clause", "xml_attributes_clause", "xml_namespaces_clause", 
		"xml_table_column", "xml_general_default_part", "xml_multiuse_expression_element", 
		"xmlroot_param_version_part", "xmlroot_param_standalone_part", "xmlserialize_param_enconding_part", 
		"xmlserialize_param_version_part", "xmlserialize_param_ident_part", "sql_plus_command", 
		"whenever_command", "set_command", "exit_command", "prompt_command", "show_errors_command", 
		"partition_extension_clause", "column_alias", "table_alias", "alias_quoted_string", 
		"where_clause", "current_of_clause", "into_clause", "xml_column_name", 
		"cost_class_name", "attribute_name", "savepoint_name", "rollback_segment_name", 
		"table_var_name", "schema_name", "routine_name", "package_name", "implementation_type_name", 
		"parameter_name", "reference_model_name", "main_model_name", "aggregate_function_name", 
		"query_name", "constraint_name", "label_name", "type_name", "sequence_name", 
		"exception_name", "function_name", "procedure_name", "trigger_name", "variable_name", 
		"index_name", "cursor_name", "record_name", "collection_name", "link_name", 
		"column_name", "tableview_name", "char_set_name", "keep_clause", "function_argument", 
		"function_argument_analytic", "function_argument_modeling", "respect_or_ignore_nulls", 
		"argument", "type_spec", "datatype", "precision_part", "native_datatype_element", 
		"bind_variable", "general_element", "general_element_part", "table_element", 
		"constant", "numeric", "numeric_negative", "quoted_string", "identifier", 
		"id_expression", "not_equal_op", "greater_than_or_equals_op", "less_than_or_equals_op", 
		"concatenation_op", "outer_join_sign", "regular_id", "string_function_name", 
		"numeric_function_name"
	};

	public override string GrammarFileName { get { return "plsql.g4"; } }

	public override string[] TokenNames { get { return tokenNames; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	public plsqlParser(ITokenStream input)
		: base(input)
	{
		_interp = new ParserATNSimulator(this,_ATN);
	}
	public partial class Swallow_to_semiContext : ParserRuleContext {
		public Swallow_to_semiContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_swallow_to_semi; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSwallow_to_semi(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSwallow_to_semi(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSwallow_to_semi(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Swallow_to_semiContext swallow_to_semi() {
		Swallow_to_semiContext _localctx = new Swallow_to_semiContext(_ctx, State);
		EnterRule(_localctx, 0, RULE_swallow_to_semi);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 771;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 770;
				_la = _input.La(1);
				if ( _la <= 0 || (_la==SEMICOLON) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				}
				}
				State = 773;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__0) | (1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALL) | (1L << ALTER) | (1L << ANALYZE) | (1L << AND) | (1L << ANY) | (1L << ARRAY) | (1L << AS) | (1L << ASC) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGIN) | (1L << BETWEEN) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BREADTH) | (1L << BULK) | (1L << BY) | (1L << BYTE) | (1L << C_LETTER) | (1L << CACHE) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHECK) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COALESCE) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CONNECT - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CREATE - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DB_ROLE_CHANGE - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEBUG - 64)) | (1L << (DEC - 64)) | (1L << (DECIMAL - 64)) | (1L << (DECLARE - 64)) | (1L << (DECOMPOSE - 64)) | (1L << (DECREMENT - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFAULTS - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEPTH - 64)) | (1L << (DESC - 64)) | (1L << (DETERMINISTIC - 64)) | (1L << (DIMENSION - 64)) | (1L << (DISABLE - 64)) | (1L << (DISASSOCIATE - 64)) | (1L << (DISTINCT - 64)) | (1L << (DOCUMENT - 64)) | (1L << (DOUBLE - 64)) | (1L << (DROP - 64)) | (1L << (DSINTERVAL_UNCONSTRAINED - 64)) | (1L << (EACH - 64)) | (1L << (ELEMENT - 64)) | (1L << (ELSE - 64)) | (1L << (ELSIF - 64)) | (1L << (EMPTY - 64)) | (1L << (ENABLE - 64)) | (1L << (ENCODING - 64)) | (1L << (END - 64)) | (1L << (ENTITYESCAPING - 64)) | (1L << (ERR - 64)) | (1L << (ERRORS - 64)) | (1L << (ESCAPE - 64)) | (1L << (EVALNAME - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (EXCEPTION - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXCLUSIVE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPLAIN - 128)) | (1L << (EXTERNAL - 128)) | (1L << (EXTRACT - 128)) | (1L << (FAILURE - 128)) | (1L << (FALSE - 128)) | (1L << (FETCH - 128)) | (1L << (FINAL - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_VALUE - 128)) | (1L << (FLOAT - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FOLLOWS - 128)) | (1L << (FOR - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FROM - 128)) | (1L << (FULL - 128)) | (1L << (FUNCTION - 128)) | (1L << (GOTO - 128)) | (1L << (GRANT - 128)) | (1L << (GROUP - 128)) | (1L << (GROUPING - 128)) | (1L << (HASH - 128)) | (1L << (HAVING - 128)) | (1L << (HIDE - 128)) | (1L << (HOUR - 128)) | (1L << (IF - 128)) | (1L << (IGNORE - 128)) | (1L << (IMMEDIATE - 128)) | (1L << (IN - 128)) | (1L << (INCLUDE - 128)) | (1L << (INCLUDING - 128)) | (1L << (INCREMENT - 128)) | (1L << (INDENT - 128)) | (1L << (INDEX - 128)) | (1L << (INDEXED - 128)) | (1L << (INDICATOR - 128)) | (1L << (INDICES - 128)) | (1L << (INFINITE - 128)) | (1L << (INLINE - 128)) | (1L << (INNER - 128)) | (1L << (INOUT - 128)) | (1L << (INSERT - 128)) | (1L << (INSTANTIABLE - 128)) | (1L << (INSTEAD - 128)) | (1L << (INT - 128)) | (1L << (INTEGER - 128)) | (1L << (INTERSECT - 128)) | (1L << (INTERVAL - 128)) | (1L << (INTO - 128)) | (1L << (INVALIDATE - 128)) | (1L << (IS - 128)) | (1L << (ISOLATION - 128)) | (1L << (ITERATE - 128)) | (1L << (JAVA - 128)) | (1L << (JOIN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (KEEP - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)) | (1L << (LAST_VALUE - 192)) | (1L << (LEADING - 192)) | (1L << (LEFT - 192)) | (1L << (LEVEL - 192)) | (1L << (LIBRARY - 192)) | (1L << (LIKE - 192)) | (1L << (LIKE2 - 192)) | (1L << (LIKE4 - 192)) | (1L << (LIKEC - 192)) | (1L << (LIMIT - 192)) | (1L << (LOCAL - 192)) | (1L << (LOCK - 192)) | (1L << (LOCKED - 192)) | (1L << (LOG - 192)) | (1L << (LOGOFF - 192)) | (1L << (LOGON - 192)) | (1L << (LONG - 192)) | (1L << (LOOP - 192)) | (1L << (MAIN - 192)) | (1L << (MAP - 192)) | (1L << (MATCHED - 192)) | (1L << (MAXVALUE - 192)) | (1L << (MEASURES - 192)) | (1L << (MEMBER - 192)) | (1L << (MERGE - 192)) | (1L << (MINUS - 192)) | (1L << (MINUTE - 192)) | (1L << (MINVALUE - 192)) | (1L << (MLSLABEL - 192)) | (1L << (MODE - 192)) | (1L << (MODEL - 192)) | (1L << (MODIFY - 192)) | (1L << (MONTH - 192)) | (1L << (MULTISET - 192)) | (1L << (NAME - 192)) | (1L << (NAN - 192)) | (1L << (NATURAL - 192)) | (1L << (NATURALN - 192)) | (1L << (NAV - 192)) | (1L << (NCHAR - 192)) | (1L << (NCHAR_CS - 192)) | (1L << (NCLOB - 192)) | (1L << (NESTED - 192)) | (1L << (NEW - 192)) | (1L << (NO - 192)) | (1L << (NOAUDIT - 192)) | (1L << (NOCACHE - 192)) | (1L << (NOCOPY - 192)) | (1L << (NOCYCLE - 192)) | (1L << (NOENTITYESCAPING - 192)) | (1L << (NOMAXVALUE - 192)) | (1L << (NOMINVALUE - 192)) | (1L << (NONE - 192)) | (1L << (NOORDER - 192)) | (1L << (NOSCHEMACHECK - 192)) | (1L << (NOT - 192)) | (1L << (NOWAIT - 192)) | (1L << (NULL - 192)) | (1L << (NULLS - 192)) | (1L << (NUMBER - 192)) | (1L << (NUMERIC - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (NVARCHAR2 - 256)) | (1L << (OBJECT - 256)) | (1L << (OF - 256)) | (1L << (OFF - 256)) | (1L << (OID - 256)) | (1L << (OLD - 256)) | (1L << (ON - 256)) | (1L << (ONLY - 256)) | (1L << (OPEN - 256)) | (1L << (OPTION - 256)) | (1L << (OR - 256)) | (1L << (ORADATA - 256)) | (1L << (ORDER - 256)) | (1L << (ORDINALITY - 256)) | (1L << (OSERROR - 256)) | (1L << (OUT - 256)) | (1L << (OUTER - 256)) | (1L << (OVER - 256)) | (1L << (OVERRIDING - 256)) | (1L << (PACKAGE - 256)) | (1L << (PARALLEL_ENABLE - 256)) | (1L << (PARAMETERS - 256)) | (1L << (PARENT - 256)) | (1L << (PARTITION - 256)) | (1L << (PASSING - 256)) | (1L << (PATH - 256)) | (1L << (PERCENT_ISOPEN - 256)) | (1L << (PERCENT_FOUND - 256)) | (1L << (PERCENT_NOTFOUND - 256)) | (1L << (PERCENT_ROWCOUNT - 256)) | (1L << (PERCENT_ROWTYPE - 256)) | (1L << (PERCENT_TYPE - 256)) | (1L << (PIPELINED - 256)) | (1L << (PIVOT - 256)) | (1L << (PLAN - 256)) | (1L << (PLS_INTEGER - 256)) | (1L << (POSITIVE - 256)) | (1L << (POSITIVEN - 256)) | (1L << (PRAGMA - 256)) | (1L << (PRECEDING - 256)) | (1L << (PRECISION - 256)) | (1L << (PRESENT - 256)) | (1L << (PRIOR - 256)) | (1L << (PROCEDURE - 256)) | (1L << (RAISE - 256)) | (1L << (RANGE - 256)) | (1L << (RAW - 256)) | (1L << (READ - 256)) | (1L << (REAL - 256)) | (1L << (RECORD - 256)) | (1L << (REF - 256)) | (1L << (REFERENCE - 256)) | (1L << (REFERENCING - 256)) | (1L << (REJECT - 256)) | (1L << (RELIES_ON - 256)) | (1L << (RENAME - 256)) | (1L << (REPLACE - 256)) | (1L << (RESPECT - 256)) | (1L << (RESTRICT_REFERENCES - 256)) | (1L << (RESULT - 256)) | (1L << (RESULT_CACHE - 256)) | (1L << (RETURN - 256)) | (1L << (RETURNING - 256)) | (1L << (REUSE - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (REVERSE - 320)) | (1L << (REVOKE - 320)) | (1L << (RIGHT - 320)) | (1L << (ROLLBACK - 320)) | (1L << (ROLLUP - 320)) | (1L << (ROW - 320)) | (1L << (ROWID - 320)) | (1L << (ROWS - 320)) | (1L << (RULES - 320)) | (1L << (SAMPLE - 320)) | (1L << (SAVE - 320)) | (1L << (SAVEPOINT - 320)) | (1L << (SCHEMA - 320)) | (1L << (SCHEMACHECK - 320)) | (1L << (SCN - 320)) | (1L << (SEARCH - 320)) | (1L << (SECOND - 320)) | (1L << (SEED - 320)) | (1L << (SEGMENT - 320)) | (1L << (SELECT - 320)) | (1L << (SELF - 320)) | (1L << (SEQUENCE - 320)) | (1L << (SEQUENTIAL - 320)) | (1L << (SERIALIZABLE - 320)) | (1L << (SERIALLY_REUSABLE - 320)) | (1L << (SERVERERROR - 320)) | (1L << (SESSIONTIMEZONE - 320)) | (1L << (SET - 320)) | (1L << (SETS - 320)) | (1L << (SETTINGS - 320)) | (1L << (SHARE - 320)) | (1L << (SHOW - 320)) | (1L << (SHUTDOWN - 320)) | (1L << (SIBLINGS - 320)) | (1L << (SIGNTYPE - 320)) | (1L << (SIMPLE_INTEGER - 320)) | (1L << (SINGLE - 320)) | (1L << (SIZE - 320)) | (1L << (SKIP_ - 320)) | (1L << (SMALLINT - 320)) | (1L << (SNAPSHOT - 320)) | (1L << (SOME - 320)) | (1L << (SPECIFICATION - 320)) | (1L << (SQLDATA - 320)) | (1L << (SQLERROR - 320)) | (1L << (STANDALONE - 320)) | (1L << (START - 320)) | (1L << (STARTUP - 320)) | (1L << (STATEMENT - 320)) | (1L << (STATEMENT_ID - 320)) | (1L << (STATIC - 320)) | (1L << (STATISTICS - 320)) | (1L << (STRING - 320)) | (1L << (SUBMULTISET - 320)) | (1L << (SUBPARTITION - 320)) | (1L << (SUBSTITUTABLE - 320)) | (1L << (SUBTYPE - 320)) | (1L << (SUCCESS - 320)) | (1L << (SUSPEND - 320)) | (1L << (TABLE - 320)) | (1L << (THE - 320)) | (1L << (THEN - 320)) | (1L << (TIME - 320)) | (1L << (TIMESTAMP - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 384)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 384)) | (1L << (TIMESTAMP_UNCONSTRAINED - 384)) | (1L << (TIMEZONE_ABBR - 384)) | (1L << (TIMEZONE_HOUR - 384)) | (1L << (TIMEZONE_MINUTE - 384)) | (1L << (TIMEZONE_REGION - 384)) | (1L << (TO - 384)) | (1L << (TRAILING - 384)) | (1L << (TRANSACTION - 384)) | (1L << (TRANSLATE - 384)) | (1L << (TREAT - 384)) | (1L << (TRIGGER - 384)) | (1L << (TRUE - 384)) | (1L << (TRUNCATE - 384)) | (1L << (TYPE - 384)) | (1L << (UNBOUNDED - 384)) | (1L << (UNDER - 384)) | (1L << (UNION - 384)) | (1L << (UNIQUE - 384)) | (1L << (UNLIMITED - 384)) | (1L << (UNPIVOT - 384)) | (1L << (UNTIL - 384)) | (1L << (UPDATE - 384)) | (1L << (UPDATED - 384)) | (1L << (UPSERT - 384)) | (1L << (UROWID - 384)) | (1L << (USE - 384)) | (1L << (USING - 384)) | (1L << (VALIDATE - 384)) | (1L << (VALUE - 384)) | (1L << (VALUES - 384)) | (1L << (VARCHAR - 384)) | (1L << (VARCHAR2 - 384)) | (1L << (VARIABLE - 384)) | (1L << (VARRAY - 384)) | (1L << (VARYING - 384)) | (1L << (VERSION - 384)) | (1L << (VERSIONS - 384)) | (1L << (WAIT - 384)) | (1L << (WARNING - 384)) | (1L << (WELLFORMED - 384)) | (1L << (WHEN - 384)) | (1L << (WHENEVER - 384)) | (1L << (WHERE - 384)) | (1L << (WHILE - 384)) | (1L << (WITH - 384)) | (1L << (WITHIN - 384)) | (1L << (WORK - 384)) | (1L << (WRITE - 384)) | (1L << (XML - 384)) | (1L << (XMLAGG - 384)) | (1L << (XMLATTRIBUTES - 384)) | (1L << (XMLCAST - 384)) | (1L << (XMLCOLATTVAL - 384)) | (1L << (XMLELEMENT - 384)) | (1L << (XMLEXISTS - 384)) | (1L << (XMLFOREST - 384)) | (1L << (XMLNAMESPACES - 384)) | (1L << (XMLPARSE - 384)) | (1L << (XMLPI - 384)) | (1L << (XMLQUERY - 384)) | (1L << (XMLROOT - 384)) | (1L << (XMLSERIALIZE - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (XMLTABLE - 448)) | (1L << (YEAR - 448)) | (1L << (YES - 448)) | (1L << (YMINTERVAL_UNCONSTRAINED - 448)) | (1L << (ZONE - 448)) | (1L << (PREDICTION - 448)) | (1L << (PREDICTION_BOUNDS - 448)) | (1L << (PREDICTION_COST - 448)) | (1L << (PREDICTION_DETAILS - 448)) | (1L << (PREDICTION_PROBABILITY - 448)) | (1L << (PREDICTION_SET - 448)) | (1L << (CUME_DIST - 448)) | (1L << (DENSE_RANK - 448)) | (1L << (LISTAGG - 448)) | (1L << (PERCENT_RANK - 448)) | (1L << (PERCENTILE_CONT - 448)) | (1L << (PERCENTILE_DISC - 448)) | (1L << (RANK - 448)) | (1L << (AVG - 448)) | (1L << (CORR - 448)) | (1L << (COVAR_ - 448)) | (1L << (DECODE - 448)) | (1L << (LAG - 448)) | (1L << (LEAD - 448)) | (1L << (MAX - 448)) | (1L << (MEDIAN - 448)) | (1L << (MIN - 448)) | (1L << (NTILE - 448)) | (1L << (NVL - 448)) | (1L << (RATIO_TO_REPORT - 448)) | (1L << (REGR_ - 448)) | (1L << (ROUND - 448)) | (1L << (ROW_NUMBER - 448)) | (1L << (SUBSTR - 448)) | (1L << (TO_CHAR - 448)) | (1L << (TRIM - 448)) | (1L << (SUM - 448)) | (1L << (STDDEV - 448)) | (1L << (VAR_ - 448)) | (1L << (VARIANCE - 448)) | (1L << (NATIONAL_CHAR_STRING_LIT - 448)) | (1L << (BIT_STRING_LIT - 448)) | (1L << (HEX_STRING_LIT - 448)) | (1L << (DOUBLE_PERIOD - 448)) | (1L << (PERIOD - 448)) | (1L << (UNSIGNED_INTEGER - 448)) | (1L << (APPROXIMATE_NUM_LIT - 448)) | (1L << (CHAR_STRING - 448)) | (1L << (DELIMITED_ID - 448)) | (1L << (PERCENT - 448)) | (1L << (AMPERSAND - 448)) | (1L << (LEFT_PAREN - 448)) | (1L << (RIGHT_PAREN - 448)) | (1L << (DOUBLE_ASTERISK - 448)) | (1L << (ASTERISK - 448)) | (1L << (PLUS_SIGN - 448)) | (1L << (MINUS_SIGN - 448)) | (1L << (COMMA - 448)) | (1L << (SOLIDUS - 448)) | (1L << (AT_SIGN - 448)) | (1L << (ASSIGN_OP - 448)) | (1L << (BINDVAR - 448)) | (1L << (COLON - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (LESS_THAN_OR_EQUALS_OP - 512)) | (1L << (LESS_THAN_OP - 512)) | (1L << (GREATER_THAN_OR_EQUALS_OP - 512)) | (1L << (NOT_EQUAL_OP - 512)) | (1L << (CARRET_OPERATOR_PART - 512)) | (1L << (TILDE_OPERATOR_PART - 512)) | (1L << (EXCLAMATION_OPERATOR_PART - 512)) | (1L << (GREATER_THAN_OP - 512)) | (1L << (CONCATENATION_OP - 512)) | (1L << (VERTICAL_BAR - 512)) | (1L << (EQUALS_OP - 512)) | (1L << (LEFT_BRACKET - 512)) | (1L << (RIGHT_BRACKET - 512)) | (1L << (INTRODUCER - 512)) | (1L << (SPACES - 512)) | (1L << (SINGLE_LINE_COMMENT - 512)) | (1L << (MULTI_LINE_COMMENT - 512)) | (1L << (PROMPT - 512)) | (1L << (REGULAR_ID - 512)) | (1L << (ZV - 512)))) != 0) );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Compilation_unitContext : ParserRuleContext {
		public IReadOnlyList<Unit_statement_listContext> unit_statement_list() {
			return GetRuleContexts<Unit_statement_listContext>();
		}
		public Unit_statement_listContext unit_statement_list(int i) {
			return GetRuleContext<Unit_statement_listContext>(i);
		}
		public ITerminalNode Eof() { return GetToken(plsqlParser.Eof, 0); }
		public Compilation_unitContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compilation_unit; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCompilation_unit(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCompilation_unit(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompilation_unit(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Compilation_unitContext compilation_unit() {
		Compilation_unitContext _localctx = new Compilation_unitContext(_ctx, State);
		EnterRule(_localctx, 2, RULE_compilation_unit);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 778;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==ALTER || ((((_la - 78)) & ~0x3f) == 0 && ((1L << (_la - 78)) & ((1L << (CREATE - 78)) | (1L << (DELETE - 78)) | (1L << (DROP - 78)) | (1L << (EXPLAIN - 78)))) != 0) || ((((_la - 178)) & ~0x3f) == 0 && ((1L << (_la - 178)) & ((1L << (INSERT - 178)) | (1L << (LOCK - 178)) | (1L << (MERGE - 178)))) != 0) || _la==SELECT || _la==UPDATE || _la==WITH || _la==LEFT_PAREN || _la==SEMICOLON) {
				{
				{
				State = 775; unit_statement_list();
				}
				}
				State = 780;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 781; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Sql_scriptContext : ParserRuleContext {
		public ITerminalNode Eof() { return GetToken(plsqlParser.Eof, 0); }
		public IReadOnlyList<Sql_plus_commandContext> sql_plus_command() {
			return GetRuleContexts<Sql_plus_commandContext>();
		}
		public IReadOnlyList<Unit_statementContext> unit_statement() {
			return GetRuleContexts<Unit_statementContext>();
		}
		public Unit_statementContext unit_statement(int i) {
			return GetRuleContext<Unit_statementContext>(i);
		}
		public Sql_plus_commandContext sql_plus_command(int i) {
			return GetRuleContext<Sql_plus_commandContext>(i);
		}
		public Sql_scriptContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sql_script; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSql_script(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSql_script(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSql_script(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Sql_scriptContext sql_script() {
		Sql_scriptContext _localctx = new Sql_scriptContext(_ctx, State);
		EnterRule(_localctx, 4, RULE_sql_script);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 787;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==ALTER || ((((_la - 78)) & ~0x3f) == 0 && ((1L << (_la - 78)) & ((1L << (CREATE - 78)) | (1L << (DELETE - 78)) | (1L << (DROP - 78)) | (1L << (EXIT - 78)) | (1L << (EXPLAIN - 78)))) != 0) || ((((_la - 178)) & ~0x3f) == 0 && ((1L << (_la - 178)) & ((1L << (INSERT - 178)) | (1L << (LOCK - 178)) | (1L << (MERGE - 178)))) != 0) || ((((_la - 339)) & ~0x3f) == 0 && ((1L << (_la - 339)) & ((1L << (SELECT - 339)) | (1L << (SET - 339)) | (1L << (SHOW - 339)))) != 0) || ((((_la - 407)) & ~0x3f) == 0 && ((1L << (_la - 407)) & ((1L << (UPDATE - 407)) | (1L << (WHENEVER - 407)) | (1L << (WITH - 407)))) != 0) || ((((_la - 499)) & ~0x3f) == 0 && ((1L << (_la - 499)) & ((1L << (LEFT_PAREN - 499)) | (1L << (SOLIDUS - 499)) | (1L << (PROMPT - 499)))) != 0)) {
				{
				State = 785;
				switch (_input.La(1)) {
				case ALTER:
				case CREATE:
				case DELETE:
				case DROP:
				case EXPLAIN:
				case INSERT:
				case LOCK:
				case MERGE:
				case SELECT:
				case UPDATE:
				case WITH:
				case LEFT_PAREN:
					{
					State = 783; unit_statement();
					}
					break;
				case EXIT:
				case SET:
				case SHOW:
				case WHENEVER:
				case SOLIDUS:
				case PROMPT:
					{
					State = 784; sql_plus_command();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 789;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 790; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Unit_statement_listContext : ParserRuleContext {
		public IReadOnlyList<Unit_statementContext> unit_statement() {
			return GetRuleContexts<Unit_statementContext>();
		}
		public Unit_statementContext unit_statement(int i) {
			return GetRuleContext<Unit_statementContext>(i);
		}
		public Unit_statement_listContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unit_statement_list; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterUnit_statement_list(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitUnit_statement_list(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnit_statement_list(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Unit_statement_listContext unit_statement_list() {
		Unit_statement_listContext _localctx = new Unit_statement_listContext(_ctx, State);
		EnterRule(_localctx, 6, RULE_unit_statement_list);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 795;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==SEMICOLON) {
				{
				{
				State = 792; Match(SEMICOLON);
				}
				}
				State = 797;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 798; unit_statement();
			State = 807;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,6,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 800;
					_errHandler.Sync(this);
					_la = _input.La(1);
					do {
						{
						{
						State = 799; Match(SEMICOLON);
						}
						}
						State = 802;
						_errHandler.Sync(this);
						_la = _input.La(1);
					} while ( _la==SEMICOLON );
					State = 804; unit_statement();
					}
					} 
				}
				State = 809;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,6,_ctx);
			}
			State = 813;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,7,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 810; Match(SEMICOLON);
					}
					} 
				}
				State = 815;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,7,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Unit_statementContext : ParserRuleContext {
		public Create_triggerContext create_trigger() {
			return GetRuleContext<Create_triggerContext>(0);
		}
		public Drop_sequenceContext drop_sequence() {
			return GetRuleContext<Drop_sequenceContext>(0);
		}
		public Alter_typeContext alter_type() {
			return GetRuleContext<Alter_typeContext>(0);
		}
		public Create_typeContext create_type() {
			return GetRuleContext<Create_typeContext>(0);
		}
		public Alter_sequenceContext alter_sequence() {
			return GetRuleContext<Alter_sequenceContext>(0);
		}
		public Alter_procedureContext alter_procedure() {
			return GetRuleContext<Alter_procedureContext>(0);
		}
		public Alter_functionContext alter_function() {
			return GetRuleContext<Alter_functionContext>(0);
		}
		public Create_procedure_bodyContext create_procedure_body() {
			return GetRuleContext<Create_procedure_bodyContext>(0);
		}
		public Data_manipulation_language_statementsContext data_manipulation_language_statements() {
			return GetRuleContext<Data_manipulation_language_statementsContext>(0);
		}
		public Create_function_bodyContext create_function_body() {
			return GetRuleContext<Create_function_bodyContext>(0);
		}
		public Drop_typeContext drop_type() {
			return GetRuleContext<Drop_typeContext>(0);
		}
		public Drop_packageContext drop_package() {
			return GetRuleContext<Drop_packageContext>(0);
		}
		public Drop_procedureContext drop_procedure() {
			return GetRuleContext<Drop_procedureContext>(0);
		}
		public Alter_triggerContext alter_trigger() {
			return GetRuleContext<Alter_triggerContext>(0);
		}
		public Create_sequenceContext create_sequence() {
			return GetRuleContext<Create_sequenceContext>(0);
		}
		public Alter_packageContext alter_package() {
			return GetRuleContext<Alter_packageContext>(0);
		}
		public Create_package_bodyContext create_package_body() {
			return GetRuleContext<Create_package_bodyContext>(0);
		}
		public Create_packageContext create_package() {
			return GetRuleContext<Create_packageContext>(0);
		}
		public Drop_triggerContext drop_trigger() {
			return GetRuleContext<Drop_triggerContext>(0);
		}
		public Drop_functionContext drop_function() {
			return GetRuleContext<Drop_functionContext>(0);
		}
		public Unit_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unit_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterUnit_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitUnit_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnit_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Unit_statementContext unit_statement() {
		Unit_statementContext _localctx = new Unit_statementContext(_ctx, State);
		EnterRule(_localctx, 8, RULE_unit_statement);
		try {
			State = 836;
			switch ( Interpreter.AdaptivePredict(_input,8,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 816; alter_function();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 817; alter_package();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 818; alter_procedure();
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 819; alter_sequence();
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 820; alter_trigger();
				}
				break;

			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 821; alter_type();
				}
				break;

			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 822; create_function_body();
				}
				break;

			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 823; create_procedure_body();
				}
				break;

			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 824; create_package();
				}
				break;

			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 825; create_package_body();
				}
				break;

			case 11:
				EnterOuterAlt(_localctx, 11);
				{
				State = 826; create_sequence();
				}
				break;

			case 12:
				EnterOuterAlt(_localctx, 12);
				{
				State = 827; create_trigger();
				}
				break;

			case 13:
				EnterOuterAlt(_localctx, 13);
				{
				State = 828; create_type();
				}
				break;

			case 14:
				EnterOuterAlt(_localctx, 14);
				{
				State = 829; drop_function();
				}
				break;

			case 15:
				EnterOuterAlt(_localctx, 15);
				{
				State = 830; drop_package();
				}
				break;

			case 16:
				EnterOuterAlt(_localctx, 16);
				{
				State = 831; drop_procedure();
				}
				break;

			case 17:
				EnterOuterAlt(_localctx, 17);
				{
				State = 832; drop_sequence();
				}
				break;

			case 18:
				EnterOuterAlt(_localctx, 18);
				{
				State = 833; drop_trigger();
				}
				break;

			case 19:
				EnterOuterAlt(_localctx, 19);
				{
				State = 834; drop_type();
				}
				break;

			case 20:
				EnterOuterAlt(_localctx, 20);
				{
				State = 835; data_manipulation_language_statements();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Drop_functionContext : ParserRuleContext {
		public ITerminalNode FUNCTION() { return GetToken(plsqlParser.FUNCTION, 0); }
		public ITerminalNode DROP() { return GetToken(plsqlParser.DROP, 0); }
		public Function_nameContext function_name() {
			return GetRuleContext<Function_nameContext>(0);
		}
		public Drop_functionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_drop_function; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterDrop_function(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitDrop_function(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDrop_function(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Drop_functionContext drop_function() {
		Drop_functionContext _localctx = new Drop_functionContext(_ctx, State);
		EnterRule(_localctx, 10, RULE_drop_function);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 838; Match(DROP);
			State = 839; Match(FUNCTION);
			State = 840; function_name();
			State = 841; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_functionContext : ParserRuleContext {
		public ITerminalNode REUSE() { return GetToken(plsqlParser.REUSE, 0); }
		public ITerminalNode FUNCTION() { return GetToken(plsqlParser.FUNCTION, 0); }
		public ITerminalNode DEBUG() { return GetToken(plsqlParser.DEBUG, 0); }
		public Compiler_parameters_clauseContext compiler_parameters_clause(int i) {
			return GetRuleContext<Compiler_parameters_clauseContext>(i);
		}
		public IReadOnlyList<Compiler_parameters_clauseContext> compiler_parameters_clause() {
			return GetRuleContexts<Compiler_parameters_clauseContext>();
		}
		public ITerminalNode SETTINGS() { return GetToken(plsqlParser.SETTINGS, 0); }
		public ITerminalNode COMPILE() { return GetToken(plsqlParser.COMPILE, 0); }
		public ITerminalNode ALTER() { return GetToken(plsqlParser.ALTER, 0); }
		public Function_nameContext function_name() {
			return GetRuleContext<Function_nameContext>(0);
		}
		public Alter_functionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_function; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterAlter_function(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitAlter_function(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlter_function(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Alter_functionContext alter_function() {
		Alter_functionContext _localctx = new Alter_functionContext(_ctx, State);
		EnterRule(_localctx, 12, RULE_alter_function);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 843; Match(ALTER);
			State = 844; Match(FUNCTION);
			State = 845; function_name();
			State = 846; Match(COMPILE);
			State = 848;
			switch ( Interpreter.AdaptivePredict(_input,9,_ctx) ) {
			case 1:
				{
				State = 847; Match(DEBUG);
				}
				break;
			}
			State = 853;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,10,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 850; compiler_parameters_clause();
					}
					} 
				}
				State = 855;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,10,_ctx);
			}
			State = 858;
			_la = _input.La(1);
			if (_la==REUSE) {
				{
				State = 856; Match(REUSE);
				State = 857; Match(SETTINGS);
				}
			}

			State = 860; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Create_function_bodyContext : ParserRuleContext {
		public IReadOnlyList<Declare_specContext> declare_spec() {
			return GetRuleContexts<Declare_specContext>();
		}
		public ITerminalNode AGGREGATE() { return GetToken(plsqlParser.AGGREGATE, 0); }
		public ITerminalNode AS() { return GetToken(plsqlParser.AS, 0); }
		public Function_nameContext function_name() {
			return GetRuleContext<Function_nameContext>(0);
		}
		public IReadOnlyList<ITerminalNode> DETERMINISTIC() { return GetTokens(plsqlParser.DETERMINISTIC); }
		public IReadOnlyList<Parallel_enable_clauseContext> parallel_enable_clause() {
			return GetRuleContexts<Parallel_enable_clauseContext>();
		}
		public ITerminalNode RETURN() { return GetToken(plsqlParser.RETURN, 0); }
		public ITerminalNode REPLACE() { return GetToken(plsqlParser.REPLACE, 0); }
		public Result_cache_clauseContext result_cache_clause(int i) {
			return GetRuleContext<Result_cache_clauseContext>(i);
		}
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode CREATE() { return GetToken(plsqlParser.CREATE, 0); }
		public Implementation_type_nameContext implementation_type_name() {
			return GetRuleContext<Implementation_type_nameContext>(0);
		}
		public Invoker_rights_clauseContext invoker_rights_clause(int i) {
			return GetRuleContext<Invoker_rights_clauseContext>(i);
		}
		public BodyContext body() {
			return GetRuleContext<BodyContext>(0);
		}
		public ITerminalNode DECLARE() { return GetToken(plsqlParser.DECLARE, 0); }
		public ParameterContext parameter(int i) {
			return GetRuleContext<ParameterContext>(i);
		}
		public Call_specContext call_spec() {
			return GetRuleContext<Call_specContext>(0);
		}
		public Declare_specContext declare_spec(int i) {
			return GetRuleContext<Declare_specContext>(i);
		}
		public ITerminalNode USING() { return GetToken(plsqlParser.USING, 0); }
		public ITerminalNode OR() { return GetToken(plsqlParser.OR, 0); }
		public ITerminalNode DETERMINISTIC(int i) {
			return GetToken(plsqlParser.DETERMINISTIC, i);
		}
		public IReadOnlyList<ParameterContext> parameter() {
			return GetRuleContexts<ParameterContext>();
		}
		public ITerminalNode FUNCTION() { return GetToken(plsqlParser.FUNCTION, 0); }
		public ITerminalNode IS() { return GetToken(plsqlParser.IS, 0); }
		public IReadOnlyList<Result_cache_clauseContext> result_cache_clause() {
			return GetRuleContexts<Result_cache_clauseContext>();
		}
		public Parallel_enable_clauseContext parallel_enable_clause(int i) {
			return GetRuleContext<Parallel_enable_clauseContext>(i);
		}
		public IReadOnlyList<Invoker_rights_clauseContext> invoker_rights_clause() {
			return GetRuleContexts<Invoker_rights_clauseContext>();
		}
		public ITerminalNode PIPELINED() { return GetToken(plsqlParser.PIPELINED, 0); }
		public Create_function_bodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_create_function_body; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCreate_function_body(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCreate_function_body(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreate_function_body(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Create_function_bodyContext create_function_body() {
		Create_function_bodyContext _localctx = new Create_function_bodyContext(_ctx, State);
		EnterRule(_localctx, 14, RULE_create_function_body);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 862; Match(CREATE);
			State = 865;
			_la = _input.La(1);
			if (_la==OR) {
				{
				State = 863; Match(OR);
				State = 864; Match(REPLACE);
				}
			}

			State = 867; Match(FUNCTION);
			State = 868; function_name();
			State = 880;
			_la = _input.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 869; Match(LEFT_PAREN);
				State = 870; parameter();
				State = 875;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 871; Match(COMMA);
					State = 872; parameter();
					}
					}
					State = 877;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 878; Match(RIGHT_PAREN);
				}
			}

			State = 882; Match(RETURN);
			State = 883; type_spec();
			State = 890;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==AUTHID || _la==DETERMINISTIC || _la==PARALLEL_ENABLE || _la==RESULT_CACHE) {
				{
				State = 888;
				switch (_input.La(1)) {
				case AUTHID:
					{
					State = 884; invoker_rights_clause();
					}
					break;
				case PARALLEL_ENABLE:
					{
					State = 885; parallel_enable_clause();
					}
					break;
				case RESULT_CACHE:
					{
					State = 886; result_cache_clause();
					}
					break;
				case DETERMINISTIC:
					{
					State = 887; Match(DETERMINISTIC);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 892;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 913;
			switch ( Interpreter.AdaptivePredict(_input,21,_ctx) ) {
			case 1:
				{
				{
				State = 894;
				_la = _input.La(1);
				if (_la==PIPELINED) {
					{
					State = 893; Match(PIPELINED);
					}
				}

				State = 896;
				_la = _input.La(1);
				if ( !(_la==AS || _la==IS) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				State = 908;
				switch ( Interpreter.AdaptivePredict(_input,20,_ctx) ) {
				case 1:
					{
					State = 898;
					_la = _input.La(1);
					if (_la==DECLARE) {
						{
						State = 897; Match(DECLARE);
						}
					}

					State = 903;
					_errHandler.Sync(this);
					_la = _input.La(1);
					while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (CONSTANT - 66)) | (1L << (CONSTRAINT - 66)) | (1L << (CONSTRAINTS - 66)) | (1L << (CONSTRUCTOR - 66)) | (1L << (CONTENT - 66)) | (1L << (CONTEXT - 66)) | (1L << (CONTINUE - 66)) | (1L << (CONVERT - 66)) | (1L << (CORRUPT_XID - 66)) | (1L << (CORRUPT_XID_ALL - 66)) | (1L << (COST - 66)) | (1L << (COUNT - 66)) | (1L << (CROSS - 66)) | (1L << (CUBE - 66)) | (1L << (CURRENT_USER - 66)) | (1L << (CURSOR - 66)) | (1L << (CUSTOMDATUM - 66)) | (1L << (CYCLE - 66)) | (1L << (DATA - 66)) | (1L << (DATABASE - 66)) | (1L << (DAY - 66)) | (1L << (DB_ROLE_CHANGE - 66)) | (1L << (DBTIMEZONE - 66)) | (1L << (DDL - 66)) | (1L << (DEBUG - 66)) | (1L << (DEC - 66)) | (1L << (DECIMAL - 66)) | (1L << (DECOMPOSE - 66)) | (1L << (DECREMENT - 66)) | (1L << (DEFAULTS - 66)) | (1L << (DEFERRED - 66)) | (1L << (DEFINER - 66)) | (1L << (DETERMINISTIC - 66)) | (1L << (DIMENSION - 66)) | (1L << (DISABLE - 66)) | (1L << (DISASSOCIATE - 66)) | (1L << (DOCUMENT - 66)) | (1L << (DOUBLE - 66)) | (1L << (DSINTERVAL_UNCONSTRAINED - 66)) | (1L << (EACH - 66)) | (1L << (ELEMENT - 66)) | (1L << (EMPTY - 66)) | (1L << (ENABLE - 66)) | (1L << (ENCODING - 66)) | (1L << (ENTITYESCAPING - 66)) | (1L << (ERR - 66)) | (1L << (ERRORS - 66)) | (1L << (ESCAPE - 66)) | (1L << (EVALNAME - 66)) | (1L << (EXCEPTION - 66)) | (1L << (EXCEPTION_INIT - 66)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)) | (1L << (EXIT - 130)) | (1L << (EXPLAIN - 130)) | (1L << (EXTERNAL - 130)) | (1L << (EXTRACT - 130)) | (1L << (FAILURE - 130)) | (1L << (FINAL - 130)) | (1L << (FIRST - 130)) | (1L << (FIRST_VALUE - 130)) | (1L << (FLOAT - 130)) | (1L << (FOLLOWING - 130)) | (1L << (FOLLOWS - 130)) | (1L << (FORALL - 130)) | (1L << (FORCE - 130)) | (1L << (FULL - 130)) | (1L << (FUNCTION - 130)) | (1L << (GROUPING - 130)) | (1L << (HASH - 130)) | (1L << (HIDE - 130)) | (1L << (HOUR - 130)) | (1L << (IGNORE - 130)) | (1L << (IMMEDIATE - 130)) | (1L << (INCLUDE - 130)) | (1L << (INCLUDING - 130)) | (1L << (INCREMENT - 130)) | (1L << (INDENT - 130)) | (1L << (INDEXED - 130)) | (1L << (INDICATOR - 130)) | (1L << (INDICES - 130)) | (1L << (INFINITE - 130)) | (1L << (INLINE - 130)) | (1L << (INNER - 130)) | (1L << (INOUT - 130)) | (1L << (INSTANTIABLE - 130)) | (1L << (INSTEAD - 130)) | (1L << (INT - 130)) | (1L << (INTEGER - 130)) | (1L << (INTERVAL - 130)) | (1L << (INVALIDATE - 130)) | (1L << (ISOLATION - 130)) | (1L << (ITERATE - 130)) | (1L << (JAVA - 130)) | (1L << (JOIN - 130)) | (1L << (KEEP - 130)) | (1L << (LANGUAGE - 130)))) != 0) || ((((_la - 194)) & ~0x3f) == 0 && ((1L << (_la - 194)) & ((1L << (LAST - 194)) | (1L << (LAST_VALUE - 194)) | (1L << (LEADING - 194)) | (1L << (LEFT - 194)) | (1L << (LEVEL - 194)) | (1L << (LIBRARY - 194)) | (1L << (LIKE2 - 194)) | (1L << (LIKE4 - 194)) | (1L << (LIKEC - 194)) | (1L << (LIMIT - 194)) | (1L << (LOCAL - 194)) | (1L << (LOCKED - 194)) | (1L << (LOG - 194)) | (1L << (LOGOFF - 194)) | (1L << (LOGON - 194)) | (1L << (LONG - 194)) | (1L << (LOOP - 194)) | (1L << (MAIN - 194)) | (1L << (MAP - 194)) | (1L << (MATCHED - 194)) | (1L << (MAXVALUE - 194)) | (1L << (MEASURES - 194)) | (1L << (MEMBER - 194)) | (1L << (MERGE - 194)) | (1L << (MINUTE - 194)) | (1L << (MINVALUE - 194)) | (1L << (MLSLABEL - 194)) | (1L << (MODEL - 194)) | (1L << (MODIFY - 194)) | (1L << (MONTH - 194)) | (1L << (MULTISET - 194)) | (1L << (NAME - 194)) | (1L << (NAN - 194)) | (1L << (NATURAL - 194)) | (1L << (NATURALN - 194)) | (1L << (NAV - 194)) | (1L << (NCHAR - 194)) | (1L << (NCHAR_CS - 194)) | (1L << (NCLOB - 194)) | (1L << (NESTED - 194)) | (1L << (NEW - 194)) | (1L << (NO - 194)) | (1L << (NOAUDIT - 194)) | (1L << (NOCOPY - 194)) | (1L << (NOCYCLE - 194)) | (1L << (NOENTITYESCAPING - 194)) | (1L << (NONE - 194)) | (1L << (NOSCHEMACHECK - 194)) | (1L << (NULLS - 194)) | (1L << (NUMBER - 194)) | (1L << (NUMERIC - 194)) | (1L << (NVARCHAR2 - 194)) | (1L << (OBJECT - 194)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (OFF - 259)) | (1L << (OID - 259)) | (1L << (OLD - 259)) | (1L << (ONLY - 259)) | (1L << (OPEN - 259)) | (1L << (ORADATA - 259)) | (1L << (ORDINALITY - 259)) | (1L << (OSERROR - 259)) | (1L << (OUT - 259)) | (1L << (OUTER - 259)) | (1L << (OVER - 259)) | (1L << (OVERRIDING - 259)) | (1L << (PACKAGE - 259)) | (1L << (PARALLEL_ENABLE - 259)) | (1L << (PARAMETERS - 259)) | (1L << (PARENT - 259)) | (1L << (PARTITION - 259)) | (1L << (PASSING - 259)) | (1L << (PATH - 259)) | (1L << (PIPELINED - 259)) | (1L << (PLAN - 259)) | (1L << (PLS_INTEGER - 259)) | (1L << (POSITIVE - 259)) | (1L << (POSITIVEN - 259)) | (1L << (PRAGMA - 259)) | (1L << (PRECEDING - 259)) | (1L << (PRECISION - 259)) | (1L << (PRESENT - 259)) | (1L << (PROCEDURE - 259)) | (1L << (RAISE - 259)) | (1L << (RANGE - 259)) | (1L << (RAW - 259)) | (1L << (READ - 259)) | (1L << (REAL - 259)) | (1L << (RECORD - 259)) | (1L << (REF - 259)) | (1L << (REFERENCE - 259)) | (1L << (REFERENCING - 259)) | (1L << (REJECT - 259)) | (1L << (RELIES_ON - 259)) | (1L << (RENAME - 259)) | (1L << (REPLACE - 259)) | (1L << (RESPECT - 259)) | (1L << (RESTRICT_REFERENCES - 259)) | (1L << (RESULT - 259)) | (1L << (RESULT_CACHE - 259)) | (1L << (RETURN - 259)) | (1L << (RETURNING - 259)) | (1L << (REUSE - 259)) | (1L << (REVERSE - 259)) | (1L << (RIGHT - 259)))) != 0) || ((((_la - 323)) & ~0x3f) == 0 && ((1L << (_la - 323)) & ((1L << (ROLLBACK - 323)) | (1L << (ROLLUP - 323)) | (1L << (ROW - 323)) | (1L << (ROWID - 323)) | (1L << (ROWS - 323)) | (1L << (RULES - 323)) | (1L << (SAMPLE - 323)) | (1L << (SAVE - 323)) | (1L << (SAVEPOINT - 323)) | (1L << (SCHEMA - 323)) | (1L << (SCHEMACHECK - 323)) | (1L << (SCN - 323)) | (1L << (SECOND - 323)) | (1L << (SEED - 323)) | (1L << (SEGMENT - 323)) | (1L << (SELF - 323)) | (1L << (SEQUENTIAL - 323)) | (1L << (SERIALIZABLE - 323)) | (1L << (SERIALLY_REUSABLE - 323)) | (1L << (SERVERERROR - 323)) | (1L << (SESSIONTIMEZONE - 323)) | (1L << (SET - 323)) | (1L << (SETS - 323)) | (1L << (SETTINGS - 323)) | (1L << (SHOW - 323)) | (1L << (SHUTDOWN - 323)) | (1L << (SIBLINGS - 323)) | (1L << (SIGNTYPE - 323)) | (1L << (SIMPLE_INTEGER - 323)) | (1L << (SINGLE - 323)) | (1L << (SKIP_ - 323)) | (1L << (SMALLINT - 323)) | (1L << (SNAPSHOT - 323)) | (1L << (SOME - 323)) | (1L << (SPECIFICATION - 323)) | (1L << (SQLDATA - 323)) | (1L << (SQLERROR - 323)) | (1L << (STANDALONE - 323)) | (1L << (STARTUP - 323)) | (1L << (STATEMENT - 323)) | (1L << (STATEMENT_ID - 323)) | (1L << (STATIC - 323)) | (1L << (STATISTICS - 323)) | (1L << (STRING - 323)) | (1L << (SUBMULTISET - 323)) | (1L << (SUBPARTITION - 323)) | (1L << (SUBSTITUTABLE - 323)) | (1L << (SUBTYPE - 323)) | (1L << (SUCCESS - 323)) | (1L << (SUSPEND - 323)) | (1L << (TIME - 323)) | (1L << (TIMESTAMP - 323)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_UNCONSTRAINED - 323)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TIMEZONE_ABBR - 387)) | (1L << (TIMEZONE_HOUR - 387)) | (1L << (TIMEZONE_MINUTE - 387)) | (1L << (TIMEZONE_REGION - 387)) | (1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (YMINTERVAL_UNCONSTRAINED - 451)) | (1L << (ZONE - 451)) | (1L << (PREDICTION - 451)) | (1L << (PREDICTION_BOUNDS - 451)) | (1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (COVAR_ - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (REGR_ - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (TRIM - 451)) | (1L << (SUM - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (VARIANCE - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
						{
						{
						State = 900; declare_spec();
						}
						}
						State = 905;
						_errHandler.Sync(this);
						_la = _input.La(1);
					}
					State = 906; body();
					}
					break;

				case 2:
					{
					State = 907; call_spec();
					}
					break;
				}
				}
				}
				break;

			case 2:
				{
				State = 910;
				_la = _input.La(1);
				if ( !(_la==AGGREGATE || _la==PIPELINED) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				State = 911; Match(USING);
				State = 912; implementation_type_name();
				}
				break;
			}
			State = 915; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Parallel_enable_clauseContext : ParserRuleContext {
		public Partition_by_clauseContext partition_by_clause() {
			return GetRuleContext<Partition_by_clauseContext>(0);
		}
		public ITerminalNode PARALLEL_ENABLE() { return GetToken(plsqlParser.PARALLEL_ENABLE, 0); }
		public Parallel_enable_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parallel_enable_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterParallel_enable_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitParallel_enable_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParallel_enable_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Parallel_enable_clauseContext parallel_enable_clause() {
		Parallel_enable_clauseContext _localctx = new Parallel_enable_clauseContext(_ctx, State);
		EnterRule(_localctx, 16, RULE_parallel_enable_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 917; Match(PARALLEL_ENABLE);
			State = 919;
			_la = _input.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 918; partition_by_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Partition_by_clauseContext : ParserRuleContext {
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public Streaming_clauseContext streaming_clause() {
			return GetRuleContext<Streaming_clauseContext>(0);
		}
		public IReadOnlyList<Column_nameContext> column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public ITerminalNode RANGE() { return GetToken(plsqlParser.RANGE, 0); }
		public ITerminalNode PARTITION() { return GetToken(plsqlParser.PARTITION, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode BY() { return GetToken(plsqlParser.BY, 0); }
		public ITerminalNode ANY() { return GetToken(plsqlParser.ANY, 0); }
		public ITerminalNode HASH() { return GetToken(plsqlParser.HASH, 0); }
		public Partition_by_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partition_by_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterPartition_by_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitPartition_by_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPartition_by_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Partition_by_clauseContext partition_by_clause() {
		Partition_by_clauseContext _localctx = new Partition_by_clauseContext(_ctx, State);
		EnterRule(_localctx, 18, RULE_partition_by_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 921; Match(LEFT_PAREN);
			State = 922; Match(PARTITION);
			State = 923; expression();
			State = 924; Match(BY);
			State = 938;
			switch (_input.La(1)) {
			case ANY:
				{
				State = 925; Match(ANY);
				}
				break;
			case HASH:
			case RANGE:
				{
				State = 926;
				_la = _input.La(1);
				if ( !(_la==HASH || _la==RANGE) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				State = 927; Match(LEFT_PAREN);
				State = 928; column_name();
				State = 933;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 929; Match(COMMA);
					State = 930; column_name();
					}
					}
					State = 935;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 936; Match(RIGHT_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 941;
			_la = _input.La(1);
			if (_la==CLUSTER || _la==ORDER) {
				{
				State = 940; streaming_clause();
				}
			}

			State = 943; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Result_cache_clauseContext : ParserRuleContext {
		public ITerminalNode RESULT_CACHE() { return GetToken(plsqlParser.RESULT_CACHE, 0); }
		public Relies_on_partContext relies_on_part() {
			return GetRuleContext<Relies_on_partContext>(0);
		}
		public Result_cache_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_result_cache_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterResult_cache_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitResult_cache_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitResult_cache_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Result_cache_clauseContext result_cache_clause() {
		Result_cache_clauseContext _localctx = new Result_cache_clauseContext(_ctx, State);
		EnterRule(_localctx, 20, RULE_result_cache_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 945; Match(RESULT_CACHE);
			State = 947;
			_la = _input.La(1);
			if (_la==RELIES_ON) {
				{
				State = 946; relies_on_part();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Relies_on_partContext : ParserRuleContext {
		public IReadOnlyList<Tableview_nameContext> tableview_name() {
			return GetRuleContexts<Tableview_nameContext>();
		}
		public ITerminalNode RELIES_ON() { return GetToken(plsqlParser.RELIES_ON, 0); }
		public Tableview_nameContext tableview_name(int i) {
			return GetRuleContext<Tableview_nameContext>(i);
		}
		public Relies_on_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_relies_on_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterRelies_on_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitRelies_on_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRelies_on_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Relies_on_partContext relies_on_part() {
		Relies_on_partContext _localctx = new Relies_on_partContext(_ctx, State);
		EnterRule(_localctx, 22, RULE_relies_on_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 949; Match(RELIES_ON);
			State = 950; Match(LEFT_PAREN);
			State = 951; tableview_name();
			State = 956;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 952; Match(COMMA);
				State = 953; tableview_name();
				}
				}
				State = 958;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 959; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Streaming_clauseContext : ParserRuleContext {
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public IReadOnlyList<Column_nameContext> column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public ITerminalNode CLUSTER() { return GetToken(plsqlParser.CLUSTER, 0); }
		public ITerminalNode ORDER() { return GetToken(plsqlParser.ORDER, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode BY() { return GetToken(plsqlParser.BY, 0); }
		public Streaming_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_streaming_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterStreaming_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitStreaming_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStreaming_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Streaming_clauseContext streaming_clause() {
		Streaming_clauseContext _localctx = new Streaming_clauseContext(_ctx, State);
		EnterRule(_localctx, 24, RULE_streaming_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 961;
			_la = _input.La(1);
			if ( !(_la==CLUSTER || _la==ORDER) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			State = 962; expression();
			State = 963; Match(BY);
			State = 964; Match(LEFT_PAREN);
			State = 965; column_name();
			State = 970;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 966; Match(COMMA);
				State = 967; column_name();
				}
				}
				State = 972;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 973; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Drop_packageContext : ParserRuleContext {
		public Package_nameContext package_name() {
			return GetRuleContext<Package_nameContext>(0);
		}
		public ITerminalNode PACKAGE() { return GetToken(plsqlParser.PACKAGE, 0); }
		public ITerminalNode DROP() { return GetToken(plsqlParser.DROP, 0); }
		public ITerminalNode BODY() { return GetToken(plsqlParser.BODY, 0); }
		public Drop_packageContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_drop_package; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterDrop_package(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitDrop_package(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDrop_package(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Drop_packageContext drop_package() {
		Drop_packageContext _localctx = new Drop_packageContext(_ctx, State);
		EnterRule(_localctx, 26, RULE_drop_package);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 975; Match(DROP);
			State = 976; Match(PACKAGE);
			State = 978;
			switch ( Interpreter.AdaptivePredict(_input,29,_ctx) ) {
			case 1:
				{
				State = 977; Match(BODY);
				}
				break;
			}
			State = 980; package_name();
			State = 981; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_packageContext : ParserRuleContext {
		public Package_nameContext package_name() {
			return GetRuleContext<Package_nameContext>(0);
		}
		public ITerminalNode REUSE() { return GetToken(plsqlParser.REUSE, 0); }
		public ITerminalNode DEBUG() { return GetToken(plsqlParser.DEBUG, 0); }
		public Compiler_parameters_clauseContext compiler_parameters_clause(int i) {
			return GetRuleContext<Compiler_parameters_clauseContext>(i);
		}
		public IReadOnlyList<ITerminalNode> PACKAGE() { return GetTokens(plsqlParser.PACKAGE); }
		public ITerminalNode PACKAGE(int i) {
			return GetToken(plsqlParser.PACKAGE, i);
		}
		public IReadOnlyList<Compiler_parameters_clauseContext> compiler_parameters_clause() {
			return GetRuleContexts<Compiler_parameters_clauseContext>();
		}
		public ITerminalNode SETTINGS() { return GetToken(plsqlParser.SETTINGS, 0); }
		public ITerminalNode COMPILE() { return GetToken(plsqlParser.COMPILE, 0); }
		public ITerminalNode ALTER() { return GetToken(plsqlParser.ALTER, 0); }
		public ITerminalNode BODY() { return GetToken(plsqlParser.BODY, 0); }
		public ITerminalNode SPECIFICATION() { return GetToken(plsqlParser.SPECIFICATION, 0); }
		public Alter_packageContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_package; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterAlter_package(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitAlter_package(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlter_package(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Alter_packageContext alter_package() {
		Alter_packageContext _localctx = new Alter_packageContext(_ctx, State);
		EnterRule(_localctx, 28, RULE_alter_package);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 983; Match(ALTER);
			State = 984; Match(PACKAGE);
			State = 985; package_name();
			State = 986; Match(COMPILE);
			State = 988;
			switch ( Interpreter.AdaptivePredict(_input,30,_ctx) ) {
			case 1:
				{
				State = 987; Match(DEBUG);
				}
				break;
			}
			State = 991;
			switch ( Interpreter.AdaptivePredict(_input,31,_ctx) ) {
			case 1:
				{
				State = 990;
				_la = _input.La(1);
				if ( !(_la==BODY || _la==PACKAGE || _la==SPECIFICATION) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				}
				break;
			}
			State = 996;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,32,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 993; compiler_parameters_clause();
					}
					} 
				}
				State = 998;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,32,_ctx);
			}
			State = 1001;
			_la = _input.La(1);
			if (_la==REUSE) {
				{
				State = 999; Match(REUSE);
				State = 1000; Match(SETTINGS);
				}
			}

			State = 1003; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Create_packageContext : ParserRuleContext {
		public IReadOnlyList<Package_nameContext> package_name() {
			return GetRuleContexts<Package_nameContext>();
		}
		public ITerminalNode REPLACE() { return GetToken(plsqlParser.REPLACE, 0); }
		public ITerminalNode IS() { return GetToken(plsqlParser.IS, 0); }
		public ITerminalNode PACKAGE() { return GetToken(plsqlParser.PACKAGE, 0); }
		public IReadOnlyList<Package_obj_specContext> package_obj_spec() {
			return GetRuleContexts<Package_obj_specContext>();
		}
		public Package_obj_specContext package_obj_spec(int i) {
			return GetRuleContext<Package_obj_specContext>(i);
		}
		public Package_nameContext package_name(int i) {
			return GetRuleContext<Package_nameContext>(i);
		}
		public ITerminalNode END() { return GetToken(plsqlParser.END, 0); }
		public ITerminalNode CREATE() { return GetToken(plsqlParser.CREATE, 0); }
		public ITerminalNode OR() { return GetToken(plsqlParser.OR, 0); }
		public ITerminalNode AS() { return GetToken(plsqlParser.AS, 0); }
		public Invoker_rights_clauseContext invoker_rights_clause() {
			return GetRuleContext<Invoker_rights_clauseContext>(0);
		}
		public Create_packageContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_create_package; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCreate_package(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCreate_package(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreate_package(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Create_packageContext create_package() {
		Create_packageContext _localctx = new Create_packageContext(_ctx, State);
		EnterRule(_localctx, 30, RULE_create_package);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1005; Match(CREATE);
			State = 1008;
			_la = _input.La(1);
			if (_la==OR) {
				{
				State = 1006; Match(OR);
				State = 1007; Match(REPLACE);
				}
			}

			State = 1010; Match(PACKAGE);
			State = 1011; package_name();
			State = 1013;
			_la = _input.La(1);
			if (_la==AUTHID) {
				{
				State = 1012; invoker_rights_clause();
				}
			}

			State = 1015;
			_la = _input.La(1);
			if ( !(_la==AS || _la==IS) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			State = 1019;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (CONSTANT - 66)) | (1L << (CONSTRAINT - 66)) | (1L << (CONSTRAINTS - 66)) | (1L << (CONSTRUCTOR - 66)) | (1L << (CONTENT - 66)) | (1L << (CONTEXT - 66)) | (1L << (CONTINUE - 66)) | (1L << (CONVERT - 66)) | (1L << (CORRUPT_XID - 66)) | (1L << (CORRUPT_XID_ALL - 66)) | (1L << (COST - 66)) | (1L << (COUNT - 66)) | (1L << (CROSS - 66)) | (1L << (CUBE - 66)) | (1L << (CURRENT_USER - 66)) | (1L << (CURSOR - 66)) | (1L << (CUSTOMDATUM - 66)) | (1L << (CYCLE - 66)) | (1L << (DATA - 66)) | (1L << (DATABASE - 66)) | (1L << (DAY - 66)) | (1L << (DB_ROLE_CHANGE - 66)) | (1L << (DBTIMEZONE - 66)) | (1L << (DDL - 66)) | (1L << (DEBUG - 66)) | (1L << (DEC - 66)) | (1L << (DECIMAL - 66)) | (1L << (DECOMPOSE - 66)) | (1L << (DECREMENT - 66)) | (1L << (DEFAULTS - 66)) | (1L << (DEFERRED - 66)) | (1L << (DEFINER - 66)) | (1L << (DETERMINISTIC - 66)) | (1L << (DIMENSION - 66)) | (1L << (DISABLE - 66)) | (1L << (DISASSOCIATE - 66)) | (1L << (DOCUMENT - 66)) | (1L << (DOUBLE - 66)) | (1L << (DSINTERVAL_UNCONSTRAINED - 66)) | (1L << (EACH - 66)) | (1L << (ELEMENT - 66)) | (1L << (EMPTY - 66)) | (1L << (ENABLE - 66)) | (1L << (ENCODING - 66)) | (1L << (ENTITYESCAPING - 66)) | (1L << (ERR - 66)) | (1L << (ERRORS - 66)) | (1L << (ESCAPE - 66)) | (1L << (EVALNAME - 66)) | (1L << (EXCEPTION - 66)) | (1L << (EXCEPTION_INIT - 66)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)) | (1L << (EXIT - 130)) | (1L << (EXPLAIN - 130)) | (1L << (EXTERNAL - 130)) | (1L << (EXTRACT - 130)) | (1L << (FAILURE - 130)) | (1L << (FINAL - 130)) | (1L << (FIRST - 130)) | (1L << (FIRST_VALUE - 130)) | (1L << (FLOAT - 130)) | (1L << (FOLLOWING - 130)) | (1L << (FOLLOWS - 130)) | (1L << (FORALL - 130)) | (1L << (FORCE - 130)) | (1L << (FULL - 130)) | (1L << (FUNCTION - 130)) | (1L << (GROUPING - 130)) | (1L << (HASH - 130)) | (1L << (HIDE - 130)) | (1L << (HOUR - 130)) | (1L << (IGNORE - 130)) | (1L << (IMMEDIATE - 130)) | (1L << (INCLUDE - 130)) | (1L << (INCLUDING - 130)) | (1L << (INCREMENT - 130)) | (1L << (INDENT - 130)) | (1L << (INDEXED - 130)) | (1L << (INDICATOR - 130)) | (1L << (INDICES - 130)) | (1L << (INFINITE - 130)) | (1L << (INLINE - 130)) | (1L << (INNER - 130)) | (1L << (INOUT - 130)) | (1L << (INSTANTIABLE - 130)) | (1L << (INSTEAD - 130)) | (1L << (INT - 130)) | (1L << (INTEGER - 130)) | (1L << (INTERVAL - 130)) | (1L << (INVALIDATE - 130)) | (1L << (ISOLATION - 130)) | (1L << (ITERATE - 130)) | (1L << (JAVA - 130)) | (1L << (JOIN - 130)) | (1L << (KEEP - 130)) | (1L << (LANGUAGE - 130)))) != 0) || ((((_la - 194)) & ~0x3f) == 0 && ((1L << (_la - 194)) & ((1L << (LAST - 194)) | (1L << (LAST_VALUE - 194)) | (1L << (LEADING - 194)) | (1L << (LEFT - 194)) | (1L << (LEVEL - 194)) | (1L << (LIBRARY - 194)) | (1L << (LIKE2 - 194)) | (1L << (LIKE4 - 194)) | (1L << (LIKEC - 194)) | (1L << (LIMIT - 194)) | (1L << (LOCAL - 194)) | (1L << (LOCKED - 194)) | (1L << (LOG - 194)) | (1L << (LOGOFF - 194)) | (1L << (LOGON - 194)) | (1L << (LONG - 194)) | (1L << (LOOP - 194)) | (1L << (MAIN - 194)) | (1L << (MAP - 194)) | (1L << (MATCHED - 194)) | (1L << (MAXVALUE - 194)) | (1L << (MEASURES - 194)) | (1L << (MEMBER - 194)) | (1L << (MERGE - 194)) | (1L << (MINUTE - 194)) | (1L << (MINVALUE - 194)) | (1L << (MLSLABEL - 194)) | (1L << (MODEL - 194)) | (1L << (MODIFY - 194)) | (1L << (MONTH - 194)) | (1L << (MULTISET - 194)) | (1L << (NAME - 194)) | (1L << (NAN - 194)) | (1L << (NATURAL - 194)) | (1L << (NATURALN - 194)) | (1L << (NAV - 194)) | (1L << (NCHAR - 194)) | (1L << (NCHAR_CS - 194)) | (1L << (NCLOB - 194)) | (1L << (NESTED - 194)) | (1L << (NEW - 194)) | (1L << (NO - 194)) | (1L << (NOAUDIT - 194)) | (1L << (NOCOPY - 194)) | (1L << (NOCYCLE - 194)) | (1L << (NOENTITYESCAPING - 194)) | (1L << (NONE - 194)) | (1L << (NOSCHEMACHECK - 194)) | (1L << (NULLS - 194)) | (1L << (NUMBER - 194)) | (1L << (NUMERIC - 194)) | (1L << (NVARCHAR2 - 194)) | (1L << (OBJECT - 194)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (OFF - 259)) | (1L << (OID - 259)) | (1L << (OLD - 259)) | (1L << (ONLY - 259)) | (1L << (OPEN - 259)) | (1L << (ORADATA - 259)) | (1L << (ORDINALITY - 259)) | (1L << (OSERROR - 259)) | (1L << (OUT - 259)) | (1L << (OUTER - 259)) | (1L << (OVER - 259)) | (1L << (OVERRIDING - 259)) | (1L << (PACKAGE - 259)) | (1L << (PARALLEL_ENABLE - 259)) | (1L << (PARAMETERS - 259)) | (1L << (PARENT - 259)) | (1L << (PARTITION - 259)) | (1L << (PASSING - 259)) | (1L << (PATH - 259)) | (1L << (PIPELINED - 259)) | (1L << (PLAN - 259)) | (1L << (PLS_INTEGER - 259)) | (1L << (POSITIVE - 259)) | (1L << (POSITIVEN - 259)) | (1L << (PRAGMA - 259)) | (1L << (PRECEDING - 259)) | (1L << (PRECISION - 259)) | (1L << (PRESENT - 259)) | (1L << (PROCEDURE - 259)) | (1L << (RAISE - 259)) | (1L << (RANGE - 259)) | (1L << (RAW - 259)) | (1L << (READ - 259)) | (1L << (REAL - 259)) | (1L << (RECORD - 259)) | (1L << (REF - 259)) | (1L << (REFERENCE - 259)) | (1L << (REFERENCING - 259)) | (1L << (REJECT - 259)) | (1L << (RELIES_ON - 259)) | (1L << (RENAME - 259)) | (1L << (REPLACE - 259)) | (1L << (RESPECT - 259)) | (1L << (RESTRICT_REFERENCES - 259)) | (1L << (RESULT - 259)) | (1L << (RESULT_CACHE - 259)) | (1L << (RETURN - 259)) | (1L << (RETURNING - 259)) | (1L << (REUSE - 259)) | (1L << (REVERSE - 259)) | (1L << (RIGHT - 259)))) != 0) || ((((_la - 323)) & ~0x3f) == 0 && ((1L << (_la - 323)) & ((1L << (ROLLBACK - 323)) | (1L << (ROLLUP - 323)) | (1L << (ROW - 323)) | (1L << (ROWID - 323)) | (1L << (ROWS - 323)) | (1L << (RULES - 323)) | (1L << (SAMPLE - 323)) | (1L << (SAVE - 323)) | (1L << (SAVEPOINT - 323)) | (1L << (SCHEMA - 323)) | (1L << (SCHEMACHECK - 323)) | (1L << (SCN - 323)) | (1L << (SECOND - 323)) | (1L << (SEED - 323)) | (1L << (SEGMENT - 323)) | (1L << (SELF - 323)) | (1L << (SEQUENTIAL - 323)) | (1L << (SERIALIZABLE - 323)) | (1L << (SERIALLY_REUSABLE - 323)) | (1L << (SERVERERROR - 323)) | (1L << (SESSIONTIMEZONE - 323)) | (1L << (SET - 323)) | (1L << (SETS - 323)) | (1L << (SETTINGS - 323)) | (1L << (SHOW - 323)) | (1L << (SHUTDOWN - 323)) | (1L << (SIBLINGS - 323)) | (1L << (SIGNTYPE - 323)) | (1L << (SIMPLE_INTEGER - 323)) | (1L << (SINGLE - 323)) | (1L << (SKIP_ - 323)) | (1L << (SMALLINT - 323)) | (1L << (SNAPSHOT - 323)) | (1L << (SOME - 323)) | (1L << (SPECIFICATION - 323)) | (1L << (SQLDATA - 323)) | (1L << (SQLERROR - 323)) | (1L << (STANDALONE - 323)) | (1L << (STARTUP - 323)) | (1L << (STATEMENT - 323)) | (1L << (STATEMENT_ID - 323)) | (1L << (STATIC - 323)) | (1L << (STATISTICS - 323)) | (1L << (STRING - 323)) | (1L << (SUBMULTISET - 323)) | (1L << (SUBPARTITION - 323)) | (1L << (SUBSTITUTABLE - 323)) | (1L << (SUBTYPE - 323)) | (1L << (SUCCESS - 323)) | (1L << (SUSPEND - 323)) | (1L << (TIME - 323)) | (1L << (TIMESTAMP - 323)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_UNCONSTRAINED - 323)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TIMEZONE_ABBR - 387)) | (1L << (TIMEZONE_HOUR - 387)) | (1L << (TIMEZONE_MINUTE - 387)) | (1L << (TIMEZONE_REGION - 387)) | (1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (YMINTERVAL_UNCONSTRAINED - 451)) | (1L << (ZONE - 451)) | (1L << (PREDICTION - 451)) | (1L << (PREDICTION_BOUNDS - 451)) | (1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (COVAR_ - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (REGR_ - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (TRIM - 451)) | (1L << (SUM - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (VARIANCE - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				{
				State = 1016; package_obj_spec();
				}
				}
				State = 1021;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 1022; Match(END);
			State = 1024;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (CONSTANT - 66)) | (1L << (CONSTRAINT - 66)) | (1L << (CONSTRAINTS - 66)) | (1L << (CONSTRUCTOR - 66)) | (1L << (CONTENT - 66)) | (1L << (CONTEXT - 66)) | (1L << (CONTINUE - 66)) | (1L << (CONVERT - 66)) | (1L << (CORRUPT_XID - 66)) | (1L << (CORRUPT_XID_ALL - 66)) | (1L << (COST - 66)) | (1L << (COUNT - 66)) | (1L << (CROSS - 66)) | (1L << (CUBE - 66)) | (1L << (CURRENT_USER - 66)) | (1L << (CURSOR - 66)) | (1L << (CUSTOMDATUM - 66)) | (1L << (CYCLE - 66)) | (1L << (DATA - 66)) | (1L << (DATABASE - 66)) | (1L << (DAY - 66)) | (1L << (DB_ROLE_CHANGE - 66)) | (1L << (DBTIMEZONE - 66)) | (1L << (DDL - 66)) | (1L << (DEBUG - 66)) | (1L << (DEC - 66)) | (1L << (DECIMAL - 66)) | (1L << (DECOMPOSE - 66)) | (1L << (DECREMENT - 66)) | (1L << (DEFAULTS - 66)) | (1L << (DEFERRED - 66)) | (1L << (DEFINER - 66)) | (1L << (DETERMINISTIC - 66)) | (1L << (DIMENSION - 66)) | (1L << (DISABLE - 66)) | (1L << (DISASSOCIATE - 66)) | (1L << (DOCUMENT - 66)) | (1L << (DOUBLE - 66)) | (1L << (DSINTERVAL_UNCONSTRAINED - 66)) | (1L << (EACH - 66)) | (1L << (ELEMENT - 66)) | (1L << (EMPTY - 66)) | (1L << (ENABLE - 66)) | (1L << (ENCODING - 66)) | (1L << (ENTITYESCAPING - 66)) | (1L << (ERR - 66)) | (1L << (ERRORS - 66)) | (1L << (ESCAPE - 66)) | (1L << (EVALNAME - 66)) | (1L << (EXCEPTION - 66)) | (1L << (EXCEPTION_INIT - 66)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)) | (1L << (EXIT - 130)) | (1L << (EXPLAIN - 130)) | (1L << (EXTERNAL - 130)) | (1L << (EXTRACT - 130)) | (1L << (FAILURE - 130)) | (1L << (FINAL - 130)) | (1L << (FIRST - 130)) | (1L << (FIRST_VALUE - 130)) | (1L << (FLOAT - 130)) | (1L << (FOLLOWING - 130)) | (1L << (FOLLOWS - 130)) | (1L << (FORALL - 130)) | (1L << (FORCE - 130)) | (1L << (FULL - 130)) | (1L << (FUNCTION - 130)) | (1L << (GROUPING - 130)) | (1L << (HASH - 130)) | (1L << (HIDE - 130)) | (1L << (HOUR - 130)) | (1L << (IGNORE - 130)) | (1L << (IMMEDIATE - 130)) | (1L << (INCLUDE - 130)) | (1L << (INCLUDING - 130)) | (1L << (INCREMENT - 130)) | (1L << (INDENT - 130)) | (1L << (INDEXED - 130)) | (1L << (INDICATOR - 130)) | (1L << (INDICES - 130)) | (1L << (INFINITE - 130)) | (1L << (INLINE - 130)) | (1L << (INNER - 130)) | (1L << (INOUT - 130)) | (1L << (INSTANTIABLE - 130)) | (1L << (INSTEAD - 130)) | (1L << (INT - 130)) | (1L << (INTEGER - 130)) | (1L << (INTERVAL - 130)) | (1L << (INVALIDATE - 130)) | (1L << (ISOLATION - 130)) | (1L << (ITERATE - 130)) | (1L << (JAVA - 130)) | (1L << (JOIN - 130)) | (1L << (KEEP - 130)) | (1L << (LANGUAGE - 130)))) != 0) || ((((_la - 194)) & ~0x3f) == 0 && ((1L << (_la - 194)) & ((1L << (LAST - 194)) | (1L << (LAST_VALUE - 194)) | (1L << (LEADING - 194)) | (1L << (LEFT - 194)) | (1L << (LEVEL - 194)) | (1L << (LIBRARY - 194)) | (1L << (LIKE2 - 194)) | (1L << (LIKE4 - 194)) | (1L << (LIKEC - 194)) | (1L << (LIMIT - 194)) | (1L << (LOCAL - 194)) | (1L << (LOCKED - 194)) | (1L << (LOG - 194)) | (1L << (LOGOFF - 194)) | (1L << (LOGON - 194)) | (1L << (LONG - 194)) | (1L << (LOOP - 194)) | (1L << (MAIN - 194)) | (1L << (MAP - 194)) | (1L << (MATCHED - 194)) | (1L << (MAXVALUE - 194)) | (1L << (MEASURES - 194)) | (1L << (MEMBER - 194)) | (1L << (MERGE - 194)) | (1L << (MINUTE - 194)) | (1L << (MINVALUE - 194)) | (1L << (MLSLABEL - 194)) | (1L << (MODEL - 194)) | (1L << (MODIFY - 194)) | (1L << (MONTH - 194)) | (1L << (MULTISET - 194)) | (1L << (NAME - 194)) | (1L << (NAN - 194)) | (1L << (NATURAL - 194)) | (1L << (NATURALN - 194)) | (1L << (NAV - 194)) | (1L << (NCHAR - 194)) | (1L << (NCHAR_CS - 194)) | (1L << (NCLOB - 194)) | (1L << (NESTED - 194)) | (1L << (NEW - 194)) | (1L << (NO - 194)) | (1L << (NOAUDIT - 194)) | (1L << (NOCOPY - 194)) | (1L << (NOCYCLE - 194)) | (1L << (NOENTITYESCAPING - 194)) | (1L << (NONE - 194)) | (1L << (NOSCHEMACHECK - 194)) | (1L << (NULLS - 194)) | (1L << (NUMBER - 194)) | (1L << (NUMERIC - 194)) | (1L << (NVARCHAR2 - 194)) | (1L << (OBJECT - 194)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (OFF - 259)) | (1L << (OID - 259)) | (1L << (OLD - 259)) | (1L << (ONLY - 259)) | (1L << (OPEN - 259)) | (1L << (ORADATA - 259)) | (1L << (ORDINALITY - 259)) | (1L << (OSERROR - 259)) | (1L << (OUT - 259)) | (1L << (OUTER - 259)) | (1L << (OVER - 259)) | (1L << (OVERRIDING - 259)) | (1L << (PACKAGE - 259)) | (1L << (PARALLEL_ENABLE - 259)) | (1L << (PARAMETERS - 259)) | (1L << (PARENT - 259)) | (1L << (PARTITION - 259)) | (1L << (PASSING - 259)) | (1L << (PATH - 259)) | (1L << (PIPELINED - 259)) | (1L << (PLAN - 259)) | (1L << (PLS_INTEGER - 259)) | (1L << (POSITIVE - 259)) | (1L << (POSITIVEN - 259)) | (1L << (PRAGMA - 259)) | (1L << (PRECEDING - 259)) | (1L << (PRECISION - 259)) | (1L << (PRESENT - 259)) | (1L << (RAISE - 259)) | (1L << (RANGE - 259)) | (1L << (RAW - 259)) | (1L << (READ - 259)) | (1L << (REAL - 259)) | (1L << (RECORD - 259)) | (1L << (REF - 259)) | (1L << (REFERENCE - 259)) | (1L << (REFERENCING - 259)) | (1L << (REJECT - 259)) | (1L << (RELIES_ON - 259)) | (1L << (RENAME - 259)) | (1L << (REPLACE - 259)) | (1L << (RESPECT - 259)) | (1L << (RESTRICT_REFERENCES - 259)) | (1L << (RESULT - 259)) | (1L << (RESULT_CACHE - 259)) | (1L << (RETURN - 259)) | (1L << (RETURNING - 259)) | (1L << (REUSE - 259)) | (1L << (REVERSE - 259)) | (1L << (RIGHT - 259)))) != 0) || ((((_la - 323)) & ~0x3f) == 0 && ((1L << (_la - 323)) & ((1L << (ROLLBACK - 323)) | (1L << (ROLLUP - 323)) | (1L << (ROW - 323)) | (1L << (ROWID - 323)) | (1L << (ROWS - 323)) | (1L << (RULES - 323)) | (1L << (SAMPLE - 323)) | (1L << (SAVE - 323)) | (1L << (SAVEPOINT - 323)) | (1L << (SCHEMA - 323)) | (1L << (SCHEMACHECK - 323)) | (1L << (SCN - 323)) | (1L << (SECOND - 323)) | (1L << (SEED - 323)) | (1L << (SEGMENT - 323)) | (1L << (SELF - 323)) | (1L << (SEQUENTIAL - 323)) | (1L << (SERIALIZABLE - 323)) | (1L << (SERIALLY_REUSABLE - 323)) | (1L << (SERVERERROR - 323)) | (1L << (SESSIONTIMEZONE - 323)) | (1L << (SET - 323)) | (1L << (SETS - 323)) | (1L << (SETTINGS - 323)) | (1L << (SHOW - 323)) | (1L << (SHUTDOWN - 323)) | (1L << (SIBLINGS - 323)) | (1L << (SIGNTYPE - 323)) | (1L << (SIMPLE_INTEGER - 323)) | (1L << (SINGLE - 323)) | (1L << (SKIP_ - 323)) | (1L << (SMALLINT - 323)) | (1L << (SNAPSHOT - 323)) | (1L << (SOME - 323)) | (1L << (SPECIFICATION - 323)) | (1L << (SQLDATA - 323)) | (1L << (SQLERROR - 323)) | (1L << (STANDALONE - 323)) | (1L << (STARTUP - 323)) | (1L << (STATEMENT - 323)) | (1L << (STATEMENT_ID - 323)) | (1L << (STATIC - 323)) | (1L << (STATISTICS - 323)) | (1L << (STRING - 323)) | (1L << (SUBMULTISET - 323)) | (1L << (SUBPARTITION - 323)) | (1L << (SUBSTITUTABLE - 323)) | (1L << (SUBTYPE - 323)) | (1L << (SUCCESS - 323)) | (1L << (SUSPEND - 323)) | (1L << (TIME - 323)) | (1L << (TIMESTAMP - 323)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_UNCONSTRAINED - 323)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TIMEZONE_ABBR - 387)) | (1L << (TIMEZONE_HOUR - 387)) | (1L << (TIMEZONE_MINUTE - 387)) | (1L << (TIMEZONE_REGION - 387)) | (1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (YMINTERVAL_UNCONSTRAINED - 451)) | (1L << (ZONE - 451)) | (1L << (PREDICTION - 451)) | (1L << (PREDICTION_BOUNDS - 451)) | (1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (COVAR_ - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (REGR_ - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (TRIM - 451)) | (1L << (SUM - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (VARIANCE - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 1023; package_name();
				}
			}

			State = 1026; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Create_package_bodyContext : ParserRuleContext {
		public Seq_of_statementsContext seq_of_statements() {
			return GetRuleContext<Seq_of_statementsContext>(0);
		}
		public IReadOnlyList<Package_obj_bodyContext> package_obj_body() {
			return GetRuleContexts<Package_obj_bodyContext>();
		}
		public ITerminalNode PACKAGE() { return GetToken(plsqlParser.PACKAGE, 0); }
		public Package_obj_bodyContext package_obj_body(int i) {
			return GetRuleContext<Package_obj_bodyContext>(i);
		}
		public ITerminalNode OR() { return GetToken(plsqlParser.OR, 0); }
		public ITerminalNode AS() { return GetToken(plsqlParser.AS, 0); }
		public IReadOnlyList<Package_nameContext> package_name() {
			return GetRuleContexts<Package_nameContext>();
		}
		public ITerminalNode REPLACE() { return GetToken(plsqlParser.REPLACE, 0); }
		public ITerminalNode IS() { return GetToken(plsqlParser.IS, 0); }
		public Package_nameContext package_name(int i) {
			return GetRuleContext<Package_nameContext>(i);
		}
		public ITerminalNode BEGIN() { return GetToken(plsqlParser.BEGIN, 0); }
		public ITerminalNode END() { return GetToken(plsqlParser.END, 0); }
		public ITerminalNode CREATE() { return GetToken(plsqlParser.CREATE, 0); }
		public ITerminalNode BODY() { return GetToken(plsqlParser.BODY, 0); }
		public Create_package_bodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_create_package_body; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCreate_package_body(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCreate_package_body(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreate_package_body(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Create_package_bodyContext create_package_body() {
		Create_package_bodyContext _localctx = new Create_package_bodyContext(_ctx, State);
		EnterRule(_localctx, 32, RULE_create_package_body);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1028; Match(CREATE);
			State = 1031;
			_la = _input.La(1);
			if (_la==OR) {
				{
				State = 1029; Match(OR);
				State = 1030; Match(REPLACE);
				}
			}

			State = 1033; Match(PACKAGE);
			State = 1034; Match(BODY);
			State = 1035; package_name();
			State = 1036;
			_la = _input.La(1);
			if ( !(_la==AS || _la==IS) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			State = 1040;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (CONSTANT - 66)) | (1L << (CONSTRAINT - 66)) | (1L << (CONSTRAINTS - 66)) | (1L << (CONSTRUCTOR - 66)) | (1L << (CONTENT - 66)) | (1L << (CONTEXT - 66)) | (1L << (CONTINUE - 66)) | (1L << (CONVERT - 66)) | (1L << (CORRUPT_XID - 66)) | (1L << (CORRUPT_XID_ALL - 66)) | (1L << (COST - 66)) | (1L << (COUNT - 66)) | (1L << (CROSS - 66)) | (1L << (CUBE - 66)) | (1L << (CURRENT_USER - 66)) | (1L << (CURSOR - 66)) | (1L << (CUSTOMDATUM - 66)) | (1L << (CYCLE - 66)) | (1L << (DATA - 66)) | (1L << (DATABASE - 66)) | (1L << (DAY - 66)) | (1L << (DB_ROLE_CHANGE - 66)) | (1L << (DBTIMEZONE - 66)) | (1L << (DDL - 66)) | (1L << (DEBUG - 66)) | (1L << (DEC - 66)) | (1L << (DECIMAL - 66)) | (1L << (DECOMPOSE - 66)) | (1L << (DECREMENT - 66)) | (1L << (DEFAULTS - 66)) | (1L << (DEFERRED - 66)) | (1L << (DEFINER - 66)) | (1L << (DETERMINISTIC - 66)) | (1L << (DIMENSION - 66)) | (1L << (DISABLE - 66)) | (1L << (DISASSOCIATE - 66)) | (1L << (DOCUMENT - 66)) | (1L << (DOUBLE - 66)) | (1L << (DSINTERVAL_UNCONSTRAINED - 66)) | (1L << (EACH - 66)) | (1L << (ELEMENT - 66)) | (1L << (EMPTY - 66)) | (1L << (ENABLE - 66)) | (1L << (ENCODING - 66)) | (1L << (ENTITYESCAPING - 66)) | (1L << (ERR - 66)) | (1L << (ERRORS - 66)) | (1L << (ESCAPE - 66)) | (1L << (EVALNAME - 66)) | (1L << (EXCEPTION - 66)) | (1L << (EXCEPTION_INIT - 66)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)) | (1L << (EXIT - 130)) | (1L << (EXPLAIN - 130)) | (1L << (EXTERNAL - 130)) | (1L << (EXTRACT - 130)) | (1L << (FAILURE - 130)) | (1L << (FINAL - 130)) | (1L << (FIRST - 130)) | (1L << (FIRST_VALUE - 130)) | (1L << (FLOAT - 130)) | (1L << (FOLLOWING - 130)) | (1L << (FOLLOWS - 130)) | (1L << (FORALL - 130)) | (1L << (FORCE - 130)) | (1L << (FULL - 130)) | (1L << (FUNCTION - 130)) | (1L << (GROUPING - 130)) | (1L << (HASH - 130)) | (1L << (HIDE - 130)) | (1L << (HOUR - 130)) | (1L << (IGNORE - 130)) | (1L << (IMMEDIATE - 130)) | (1L << (INCLUDE - 130)) | (1L << (INCLUDING - 130)) | (1L << (INCREMENT - 130)) | (1L << (INDENT - 130)) | (1L << (INDEXED - 130)) | (1L << (INDICATOR - 130)) | (1L << (INDICES - 130)) | (1L << (INFINITE - 130)) | (1L << (INLINE - 130)) | (1L << (INNER - 130)) | (1L << (INOUT - 130)) | (1L << (INSTANTIABLE - 130)) | (1L << (INSTEAD - 130)) | (1L << (INT - 130)) | (1L << (INTEGER - 130)) | (1L << (INTERVAL - 130)) | (1L << (INVALIDATE - 130)) | (1L << (ISOLATION - 130)) | (1L << (ITERATE - 130)) | (1L << (JAVA - 130)) | (1L << (JOIN - 130)) | (1L << (KEEP - 130)) | (1L << (LANGUAGE - 130)))) != 0) || ((((_la - 194)) & ~0x3f) == 0 && ((1L << (_la - 194)) & ((1L << (LAST - 194)) | (1L << (LAST_VALUE - 194)) | (1L << (LEADING - 194)) | (1L << (LEFT - 194)) | (1L << (LEVEL - 194)) | (1L << (LIBRARY - 194)) | (1L << (LIKE2 - 194)) | (1L << (LIKE4 - 194)) | (1L << (LIKEC - 194)) | (1L << (LIMIT - 194)) | (1L << (LOCAL - 194)) | (1L << (LOCKED - 194)) | (1L << (LOG - 194)) | (1L << (LOGOFF - 194)) | (1L << (LOGON - 194)) | (1L << (LONG - 194)) | (1L << (LOOP - 194)) | (1L << (MAIN - 194)) | (1L << (MAP - 194)) | (1L << (MATCHED - 194)) | (1L << (MAXVALUE - 194)) | (1L << (MEASURES - 194)) | (1L << (MEMBER - 194)) | (1L << (MERGE - 194)) | (1L << (MINUTE - 194)) | (1L << (MINVALUE - 194)) | (1L << (MLSLABEL - 194)) | (1L << (MODEL - 194)) | (1L << (MODIFY - 194)) | (1L << (MONTH - 194)) | (1L << (MULTISET - 194)) | (1L << (NAME - 194)) | (1L << (NAN - 194)) | (1L << (NATURAL - 194)) | (1L << (NATURALN - 194)) | (1L << (NAV - 194)) | (1L << (NCHAR - 194)) | (1L << (NCHAR_CS - 194)) | (1L << (NCLOB - 194)) | (1L << (NESTED - 194)) | (1L << (NEW - 194)) | (1L << (NO - 194)) | (1L << (NOAUDIT - 194)) | (1L << (NOCOPY - 194)) | (1L << (NOCYCLE - 194)) | (1L << (NOENTITYESCAPING - 194)) | (1L << (NONE - 194)) | (1L << (NOSCHEMACHECK - 194)) | (1L << (NULLS - 194)) | (1L << (NUMBER - 194)) | (1L << (NUMERIC - 194)) | (1L << (NVARCHAR2 - 194)) | (1L << (OBJECT - 194)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (OFF - 259)) | (1L << (OID - 259)) | (1L << (OLD - 259)) | (1L << (ONLY - 259)) | (1L << (OPEN - 259)) | (1L << (ORADATA - 259)) | (1L << (ORDINALITY - 259)) | (1L << (OSERROR - 259)) | (1L << (OUT - 259)) | (1L << (OUTER - 259)) | (1L << (OVER - 259)) | (1L << (OVERRIDING - 259)) | (1L << (PACKAGE - 259)) | (1L << (PARALLEL_ENABLE - 259)) | (1L << (PARAMETERS - 259)) | (1L << (PARENT - 259)) | (1L << (PARTITION - 259)) | (1L << (PASSING - 259)) | (1L << (PATH - 259)) | (1L << (PIPELINED - 259)) | (1L << (PLAN - 259)) | (1L << (PLS_INTEGER - 259)) | (1L << (POSITIVE - 259)) | (1L << (POSITIVEN - 259)) | (1L << (PRAGMA - 259)) | (1L << (PRECEDING - 259)) | (1L << (PRECISION - 259)) | (1L << (PRESENT - 259)) | (1L << (PROCEDURE - 259)) | (1L << (RAISE - 259)) | (1L << (RANGE - 259)) | (1L << (RAW - 259)) | (1L << (READ - 259)) | (1L << (REAL - 259)) | (1L << (RECORD - 259)) | (1L << (REF - 259)) | (1L << (REFERENCE - 259)) | (1L << (REFERENCING - 259)) | (1L << (REJECT - 259)) | (1L << (RELIES_ON - 259)) | (1L << (RENAME - 259)) | (1L << (REPLACE - 259)) | (1L << (RESPECT - 259)) | (1L << (RESTRICT_REFERENCES - 259)) | (1L << (RESULT - 259)) | (1L << (RESULT_CACHE - 259)) | (1L << (RETURN - 259)) | (1L << (RETURNING - 259)) | (1L << (REUSE - 259)) | (1L << (REVERSE - 259)) | (1L << (RIGHT - 259)))) != 0) || ((((_la - 323)) & ~0x3f) == 0 && ((1L << (_la - 323)) & ((1L << (ROLLBACK - 323)) | (1L << (ROLLUP - 323)) | (1L << (ROW - 323)) | (1L << (ROWID - 323)) | (1L << (ROWS - 323)) | (1L << (RULES - 323)) | (1L << (SAMPLE - 323)) | (1L << (SAVE - 323)) | (1L << (SAVEPOINT - 323)) | (1L << (SCHEMA - 323)) | (1L << (SCHEMACHECK - 323)) | (1L << (SCN - 323)) | (1L << (SECOND - 323)) | (1L << (SEED - 323)) | (1L << (SEGMENT - 323)) | (1L << (SELF - 323)) | (1L << (SEQUENTIAL - 323)) | (1L << (SERIALIZABLE - 323)) | (1L << (SERIALLY_REUSABLE - 323)) | (1L << (SERVERERROR - 323)) | (1L << (SESSIONTIMEZONE - 323)) | (1L << (SET - 323)) | (1L << (SETS - 323)) | (1L << (SETTINGS - 323)) | (1L << (SHOW - 323)) | (1L << (SHUTDOWN - 323)) | (1L << (SIBLINGS - 323)) | (1L << (SIGNTYPE - 323)) | (1L << (SIMPLE_INTEGER - 323)) | (1L << (SINGLE - 323)) | (1L << (SKIP_ - 323)) | (1L << (SMALLINT - 323)) | (1L << (SNAPSHOT - 323)) | (1L << (SOME - 323)) | (1L << (SPECIFICATION - 323)) | (1L << (SQLDATA - 323)) | (1L << (SQLERROR - 323)) | (1L << (STANDALONE - 323)) | (1L << (STARTUP - 323)) | (1L << (STATEMENT - 323)) | (1L << (STATEMENT_ID - 323)) | (1L << (STATIC - 323)) | (1L << (STATISTICS - 323)) | (1L << (STRING - 323)) | (1L << (SUBMULTISET - 323)) | (1L << (SUBPARTITION - 323)) | (1L << (SUBSTITUTABLE - 323)) | (1L << (SUBTYPE - 323)) | (1L << (SUCCESS - 323)) | (1L << (SUSPEND - 323)) | (1L << (TIME - 323)) | (1L << (TIMESTAMP - 323)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_UNCONSTRAINED - 323)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TIMEZONE_ABBR - 387)) | (1L << (TIMEZONE_HOUR - 387)) | (1L << (TIMEZONE_MINUTE - 387)) | (1L << (TIMEZONE_REGION - 387)) | (1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (YMINTERVAL_UNCONSTRAINED - 451)) | (1L << (ZONE - 451)) | (1L << (PREDICTION - 451)) | (1L << (PREDICTION_BOUNDS - 451)) | (1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (COVAR_ - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (REGR_ - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (TRIM - 451)) | (1L << (SUM - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (VARIANCE - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				{
				State = 1037; package_obj_body();
				}
				}
				State = 1042;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 1049;
			switch (_input.La(1)) {
			case BEGIN:
				{
				State = 1043; Match(BEGIN);
				State = 1044; seq_of_statements();
				}
				break;
			case END:
				{
				State = 1045; Match(END);
				State = 1047;
				_la = _input.La(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (CONSTANT - 66)) | (1L << (CONSTRAINT - 66)) | (1L << (CONSTRAINTS - 66)) | (1L << (CONSTRUCTOR - 66)) | (1L << (CONTENT - 66)) | (1L << (CONTEXT - 66)) | (1L << (CONTINUE - 66)) | (1L << (CONVERT - 66)) | (1L << (CORRUPT_XID - 66)) | (1L << (CORRUPT_XID_ALL - 66)) | (1L << (COST - 66)) | (1L << (COUNT - 66)) | (1L << (CROSS - 66)) | (1L << (CUBE - 66)) | (1L << (CURRENT_USER - 66)) | (1L << (CURSOR - 66)) | (1L << (CUSTOMDATUM - 66)) | (1L << (CYCLE - 66)) | (1L << (DATA - 66)) | (1L << (DATABASE - 66)) | (1L << (DAY - 66)) | (1L << (DB_ROLE_CHANGE - 66)) | (1L << (DBTIMEZONE - 66)) | (1L << (DDL - 66)) | (1L << (DEBUG - 66)) | (1L << (DEC - 66)) | (1L << (DECIMAL - 66)) | (1L << (DECOMPOSE - 66)) | (1L << (DECREMENT - 66)) | (1L << (DEFAULTS - 66)) | (1L << (DEFERRED - 66)) | (1L << (DEFINER - 66)) | (1L << (DETERMINISTIC - 66)) | (1L << (DIMENSION - 66)) | (1L << (DISABLE - 66)) | (1L << (DISASSOCIATE - 66)) | (1L << (DOCUMENT - 66)) | (1L << (DOUBLE - 66)) | (1L << (DSINTERVAL_UNCONSTRAINED - 66)) | (1L << (EACH - 66)) | (1L << (ELEMENT - 66)) | (1L << (EMPTY - 66)) | (1L << (ENABLE - 66)) | (1L << (ENCODING - 66)) | (1L << (ENTITYESCAPING - 66)) | (1L << (ERR - 66)) | (1L << (ERRORS - 66)) | (1L << (ESCAPE - 66)) | (1L << (EVALNAME - 66)) | (1L << (EXCEPTION - 66)) | (1L << (EXCEPTION_INIT - 66)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)) | (1L << (EXIT - 130)) | (1L << (EXPLAIN - 130)) | (1L << (EXTERNAL - 130)) | (1L << (EXTRACT - 130)) | (1L << (FAILURE - 130)) | (1L << (FINAL - 130)) | (1L << (FIRST - 130)) | (1L << (FIRST_VALUE - 130)) | (1L << (FLOAT - 130)) | (1L << (FOLLOWING - 130)) | (1L << (FOLLOWS - 130)) | (1L << (FORALL - 130)) | (1L << (FORCE - 130)) | (1L << (FULL - 130)) | (1L << (FUNCTION - 130)) | (1L << (GROUPING - 130)) | (1L << (HASH - 130)) | (1L << (HIDE - 130)) | (1L << (HOUR - 130)) | (1L << (IGNORE - 130)) | (1L << (IMMEDIATE - 130)) | (1L << (INCLUDE - 130)) | (1L << (INCLUDING - 130)) | (1L << (INCREMENT - 130)) | (1L << (INDENT - 130)) | (1L << (INDEXED - 130)) | (1L << (INDICATOR - 130)) | (1L << (INDICES - 130)) | (1L << (INFINITE - 130)) | (1L << (INLINE - 130)) | (1L << (INNER - 130)) | (1L << (INOUT - 130)) | (1L << (INSTANTIABLE - 130)) | (1L << (INSTEAD - 130)) | (1L << (INT - 130)) | (1L << (INTEGER - 130)) | (1L << (INTERVAL - 130)) | (1L << (INVALIDATE - 130)) | (1L << (ISOLATION - 130)) | (1L << (ITERATE - 130)) | (1L << (JAVA - 130)) | (1L << (JOIN - 130)) | (1L << (KEEP - 130)) | (1L << (LANGUAGE - 130)))) != 0) || ((((_la - 194)) & ~0x3f) == 0 && ((1L << (_la - 194)) & ((1L << (LAST - 194)) | (1L << (LAST_VALUE - 194)) | (1L << (LEADING - 194)) | (1L << (LEFT - 194)) | (1L << (LEVEL - 194)) | (1L << (LIBRARY - 194)) | (1L << (LIKE2 - 194)) | (1L << (LIKE4 - 194)) | (1L << (LIKEC - 194)) | (1L << (LIMIT - 194)) | (1L << (LOCAL - 194)) | (1L << (LOCKED - 194)) | (1L << (LOG - 194)) | (1L << (LOGOFF - 194)) | (1L << (LOGON - 194)) | (1L << (LONG - 194)) | (1L << (LOOP - 194)) | (1L << (MAIN - 194)) | (1L << (MAP - 194)) | (1L << (MATCHED - 194)) | (1L << (MAXVALUE - 194)) | (1L << (MEASURES - 194)) | (1L << (MEMBER - 194)) | (1L << (MERGE - 194)) | (1L << (MINUTE - 194)) | (1L << (MINVALUE - 194)) | (1L << (MLSLABEL - 194)) | (1L << (MODEL - 194)) | (1L << (MODIFY - 194)) | (1L << (MONTH - 194)) | (1L << (MULTISET - 194)) | (1L << (NAME - 194)) | (1L << (NAN - 194)) | (1L << (NATURAL - 194)) | (1L << (NATURALN - 194)) | (1L << (NAV - 194)) | (1L << (NCHAR - 194)) | (1L << (NCHAR_CS - 194)) | (1L << (NCLOB - 194)) | (1L << (NESTED - 194)) | (1L << (NEW - 194)) | (1L << (NO - 194)) | (1L << (NOAUDIT - 194)) | (1L << (NOCOPY - 194)) | (1L << (NOCYCLE - 194)) | (1L << (NOENTITYESCAPING - 194)) | (1L << (NONE - 194)) | (1L << (NOSCHEMACHECK - 194)) | (1L << (NULLS - 194)) | (1L << (NUMBER - 194)) | (1L << (NUMERIC - 194)) | (1L << (NVARCHAR2 - 194)) | (1L << (OBJECT - 194)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (OFF - 259)) | (1L << (OID - 259)) | (1L << (OLD - 259)) | (1L << (ONLY - 259)) | (1L << (OPEN - 259)) | (1L << (ORADATA - 259)) | (1L << (ORDINALITY - 259)) | (1L << (OSERROR - 259)) | (1L << (OUT - 259)) | (1L << (OUTER - 259)) | (1L << (OVER - 259)) | (1L << (OVERRIDING - 259)) | (1L << (PACKAGE - 259)) | (1L << (PARALLEL_ENABLE - 259)) | (1L << (PARAMETERS - 259)) | (1L << (PARENT - 259)) | (1L << (PARTITION - 259)) | (1L << (PASSING - 259)) | (1L << (PATH - 259)) | (1L << (PIPELINED - 259)) | (1L << (PLAN - 259)) | (1L << (PLS_INTEGER - 259)) | (1L << (POSITIVE - 259)) | (1L << (POSITIVEN - 259)) | (1L << (PRAGMA - 259)) | (1L << (PRECEDING - 259)) | (1L << (PRECISION - 259)) | (1L << (PRESENT - 259)) | (1L << (RAISE - 259)) | (1L << (RANGE - 259)) | (1L << (RAW - 259)) | (1L << (READ - 259)) | (1L << (REAL - 259)) | (1L << (RECORD - 259)) | (1L << (REF - 259)) | (1L << (REFERENCE - 259)) | (1L << (REFERENCING - 259)) | (1L << (REJECT - 259)) | (1L << (RELIES_ON - 259)) | (1L << (RENAME - 259)) | (1L << (REPLACE - 259)) | (1L << (RESPECT - 259)) | (1L << (RESTRICT_REFERENCES - 259)) | (1L << (RESULT - 259)) | (1L << (RESULT_CACHE - 259)) | (1L << (RETURN - 259)) | (1L << (RETURNING - 259)) | (1L << (REUSE - 259)) | (1L << (REVERSE - 259)) | (1L << (RIGHT - 259)))) != 0) || ((((_la - 323)) & ~0x3f) == 0 && ((1L << (_la - 323)) & ((1L << (ROLLBACK - 323)) | (1L << (ROLLUP - 323)) | (1L << (ROW - 323)) | (1L << (ROWID - 323)) | (1L << (ROWS - 323)) | (1L << (RULES - 323)) | (1L << (SAMPLE - 323)) | (1L << (SAVE - 323)) | (1L << (SAVEPOINT - 323)) | (1L << (SCHEMA - 323)) | (1L << (SCHEMACHECK - 323)) | (1L << (SCN - 323)) | (1L << (SECOND - 323)) | (1L << (SEED - 323)) | (1L << (SEGMENT - 323)) | (1L << (SELF - 323)) | (1L << (SEQUENTIAL - 323)) | (1L << (SERIALIZABLE - 323)) | (1L << (SERIALLY_REUSABLE - 323)) | (1L << (SERVERERROR - 323)) | (1L << (SESSIONTIMEZONE - 323)) | (1L << (SET - 323)) | (1L << (SETS - 323)) | (1L << (SETTINGS - 323)) | (1L << (SHOW - 323)) | (1L << (SHUTDOWN - 323)) | (1L << (SIBLINGS - 323)) | (1L << (SIGNTYPE - 323)) | (1L << (SIMPLE_INTEGER - 323)) | (1L << (SINGLE - 323)) | (1L << (SKIP_ - 323)) | (1L << (SMALLINT - 323)) | (1L << (SNAPSHOT - 323)) | (1L << (SOME - 323)) | (1L << (SPECIFICATION - 323)) | (1L << (SQLDATA - 323)) | (1L << (SQLERROR - 323)) | (1L << (STANDALONE - 323)) | (1L << (STARTUP - 323)) | (1L << (STATEMENT - 323)) | (1L << (STATEMENT_ID - 323)) | (1L << (STATIC - 323)) | (1L << (STATISTICS - 323)) | (1L << (STRING - 323)) | (1L << (SUBMULTISET - 323)) | (1L << (SUBPARTITION - 323)) | (1L << (SUBSTITUTABLE - 323)) | (1L << (SUBTYPE - 323)) | (1L << (SUCCESS - 323)) | (1L << (SUSPEND - 323)) | (1L << (TIME - 323)) | (1L << (TIMESTAMP - 323)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_UNCONSTRAINED - 323)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TIMEZONE_ABBR - 387)) | (1L << (TIMEZONE_HOUR - 387)) | (1L << (TIMEZONE_MINUTE - 387)) | (1L << (TIMEZONE_REGION - 387)) | (1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (YMINTERVAL_UNCONSTRAINED - 451)) | (1L << (ZONE - 451)) | (1L << (PREDICTION - 451)) | (1L << (PREDICTION_BOUNDS - 451)) | (1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (COVAR_ - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (REGR_ - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (TRIM - 451)) | (1L << (SUM - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (VARIANCE - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
					{
					State = 1046; package_name();
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1051; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Package_obj_specContext : ParserRuleContext {
		public Function_specContext function_spec() {
			return GetRuleContext<Function_specContext>(0);
		}
		public Pragma_declarationContext pragma_declaration() {
			return GetRuleContext<Pragma_declarationContext>(0);
		}
		public Subtype_declarationContext subtype_declaration() {
			return GetRuleContext<Subtype_declarationContext>(0);
		}
		public Cursor_declarationContext cursor_declaration() {
			return GetRuleContext<Cursor_declarationContext>(0);
		}
		public Variable_declarationContext variable_declaration() {
			return GetRuleContext<Variable_declarationContext>(0);
		}
		public Exception_declarationContext exception_declaration() {
			return GetRuleContext<Exception_declarationContext>(0);
		}
		public Procedure_specContext procedure_spec() {
			return GetRuleContext<Procedure_specContext>(0);
		}
		public Type_declarationContext type_declaration() {
			return GetRuleContext<Type_declarationContext>(0);
		}
		public Package_obj_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_package_obj_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterPackage_obj_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitPackage_obj_spec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPackage_obj_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Package_obj_specContext package_obj_spec() {
		Package_obj_specContext _localctx = new Package_obj_specContext(_ctx, State);
		EnterRule(_localctx, 34, RULE_package_obj_spec);
		try {
			State = 1061;
			switch ( Interpreter.AdaptivePredict(_input,42,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1053; variable_declaration();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1054; subtype_declaration();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1055; cursor_declaration();
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1056; exception_declaration();
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 1057; pragma_declaration();
				}
				break;

			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 1058; type_declaration();
				}
				break;

			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 1059; procedure_spec();
				}
				break;

			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 1060; function_spec();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Procedure_specContext : ParserRuleContext {
		public IReadOnlyList<ParameterContext> parameter() {
			return GetRuleContexts<ParameterContext>();
		}
		public ParameterContext parameter(int i) {
			return GetRuleContext<ParameterContext>(i);
		}
		public ITerminalNode PROCEDURE() { return GetToken(plsqlParser.PROCEDURE, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Procedure_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_procedure_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterProcedure_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitProcedure_spec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProcedure_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Procedure_specContext procedure_spec() {
		Procedure_specContext _localctx = new Procedure_specContext(_ctx, State);
		EnterRule(_localctx, 36, RULE_procedure_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1063; Match(PROCEDURE);
			State = 1064; identifier();
			State = 1076;
			_la = _input.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 1065; Match(LEFT_PAREN);
				State = 1066; parameter();
				State = 1071;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 1067; Match(COMMA);
					State = 1068; parameter();
					}
					}
					State = 1073;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 1074; Match(RIGHT_PAREN);
				}
			}

			State = 1078; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Function_specContext : ParserRuleContext {
		public ITerminalNode DETERMINISTIC() { return GetToken(plsqlParser.DETERMINISTIC, 0); }
		public IReadOnlyList<ParameterContext> parameter() {
			return GetRuleContexts<ParameterContext>();
		}
		public ITerminalNode FUNCTION() { return GetToken(plsqlParser.FUNCTION, 0); }
		public ITerminalNode RETURN() { return GetToken(plsqlParser.RETURN, 0); }
		public ParameterContext parameter(int i) {
			return GetRuleContext<ParameterContext>(i);
		}
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode RESULT_CACHE() { return GetToken(plsqlParser.RESULT_CACHE, 0); }
		public Function_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterFunction_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitFunction_spec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Function_specContext function_spec() {
		Function_specContext _localctx = new Function_specContext(_ctx, State);
		EnterRule(_localctx, 38, RULE_function_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1080; Match(FUNCTION);
			State = 1081; identifier();
			State = 1093;
			_la = _input.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 1082; Match(LEFT_PAREN);
				State = 1083; parameter();
				State = 1088;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 1084; Match(COMMA);
					State = 1085; parameter();
					}
					}
					State = 1090;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 1091; Match(RIGHT_PAREN);
				}
			}

			State = 1095; Match(RETURN);
			State = 1096; type_spec();
			State = 1098;
			_la = _input.La(1);
			if (_la==DETERMINISTIC) {
				{
				State = 1097; Match(DETERMINISTIC);
				}
			}

			State = 1101;
			_la = _input.La(1);
			if (_la==RESULT_CACHE) {
				{
				State = 1100; Match(RESULT_CACHE);
				}
			}

			State = 1103; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Package_obj_bodyContext : ParserRuleContext {
		public Function_specContext function_spec() {
			return GetRuleContext<Function_specContext>(0);
		}
		public Subtype_declarationContext subtype_declaration() {
			return GetRuleContext<Subtype_declarationContext>(0);
		}
		public Function_bodyContext function_body() {
			return GetRuleContext<Function_bodyContext>(0);
		}
		public Cursor_declarationContext cursor_declaration() {
			return GetRuleContext<Cursor_declarationContext>(0);
		}
		public Variable_declarationContext variable_declaration() {
			return GetRuleContext<Variable_declarationContext>(0);
		}
		public Exception_declarationContext exception_declaration() {
			return GetRuleContext<Exception_declarationContext>(0);
		}
		public Procedure_specContext procedure_spec() {
			return GetRuleContext<Procedure_specContext>(0);
		}
		public Type_declarationContext type_declaration() {
			return GetRuleContext<Type_declarationContext>(0);
		}
		public Procedure_bodyContext procedure_body() {
			return GetRuleContext<Procedure_bodyContext>(0);
		}
		public Package_obj_bodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_package_obj_body; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterPackage_obj_body(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitPackage_obj_body(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPackage_obj_body(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Package_obj_bodyContext package_obj_body() {
		Package_obj_bodyContext _localctx = new Package_obj_bodyContext(_ctx, State);
		EnterRule(_localctx, 40, RULE_package_obj_body);
		try {
			State = 1114;
			switch ( Interpreter.AdaptivePredict(_input,49,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1105; variable_declaration();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1106; subtype_declaration();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1107; cursor_declaration();
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1108; exception_declaration();
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 1109; type_declaration();
				}
				break;

			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 1110; procedure_body();
				}
				break;

			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 1111; function_body();
				}
				break;

			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 1112; procedure_spec();
				}
				break;

			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 1113; function_spec();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Drop_procedureContext : ParserRuleContext {
		public ITerminalNode DROP() { return GetToken(plsqlParser.DROP, 0); }
		public ITerminalNode PROCEDURE() { return GetToken(plsqlParser.PROCEDURE, 0); }
		public Procedure_nameContext procedure_name() {
			return GetRuleContext<Procedure_nameContext>(0);
		}
		public Drop_procedureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_drop_procedure; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterDrop_procedure(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitDrop_procedure(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDrop_procedure(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Drop_procedureContext drop_procedure() {
		Drop_procedureContext _localctx = new Drop_procedureContext(_ctx, State);
		EnterRule(_localctx, 42, RULE_drop_procedure);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1116; Match(DROP);
			State = 1117; Match(PROCEDURE);
			State = 1118; procedure_name();
			State = 1119; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_procedureContext : ParserRuleContext {
		public ITerminalNode REUSE() { return GetToken(plsqlParser.REUSE, 0); }
		public ITerminalNode DEBUG() { return GetToken(plsqlParser.DEBUG, 0); }
		public Compiler_parameters_clauseContext compiler_parameters_clause(int i) {
			return GetRuleContext<Compiler_parameters_clauseContext>(i);
		}
		public IReadOnlyList<Compiler_parameters_clauseContext> compiler_parameters_clause() {
			return GetRuleContexts<Compiler_parameters_clauseContext>();
		}
		public ITerminalNode SETTINGS() { return GetToken(plsqlParser.SETTINGS, 0); }
		public ITerminalNode COMPILE() { return GetToken(plsqlParser.COMPILE, 0); }
		public ITerminalNode PROCEDURE() { return GetToken(plsqlParser.PROCEDURE, 0); }
		public ITerminalNode ALTER() { return GetToken(plsqlParser.ALTER, 0); }
		public Procedure_nameContext procedure_name() {
			return GetRuleContext<Procedure_nameContext>(0);
		}
		public Alter_procedureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_procedure; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterAlter_procedure(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitAlter_procedure(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlter_procedure(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Alter_procedureContext alter_procedure() {
		Alter_procedureContext _localctx = new Alter_procedureContext(_ctx, State);
		EnterRule(_localctx, 44, RULE_alter_procedure);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1121; Match(ALTER);
			State = 1122; Match(PROCEDURE);
			State = 1123; procedure_name();
			State = 1124; Match(COMPILE);
			State = 1126;
			switch ( Interpreter.AdaptivePredict(_input,50,_ctx) ) {
			case 1:
				{
				State = 1125; Match(DEBUG);
				}
				break;
			}
			State = 1131;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,51,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 1128; compiler_parameters_clause();
					}
					} 
				}
				State = 1133;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,51,_ctx);
			}
			State = 1136;
			_la = _input.La(1);
			if (_la==REUSE) {
				{
				State = 1134; Match(REUSE);
				State = 1135; Match(SETTINGS);
				}
			}

			State = 1138; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Function_bodyContext : ParserRuleContext {
		public IReadOnlyList<Declare_specContext> declare_spec() {
			return GetRuleContexts<Declare_specContext>();
		}
		public ITerminalNode AGGREGATE() { return GetToken(plsqlParser.AGGREGATE, 0); }
		public ITerminalNode AS() { return GetToken(plsqlParser.AS, 0); }
		public IReadOnlyList<ITerminalNode> DETERMINISTIC() { return GetTokens(plsqlParser.DETERMINISTIC); }
		public IReadOnlyList<Parallel_enable_clauseContext> parallel_enable_clause() {
			return GetRuleContexts<Parallel_enable_clauseContext>();
		}
		public ITerminalNode RETURN() { return GetToken(plsqlParser.RETURN, 0); }
		public Result_cache_clauseContext result_cache_clause(int i) {
			return GetRuleContext<Result_cache_clauseContext>(i);
		}
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public Implementation_type_nameContext implementation_type_name() {
			return GetRuleContext<Implementation_type_nameContext>(0);
		}
		public Invoker_rights_clauseContext invoker_rights_clause(int i) {
			return GetRuleContext<Invoker_rights_clauseContext>(i);
		}
		public BodyContext body() {
			return GetRuleContext<BodyContext>(0);
		}
		public ITerminalNode DECLARE() { return GetToken(plsqlParser.DECLARE, 0); }
		public ParameterContext parameter(int i) {
			return GetRuleContext<ParameterContext>(i);
		}
		public Call_specContext call_spec() {
			return GetRuleContext<Call_specContext>(0);
		}
		public Declare_specContext declare_spec(int i) {
			return GetRuleContext<Declare_specContext>(i);
		}
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode USING() { return GetToken(plsqlParser.USING, 0); }
		public ITerminalNode DETERMINISTIC(int i) {
			return GetToken(plsqlParser.DETERMINISTIC, i);
		}
		public IReadOnlyList<ParameterContext> parameter() {
			return GetRuleContexts<ParameterContext>();
		}
		public ITerminalNode FUNCTION() { return GetToken(plsqlParser.FUNCTION, 0); }
		public ITerminalNode IS() { return GetToken(plsqlParser.IS, 0); }
		public IReadOnlyList<Result_cache_clauseContext> result_cache_clause() {
			return GetRuleContexts<Result_cache_clauseContext>();
		}
		public Parallel_enable_clauseContext parallel_enable_clause(int i) {
			return GetRuleContext<Parallel_enable_clauseContext>(i);
		}
		public IReadOnlyList<Invoker_rights_clauseContext> invoker_rights_clause() {
			return GetRuleContexts<Invoker_rights_clauseContext>();
		}
		public ITerminalNode PIPELINED() { return GetToken(plsqlParser.PIPELINED, 0); }
		public Function_bodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function_body; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterFunction_body(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitFunction_body(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction_body(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Function_bodyContext function_body() {
		Function_bodyContext _localctx = new Function_bodyContext(_ctx, State);
		EnterRule(_localctx, 46, RULE_function_body);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1140; Match(FUNCTION);
			State = 1141; identifier();
			State = 1153;
			_la = _input.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 1142; Match(LEFT_PAREN);
				State = 1143; parameter();
				State = 1148;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 1144; Match(COMMA);
					State = 1145; parameter();
					}
					}
					State = 1150;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 1151; Match(RIGHT_PAREN);
				}
			}

			State = 1155; Match(RETURN);
			State = 1156; type_spec();
			State = 1163;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==AUTHID || _la==DETERMINISTIC || _la==PARALLEL_ENABLE || _la==RESULT_CACHE) {
				{
				State = 1161;
				switch (_input.La(1)) {
				case AUTHID:
					{
					State = 1157; invoker_rights_clause();
					}
					break;
				case PARALLEL_ENABLE:
					{
					State = 1158; parallel_enable_clause();
					}
					break;
				case RESULT_CACHE:
					{
					State = 1159; result_cache_clause();
					}
					break;
				case DETERMINISTIC:
					{
					State = 1160; Match(DETERMINISTIC);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 1165;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 1186;
			switch ( Interpreter.AdaptivePredict(_input,61,_ctx) ) {
			case 1:
				{
				{
				State = 1167;
				_la = _input.La(1);
				if (_la==PIPELINED) {
					{
					State = 1166; Match(PIPELINED);
					}
				}

				State = 1169;
				_la = _input.La(1);
				if ( !(_la==AS || _la==IS) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				State = 1181;
				switch ( Interpreter.AdaptivePredict(_input,60,_ctx) ) {
				case 1:
					{
					State = 1171;
					_la = _input.La(1);
					if (_la==DECLARE) {
						{
						State = 1170; Match(DECLARE);
						}
					}

					State = 1176;
					_errHandler.Sync(this);
					_la = _input.La(1);
					while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (CONSTANT - 66)) | (1L << (CONSTRAINT - 66)) | (1L << (CONSTRAINTS - 66)) | (1L << (CONSTRUCTOR - 66)) | (1L << (CONTENT - 66)) | (1L << (CONTEXT - 66)) | (1L << (CONTINUE - 66)) | (1L << (CONVERT - 66)) | (1L << (CORRUPT_XID - 66)) | (1L << (CORRUPT_XID_ALL - 66)) | (1L << (COST - 66)) | (1L << (COUNT - 66)) | (1L << (CROSS - 66)) | (1L << (CUBE - 66)) | (1L << (CURRENT_USER - 66)) | (1L << (CURSOR - 66)) | (1L << (CUSTOMDATUM - 66)) | (1L << (CYCLE - 66)) | (1L << (DATA - 66)) | (1L << (DATABASE - 66)) | (1L << (DAY - 66)) | (1L << (DB_ROLE_CHANGE - 66)) | (1L << (DBTIMEZONE - 66)) | (1L << (DDL - 66)) | (1L << (DEBUG - 66)) | (1L << (DEC - 66)) | (1L << (DECIMAL - 66)) | (1L << (DECOMPOSE - 66)) | (1L << (DECREMENT - 66)) | (1L << (DEFAULTS - 66)) | (1L << (DEFERRED - 66)) | (1L << (DEFINER - 66)) | (1L << (DETERMINISTIC - 66)) | (1L << (DIMENSION - 66)) | (1L << (DISABLE - 66)) | (1L << (DISASSOCIATE - 66)) | (1L << (DOCUMENT - 66)) | (1L << (DOUBLE - 66)) | (1L << (DSINTERVAL_UNCONSTRAINED - 66)) | (1L << (EACH - 66)) | (1L << (ELEMENT - 66)) | (1L << (EMPTY - 66)) | (1L << (ENABLE - 66)) | (1L << (ENCODING - 66)) | (1L << (ENTITYESCAPING - 66)) | (1L << (ERR - 66)) | (1L << (ERRORS - 66)) | (1L << (ESCAPE - 66)) | (1L << (EVALNAME - 66)) | (1L << (EXCEPTION - 66)) | (1L << (EXCEPTION_INIT - 66)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)) | (1L << (EXIT - 130)) | (1L << (EXPLAIN - 130)) | (1L << (EXTERNAL - 130)) | (1L << (EXTRACT - 130)) | (1L << (FAILURE - 130)) | (1L << (FINAL - 130)) | (1L << (FIRST - 130)) | (1L << (FIRST_VALUE - 130)) | (1L << (FLOAT - 130)) | (1L << (FOLLOWING - 130)) | (1L << (FOLLOWS - 130)) | (1L << (FORALL - 130)) | (1L << (FORCE - 130)) | (1L << (FULL - 130)) | (1L << (FUNCTION - 130)) | (1L << (GROUPING - 130)) | (1L << (HASH - 130)) | (1L << (HIDE - 130)) | (1L << (HOUR - 130)) | (1L << (IGNORE - 130)) | (1L << (IMMEDIATE - 130)) | (1L << (INCLUDE - 130)) | (1L << (INCLUDING - 130)) | (1L << (INCREMENT - 130)) | (1L << (INDENT - 130)) | (1L << (INDEXED - 130)) | (1L << (INDICATOR - 130)) | (1L << (INDICES - 130)) | (1L << (INFINITE - 130)) | (1L << (INLINE - 130)) | (1L << (INNER - 130)) | (1L << (INOUT - 130)) | (1L << (INSTANTIABLE - 130)) | (1L << (INSTEAD - 130)) | (1L << (INT - 130)) | (1L << (INTEGER - 130)) | (1L << (INTERVAL - 130)) | (1L << (INVALIDATE - 130)) | (1L << (ISOLATION - 130)) | (1L << (ITERATE - 130)) | (1L << (JAVA - 130)) | (1L << (JOIN - 130)) | (1L << (KEEP - 130)) | (1L << (LANGUAGE - 130)))) != 0) || ((((_la - 194)) & ~0x3f) == 0 && ((1L << (_la - 194)) & ((1L << (LAST - 194)) | (1L << (LAST_VALUE - 194)) | (1L << (LEADING - 194)) | (1L << (LEFT - 194)) | (1L << (LEVEL - 194)) | (1L << (LIBRARY - 194)) | (1L << (LIKE2 - 194)) | (1L << (LIKE4 - 194)) | (1L << (LIKEC - 194)) | (1L << (LIMIT - 194)) | (1L << (LOCAL - 194)) | (1L << (LOCKED - 194)) | (1L << (LOG - 194)) | (1L << (LOGOFF - 194)) | (1L << (LOGON - 194)) | (1L << (LONG - 194)) | (1L << (LOOP - 194)) | (1L << (MAIN - 194)) | (1L << (MAP - 194)) | (1L << (MATCHED - 194)) | (1L << (MAXVALUE - 194)) | (1L << (MEASURES - 194)) | (1L << (MEMBER - 194)) | (1L << (MERGE - 194)) | (1L << (MINUTE - 194)) | (1L << (MINVALUE - 194)) | (1L << (MLSLABEL - 194)) | (1L << (MODEL - 194)) | (1L << (MODIFY - 194)) | (1L << (MONTH - 194)) | (1L << (MULTISET - 194)) | (1L << (NAME - 194)) | (1L << (NAN - 194)) | (1L << (NATURAL - 194)) | (1L << (NATURALN - 194)) | (1L << (NAV - 194)) | (1L << (NCHAR - 194)) | (1L << (NCHAR_CS - 194)) | (1L << (NCLOB - 194)) | (1L << (NESTED - 194)) | (1L << (NEW - 194)) | (1L << (NO - 194)) | (1L << (NOAUDIT - 194)) | (1L << (NOCOPY - 194)) | (1L << (NOCYCLE - 194)) | (1L << (NOENTITYESCAPING - 194)) | (1L << (NONE - 194)) | (1L << (NOSCHEMACHECK - 194)) | (1L << (NULLS - 194)) | (1L << (NUMBER - 194)) | (1L << (NUMERIC - 194)) | (1L << (NVARCHAR2 - 194)) | (1L << (OBJECT - 194)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (OFF - 259)) | (1L << (OID - 259)) | (1L << (OLD - 259)) | (1L << (ONLY - 259)) | (1L << (OPEN - 259)) | (1L << (ORADATA - 259)) | (1L << (ORDINALITY - 259)) | (1L << (OSERROR - 259)) | (1L << (OUT - 259)) | (1L << (OUTER - 259)) | (1L << (OVER - 259)) | (1L << (OVERRIDING - 259)) | (1L << (PACKAGE - 259)) | (1L << (PARALLEL_ENABLE - 259)) | (1L << (PARAMETERS - 259)) | (1L << (PARENT - 259)) | (1L << (PARTITION - 259)) | (1L << (PASSING - 259)) | (1L << (PATH - 259)) | (1L << (PIPELINED - 259)) | (1L << (PLAN - 259)) | (1L << (PLS_INTEGER - 259)) | (1L << (POSITIVE - 259)) | (1L << (POSITIVEN - 259)) | (1L << (PRAGMA - 259)) | (1L << (PRECEDING - 259)) | (1L << (PRECISION - 259)) | (1L << (PRESENT - 259)) | (1L << (PROCEDURE - 259)) | (1L << (RAISE - 259)) | (1L << (RANGE - 259)) | (1L << (RAW - 259)) | (1L << (READ - 259)) | (1L << (REAL - 259)) | (1L << (RECORD - 259)) | (1L << (REF - 259)) | (1L << (REFERENCE - 259)) | (1L << (REFERENCING - 259)) | (1L << (REJECT - 259)) | (1L << (RELIES_ON - 259)) | (1L << (RENAME - 259)) | (1L << (REPLACE - 259)) | (1L << (RESPECT - 259)) | (1L << (RESTRICT_REFERENCES - 259)) | (1L << (RESULT - 259)) | (1L << (RESULT_CACHE - 259)) | (1L << (RETURN - 259)) | (1L << (RETURNING - 259)) | (1L << (REUSE - 259)) | (1L << (REVERSE - 259)) | (1L << (RIGHT - 259)))) != 0) || ((((_la - 323)) & ~0x3f) == 0 && ((1L << (_la - 323)) & ((1L << (ROLLBACK - 323)) | (1L << (ROLLUP - 323)) | (1L << (ROW - 323)) | (1L << (ROWID - 323)) | (1L << (ROWS - 323)) | (1L << (RULES - 323)) | (1L << (SAMPLE - 323)) | (1L << (SAVE - 323)) | (1L << (SAVEPOINT - 323)) | (1L << (SCHEMA - 323)) | (1L << (SCHEMACHECK - 323)) | (1L << (SCN - 323)) | (1L << (SECOND - 323)) | (1L << (SEED - 323)) | (1L << (SEGMENT - 323)) | (1L << (SELF - 323)) | (1L << (SEQUENTIAL - 323)) | (1L << (SERIALIZABLE - 323)) | (1L << (SERIALLY_REUSABLE - 323)) | (1L << (SERVERERROR - 323)) | (1L << (SESSIONTIMEZONE - 323)) | (1L << (SET - 323)) | (1L << (SETS - 323)) | (1L << (SETTINGS - 323)) | (1L << (SHOW - 323)) | (1L << (SHUTDOWN - 323)) | (1L << (SIBLINGS - 323)) | (1L << (SIGNTYPE - 323)) | (1L << (SIMPLE_INTEGER - 323)) | (1L << (SINGLE - 323)) | (1L << (SKIP_ - 323)) | (1L << (SMALLINT - 323)) | (1L << (SNAPSHOT - 323)) | (1L << (SOME - 323)) | (1L << (SPECIFICATION - 323)) | (1L << (SQLDATA - 323)) | (1L << (SQLERROR - 323)) | (1L << (STANDALONE - 323)) | (1L << (STARTUP - 323)) | (1L << (STATEMENT - 323)) | (1L << (STATEMENT_ID - 323)) | (1L << (STATIC - 323)) | (1L << (STATISTICS - 323)) | (1L << (STRING - 323)) | (1L << (SUBMULTISET - 323)) | (1L << (SUBPARTITION - 323)) | (1L << (SUBSTITUTABLE - 323)) | (1L << (SUBTYPE - 323)) | (1L << (SUCCESS - 323)) | (1L << (SUSPEND - 323)) | (1L << (TIME - 323)) | (1L << (TIMESTAMP - 323)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_UNCONSTRAINED - 323)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TIMEZONE_ABBR - 387)) | (1L << (TIMEZONE_HOUR - 387)) | (1L << (TIMEZONE_MINUTE - 387)) | (1L << (TIMEZONE_REGION - 387)) | (1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (YMINTERVAL_UNCONSTRAINED - 451)) | (1L << (ZONE - 451)) | (1L << (PREDICTION - 451)) | (1L << (PREDICTION_BOUNDS - 451)) | (1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (COVAR_ - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (REGR_ - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (TRIM - 451)) | (1L << (SUM - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (VARIANCE - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
						{
						{
						State = 1173; declare_spec();
						}
						}
						State = 1178;
						_errHandler.Sync(this);
						_la = _input.La(1);
					}
					State = 1179; body();
					}
					break;

				case 2:
					{
					State = 1180; call_spec();
					}
					break;
				}
				}
				}
				break;

			case 2:
				{
				State = 1183;
				_la = _input.La(1);
				if ( !(_la==AGGREGATE || _la==PIPELINED) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				State = 1184; Match(USING);
				State = 1185; implementation_type_name();
				}
				break;
			}
			State = 1188; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Procedure_bodyContext : ParserRuleContext {
		public IReadOnlyList<ParameterContext> parameter() {
			return GetRuleContexts<ParameterContext>();
		}
		public IReadOnlyList<Declare_specContext> declare_spec() {
			return GetRuleContexts<Declare_specContext>();
		}
		public ITerminalNode IS() { return GetToken(plsqlParser.IS, 0); }
		public ITerminalNode EXTERNAL() { return GetToken(plsqlParser.EXTERNAL, 0); }
		public ITerminalNode DECLARE() { return GetToken(plsqlParser.DECLARE, 0); }
		public ParameterContext parameter(int i) {
			return GetRuleContext<ParameterContext>(i);
		}
		public Call_specContext call_spec() {
			return GetRuleContext<Call_specContext>(0);
		}
		public ITerminalNode PROCEDURE() { return GetToken(plsqlParser.PROCEDURE, 0); }
		public Declare_specContext declare_spec(int i) {
			return GetRuleContext<Declare_specContext>(i);
		}
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public BodyContext body() {
			return GetRuleContext<BodyContext>(0);
		}
		public ITerminalNode AS() { return GetToken(plsqlParser.AS, 0); }
		public Procedure_bodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_procedure_body; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterProcedure_body(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitProcedure_body(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProcedure_body(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Procedure_bodyContext procedure_body() {
		Procedure_bodyContext _localctx = new Procedure_bodyContext(_ctx, State);
		EnterRule(_localctx, 48, RULE_procedure_body);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1190; Match(PROCEDURE);
			State = 1191; identifier();
			State = 1203;
			_la = _input.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 1192; Match(LEFT_PAREN);
				State = 1193; parameter();
				State = 1198;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 1194; Match(COMMA);
					State = 1195; parameter();
					}
					}
					State = 1200;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 1201; Match(RIGHT_PAREN);
				}
			}

			State = 1205;
			_la = _input.La(1);
			if ( !(_la==AS || _la==IS) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			State = 1218;
			switch ( Interpreter.AdaptivePredict(_input,66,_ctx) ) {
			case 1:
				{
				State = 1207;
				_la = _input.La(1);
				if (_la==DECLARE) {
					{
					State = 1206; Match(DECLARE);
					}
				}

				State = 1212;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (CONSTANT - 66)) | (1L << (CONSTRAINT - 66)) | (1L << (CONSTRAINTS - 66)) | (1L << (CONSTRUCTOR - 66)) | (1L << (CONTENT - 66)) | (1L << (CONTEXT - 66)) | (1L << (CONTINUE - 66)) | (1L << (CONVERT - 66)) | (1L << (CORRUPT_XID - 66)) | (1L << (CORRUPT_XID_ALL - 66)) | (1L << (COST - 66)) | (1L << (COUNT - 66)) | (1L << (CROSS - 66)) | (1L << (CUBE - 66)) | (1L << (CURRENT_USER - 66)) | (1L << (CURSOR - 66)) | (1L << (CUSTOMDATUM - 66)) | (1L << (CYCLE - 66)) | (1L << (DATA - 66)) | (1L << (DATABASE - 66)) | (1L << (DAY - 66)) | (1L << (DB_ROLE_CHANGE - 66)) | (1L << (DBTIMEZONE - 66)) | (1L << (DDL - 66)) | (1L << (DEBUG - 66)) | (1L << (DEC - 66)) | (1L << (DECIMAL - 66)) | (1L << (DECOMPOSE - 66)) | (1L << (DECREMENT - 66)) | (1L << (DEFAULTS - 66)) | (1L << (DEFERRED - 66)) | (1L << (DEFINER - 66)) | (1L << (DETERMINISTIC - 66)) | (1L << (DIMENSION - 66)) | (1L << (DISABLE - 66)) | (1L << (DISASSOCIATE - 66)) | (1L << (DOCUMENT - 66)) | (1L << (DOUBLE - 66)) | (1L << (DSINTERVAL_UNCONSTRAINED - 66)) | (1L << (EACH - 66)) | (1L << (ELEMENT - 66)) | (1L << (EMPTY - 66)) | (1L << (ENABLE - 66)) | (1L << (ENCODING - 66)) | (1L << (ENTITYESCAPING - 66)) | (1L << (ERR - 66)) | (1L << (ERRORS - 66)) | (1L << (ESCAPE - 66)) | (1L << (EVALNAME - 66)) | (1L << (EXCEPTION - 66)) | (1L << (EXCEPTION_INIT - 66)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)) | (1L << (EXIT - 130)) | (1L << (EXPLAIN - 130)) | (1L << (EXTERNAL - 130)) | (1L << (EXTRACT - 130)) | (1L << (FAILURE - 130)) | (1L << (FINAL - 130)) | (1L << (FIRST - 130)) | (1L << (FIRST_VALUE - 130)) | (1L << (FLOAT - 130)) | (1L << (FOLLOWING - 130)) | (1L << (FOLLOWS - 130)) | (1L << (FORALL - 130)) | (1L << (FORCE - 130)) | (1L << (FULL - 130)) | (1L << (FUNCTION - 130)) | (1L << (GROUPING - 130)) | (1L << (HASH - 130)) | (1L << (HIDE - 130)) | (1L << (HOUR - 130)) | (1L << (IGNORE - 130)) | (1L << (IMMEDIATE - 130)) | (1L << (INCLUDE - 130)) | (1L << (INCLUDING - 130)) | (1L << (INCREMENT - 130)) | (1L << (INDENT - 130)) | (1L << (INDEXED - 130)) | (1L << (INDICATOR - 130)) | (1L << (INDICES - 130)) | (1L << (INFINITE - 130)) | (1L << (INLINE - 130)) | (1L << (INNER - 130)) | (1L << (INOUT - 130)) | (1L << (INSTANTIABLE - 130)) | (1L << (INSTEAD - 130)) | (1L << (INT - 130)) | (1L << (INTEGER - 130)) | (1L << (INTERVAL - 130)) | (1L << (INVALIDATE - 130)) | (1L << (ISOLATION - 130)) | (1L << (ITERATE - 130)) | (1L << (JAVA - 130)) | (1L << (JOIN - 130)) | (1L << (KEEP - 130)) | (1L << (LANGUAGE - 130)))) != 0) || ((((_la - 194)) & ~0x3f) == 0 && ((1L << (_la - 194)) & ((1L << (LAST - 194)) | (1L << (LAST_VALUE - 194)) | (1L << (LEADING - 194)) | (1L << (LEFT - 194)) | (1L << (LEVEL - 194)) | (1L << (LIBRARY - 194)) | (1L << (LIKE2 - 194)) | (1L << (LIKE4 - 194)) | (1L << (LIKEC - 194)) | (1L << (LIMIT - 194)) | (1L << (LOCAL - 194)) | (1L << (LOCKED - 194)) | (1L << (LOG - 194)) | (1L << (LOGOFF - 194)) | (1L << (LOGON - 194)) | (1L << (LONG - 194)) | (1L << (LOOP - 194)) | (1L << (MAIN - 194)) | (1L << (MAP - 194)) | (1L << (MATCHED - 194)) | (1L << (MAXVALUE - 194)) | (1L << (MEASURES - 194)) | (1L << (MEMBER - 194)) | (1L << (MERGE - 194)) | (1L << (MINUTE - 194)) | (1L << (MINVALUE - 194)) | (1L << (MLSLABEL - 194)) | (1L << (MODEL - 194)) | (1L << (MODIFY - 194)) | (1L << (MONTH - 194)) | (1L << (MULTISET - 194)) | (1L << (NAME - 194)) | (1L << (NAN - 194)) | (1L << (NATURAL - 194)) | (1L << (NATURALN - 194)) | (1L << (NAV - 194)) | (1L << (NCHAR - 194)) | (1L << (NCHAR_CS - 194)) | (1L << (NCLOB - 194)) | (1L << (NESTED - 194)) | (1L << (NEW - 194)) | (1L << (NO - 194)) | (1L << (NOAUDIT - 194)) | (1L << (NOCOPY - 194)) | (1L << (NOCYCLE - 194)) | (1L << (NOENTITYESCAPING - 194)) | (1L << (NONE - 194)) | (1L << (NOSCHEMACHECK - 194)) | (1L << (NULLS - 194)) | (1L << (NUMBER - 194)) | (1L << (NUMERIC - 194)) | (1L << (NVARCHAR2 - 194)) | (1L << (OBJECT - 194)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (OFF - 259)) | (1L << (OID - 259)) | (1L << (OLD - 259)) | (1L << (ONLY - 259)) | (1L << (OPEN - 259)) | (1L << (ORADATA - 259)) | (1L << (ORDINALITY - 259)) | (1L << (OSERROR - 259)) | (1L << (OUT - 259)) | (1L << (OUTER - 259)) | (1L << (OVER - 259)) | (1L << (OVERRIDING - 259)) | (1L << (PACKAGE - 259)) | (1L << (PARALLEL_ENABLE - 259)) | (1L << (PARAMETERS - 259)) | (1L << (PARENT - 259)) | (1L << (PARTITION - 259)) | (1L << (PASSING - 259)) | (1L << (PATH - 259)) | (1L << (PIPELINED - 259)) | (1L << (PLAN - 259)) | (1L << (PLS_INTEGER - 259)) | (1L << (POSITIVE - 259)) | (1L << (POSITIVEN - 259)) | (1L << (PRAGMA - 259)) | (1L << (PRECEDING - 259)) | (1L << (PRECISION - 259)) | (1L << (PRESENT - 259)) | (1L << (PROCEDURE - 259)) | (1L << (RAISE - 259)) | (1L << (RANGE - 259)) | (1L << (RAW - 259)) | (1L << (READ - 259)) | (1L << (REAL - 259)) | (1L << (RECORD - 259)) | (1L << (REF - 259)) | (1L << (REFERENCE - 259)) | (1L << (REFERENCING - 259)) | (1L << (REJECT - 259)) | (1L << (RELIES_ON - 259)) | (1L << (RENAME - 259)) | (1L << (REPLACE - 259)) | (1L << (RESPECT - 259)) | (1L << (RESTRICT_REFERENCES - 259)) | (1L << (RESULT - 259)) | (1L << (RESULT_CACHE - 259)) | (1L << (RETURN - 259)) | (1L << (RETURNING - 259)) | (1L << (REUSE - 259)) | (1L << (REVERSE - 259)) | (1L << (RIGHT - 259)))) != 0) || ((((_la - 323)) & ~0x3f) == 0 && ((1L << (_la - 323)) & ((1L << (ROLLBACK - 323)) | (1L << (ROLLUP - 323)) | (1L << (ROW - 323)) | (1L << (ROWID - 323)) | (1L << (ROWS - 323)) | (1L << (RULES - 323)) | (1L << (SAMPLE - 323)) | (1L << (SAVE - 323)) | (1L << (SAVEPOINT - 323)) | (1L << (SCHEMA - 323)) | (1L << (SCHEMACHECK - 323)) | (1L << (SCN - 323)) | (1L << (SECOND - 323)) | (1L << (SEED - 323)) | (1L << (SEGMENT - 323)) | (1L << (SELF - 323)) | (1L << (SEQUENTIAL - 323)) | (1L << (SERIALIZABLE - 323)) | (1L << (SERIALLY_REUSABLE - 323)) | (1L << (SERVERERROR - 323)) | (1L << (SESSIONTIMEZONE - 323)) | (1L << (SET - 323)) | (1L << (SETS - 323)) | (1L << (SETTINGS - 323)) | (1L << (SHOW - 323)) | (1L << (SHUTDOWN - 323)) | (1L << (SIBLINGS - 323)) | (1L << (SIGNTYPE - 323)) | (1L << (SIMPLE_INTEGER - 323)) | (1L << (SINGLE - 323)) | (1L << (SKIP_ - 323)) | (1L << (SMALLINT - 323)) | (1L << (SNAPSHOT - 323)) | (1L << (SOME - 323)) | (1L << (SPECIFICATION - 323)) | (1L << (SQLDATA - 323)) | (1L << (SQLERROR - 323)) | (1L << (STANDALONE - 323)) | (1L << (STARTUP - 323)) | (1L << (STATEMENT - 323)) | (1L << (STATEMENT_ID - 323)) | (1L << (STATIC - 323)) | (1L << (STATISTICS - 323)) | (1L << (STRING - 323)) | (1L << (SUBMULTISET - 323)) | (1L << (SUBPARTITION - 323)) | (1L << (SUBSTITUTABLE - 323)) | (1L << (SUBTYPE - 323)) | (1L << (SUCCESS - 323)) | (1L << (SUSPEND - 323)) | (1L << (TIME - 323)) | (1L << (TIMESTAMP - 323)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_UNCONSTRAINED - 323)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TIMEZONE_ABBR - 387)) | (1L << (TIMEZONE_HOUR - 387)) | (1L << (TIMEZONE_MINUTE - 387)) | (1L << (TIMEZONE_REGION - 387)) | (1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (YMINTERVAL_UNCONSTRAINED - 451)) | (1L << (ZONE - 451)) | (1L << (PREDICTION - 451)) | (1L << (PREDICTION_BOUNDS - 451)) | (1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (COVAR_ - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (REGR_ - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (TRIM - 451)) | (1L << (SUM - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (VARIANCE - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
					{
					{
					State = 1209; declare_spec();
					}
					}
					State = 1214;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 1215; body();
				}
				break;

			case 2:
				{
				State = 1216; call_spec();
				}
				break;

			case 3:
				{
				State = 1217; Match(EXTERNAL);
				}
				break;
			}
			State = 1220; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Create_procedure_bodyContext : ParserRuleContext {
		public IReadOnlyList<Declare_specContext> declare_spec() {
			return GetRuleContexts<Declare_specContext>();
		}
		public ITerminalNode EXTERNAL() { return GetToken(plsqlParser.EXTERNAL, 0); }
		public ITerminalNode DECLARE() { return GetToken(plsqlParser.DECLARE, 0); }
		public ParameterContext parameter(int i) {
			return GetRuleContext<ParameterContext>(i);
		}
		public Call_specContext call_spec() {
			return GetRuleContext<Call_specContext>(0);
		}
		public Declare_specContext declare_spec(int i) {
			return GetRuleContext<Declare_specContext>(i);
		}
		public ITerminalNode OR() { return GetToken(plsqlParser.OR, 0); }
		public ITerminalNode AS() { return GetToken(plsqlParser.AS, 0); }
		public IReadOnlyList<ParameterContext> parameter() {
			return GetRuleContexts<ParameterContext>();
		}
		public ITerminalNode REPLACE() { return GetToken(plsqlParser.REPLACE, 0); }
		public ITerminalNode IS() { return GetToken(plsqlParser.IS, 0); }
		public ITerminalNode PROCEDURE() { return GetToken(plsqlParser.PROCEDURE, 0); }
		public ITerminalNode CREATE() { return GetToken(plsqlParser.CREATE, 0); }
		public BodyContext body() {
			return GetRuleContext<BodyContext>(0);
		}
		public Invoker_rights_clauseContext invoker_rights_clause() {
			return GetRuleContext<Invoker_rights_clauseContext>(0);
		}
		public Procedure_nameContext procedure_name() {
			return GetRuleContext<Procedure_nameContext>(0);
		}
		public Create_procedure_bodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_create_procedure_body; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCreate_procedure_body(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCreate_procedure_body(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreate_procedure_body(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Create_procedure_bodyContext create_procedure_body() {
		Create_procedure_bodyContext _localctx = new Create_procedure_bodyContext(_ctx, State);
		EnterRule(_localctx, 50, RULE_create_procedure_body);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1222; Match(CREATE);
			State = 1225;
			_la = _input.La(1);
			if (_la==OR) {
				{
				State = 1223; Match(OR);
				State = 1224; Match(REPLACE);
				}
			}

			State = 1227; Match(PROCEDURE);
			State = 1228; procedure_name();
			State = 1240;
			_la = _input.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 1229; Match(LEFT_PAREN);
				State = 1230; parameter();
				State = 1235;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 1231; Match(COMMA);
					State = 1232; parameter();
					}
					}
					State = 1237;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 1238; Match(RIGHT_PAREN);
				}
			}

			State = 1243;
			_la = _input.La(1);
			if (_la==AUTHID) {
				{
				State = 1242; invoker_rights_clause();
				}
			}

			State = 1245;
			_la = _input.La(1);
			if ( !(_la==AS || _la==IS) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			State = 1258;
			switch ( Interpreter.AdaptivePredict(_input,73,_ctx) ) {
			case 1:
				{
				State = 1247;
				_la = _input.La(1);
				if (_la==DECLARE) {
					{
					State = 1246; Match(DECLARE);
					}
				}

				State = 1252;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (CONSTANT - 66)) | (1L << (CONSTRAINT - 66)) | (1L << (CONSTRAINTS - 66)) | (1L << (CONSTRUCTOR - 66)) | (1L << (CONTENT - 66)) | (1L << (CONTEXT - 66)) | (1L << (CONTINUE - 66)) | (1L << (CONVERT - 66)) | (1L << (CORRUPT_XID - 66)) | (1L << (CORRUPT_XID_ALL - 66)) | (1L << (COST - 66)) | (1L << (COUNT - 66)) | (1L << (CROSS - 66)) | (1L << (CUBE - 66)) | (1L << (CURRENT_USER - 66)) | (1L << (CURSOR - 66)) | (1L << (CUSTOMDATUM - 66)) | (1L << (CYCLE - 66)) | (1L << (DATA - 66)) | (1L << (DATABASE - 66)) | (1L << (DAY - 66)) | (1L << (DB_ROLE_CHANGE - 66)) | (1L << (DBTIMEZONE - 66)) | (1L << (DDL - 66)) | (1L << (DEBUG - 66)) | (1L << (DEC - 66)) | (1L << (DECIMAL - 66)) | (1L << (DECOMPOSE - 66)) | (1L << (DECREMENT - 66)) | (1L << (DEFAULTS - 66)) | (1L << (DEFERRED - 66)) | (1L << (DEFINER - 66)) | (1L << (DETERMINISTIC - 66)) | (1L << (DIMENSION - 66)) | (1L << (DISABLE - 66)) | (1L << (DISASSOCIATE - 66)) | (1L << (DOCUMENT - 66)) | (1L << (DOUBLE - 66)) | (1L << (DSINTERVAL_UNCONSTRAINED - 66)) | (1L << (EACH - 66)) | (1L << (ELEMENT - 66)) | (1L << (EMPTY - 66)) | (1L << (ENABLE - 66)) | (1L << (ENCODING - 66)) | (1L << (ENTITYESCAPING - 66)) | (1L << (ERR - 66)) | (1L << (ERRORS - 66)) | (1L << (ESCAPE - 66)) | (1L << (EVALNAME - 66)) | (1L << (EXCEPTION - 66)) | (1L << (EXCEPTION_INIT - 66)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)) | (1L << (EXIT - 130)) | (1L << (EXPLAIN - 130)) | (1L << (EXTERNAL - 130)) | (1L << (EXTRACT - 130)) | (1L << (FAILURE - 130)) | (1L << (FINAL - 130)) | (1L << (FIRST - 130)) | (1L << (FIRST_VALUE - 130)) | (1L << (FLOAT - 130)) | (1L << (FOLLOWING - 130)) | (1L << (FOLLOWS - 130)) | (1L << (FORALL - 130)) | (1L << (FORCE - 130)) | (1L << (FULL - 130)) | (1L << (FUNCTION - 130)) | (1L << (GROUPING - 130)) | (1L << (HASH - 130)) | (1L << (HIDE - 130)) | (1L << (HOUR - 130)) | (1L << (IGNORE - 130)) | (1L << (IMMEDIATE - 130)) | (1L << (INCLUDE - 130)) | (1L << (INCLUDING - 130)) | (1L << (INCREMENT - 130)) | (1L << (INDENT - 130)) | (1L << (INDEXED - 130)) | (1L << (INDICATOR - 130)) | (1L << (INDICES - 130)) | (1L << (INFINITE - 130)) | (1L << (INLINE - 130)) | (1L << (INNER - 130)) | (1L << (INOUT - 130)) | (1L << (INSTANTIABLE - 130)) | (1L << (INSTEAD - 130)) | (1L << (INT - 130)) | (1L << (INTEGER - 130)) | (1L << (INTERVAL - 130)) | (1L << (INVALIDATE - 130)) | (1L << (ISOLATION - 130)) | (1L << (ITERATE - 130)) | (1L << (JAVA - 130)) | (1L << (JOIN - 130)) | (1L << (KEEP - 130)) | (1L << (LANGUAGE - 130)))) != 0) || ((((_la - 194)) & ~0x3f) == 0 && ((1L << (_la - 194)) & ((1L << (LAST - 194)) | (1L << (LAST_VALUE - 194)) | (1L << (LEADING - 194)) | (1L << (LEFT - 194)) | (1L << (LEVEL - 194)) | (1L << (LIBRARY - 194)) | (1L << (LIKE2 - 194)) | (1L << (LIKE4 - 194)) | (1L << (LIKEC - 194)) | (1L << (LIMIT - 194)) | (1L << (LOCAL - 194)) | (1L << (LOCKED - 194)) | (1L << (LOG - 194)) | (1L << (LOGOFF - 194)) | (1L << (LOGON - 194)) | (1L << (LONG - 194)) | (1L << (LOOP - 194)) | (1L << (MAIN - 194)) | (1L << (MAP - 194)) | (1L << (MATCHED - 194)) | (1L << (MAXVALUE - 194)) | (1L << (MEASURES - 194)) | (1L << (MEMBER - 194)) | (1L << (MERGE - 194)) | (1L << (MINUTE - 194)) | (1L << (MINVALUE - 194)) | (1L << (MLSLABEL - 194)) | (1L << (MODEL - 194)) | (1L << (MODIFY - 194)) | (1L << (MONTH - 194)) | (1L << (MULTISET - 194)) | (1L << (NAME - 194)) | (1L << (NAN - 194)) | (1L << (NATURAL - 194)) | (1L << (NATURALN - 194)) | (1L << (NAV - 194)) | (1L << (NCHAR - 194)) | (1L << (NCHAR_CS - 194)) | (1L << (NCLOB - 194)) | (1L << (NESTED - 194)) | (1L << (NEW - 194)) | (1L << (NO - 194)) | (1L << (NOAUDIT - 194)) | (1L << (NOCOPY - 194)) | (1L << (NOCYCLE - 194)) | (1L << (NOENTITYESCAPING - 194)) | (1L << (NONE - 194)) | (1L << (NOSCHEMACHECK - 194)) | (1L << (NULLS - 194)) | (1L << (NUMBER - 194)) | (1L << (NUMERIC - 194)) | (1L << (NVARCHAR2 - 194)) | (1L << (OBJECT - 194)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (OFF - 259)) | (1L << (OID - 259)) | (1L << (OLD - 259)) | (1L << (ONLY - 259)) | (1L << (OPEN - 259)) | (1L << (ORADATA - 259)) | (1L << (ORDINALITY - 259)) | (1L << (OSERROR - 259)) | (1L << (OUT - 259)) | (1L << (OUTER - 259)) | (1L << (OVER - 259)) | (1L << (OVERRIDING - 259)) | (1L << (PACKAGE - 259)) | (1L << (PARALLEL_ENABLE - 259)) | (1L << (PARAMETERS - 259)) | (1L << (PARENT - 259)) | (1L << (PARTITION - 259)) | (1L << (PASSING - 259)) | (1L << (PATH - 259)) | (1L << (PIPELINED - 259)) | (1L << (PLAN - 259)) | (1L << (PLS_INTEGER - 259)) | (1L << (POSITIVE - 259)) | (1L << (POSITIVEN - 259)) | (1L << (PRAGMA - 259)) | (1L << (PRECEDING - 259)) | (1L << (PRECISION - 259)) | (1L << (PRESENT - 259)) | (1L << (PROCEDURE - 259)) | (1L << (RAISE - 259)) | (1L << (RANGE - 259)) | (1L << (RAW - 259)) | (1L << (READ - 259)) | (1L << (REAL - 259)) | (1L << (RECORD - 259)) | (1L << (REF - 259)) | (1L << (REFERENCE - 259)) | (1L << (REFERENCING - 259)) | (1L << (REJECT - 259)) | (1L << (RELIES_ON - 259)) | (1L << (RENAME - 259)) | (1L << (REPLACE - 259)) | (1L << (RESPECT - 259)) | (1L << (RESTRICT_REFERENCES - 259)) | (1L << (RESULT - 259)) | (1L << (RESULT_CACHE - 259)) | (1L << (RETURN - 259)) | (1L << (RETURNING - 259)) | (1L << (REUSE - 259)) | (1L << (REVERSE - 259)) | (1L << (RIGHT - 259)))) != 0) || ((((_la - 323)) & ~0x3f) == 0 && ((1L << (_la - 323)) & ((1L << (ROLLBACK - 323)) | (1L << (ROLLUP - 323)) | (1L << (ROW - 323)) | (1L << (ROWID - 323)) | (1L << (ROWS - 323)) | (1L << (RULES - 323)) | (1L << (SAMPLE - 323)) | (1L << (SAVE - 323)) | (1L << (SAVEPOINT - 323)) | (1L << (SCHEMA - 323)) | (1L << (SCHEMACHECK - 323)) | (1L << (SCN - 323)) | (1L << (SECOND - 323)) | (1L << (SEED - 323)) | (1L << (SEGMENT - 323)) | (1L << (SELF - 323)) | (1L << (SEQUENTIAL - 323)) | (1L << (SERIALIZABLE - 323)) | (1L << (SERIALLY_REUSABLE - 323)) | (1L << (SERVERERROR - 323)) | (1L << (SESSIONTIMEZONE - 323)) | (1L << (SET - 323)) | (1L << (SETS - 323)) | (1L << (SETTINGS - 323)) | (1L << (SHOW - 323)) | (1L << (SHUTDOWN - 323)) | (1L << (SIBLINGS - 323)) | (1L << (SIGNTYPE - 323)) | (1L << (SIMPLE_INTEGER - 323)) | (1L << (SINGLE - 323)) | (1L << (SKIP_ - 323)) | (1L << (SMALLINT - 323)) | (1L << (SNAPSHOT - 323)) | (1L << (SOME - 323)) | (1L << (SPECIFICATION - 323)) | (1L << (SQLDATA - 323)) | (1L << (SQLERROR - 323)) | (1L << (STANDALONE - 323)) | (1L << (STARTUP - 323)) | (1L << (STATEMENT - 323)) | (1L << (STATEMENT_ID - 323)) | (1L << (STATIC - 323)) | (1L << (STATISTICS - 323)) | (1L << (STRING - 323)) | (1L << (SUBMULTISET - 323)) | (1L << (SUBPARTITION - 323)) | (1L << (SUBSTITUTABLE - 323)) | (1L << (SUBTYPE - 323)) | (1L << (SUCCESS - 323)) | (1L << (SUSPEND - 323)) | (1L << (TIME - 323)) | (1L << (TIMESTAMP - 323)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_UNCONSTRAINED - 323)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TIMEZONE_ABBR - 387)) | (1L << (TIMEZONE_HOUR - 387)) | (1L << (TIMEZONE_MINUTE - 387)) | (1L << (TIMEZONE_REGION - 387)) | (1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (YMINTERVAL_UNCONSTRAINED - 451)) | (1L << (ZONE - 451)) | (1L << (PREDICTION - 451)) | (1L << (PREDICTION_BOUNDS - 451)) | (1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (COVAR_ - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (REGR_ - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (TRIM - 451)) | (1L << (SUM - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (VARIANCE - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
					{
					{
					State = 1249; declare_spec();
					}
					}
					State = 1254;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 1255; body();
				}
				break;

			case 2:
				{
				State = 1256; call_spec();
				}
				break;

			case 3:
				{
				State = 1257; Match(EXTERNAL);
				}
				break;
			}
			State = 1260; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Drop_triggerContext : ParserRuleContext {
		public Trigger_nameContext trigger_name() {
			return GetRuleContext<Trigger_nameContext>(0);
		}
		public ITerminalNode DROP() { return GetToken(plsqlParser.DROP, 0); }
		public ITerminalNode TRIGGER() { return GetToken(plsqlParser.TRIGGER, 0); }
		public Drop_triggerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_drop_trigger; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterDrop_trigger(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitDrop_trigger(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDrop_trigger(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Drop_triggerContext drop_trigger() {
		Drop_triggerContext _localctx = new Drop_triggerContext(_ctx, State);
		EnterRule(_localctx, 52, RULE_drop_trigger);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1262; Match(DROP);
			State = 1263; Match(TRIGGER);
			State = 1264; trigger_name();
			State = 1265; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_triggerContext : ParserRuleContext {
		public Trigger_nameContext tn1;
		public Trigger_nameContext tn2;
		public ITerminalNode DISABLE() { return GetToken(plsqlParser.DISABLE, 0); }
		public IReadOnlyList<Trigger_nameContext> trigger_name() {
			return GetRuleContexts<Trigger_nameContext>();
		}
		public Trigger_nameContext trigger_name(int i) {
			return GetRuleContext<Trigger_nameContext>(i);
		}
		public ITerminalNode SETTINGS() { return GetToken(plsqlParser.SETTINGS, 0); }
		public ITerminalNode ENABLE() { return GetToken(plsqlParser.ENABLE, 0); }
		public ITerminalNode COMPILE() { return GetToken(plsqlParser.COMPILE, 0); }
		public ITerminalNode TO() { return GetToken(plsqlParser.TO, 0); }
		public ITerminalNode TRIGGER() { return GetToken(plsqlParser.TRIGGER, 0); }
		public ITerminalNode RENAME() { return GetToken(plsqlParser.RENAME, 0); }
		public ITerminalNode REUSE() { return GetToken(plsqlParser.REUSE, 0); }
		public ITerminalNode DEBUG() { return GetToken(plsqlParser.DEBUG, 0); }
		public Compiler_parameters_clauseContext compiler_parameters_clause(int i) {
			return GetRuleContext<Compiler_parameters_clauseContext>(i);
		}
		public IReadOnlyList<Compiler_parameters_clauseContext> compiler_parameters_clause() {
			return GetRuleContexts<Compiler_parameters_clauseContext>();
		}
		public ITerminalNode ALTER() { return GetToken(plsqlParser.ALTER, 0); }
		public Alter_triggerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_trigger; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterAlter_trigger(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitAlter_trigger(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlter_trigger(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Alter_triggerContext alter_trigger() {
		Alter_triggerContext _localctx = new Alter_triggerContext(_ctx, State);
		EnterRule(_localctx, 54, RULE_alter_trigger);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1267; Match(ALTER);
			State = 1268; Match(TRIGGER);
			State = 1269; _localctx.tn1 = trigger_name();
			State = 1288;
			switch (_input.La(1)) {
			case DISABLE:
			case ENABLE:
				{
				State = 1270;
				_la = _input.La(1);
				if ( !(_la==DISABLE || _la==ENABLE) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				}
				break;
			case RENAME:
				{
				State = 1271; Match(RENAME);
				State = 1272; Match(TO);
				State = 1273; _localctx.tn2 = trigger_name();
				}
				break;
			case COMPILE:
				{
				State = 1274; Match(COMPILE);
				State = 1276;
				switch ( Interpreter.AdaptivePredict(_input,74,_ctx) ) {
				case 1:
					{
					State = 1275; Match(DEBUG);
					}
					break;
				}
				State = 1281;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,75,_ctx);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
					if ( _alt==1 ) {
						{
						{
						State = 1278; compiler_parameters_clause();
						}
						} 
					}
					State = 1283;
					_errHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(_input,75,_ctx);
				}
				State = 1286;
				_la = _input.La(1);
				if (_la==REUSE) {
					{
					State = 1284; Match(REUSE);
					State = 1285; Match(SETTINGS);
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1290; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Create_triggerContext : ParserRuleContext {
		public ITerminalNode DISABLE() { return GetToken(plsqlParser.DISABLE, 0); }
		public Trigger_nameContext trigger_name() {
			return GetRuleContext<Trigger_nameContext>(0);
		}
		public ITerminalNode ENABLE() { return GetToken(plsqlParser.ENABLE, 0); }
		public Trigger_bodyContext trigger_body() {
			return GetRuleContext<Trigger_bodyContext>(0);
		}
		public ITerminalNode OR() { return GetToken(plsqlParser.OR, 0); }
		public ITerminalNode TRIGGER() { return GetToken(plsqlParser.TRIGGER, 0); }
		public Simple_dml_triggerContext simple_dml_trigger() {
			return GetRuleContext<Simple_dml_triggerContext>(0);
		}
		public ITerminalNode REPLACE() { return GetToken(plsqlParser.REPLACE, 0); }
		public Trigger_when_clauseContext trigger_when_clause() {
			return GetRuleContext<Trigger_when_clauseContext>(0);
		}
		public ITerminalNode CREATE() { return GetToken(plsqlParser.CREATE, 0); }
		public Non_dml_triggerContext non_dml_trigger() {
			return GetRuleContext<Non_dml_triggerContext>(0);
		}
		public Compound_dml_triggerContext compound_dml_trigger() {
			return GetRuleContext<Compound_dml_triggerContext>(0);
		}
		public Trigger_follows_clauseContext trigger_follows_clause() {
			return GetRuleContext<Trigger_follows_clauseContext>(0);
		}
		public Create_triggerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_create_trigger; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCreate_trigger(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCreate_trigger(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreate_trigger(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Create_triggerContext create_trigger() {
		Create_triggerContext _localctx = new Create_triggerContext(_ctx, State);
		EnterRule(_localctx, 56, RULE_create_trigger);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1292; Match(CREATE);
			State = 1295;
			_la = _input.La(1);
			if (_la==OR) {
				{
				State = 1293; Match(OR);
				State = 1294; Match(REPLACE);
				}
			}

			State = 1297; Match(TRIGGER);
			State = 1298; trigger_name();
			State = 1302;
			switch ( Interpreter.AdaptivePredict(_input,79,_ctx) ) {
			case 1:
				{
				State = 1299; simple_dml_trigger();
				}
				break;

			case 2:
				{
				State = 1300; compound_dml_trigger();
				}
				break;

			case 3:
				{
				State = 1301; non_dml_trigger();
				}
				break;
			}
			State = 1305;
			switch ( Interpreter.AdaptivePredict(_input,80,_ctx) ) {
			case 1:
				{
				State = 1304; trigger_follows_clause();
				}
				break;
			}
			State = 1308;
			switch ( Interpreter.AdaptivePredict(_input,81,_ctx) ) {
			case 1:
				{
				State = 1307;
				_la = _input.La(1);
				if ( !(_la==DISABLE || _la==ENABLE) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				}
				break;
			}
			State = 1311;
			_la = _input.La(1);
			if (_la==WHEN) {
				{
				State = 1310; trigger_when_clause();
				}
			}

			State = 1313; trigger_body();
			State = 1314; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Trigger_follows_clauseContext : ParserRuleContext {
		public ITerminalNode FOLLOWS() { return GetToken(plsqlParser.FOLLOWS, 0); }
		public IReadOnlyList<Trigger_nameContext> trigger_name() {
			return GetRuleContexts<Trigger_nameContext>();
		}
		public Trigger_nameContext trigger_name(int i) {
			return GetRuleContext<Trigger_nameContext>(i);
		}
		public Trigger_follows_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_trigger_follows_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterTrigger_follows_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitTrigger_follows_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTrigger_follows_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Trigger_follows_clauseContext trigger_follows_clause() {
		Trigger_follows_clauseContext _localctx = new Trigger_follows_clauseContext(_ctx, State);
		EnterRule(_localctx, 58, RULE_trigger_follows_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1316; Match(FOLLOWS);
			State = 1317; trigger_name();
			State = 1322;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 1318; Match(COMMA);
				State = 1319; trigger_name();
				}
				}
				State = 1324;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Trigger_when_clauseContext : ParserRuleContext {
		public ITerminalNode WHEN() { return GetToken(plsqlParser.WHEN, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public Trigger_when_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_trigger_when_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterTrigger_when_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitTrigger_when_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTrigger_when_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Trigger_when_clauseContext trigger_when_clause() {
		Trigger_when_clauseContext _localctx = new Trigger_when_clauseContext(_ctx, State);
		EnterRule(_localctx, 60, RULE_trigger_when_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1325; Match(WHEN);
			State = 1326; Match(LEFT_PAREN);
			State = 1327; condition();
			State = 1328; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Simple_dml_triggerContext : ParserRuleContext {
		public For_each_rowContext for_each_row() {
			return GetRuleContext<For_each_rowContext>(0);
		}
		public Dml_event_clauseContext dml_event_clause() {
			return GetRuleContext<Dml_event_clauseContext>(0);
		}
		public Referencing_clauseContext referencing_clause() {
			return GetRuleContext<Referencing_clauseContext>(0);
		}
		public ITerminalNode BEFORE() { return GetToken(plsqlParser.BEFORE, 0); }
		public ITerminalNode OF() { return GetToken(plsqlParser.OF, 0); }
		public ITerminalNode INSTEAD() { return GetToken(plsqlParser.INSTEAD, 0); }
		public ITerminalNode AFTER() { return GetToken(plsqlParser.AFTER, 0); }
		public Simple_dml_triggerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simple_dml_trigger; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSimple_dml_trigger(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSimple_dml_trigger(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSimple_dml_trigger(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Simple_dml_triggerContext simple_dml_trigger() {
		Simple_dml_triggerContext _localctx = new Simple_dml_triggerContext(_ctx, State);
		EnterRule(_localctx, 62, RULE_simple_dml_trigger);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1334;
			switch (_input.La(1)) {
			case BEFORE:
				{
				State = 1330; Match(BEFORE);
				}
				break;
			case AFTER:
				{
				State = 1331; Match(AFTER);
				}
				break;
			case INSTEAD:
				{
				State = 1332; Match(INSTEAD);
				State = 1333; Match(OF);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1336; dml_event_clause();
			State = 1338;
			switch ( Interpreter.AdaptivePredict(_input,85,_ctx) ) {
			case 1:
				{
				State = 1337; referencing_clause();
				}
				break;
			}
			State = 1341;
			_la = _input.La(1);
			if (_la==FOR) {
				{
				State = 1340; for_each_row();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class For_each_rowContext : ParserRuleContext {
		public ITerminalNode ROW() { return GetToken(plsqlParser.ROW, 0); }
		public ITerminalNode FOR() { return GetToken(plsqlParser.FOR, 0); }
		public ITerminalNode EACH() { return GetToken(plsqlParser.EACH, 0); }
		public For_each_rowContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_for_each_row; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterFor_each_row(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitFor_each_row(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFor_each_row(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public For_each_rowContext for_each_row() {
		For_each_rowContext _localctx = new For_each_rowContext(_ctx, State);
		EnterRule(_localctx, 64, RULE_for_each_row);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1343; Match(FOR);
			State = 1344; Match(EACH);
			State = 1345; Match(ROW);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Compound_dml_triggerContext : ParserRuleContext {
		public Dml_event_clauseContext dml_event_clause() {
			return GetRuleContext<Dml_event_clauseContext>(0);
		}
		public Referencing_clauseContext referencing_clause() {
			return GetRuleContext<Referencing_clauseContext>(0);
		}
		public ITerminalNode FOR() { return GetToken(plsqlParser.FOR, 0); }
		public Compound_dml_triggerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compound_dml_trigger; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCompound_dml_trigger(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCompound_dml_trigger(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompound_dml_trigger(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Compound_dml_triggerContext compound_dml_trigger() {
		Compound_dml_triggerContext _localctx = new Compound_dml_triggerContext(_ctx, State);
		EnterRule(_localctx, 66, RULE_compound_dml_trigger);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1347; Match(FOR);
			State = 1348; dml_event_clause();
			State = 1350;
			switch ( Interpreter.AdaptivePredict(_input,87,_ctx) ) {
			case 1:
				{
				State = 1349; referencing_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Non_dml_triggerContext : ParserRuleContext {
		public Non_dml_eventContext non_dml_event(int i) {
			return GetRuleContext<Non_dml_eventContext>(i);
		}
		public ITerminalNode ON() { return GetToken(plsqlParser.ON, 0); }
		public ITerminalNode BEFORE() { return GetToken(plsqlParser.BEFORE, 0); }
		public IReadOnlyList<Non_dml_eventContext> non_dml_event() {
			return GetRuleContexts<Non_dml_eventContext>();
		}
		public ITerminalNode DATABASE() { return GetToken(plsqlParser.DATABASE, 0); }
		public IReadOnlyList<ITerminalNode> OR() { return GetTokens(plsqlParser.OR); }
		public Schema_nameContext schema_name() {
			return GetRuleContext<Schema_nameContext>(0);
		}
		public ITerminalNode OR(int i) {
			return GetToken(plsqlParser.OR, i);
		}
		public ITerminalNode AFTER() { return GetToken(plsqlParser.AFTER, 0); }
		public ITerminalNode SCHEMA() { return GetToken(plsqlParser.SCHEMA, 0); }
		public Non_dml_triggerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_non_dml_trigger; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterNon_dml_trigger(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitNon_dml_trigger(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNon_dml_trigger(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Non_dml_triggerContext non_dml_trigger() {
		Non_dml_triggerContext _localctx = new Non_dml_triggerContext(_ctx, State);
		EnterRule(_localctx, 68, RULE_non_dml_trigger);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1352;
			_la = _input.La(1);
			if ( !(_la==AFTER || _la==BEFORE) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			State = 1353; non_dml_event();
			State = 1358;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==OR) {
				{
				{
				State = 1354; Match(OR);
				State = 1355; non_dml_event();
				}
				}
				State = 1360;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 1361; Match(ON);
			State = 1369;
			switch ( Interpreter.AdaptivePredict(_input,90,_ctx) ) {
			case 1:
				{
				State = 1362; Match(DATABASE);
				}
				break;

			case 2:
				{
				State = 1366;
				switch ( Interpreter.AdaptivePredict(_input,89,_ctx) ) {
				case 1:
					{
					State = 1363; schema_name();
					State = 1364; Match(PERIOD);
					}
					break;
				}
				State = 1368; Match(SCHEMA);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Trigger_bodyContext : ParserRuleContext {
		public Trigger_blockContext trigger_block() {
			return GetRuleContext<Trigger_blockContext>(0);
		}
		public ITerminalNode CALL() { return GetToken(plsqlParser.CALL, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode TRIGGER() { return GetToken(plsqlParser.TRIGGER, 0); }
		public ITerminalNode COMPOUND() { return GetToken(plsqlParser.COMPOUND, 0); }
		public Trigger_bodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_trigger_body; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterTrigger_body(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitTrigger_body(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTrigger_body(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Trigger_bodyContext trigger_body() {
		Trigger_bodyContext _localctx = new Trigger_bodyContext(_ctx, State);
		EnterRule(_localctx, 70, RULE_trigger_body);
		try {
			State = 1376;
			switch ( Interpreter.AdaptivePredict(_input,91,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1371; Match(COMPOUND);
				State = 1372; Match(TRIGGER);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1373; Match(CALL);
				State = 1374; identifier();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1375; trigger_block();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Routine_clauseContext : ParserRuleContext {
		public Function_argumentContext function_argument() {
			return GetRuleContext<Function_argumentContext>(0);
		}
		public Routine_nameContext routine_name() {
			return GetRuleContext<Routine_nameContext>(0);
		}
		public Routine_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_routine_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterRoutine_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitRoutine_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRoutine_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Routine_clauseContext routine_clause() {
		Routine_clauseContext _localctx = new Routine_clauseContext(_ctx, State);
		EnterRule(_localctx, 72, RULE_routine_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1378; routine_name();
			State = 1380;
			_la = _input.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 1379; function_argument();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Compound_trigger_blockContext : ParserRuleContext {
		public IReadOnlyList<Declare_specContext> declare_spec() {
			return GetRuleContexts<Declare_specContext>();
		}
		public Timing_point_sectionContext timing_point_section(int i) {
			return GetRuleContext<Timing_point_sectionContext>(i);
		}
		public Trigger_nameContext trigger_name() {
			return GetRuleContext<Trigger_nameContext>(0);
		}
		public ITerminalNode END() { return GetToken(plsqlParser.END, 0); }
		public Declare_specContext declare_spec(int i) {
			return GetRuleContext<Declare_specContext>(i);
		}
		public ITerminalNode TRIGGER() { return GetToken(plsqlParser.TRIGGER, 0); }
		public ITerminalNode COMPOUND() { return GetToken(plsqlParser.COMPOUND, 0); }
		public IReadOnlyList<Timing_point_sectionContext> timing_point_section() {
			return GetRuleContexts<Timing_point_sectionContext>();
		}
		public Compound_trigger_blockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compound_trigger_block; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCompound_trigger_block(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCompound_trigger_block(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompound_trigger_block(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Compound_trigger_blockContext compound_trigger_block() {
		Compound_trigger_blockContext _localctx = new Compound_trigger_blockContext(_ctx, State);
		EnterRule(_localctx, 74, RULE_compound_trigger_block);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1382; Match(COMPOUND);
			State = 1383; Match(TRIGGER);
			State = 1387;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,93,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 1384; declare_spec();
					}
					} 
				}
				State = 1389;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,93,_ctx);
			}
			State = 1391;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 1390; timing_point_section();
				}
				}
				State = 1393;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==AFTER || _la==BEFORE );
			State = 1395; Match(END);
			State = 1396; trigger_name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Timing_point_sectionContext : ParserRuleContext {
		public IToken bk;
		public IToken ak;
		public IReadOnlyList<ITerminalNode> ROW() { return GetTokens(plsqlParser.ROW); }
		public ITerminalNode IS() { return GetToken(plsqlParser.IS, 0); }
		public Trigger_blockContext trigger_block() {
			return GetRuleContext<Trigger_blockContext>(0);
		}
		public ITerminalNode ROW(int i) {
			return GetToken(plsqlParser.ROW, i);
		}
		public IReadOnlyList<ITerminalNode> BEFORE() { return GetTokens(plsqlParser.BEFORE); }
		public IReadOnlyList<ITerminalNode> STATEMENT() { return GetTokens(plsqlParser.STATEMENT); }
		public ITerminalNode STATEMENT(int i) {
			return GetToken(plsqlParser.STATEMENT, i);
		}
		public ITerminalNode AFTER(int i) {
			return GetToken(plsqlParser.AFTER, i);
		}
		public ITerminalNode EACH(int i) {
			return GetToken(plsqlParser.EACH, i);
		}
		public IReadOnlyList<ITerminalNode> EACH() { return GetTokens(plsqlParser.EACH); }
		public ITerminalNode BEFORE(int i) {
			return GetToken(plsqlParser.BEFORE, i);
		}
		public IReadOnlyList<ITerminalNode> AFTER() { return GetTokens(plsqlParser.AFTER); }
		public Timing_point_sectionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_timing_point_section; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterTiming_point_section(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitTiming_point_section(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTiming_point_section(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Timing_point_sectionContext timing_point_section() {
		Timing_point_sectionContext _localctx = new Timing_point_sectionContext(_ctx, State);
		EnterRule(_localctx, 76, RULE_timing_point_section);
		try {
			State = 1434;
			switch ( Interpreter.AdaptivePredict(_input,95,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1398; _localctx.bk = Match(BEFORE);
				State = 1399; Match(STATEMENT);
				State = 1400; Match(IS);
				State = 1401; trigger_block();
				State = 1402; Match(BEFORE);
				State = 1403; Match(STATEMENT);
				State = 1404; Match(SEMICOLON);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1406; _localctx.bk = Match(BEFORE);
				State = 1407; Match(EACH);
				State = 1408; Match(ROW);
				State = 1409; Match(IS);
				State = 1410; trigger_block();
				State = 1411; Match(BEFORE);
				State = 1412; Match(EACH);
				State = 1413; Match(ROW);
				State = 1414; Match(SEMICOLON);
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1416; _localctx.ak = Match(AFTER);
				State = 1417; Match(STATEMENT);
				State = 1418; Match(IS);
				State = 1419; trigger_block();
				State = 1420; Match(AFTER);
				State = 1421; Match(STATEMENT);
				State = 1422; Match(SEMICOLON);
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1424; _localctx.ak = Match(AFTER);
				State = 1425; Match(EACH);
				State = 1426; Match(ROW);
				State = 1427; Match(IS);
				State = 1428; trigger_block();
				State = 1429; Match(AFTER);
				State = 1430; Match(EACH);
				State = 1431; Match(ROW);
				State = 1432; Match(SEMICOLON);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Non_dml_eventContext : ParserRuleContext {
		public ITerminalNode COMMENT() { return GetToken(plsqlParser.COMMENT, 0); }
		public ITerminalNode LOGON() { return GetToken(plsqlParser.LOGON, 0); }
		public ITerminalNode REVOKE() { return GetToken(plsqlParser.REVOKE, 0); }
		public ITerminalNode SUSPEND() { return GetToken(plsqlParser.SUSPEND, 0); }
		public ITerminalNode ANALYZE() { return GetToken(plsqlParser.ANALYZE, 0); }
		public ITerminalNode SERVERERROR() { return GetToken(plsqlParser.SERVERERROR, 0); }
		public ITerminalNode STATISTICS() { return GetToken(plsqlParser.STATISTICS, 0); }
		public ITerminalNode FOLLOWS() { return GetToken(plsqlParser.FOLLOWS, 0); }
		public ITerminalNode SHUTDOWN() { return GetToken(plsqlParser.SHUTDOWN, 0); }
		public ITerminalNode DISASSOCIATE() { return GetToken(plsqlParser.DISASSOCIATE, 0); }
		public ITerminalNode CREATE() { return GetToken(plsqlParser.CREATE, 0); }
		public ITerminalNode SCHEMA() { return GetToken(plsqlParser.SCHEMA, 0); }
		public ITerminalNode ASSOCIATE() { return GetToken(plsqlParser.ASSOCIATE, 0); }
		public ITerminalNode STARTUP() { return GetToken(plsqlParser.STARTUP, 0); }
		public ITerminalNode DATABASE() { return GetToken(plsqlParser.DATABASE, 0); }
		public ITerminalNode DROP() { return GetToken(plsqlParser.DROP, 0); }
		public ITerminalNode GRANT() { return GetToken(plsqlParser.GRANT, 0); }
		public ITerminalNode RENAME() { return GetToken(plsqlParser.RENAME, 0); }
		public ITerminalNode LOGOFF() { return GetToken(plsqlParser.LOGOFF, 0); }
		public ITerminalNode DB_ROLE_CHANGE() { return GetToken(plsqlParser.DB_ROLE_CHANGE, 0); }
		public ITerminalNode TRUNCATE() { return GetToken(plsqlParser.TRUNCATE, 0); }
		public ITerminalNode ALTER() { return GetToken(plsqlParser.ALTER, 0); }
		public ITerminalNode DDL() { return GetToken(plsqlParser.DDL, 0); }
		public ITerminalNode NOAUDIT() { return GetToken(plsqlParser.NOAUDIT, 0); }
		public ITerminalNode AUDIT() { return GetToken(plsqlParser.AUDIT, 0); }
		public Non_dml_eventContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_non_dml_event; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterNon_dml_event(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitNon_dml_event(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNon_dml_event(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Non_dml_eventContext non_dml_event() {
		Non_dml_eventContext _localctx = new Non_dml_eventContext(_ctx, State);
		EnterRule(_localctx, 78, RULE_non_dml_event);
		try {
			State = 1462;
			switch (_input.La(1)) {
			case ALTER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1436; Match(ALTER);
				}
				break;
			case ANALYZE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1437; Match(ANALYZE);
				}
				break;
			case ASSOCIATE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1438; Match(ASSOCIATE);
				State = 1439; Match(STATISTICS);
				}
				break;
			case AUDIT:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1440; Match(AUDIT);
				}
				break;
			case COMMENT:
				EnterOuterAlt(_localctx, 5);
				{
				State = 1441; Match(COMMENT);
				}
				break;
			case CREATE:
				EnterOuterAlt(_localctx, 6);
				{
				State = 1442; Match(CREATE);
				}
				break;
			case DISASSOCIATE:
				EnterOuterAlt(_localctx, 7);
				{
				State = 1443; Match(DISASSOCIATE);
				State = 1444; Match(STATISTICS);
				}
				break;
			case DROP:
				EnterOuterAlt(_localctx, 8);
				{
				State = 1445; Match(DROP);
				}
				break;
			case GRANT:
				EnterOuterAlt(_localctx, 9);
				{
				State = 1446; Match(GRANT);
				}
				break;
			case NOAUDIT:
				EnterOuterAlt(_localctx, 10);
				{
				State = 1447; Match(NOAUDIT);
				}
				break;
			case RENAME:
				EnterOuterAlt(_localctx, 11);
				{
				State = 1448; Match(RENAME);
				}
				break;
			case REVOKE:
				EnterOuterAlt(_localctx, 12);
				{
				State = 1449; Match(REVOKE);
				}
				break;
			case TRUNCATE:
				EnterOuterAlt(_localctx, 13);
				{
				State = 1450; Match(TRUNCATE);
				}
				break;
			case DDL:
				EnterOuterAlt(_localctx, 14);
				{
				State = 1451; Match(DDL);
				}
				break;
			case STARTUP:
				EnterOuterAlt(_localctx, 15);
				{
				State = 1452; Match(STARTUP);
				}
				break;
			case SHUTDOWN:
				EnterOuterAlt(_localctx, 16);
				{
				State = 1453; Match(SHUTDOWN);
				}
				break;
			case DB_ROLE_CHANGE:
				EnterOuterAlt(_localctx, 17);
				{
				State = 1454; Match(DB_ROLE_CHANGE);
				}
				break;
			case LOGON:
				EnterOuterAlt(_localctx, 18);
				{
				State = 1455; Match(LOGON);
				}
				break;
			case LOGOFF:
				EnterOuterAlt(_localctx, 19);
				{
				State = 1456; Match(LOGOFF);
				}
				break;
			case SERVERERROR:
				EnterOuterAlt(_localctx, 20);
				{
				State = 1457; Match(SERVERERROR);
				}
				break;
			case SUSPEND:
				EnterOuterAlt(_localctx, 21);
				{
				State = 1458; Match(SUSPEND);
				}
				break;
			case DATABASE:
				EnterOuterAlt(_localctx, 22);
				{
				State = 1459; Match(DATABASE);
				}
				break;
			case SCHEMA:
				EnterOuterAlt(_localctx, 23);
				{
				State = 1460; Match(SCHEMA);
				}
				break;
			case FOLLOWS:
				EnterOuterAlt(_localctx, 24);
				{
				State = 1461; Match(FOLLOWS);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Dml_event_clauseContext : ParserRuleContext {
		public ITerminalNode ON() { return GetToken(plsqlParser.ON, 0); }
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public Dml_event_elementContext dml_event_element(int i) {
			return GetRuleContext<Dml_event_elementContext>(i);
		}
		public IReadOnlyList<Dml_event_elementContext> dml_event_element() {
			return GetRuleContexts<Dml_event_elementContext>();
		}
		public Dml_event_nested_clauseContext dml_event_nested_clause() {
			return GetRuleContext<Dml_event_nested_clauseContext>(0);
		}
		public IReadOnlyList<ITerminalNode> OR() { return GetTokens(plsqlParser.OR); }
		public ITerminalNode OR(int i) {
			return GetToken(plsqlParser.OR, i);
		}
		public Dml_event_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dml_event_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterDml_event_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitDml_event_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDml_event_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Dml_event_clauseContext dml_event_clause() {
		Dml_event_clauseContext _localctx = new Dml_event_clauseContext(_ctx, State);
		EnterRule(_localctx, 80, RULE_dml_event_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1464; dml_event_element();
			State = 1469;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==OR) {
				{
				{
				State = 1465; Match(OR);
				State = 1466; dml_event_element();
				}
				}
				State = 1471;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 1472; Match(ON);
			State = 1474;
			switch ( Interpreter.AdaptivePredict(_input,98,_ctx) ) {
			case 1:
				{
				State = 1473; dml_event_nested_clause();
				}
				break;
			}
			State = 1476; tableview_name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Dml_event_elementContext : ParserRuleContext {
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public IReadOnlyList<Column_nameContext> column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public ITerminalNode UPDATE() { return GetToken(plsqlParser.UPDATE, 0); }
		public ITerminalNode DELETE() { return GetToken(plsqlParser.DELETE, 0); }
		public ITerminalNode OF() { return GetToken(plsqlParser.OF, 0); }
		public ITerminalNode INSERT() { return GetToken(plsqlParser.INSERT, 0); }
		public Dml_event_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dml_event_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterDml_event_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitDml_event_element(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDml_event_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Dml_event_elementContext dml_event_element() {
		Dml_event_elementContext _localctx = new Dml_event_elementContext(_ctx, State);
		EnterRule(_localctx, 82, RULE_dml_event_element);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1478;
			_la = _input.La(1);
			if ( !(_la==DELETE || _la==INSERT || _la==UPDATE) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			State = 1488;
			_la = _input.La(1);
			if (_la==OF) {
				{
				State = 1479; Match(OF);
				State = 1480; column_name();
				State = 1485;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 1481; Match(COMMA);
					State = 1482; column_name();
					}
					}
					State = 1487;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Dml_event_nested_clauseContext : ParserRuleContext {
		public ITerminalNode NESTED() { return GetToken(plsqlParser.NESTED, 0); }
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public ITerminalNode OF() { return GetToken(plsqlParser.OF, 0); }
		public ITerminalNode TABLE() { return GetToken(plsqlParser.TABLE, 0); }
		public Dml_event_nested_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dml_event_nested_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterDml_event_nested_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitDml_event_nested_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDml_event_nested_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Dml_event_nested_clauseContext dml_event_nested_clause() {
		Dml_event_nested_clauseContext _localctx = new Dml_event_nested_clauseContext(_ctx, State);
		EnterRule(_localctx, 84, RULE_dml_event_nested_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1490; Match(NESTED);
			State = 1491; Match(TABLE);
			State = 1492; tableview_name();
			State = 1493; Match(OF);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Referencing_clauseContext : ParserRuleContext {
		public Referencing_elementContext referencing_element(int i) {
			return GetRuleContext<Referencing_elementContext>(i);
		}
		public IReadOnlyList<Referencing_elementContext> referencing_element() {
			return GetRuleContexts<Referencing_elementContext>();
		}
		public ITerminalNode REFERENCING() { return GetToken(plsqlParser.REFERENCING, 0); }
		public Referencing_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_referencing_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterReferencing_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitReferencing_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReferencing_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Referencing_clauseContext referencing_clause() {
		Referencing_clauseContext _localctx = new Referencing_clauseContext(_ctx, State);
		EnterRule(_localctx, 86, RULE_referencing_clause);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1495; Match(REFERENCING);
			State = 1497;
			_errHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 1496; referencing_element();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 1499;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,101,_ctx);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Referencing_elementContext : ParserRuleContext {
		public ITerminalNode OLD() { return GetToken(plsqlParser.OLD, 0); }
		public ITerminalNode PARENT() { return GetToken(plsqlParser.PARENT, 0); }
		public ITerminalNode NEW() { return GetToken(plsqlParser.NEW, 0); }
		public Column_aliasContext column_alias() {
			return GetRuleContext<Column_aliasContext>(0);
		}
		public Referencing_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_referencing_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterReferencing_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitReferencing_element(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReferencing_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Referencing_elementContext referencing_element() {
		Referencing_elementContext _localctx = new Referencing_elementContext(_ctx, State);
		EnterRule(_localctx, 88, RULE_referencing_element);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1501;
			_la = _input.La(1);
			if ( !(((((_la - 238)) & ~0x3f) == 0 && ((1L << (_la - 238)) & ((1L << (NEW - 238)) | (1L << (OLD - 238)) | (1L << (PARENT - 238)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			State = 1502; column_alias();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Drop_typeContext : ParserRuleContext {
		public ITerminalNode TYPE() { return GetToken(plsqlParser.TYPE, 0); }
		public Type_nameContext type_name() {
			return GetRuleContext<Type_nameContext>(0);
		}
		public ITerminalNode FORCE() { return GetToken(plsqlParser.FORCE, 0); }
		public ITerminalNode DROP() { return GetToken(plsqlParser.DROP, 0); }
		public ITerminalNode VALIDATE() { return GetToken(plsqlParser.VALIDATE, 0); }
		public ITerminalNode BODY() { return GetToken(plsqlParser.BODY, 0); }
		public Drop_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_drop_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterDrop_type(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitDrop_type(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDrop_type(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Drop_typeContext drop_type() {
		Drop_typeContext _localctx = new Drop_typeContext(_ctx, State);
		EnterRule(_localctx, 90, RULE_drop_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1504; Match(DROP);
			State = 1505; Match(TYPE);
			State = 1507;
			switch ( Interpreter.AdaptivePredict(_input,102,_ctx) ) {
			case 1:
				{
				State = 1506; Match(BODY);
				}
				break;
			}
			State = 1509; type_name();
			State = 1511;
			_la = _input.La(1);
			if (_la==FORCE || _la==VALIDATE) {
				{
				State = 1510;
				_la = _input.La(1);
				if ( !(_la==FORCE || _la==VALIDATE) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				}
			}

			State = 1513; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_typeContext : ParserRuleContext {
		public Modifier_clauseContext modifier_clause() {
			return GetRuleContext<Modifier_clauseContext>(0);
		}
		public Alter_collection_clausesContext alter_collection_clauses() {
			return GetRuleContext<Alter_collection_clausesContext>(0);
		}
		public Replace_type_clauseContext replace_type_clause() {
			return GetRuleContext<Replace_type_clauseContext>(0);
		}
		public ITerminalNode TYPE() { return GetToken(plsqlParser.TYPE, 0); }
		public Alter_method_specContext alter_method_spec() {
			return GetRuleContext<Alter_method_specContext>(0);
		}
		public Type_nameContext type_name() {
			return GetRuleContext<Type_nameContext>(0);
		}
		public ITerminalNode ALTER() { return GetToken(plsqlParser.ALTER, 0); }
		public Dependent_handling_clauseContext dependent_handling_clause() {
			return GetRuleContext<Dependent_handling_clauseContext>(0);
		}
		public Compile_type_clauseContext compile_type_clause() {
			return GetRuleContext<Compile_type_clauseContext>(0);
		}
		public Alter_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterAlter_type(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitAlter_type(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlter_type(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Alter_typeContext alter_type() {
		Alter_typeContext _localctx = new Alter_typeContext(_ctx, State);
		EnterRule(_localctx, 92, RULE_alter_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1515; Match(ALTER);
			State = 1516; Match(TYPE);
			State = 1517; type_name();
			State = 1523;
			switch (_input.La(1)) {
			case COMPILE:
				{
				State = 1518; compile_type_clause();
				}
				break;
			case REPLACE:
				{
				State = 1519; replace_type_clause();
				}
				break;
			case ADD:
			case DROP:
				{
				State = 1520; alter_method_spec();
				}
				break;
			case MODIFY:
				{
				State = 1521; alter_collection_clauses();
				}
				break;
			case FINAL:
			case INSTANTIABLE:
			case NOT:
			case OVERRIDING:
				{
				State = 1522; modifier_clause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1526;
			_la = _input.La(1);
			if (_la==CASCADE || _la==INVALIDATE) {
				{
				State = 1525; dependent_handling_clause();
				}
			}

			State = 1528; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Compile_type_clauseContext : ParserRuleContext {
		public ITerminalNode REUSE() { return GetToken(plsqlParser.REUSE, 0); }
		public ITerminalNode DEBUG() { return GetToken(plsqlParser.DEBUG, 0); }
		public Compiler_parameters_clauseContext compiler_parameters_clause(int i) {
			return GetRuleContext<Compiler_parameters_clauseContext>(i);
		}
		public IReadOnlyList<Compiler_parameters_clauseContext> compiler_parameters_clause() {
			return GetRuleContexts<Compiler_parameters_clauseContext>();
		}
		public ITerminalNode SETTINGS() { return GetToken(plsqlParser.SETTINGS, 0); }
		public ITerminalNode COMPILE() { return GetToken(plsqlParser.COMPILE, 0); }
		public ITerminalNode BODY() { return GetToken(plsqlParser.BODY, 0); }
		public ITerminalNode SPECIFICATION() { return GetToken(plsqlParser.SPECIFICATION, 0); }
		public Compile_type_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compile_type_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCompile_type_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCompile_type_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompile_type_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Compile_type_clauseContext compile_type_clause() {
		Compile_type_clauseContext _localctx = new Compile_type_clauseContext(_ctx, State);
		EnterRule(_localctx, 94, RULE_compile_type_clause);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1530; Match(COMPILE);
			State = 1532;
			switch ( Interpreter.AdaptivePredict(_input,106,_ctx) ) {
			case 1:
				{
				State = 1531; Match(DEBUG);
				}
				break;
			}
			State = 1535;
			switch ( Interpreter.AdaptivePredict(_input,107,_ctx) ) {
			case 1:
				{
				State = 1534;
				_la = _input.La(1);
				if ( !(_la==BODY || _la==SPECIFICATION) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				}
				break;
			}
			State = 1540;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,108,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 1537; compiler_parameters_clause();
					}
					} 
				}
				State = 1542;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,108,_ctx);
			}
			State = 1545;
			_la = _input.La(1);
			if (_la==REUSE) {
				{
				State = 1543; Match(REUSE);
				State = 1544; Match(SETTINGS);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Replace_type_clauseContext : ParserRuleContext {
		public ITerminalNode REPLACE() { return GetToken(plsqlParser.REPLACE, 0); }
		public ITerminalNode OBJECT() { return GetToken(plsqlParser.OBJECT, 0); }
		public Object_member_specContext object_member_spec(int i) {
			return GetRuleContext<Object_member_specContext>(i);
		}
		public IReadOnlyList<Object_member_specContext> object_member_spec() {
			return GetRuleContexts<Object_member_specContext>();
		}
		public ITerminalNode AS() { return GetToken(plsqlParser.AS, 0); }
		public Invoker_rights_clauseContext invoker_rights_clause() {
			return GetRuleContext<Invoker_rights_clauseContext>(0);
		}
		public Replace_type_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_replace_type_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterReplace_type_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitReplace_type_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReplace_type_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Replace_type_clauseContext replace_type_clause() {
		Replace_type_clauseContext _localctx = new Replace_type_clauseContext(_ctx, State);
		EnterRule(_localctx, 96, RULE_replace_type_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1547; Match(REPLACE);
			State = 1549;
			_la = _input.La(1);
			if (_la==AUTHID) {
				{
				State = 1548; invoker_rights_clause();
				}
			}

			State = 1551; Match(AS);
			State = 1552; Match(OBJECT);
			State = 1553; Match(LEFT_PAREN);
			State = 1554; object_member_spec();
			State = 1559;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 1555; Match(COMMA);
				State = 1556; object_member_spec();
				}
				}
				State = 1561;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 1562; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_method_specContext : ParserRuleContext {
		public Alter_method_elementContext alter_method_element(int i) {
			return GetRuleContext<Alter_method_elementContext>(i);
		}
		public IReadOnlyList<Alter_method_elementContext> alter_method_element() {
			return GetRuleContexts<Alter_method_elementContext>();
		}
		public Alter_method_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_method_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterAlter_method_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitAlter_method_spec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlter_method_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Alter_method_specContext alter_method_spec() {
		Alter_method_specContext _localctx = new Alter_method_specContext(_ctx, State);
		EnterRule(_localctx, 98, RULE_alter_method_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1564; alter_method_element();
			State = 1569;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 1565; Match(COMMA);
				State = 1566; alter_method_element();
				}
				}
				State = 1571;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_method_elementContext : ParserRuleContext {
		public ITerminalNode ADD() { return GetToken(plsqlParser.ADD, 0); }
		public ITerminalNode DROP() { return GetToken(plsqlParser.DROP, 0); }
		public Subprogram_specContext subprogram_spec() {
			return GetRuleContext<Subprogram_specContext>(0);
		}
		public Map_order_function_specContext map_order_function_spec() {
			return GetRuleContext<Map_order_function_specContext>(0);
		}
		public Alter_method_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_method_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterAlter_method_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitAlter_method_element(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlter_method_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Alter_method_elementContext alter_method_element() {
		Alter_method_elementContext _localctx = new Alter_method_elementContext(_ctx, State);
		EnterRule(_localctx, 100, RULE_alter_method_element);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1572;
			_la = _input.La(1);
			if ( !(_la==ADD || _la==DROP) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			State = 1575;
			switch (_input.La(1)) {
			case MAP:
			case ORDER:
				{
				State = 1573; map_order_function_spec();
				}
				break;
			case MEMBER:
			case STATIC:
				{
				State = 1574; subprogram_spec();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_attribute_definitionContext : ParserRuleContext {
		public Attribute_definitionContext attribute_definition(int i) {
			return GetRuleContext<Attribute_definitionContext>(i);
		}
		public ITerminalNode ADD() { return GetToken(plsqlParser.ADD, 0); }
		public ITerminalNode MODIFY() { return GetToken(plsqlParser.MODIFY, 0); }
		public ITerminalNode ATTRIBUTE() { return GetToken(plsqlParser.ATTRIBUTE, 0); }
		public ITerminalNode DROP() { return GetToken(plsqlParser.DROP, 0); }
		public IReadOnlyList<Attribute_definitionContext> attribute_definition() {
			return GetRuleContexts<Attribute_definitionContext>();
		}
		public Alter_attribute_definitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_attribute_definition; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterAlter_attribute_definition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitAlter_attribute_definition(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlter_attribute_definition(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Alter_attribute_definitionContext alter_attribute_definition() {
		Alter_attribute_definitionContext _localctx = new Alter_attribute_definitionContext(_ctx, State);
		EnterRule(_localctx, 102, RULE_alter_attribute_definition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1577;
			_la = _input.La(1);
			if ( !(_la==ADD || _la==DROP || _la==MODIFY) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			State = 1578; Match(ATTRIBUTE);
			State = 1591;
			switch (_input.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROW_NUMBER:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 1579; attribute_definition();
				}
				break;
			case LEFT_PAREN:
				{
				State = 1580; Match(LEFT_PAREN);
				State = 1581; attribute_definition();
				State = 1586;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 1582; Match(COMMA);
					State = 1583; attribute_definition();
					}
					}
					State = 1588;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 1589; Match(RIGHT_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Attribute_definitionContext : ParserRuleContext {
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public Attribute_nameContext attribute_name() {
			return GetRuleContext<Attribute_nameContext>(0);
		}
		public Attribute_definitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_attribute_definition; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterAttribute_definition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitAttribute_definition(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAttribute_definition(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Attribute_definitionContext attribute_definition() {
		Attribute_definitionContext _localctx = new Attribute_definitionContext(_ctx, State);
		EnterRule(_localctx, 104, RULE_attribute_definition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1593; attribute_name();
			State = 1595;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (CONSTANT - 66)) | (1L << (CONSTRAINT - 66)) | (1L << (CONSTRAINTS - 66)) | (1L << (CONSTRUCTOR - 66)) | (1L << (CONTENT - 66)) | (1L << (CONTEXT - 66)) | (1L << (CONTINUE - 66)) | (1L << (CONVERT - 66)) | (1L << (CORRUPT_XID - 66)) | (1L << (CORRUPT_XID_ALL - 66)) | (1L << (COST - 66)) | (1L << (COUNT - 66)) | (1L << (CROSS - 66)) | (1L << (CUBE - 66)) | (1L << (CURRENT_USER - 66)) | (1L << (CURSOR - 66)) | (1L << (CUSTOMDATUM - 66)) | (1L << (CYCLE - 66)) | (1L << (DATA - 66)) | (1L << (DATABASE - 66)) | (1L << (DATE - 66)) | (1L << (DAY - 66)) | (1L << (DB_ROLE_CHANGE - 66)) | (1L << (DBTIMEZONE - 66)) | (1L << (DDL - 66)) | (1L << (DEBUG - 66)) | (1L << (DEC - 66)) | (1L << (DECIMAL - 66)) | (1L << (DECOMPOSE - 66)) | (1L << (DECREMENT - 66)) | (1L << (DEFAULTS - 66)) | (1L << (DEFERRED - 66)) | (1L << (DEFINER - 66)) | (1L << (DETERMINISTIC - 66)) | (1L << (DIMENSION - 66)) | (1L << (DISABLE - 66)) | (1L << (DISASSOCIATE - 66)) | (1L << (DOCUMENT - 66)) | (1L << (DOUBLE - 66)) | (1L << (DSINTERVAL_UNCONSTRAINED - 66)) | (1L << (EACH - 66)) | (1L << (ELEMENT - 66)) | (1L << (EMPTY - 66)) | (1L << (ENABLE - 66)) | (1L << (ENCODING - 66)) | (1L << (ENTITYESCAPING - 66)) | (1L << (ERR - 66)) | (1L << (ERRORS - 66)) | (1L << (ESCAPE - 66)) | (1L << (EVALNAME - 66)) | (1L << (EXCEPTION - 66)) | (1L << (EXCEPTION_INIT - 66)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)) | (1L << (EXIT - 130)) | (1L << (EXPLAIN - 130)) | (1L << (EXTERNAL - 130)) | (1L << (EXTRACT - 130)) | (1L << (FAILURE - 130)) | (1L << (FINAL - 130)) | (1L << (FIRST - 130)) | (1L << (FIRST_VALUE - 130)) | (1L << (FLOAT - 130)) | (1L << (FOLLOWING - 130)) | (1L << (FOLLOWS - 130)) | (1L << (FORALL - 130)) | (1L << (FORCE - 130)) | (1L << (FULL - 130)) | (1L << (FUNCTION - 130)) | (1L << (GROUPING - 130)) | (1L << (HASH - 130)) | (1L << (HIDE - 130)) | (1L << (HOUR - 130)) | (1L << (IGNORE - 130)) | (1L << (IMMEDIATE - 130)) | (1L << (INCLUDE - 130)) | (1L << (INCLUDING - 130)) | (1L << (INCREMENT - 130)) | (1L << (INDENT - 130)) | (1L << (INDEXED - 130)) | (1L << (INDICATOR - 130)) | (1L << (INDICES - 130)) | (1L << (INFINITE - 130)) | (1L << (INLINE - 130)) | (1L << (INNER - 130)) | (1L << (INOUT - 130)) | (1L << (INSTANTIABLE - 130)) | (1L << (INSTEAD - 130)) | (1L << (INT - 130)) | (1L << (INTEGER - 130)) | (1L << (INTERVAL - 130)) | (1L << (INVALIDATE - 130)) | (1L << (ISOLATION - 130)) | (1L << (ITERATE - 130)) | (1L << (JAVA - 130)) | (1L << (JOIN - 130)) | (1L << (KEEP - 130)) | (1L << (LANGUAGE - 130)))) != 0) || ((((_la - 194)) & ~0x3f) == 0 && ((1L << (_la - 194)) & ((1L << (LAST - 194)) | (1L << (LAST_VALUE - 194)) | (1L << (LEADING - 194)) | (1L << (LEFT - 194)) | (1L << (LEVEL - 194)) | (1L << (LIBRARY - 194)) | (1L << (LIKE2 - 194)) | (1L << (LIKE4 - 194)) | (1L << (LIKEC - 194)) | (1L << (LIMIT - 194)) | (1L << (LOCAL - 194)) | (1L << (LOCKED - 194)) | (1L << (LOG - 194)) | (1L << (LOGOFF - 194)) | (1L << (LOGON - 194)) | (1L << (LONG - 194)) | (1L << (LOOP - 194)) | (1L << (MAIN - 194)) | (1L << (MAP - 194)) | (1L << (MATCHED - 194)) | (1L << (MAXVALUE - 194)) | (1L << (MEASURES - 194)) | (1L << (MEMBER - 194)) | (1L << (MERGE - 194)) | (1L << (MINUTE - 194)) | (1L << (MINVALUE - 194)) | (1L << (MLSLABEL - 194)) | (1L << (MODEL - 194)) | (1L << (MODIFY - 194)) | (1L << (MONTH - 194)) | (1L << (MULTISET - 194)) | (1L << (NAME - 194)) | (1L << (NAN - 194)) | (1L << (NATURAL - 194)) | (1L << (NATURALN - 194)) | (1L << (NAV - 194)) | (1L << (NCHAR - 194)) | (1L << (NCHAR_CS - 194)) | (1L << (NCLOB - 194)) | (1L << (NESTED - 194)) | (1L << (NEW - 194)) | (1L << (NO - 194)) | (1L << (NOAUDIT - 194)) | (1L << (NOCOPY - 194)) | (1L << (NOCYCLE - 194)) | (1L << (NOENTITYESCAPING - 194)) | (1L << (NONE - 194)) | (1L << (NOSCHEMACHECK - 194)) | (1L << (NULLS - 194)) | (1L << (NUMBER - 194)) | (1L << (NUMERIC - 194)) | (1L << (NVARCHAR2 - 194)) | (1L << (OBJECT - 194)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (OFF - 259)) | (1L << (OID - 259)) | (1L << (OLD - 259)) | (1L << (ONLY - 259)) | (1L << (OPEN - 259)) | (1L << (ORADATA - 259)) | (1L << (ORDINALITY - 259)) | (1L << (OSERROR - 259)) | (1L << (OUT - 259)) | (1L << (OUTER - 259)) | (1L << (OVER - 259)) | (1L << (OVERRIDING - 259)) | (1L << (PACKAGE - 259)) | (1L << (PARALLEL_ENABLE - 259)) | (1L << (PARAMETERS - 259)) | (1L << (PARENT - 259)) | (1L << (PARTITION - 259)) | (1L << (PASSING - 259)) | (1L << (PATH - 259)) | (1L << (PIPELINED - 259)) | (1L << (PLAN - 259)) | (1L << (PLS_INTEGER - 259)) | (1L << (POSITIVE - 259)) | (1L << (POSITIVEN - 259)) | (1L << (PRAGMA - 259)) | (1L << (PRECEDING - 259)) | (1L << (PRECISION - 259)) | (1L << (PRESENT - 259)) | (1L << (RAISE - 259)) | (1L << (RANGE - 259)) | (1L << (RAW - 259)) | (1L << (READ - 259)) | (1L << (REAL - 259)) | (1L << (RECORD - 259)) | (1L << (REF - 259)) | (1L << (REFERENCE - 259)) | (1L << (REFERENCING - 259)) | (1L << (REJECT - 259)) | (1L << (RELIES_ON - 259)) | (1L << (RENAME - 259)) | (1L << (REPLACE - 259)) | (1L << (RESPECT - 259)) | (1L << (RESTRICT_REFERENCES - 259)) | (1L << (RESULT - 259)) | (1L << (RESULT_CACHE - 259)) | (1L << (RETURN - 259)) | (1L << (RETURNING - 259)) | (1L << (REUSE - 259)) | (1L << (REVERSE - 259)) | (1L << (RIGHT - 259)))) != 0) || ((((_la - 323)) & ~0x3f) == 0 && ((1L << (_la - 323)) & ((1L << (ROLLBACK - 323)) | (1L << (ROLLUP - 323)) | (1L << (ROW - 323)) | (1L << (ROWID - 323)) | (1L << (ROWS - 323)) | (1L << (RULES - 323)) | (1L << (SAMPLE - 323)) | (1L << (SAVE - 323)) | (1L << (SAVEPOINT - 323)) | (1L << (SCHEMA - 323)) | (1L << (SCHEMACHECK - 323)) | (1L << (SCN - 323)) | (1L << (SECOND - 323)) | (1L << (SEED - 323)) | (1L << (SEGMENT - 323)) | (1L << (SELF - 323)) | (1L << (SEQUENTIAL - 323)) | (1L << (SERIALIZABLE - 323)) | (1L << (SERIALLY_REUSABLE - 323)) | (1L << (SERVERERROR - 323)) | (1L << (SESSIONTIMEZONE - 323)) | (1L << (SET - 323)) | (1L << (SETS - 323)) | (1L << (SETTINGS - 323)) | (1L << (SHOW - 323)) | (1L << (SHUTDOWN - 323)) | (1L << (SIBLINGS - 323)) | (1L << (SIGNTYPE - 323)) | (1L << (SIMPLE_INTEGER - 323)) | (1L << (SINGLE - 323)) | (1L << (SKIP_ - 323)) | (1L << (SMALLINT - 323)) | (1L << (SNAPSHOT - 323)) | (1L << (SOME - 323)) | (1L << (SPECIFICATION - 323)) | (1L << (SQLDATA - 323)) | (1L << (SQLERROR - 323)) | (1L << (STANDALONE - 323)) | (1L << (STARTUP - 323)) | (1L << (STATEMENT - 323)) | (1L << (STATEMENT_ID - 323)) | (1L << (STATIC - 323)) | (1L << (STATISTICS - 323)) | (1L << (STRING - 323)) | (1L << (SUBMULTISET - 323)) | (1L << (SUBPARTITION - 323)) | (1L << (SUBSTITUTABLE - 323)) | (1L << (SUBTYPE - 323)) | (1L << (SUCCESS - 323)) | (1L << (SUSPEND - 323)) | (1L << (TIME - 323)) | (1L << (TIMESTAMP - 323)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_UNCONSTRAINED - 323)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TIMEZONE_ABBR - 387)) | (1L << (TIMEZONE_HOUR - 387)) | (1L << (TIMEZONE_MINUTE - 387)) | (1L << (TIMEZONE_REGION - 387)) | (1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (YMINTERVAL_UNCONSTRAINED - 451)) | (1L << (ZONE - 451)) | (1L << (PREDICTION - 451)) | (1L << (PREDICTION_BOUNDS - 451)) | (1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (COVAR_ - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (REGR_ - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (TRIM - 451)) | (1L << (SUM - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (VARIANCE - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==REGULAR_ID) {
				{
				State = 1594; type_spec();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_collection_clausesContext : ParserRuleContext {
		public ITerminalNode ELEMENT() { return GetToken(plsqlParser.ELEMENT, 0); }
		public ITerminalNode LIMIT() { return GetToken(plsqlParser.LIMIT, 0); }
		public ITerminalNode TYPE() { return GetToken(plsqlParser.TYPE, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode MODIFY() { return GetToken(plsqlParser.MODIFY, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Alter_collection_clausesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_collection_clauses; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterAlter_collection_clauses(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitAlter_collection_clauses(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlter_collection_clauses(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Alter_collection_clausesContext alter_collection_clauses() {
		Alter_collection_clausesContext _localctx = new Alter_collection_clausesContext(_ctx, State);
		EnterRule(_localctx, 106, RULE_alter_collection_clauses);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1597; Match(MODIFY);
			State = 1603;
			switch (_input.La(1)) {
			case LIMIT:
				{
				State = 1598; Match(LIMIT);
				State = 1599; expression();
				}
				break;
			case ELEMENT:
				{
				State = 1600; Match(ELEMENT);
				State = 1601; Match(TYPE);
				State = 1602; type_spec();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Dependent_handling_clauseContext : ParserRuleContext {
		public ITerminalNode CASCADE() { return GetToken(plsqlParser.CASCADE, 0); }
		public ITerminalNode NOT() { return GetToken(plsqlParser.NOT, 0); }
		public ITerminalNode SUBSTITUTABLE() { return GetToken(plsqlParser.SUBSTITUTABLE, 0); }
		public ITerminalNode CONVERT() { return GetToken(plsqlParser.CONVERT, 0); }
		public ITerminalNode INCLUDING() { return GetToken(plsqlParser.INCLUDING, 0); }
		public ITerminalNode TO() { return GetToken(plsqlParser.TO, 0); }
		public ITerminalNode DATA() { return GetToken(plsqlParser.DATA, 0); }
		public Dependent_exceptions_partContext dependent_exceptions_part() {
			return GetRuleContext<Dependent_exceptions_partContext>(0);
		}
		public ITerminalNode TABLE() { return GetToken(plsqlParser.TABLE, 0); }
		public ITerminalNode INVALIDATE() { return GetToken(plsqlParser.INVALIDATE, 0); }
		public Dependent_handling_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dependent_handling_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterDependent_handling_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitDependent_handling_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDependent_handling_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Dependent_handling_clauseContext dependent_handling_clause() {
		Dependent_handling_clauseContext _localctx = new Dependent_handling_clauseContext(_ctx, State);
		EnterRule(_localctx, 108, RULE_dependent_handling_clause);
		int _la;
		try {
			State = 1621;
			switch (_input.La(1)) {
			case INVALIDATE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1605; Match(INVALIDATE);
				}
				break;
			case CASCADE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1606; Match(CASCADE);
				State = 1616;
				switch (_input.La(1)) {
				case CONVERT:
					{
					State = 1607; Match(CONVERT);
					State = 1608; Match(TO);
					State = 1609; Match(SUBSTITUTABLE);
					}
					break;
				case INCLUDING:
				case NOT:
					{
					State = 1611;
					_la = _input.La(1);
					if (_la==NOT) {
						{
						State = 1610; Match(NOT);
						}
					}

					State = 1613; Match(INCLUDING);
					State = 1614; Match(TABLE);
					State = 1615; Match(DATA);
					}
					break;
				case EXCEPTIONS:
				case FORCE:
				case SEMICOLON:
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 1619;
				_la = _input.La(1);
				if (_la==EXCEPTIONS || _la==FORCE) {
					{
					State = 1618; dependent_exceptions_part();
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Dependent_exceptions_partContext : ParserRuleContext {
		public ITerminalNode EXCEPTIONS() { return GetToken(plsqlParser.EXCEPTIONS, 0); }
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public ITerminalNode FORCE() { return GetToken(plsqlParser.FORCE, 0); }
		public ITerminalNode INTO() { return GetToken(plsqlParser.INTO, 0); }
		public Dependent_exceptions_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dependent_exceptions_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterDependent_exceptions_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitDependent_exceptions_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDependent_exceptions_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Dependent_exceptions_partContext dependent_exceptions_part() {
		Dependent_exceptions_partContext _localctx = new Dependent_exceptions_partContext(_ctx, State);
		EnterRule(_localctx, 110, RULE_dependent_exceptions_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1624;
			_la = _input.La(1);
			if (_la==FORCE) {
				{
				State = 1623; Match(FORCE);
				}
			}

			State = 1626; Match(EXCEPTIONS);
			State = 1627; Match(INTO);
			State = 1628; tableview_name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Create_typeContext : ParserRuleContext {
		public ITerminalNode REPLACE() { return GetToken(plsqlParser.REPLACE, 0); }
		public ITerminalNode TYPE() { return GetToken(plsqlParser.TYPE, 0); }
		public ITerminalNode CREATE() { return GetToken(plsqlParser.CREATE, 0); }
		public ITerminalNode OR() { return GetToken(plsqlParser.OR, 0); }
		public Type_definitionContext type_definition() {
			return GetRuleContext<Type_definitionContext>(0);
		}
		public Type_bodyContext type_body() {
			return GetRuleContext<Type_bodyContext>(0);
		}
		public Create_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_create_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCreate_type(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCreate_type(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreate_type(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Create_typeContext create_type() {
		Create_typeContext _localctx = new Create_typeContext(_ctx, State);
		EnterRule(_localctx, 112, RULE_create_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1630; Match(CREATE);
			State = 1633;
			_la = _input.La(1);
			if (_la==OR) {
				{
				State = 1631; Match(OR);
				State = 1632; Match(REPLACE);
				}
			}

			State = 1635; Match(TYPE);
			State = 1638;
			switch ( Interpreter.AdaptivePredict(_input,124,_ctx) ) {
			case 1:
				{
				State = 1636; type_definition();
				}
				break;

			case 2:
				{
				State = 1637; type_body();
				}
				break;
			}
			State = 1640; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Type_definitionContext : ParserRuleContext {
		public Object_type_defContext object_type_def() {
			return GetRuleContext<Object_type_defContext>(0);
		}
		public Type_nameContext type_name() {
			return GetRuleContext<Type_nameContext>(0);
		}
		public ITerminalNode CHAR_STRING() { return GetToken(plsqlParser.CHAR_STRING, 0); }
		public ITerminalNode OID() { return GetToken(plsqlParser.OID, 0); }
		public Type_definitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_definition; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterType_definition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitType_definition(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_definition(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Type_definitionContext type_definition() {
		Type_definitionContext _localctx = new Type_definitionContext(_ctx, State);
		EnterRule(_localctx, 114, RULE_type_definition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1642; type_name();
			State = 1645;
			_la = _input.La(1);
			if (_la==OID) {
				{
				State = 1643; Match(OID);
				State = 1644; Match(CHAR_STRING);
				}
			}

			State = 1648;
			_la = _input.La(1);
			if (_la==AS || _la==AUTHID || _la==IS || _la==UNDER) {
				{
				State = 1647; object_type_def();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Object_type_defContext : ParserRuleContext {
		public Modifier_clauseContext modifier_clause(int i) {
			return GetRuleContext<Modifier_clauseContext>(i);
		}
		public IReadOnlyList<Modifier_clauseContext> modifier_clause() {
			return GetRuleContexts<Modifier_clauseContext>();
		}
		public Object_as_partContext object_as_part() {
			return GetRuleContext<Object_as_partContext>(0);
		}
		public Object_member_specContext object_member_spec(int i) {
			return GetRuleContext<Object_member_specContext>(i);
		}
		public Object_under_partContext object_under_part() {
			return GetRuleContext<Object_under_partContext>(0);
		}
		public IReadOnlyList<Object_member_specContext> object_member_spec() {
			return GetRuleContexts<Object_member_specContext>();
		}
		public Invoker_rights_clauseContext invoker_rights_clause() {
			return GetRuleContext<Invoker_rights_clauseContext>(0);
		}
		public Sqlj_object_typeContext sqlj_object_type() {
			return GetRuleContext<Sqlj_object_typeContext>(0);
		}
		public Object_type_defContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_object_type_def; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterObject_type_def(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitObject_type_def(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitObject_type_def(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Object_type_defContext object_type_def() {
		Object_type_defContext _localctx = new Object_type_defContext(_ctx, State);
		EnterRule(_localctx, 116, RULE_object_type_def);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1651;
			_la = _input.La(1);
			if (_la==AUTHID) {
				{
				State = 1650; invoker_rights_clause();
				}
			}

			State = 1655;
			switch (_input.La(1)) {
			case AS:
			case IS:
				{
				State = 1653; object_as_part();
				}
				break;
			case UNDER:
				{
				State = 1654; object_under_part();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1658;
			_la = _input.La(1);
			if (_la==EXTERNAL) {
				{
				State = 1657; sqlj_object_type();
				}
			}

			State = 1671;
			_la = _input.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 1660; Match(LEFT_PAREN);
				State = 1661; object_member_spec();
				State = 1666;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 1662; Match(COMMA);
					State = 1663; object_member_spec();
					}
					}
					State = 1668;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 1669; Match(RIGHT_PAREN);
				}
			}

			State = 1676;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==FINAL || _la==INSTANTIABLE || _la==NOT || _la==OVERRIDING) {
				{
				{
				State = 1673; modifier_clause();
				}
				}
				State = 1678;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Object_as_partContext : ParserRuleContext {
		public Varray_type_defContext varray_type_def() {
			return GetRuleContext<Varray_type_defContext>(0);
		}
		public ITerminalNode IS() { return GetToken(plsqlParser.IS, 0); }
		public ITerminalNode OBJECT() { return GetToken(plsqlParser.OBJECT, 0); }
		public Nested_table_type_defContext nested_table_type_def() {
			return GetRuleContext<Nested_table_type_defContext>(0);
		}
		public ITerminalNode AS() { return GetToken(plsqlParser.AS, 0); }
		public Object_as_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_object_as_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterObject_as_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitObject_as_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitObject_as_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Object_as_partContext object_as_part() {
		Object_as_partContext _localctx = new Object_as_partContext(_ctx, State);
		EnterRule(_localctx, 118, RULE_object_as_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1679;
			_la = _input.La(1);
			if ( !(_la==AS || _la==IS) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			State = 1683;
			switch (_input.La(1)) {
			case OBJECT:
				{
				State = 1680; Match(OBJECT);
				}
				break;
			case VARRAY:
			case VARYING:
				{
				State = 1681; varray_type_def();
				}
				break;
			case TABLE:
				{
				State = 1682; nested_table_type_def();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Object_under_partContext : ParserRuleContext {
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode UNDER() { return GetToken(plsqlParser.UNDER, 0); }
		public Object_under_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_object_under_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterObject_under_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitObject_under_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitObject_under_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Object_under_partContext object_under_part() {
		Object_under_partContext _localctx = new Object_under_partContext(_ctx, State);
		EnterRule(_localctx, 120, RULE_object_under_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1685; Match(UNDER);
			State = 1686; type_spec();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Nested_table_type_defContext : ParserRuleContext {
		public ITerminalNode NOT() { return GetToken(plsqlParser.NOT, 0); }
		public ITerminalNode NULL() { return GetToken(plsqlParser.NULL, 0); }
		public ITerminalNode OF() { return GetToken(plsqlParser.OF, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode TABLE() { return GetToken(plsqlParser.TABLE, 0); }
		public Nested_table_type_defContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nested_table_type_def; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterNested_table_type_def(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitNested_table_type_def(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNested_table_type_def(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Nested_table_type_defContext nested_table_type_def() {
		Nested_table_type_defContext _localctx = new Nested_table_type_defContext(_ctx, State);
		EnterRule(_localctx, 122, RULE_nested_table_type_def);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1688; Match(TABLE);
			State = 1689; Match(OF);
			State = 1690; type_spec();
			State = 1693;
			switch ( Interpreter.AdaptivePredict(_input,134,_ctx) ) {
			case 1:
				{
				State = 1691; Match(NOT);
				State = 1692; Match(NULL);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Sqlj_object_typeContext : ParserRuleContext {
		public ITerminalNode EXTERNAL() { return GetToken(plsqlParser.EXTERNAL, 0); }
		public ITerminalNode CUSTOMDATUM() { return GetToken(plsqlParser.CUSTOMDATUM, 0); }
		public ITerminalNode NAME() { return GetToken(plsqlParser.NAME, 0); }
		public ITerminalNode LANGUAGE() { return GetToken(plsqlParser.LANGUAGE, 0); }
		public ITerminalNode JAVA() { return GetToken(plsqlParser.JAVA, 0); }
		public ITerminalNode USING() { return GetToken(plsqlParser.USING, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode SQLDATA() { return GetToken(plsqlParser.SQLDATA, 0); }
		public ITerminalNode ORADATA() { return GetToken(plsqlParser.ORADATA, 0); }
		public Sqlj_object_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sqlj_object_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSqlj_object_type(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSqlj_object_type(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSqlj_object_type(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Sqlj_object_typeContext sqlj_object_type() {
		Sqlj_object_typeContext _localctx = new Sqlj_object_typeContext(_ctx, State);
		EnterRule(_localctx, 124, RULE_sqlj_object_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1695; Match(EXTERNAL);
			State = 1696; Match(NAME);
			State = 1697; expression();
			State = 1698; Match(LANGUAGE);
			State = 1699; Match(JAVA);
			State = 1700; Match(USING);
			State = 1701;
			_la = _input.La(1);
			if ( !(_la==CUSTOMDATUM || _la==ORADATA || _la==SQLDATA) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Type_bodyContext : ParserRuleContext {
		public ITerminalNode IS() { return GetToken(plsqlParser.IS, 0); }
		public IReadOnlyList<Type_body_elementsContext> type_body_elements() {
			return GetRuleContexts<Type_body_elementsContext>();
		}
		public Type_nameContext type_name() {
			return GetRuleContext<Type_nameContext>(0);
		}
		public ITerminalNode END() { return GetToken(plsqlParser.END, 0); }
		public ITerminalNode BODY() { return GetToken(plsqlParser.BODY, 0); }
		public ITerminalNode AS() { return GetToken(plsqlParser.AS, 0); }
		public Type_body_elementsContext type_body_elements(int i) {
			return GetRuleContext<Type_body_elementsContext>(i);
		}
		public Type_bodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_body; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterType_body(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitType_body(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_body(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Type_bodyContext type_body() {
		Type_bodyContext _localctx = new Type_bodyContext(_ctx, State);
		EnterRule(_localctx, 126, RULE_type_body);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1703; Match(BODY);
			State = 1704; type_name();
			State = 1705;
			_la = _input.La(1);
			if ( !(_la==AS || _la==IS) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			State = 1707;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 1706; type_body_elements();
				}
				}
				State = 1709;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( ((((_la - 214)) & ~0x3f) == 0 && ((1L << (_la - 214)) & ((1L << (MAP - 214)) | (1L << (MEMBER - 214)) | (1L << (ORDER - 214)))) != 0) || _la==STATIC );
			State = 1711; Match(END);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Type_body_elementsContext : ParserRuleContext {
		public Map_order_func_declarationContext map_order_func_declaration() {
			return GetRuleContext<Map_order_func_declarationContext>(0);
		}
		public Subprog_decl_in_typeContext subprog_decl_in_type() {
			return GetRuleContext<Subprog_decl_in_typeContext>(0);
		}
		public Type_body_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_body_elements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterType_body_elements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitType_body_elements(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_body_elements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Type_body_elementsContext type_body_elements() {
		Type_body_elementsContext _localctx = new Type_body_elementsContext(_ctx, State);
		EnterRule(_localctx, 128, RULE_type_body_elements);
		try {
			State = 1715;
			switch (_input.La(1)) {
			case MAP:
			case ORDER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1713; map_order_func_declaration();
				}
				break;
			case MEMBER:
			case STATIC:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1714; subprog_decl_in_type();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Map_order_func_declarationContext : ParserRuleContext {
		public ITerminalNode MAP() { return GetToken(plsqlParser.MAP, 0); }
		public ITerminalNode ORDER() { return GetToken(plsqlParser.ORDER, 0); }
		public ITerminalNode MEMBER() { return GetToken(plsqlParser.MEMBER, 0); }
		public Func_decl_in_typeContext func_decl_in_type() {
			return GetRuleContext<Func_decl_in_typeContext>(0);
		}
		public Map_order_func_declarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_map_order_func_declaration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterMap_order_func_declaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitMap_order_func_declaration(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMap_order_func_declaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Map_order_func_declarationContext map_order_func_declaration() {
		Map_order_func_declarationContext _localctx = new Map_order_func_declarationContext(_ctx, State);
		EnterRule(_localctx, 130, RULE_map_order_func_declaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1717;
			_la = _input.La(1);
			if ( !(_la==MAP || _la==ORDER) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			State = 1718; Match(MEMBER);
			State = 1719; func_decl_in_type();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Subprog_decl_in_typeContext : ParserRuleContext {
		public ITerminalNode STATIC() { return GetToken(plsqlParser.STATIC, 0); }
		public Proc_decl_in_typeContext proc_decl_in_type() {
			return GetRuleContext<Proc_decl_in_typeContext>(0);
		}
		public ITerminalNode MEMBER() { return GetToken(plsqlParser.MEMBER, 0); }
		public Func_decl_in_typeContext func_decl_in_type() {
			return GetRuleContext<Func_decl_in_typeContext>(0);
		}
		public Constructor_declarationContext constructor_declaration() {
			return GetRuleContext<Constructor_declarationContext>(0);
		}
		public Subprog_decl_in_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subprog_decl_in_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSubprog_decl_in_type(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSubprog_decl_in_type(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubprog_decl_in_type(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Subprog_decl_in_typeContext subprog_decl_in_type() {
		Subprog_decl_in_typeContext _localctx = new Subprog_decl_in_typeContext(_ctx, State);
		EnterRule(_localctx, 132, RULE_subprog_decl_in_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1721;
			_la = _input.La(1);
			if ( !(_la==MEMBER || _la==STATIC) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			State = 1725;
			switch (_input.La(1)) {
			case PROCEDURE:
				{
				State = 1722; proc_decl_in_type();
				}
				break;
			case FUNCTION:
				{
				State = 1723; func_decl_in_type();
				}
				break;
			case CONSTRUCTOR:
			case FINAL:
			case INSTANTIABLE:
				{
				State = 1724; constructor_declaration();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Proc_decl_in_typeContext : ParserRuleContext {
		public IReadOnlyList<Declare_specContext> declare_spec() {
			return GetRuleContexts<Declare_specContext>();
		}
		public ITerminalNode IS() { return GetToken(plsqlParser.IS, 0); }
		public IReadOnlyList<Type_elements_parameterContext> type_elements_parameter() {
			return GetRuleContexts<Type_elements_parameterContext>();
		}
		public ITerminalNode DECLARE() { return GetToken(plsqlParser.DECLARE, 0); }
		public Call_specContext call_spec() {
			return GetRuleContext<Call_specContext>(0);
		}
		public ITerminalNode PROCEDURE() { return GetToken(plsqlParser.PROCEDURE, 0); }
		public Type_elements_parameterContext type_elements_parameter(int i) {
			return GetRuleContext<Type_elements_parameterContext>(i);
		}
		public Declare_specContext declare_spec(int i) {
			return GetRuleContext<Declare_specContext>(i);
		}
		public BodyContext body() {
			return GetRuleContext<BodyContext>(0);
		}
		public ITerminalNode AS() { return GetToken(plsqlParser.AS, 0); }
		public Procedure_nameContext procedure_name() {
			return GetRuleContext<Procedure_nameContext>(0);
		}
		public Proc_decl_in_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_proc_decl_in_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterProc_decl_in_type(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitProc_decl_in_type(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProc_decl_in_type(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Proc_decl_in_typeContext proc_decl_in_type() {
		Proc_decl_in_typeContext _localctx = new Proc_decl_in_typeContext(_ctx, State);
		EnterRule(_localctx, 134, RULE_proc_decl_in_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1727; Match(PROCEDURE);
			State = 1728; procedure_name();
			State = 1729; Match(LEFT_PAREN);
			State = 1730; type_elements_parameter();
			State = 1735;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 1731; Match(COMMA);
				State = 1732; type_elements_parameter();
				}
				}
				State = 1737;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 1738; Match(RIGHT_PAREN);
			State = 1739;
			_la = _input.La(1);
			if ( !(_la==AS || _la==IS) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			State = 1753;
			switch ( Interpreter.AdaptivePredict(_input,141,_ctx) ) {
			case 1:
				{
				State = 1740; call_spec();
				}
				break;

			case 2:
				{
				State = 1742;
				_la = _input.La(1);
				if (_la==DECLARE) {
					{
					State = 1741; Match(DECLARE);
					}
				}

				State = 1747;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (CONSTANT - 66)) | (1L << (CONSTRAINT - 66)) | (1L << (CONSTRAINTS - 66)) | (1L << (CONSTRUCTOR - 66)) | (1L << (CONTENT - 66)) | (1L << (CONTEXT - 66)) | (1L << (CONTINUE - 66)) | (1L << (CONVERT - 66)) | (1L << (CORRUPT_XID - 66)) | (1L << (CORRUPT_XID_ALL - 66)) | (1L << (COST - 66)) | (1L << (COUNT - 66)) | (1L << (CROSS - 66)) | (1L << (CUBE - 66)) | (1L << (CURRENT_USER - 66)) | (1L << (CURSOR - 66)) | (1L << (CUSTOMDATUM - 66)) | (1L << (CYCLE - 66)) | (1L << (DATA - 66)) | (1L << (DATABASE - 66)) | (1L << (DAY - 66)) | (1L << (DB_ROLE_CHANGE - 66)) | (1L << (DBTIMEZONE - 66)) | (1L << (DDL - 66)) | (1L << (DEBUG - 66)) | (1L << (DEC - 66)) | (1L << (DECIMAL - 66)) | (1L << (DECOMPOSE - 66)) | (1L << (DECREMENT - 66)) | (1L << (DEFAULTS - 66)) | (1L << (DEFERRED - 66)) | (1L << (DEFINER - 66)) | (1L << (DETERMINISTIC - 66)) | (1L << (DIMENSION - 66)) | (1L << (DISABLE - 66)) | (1L << (DISASSOCIATE - 66)) | (1L << (DOCUMENT - 66)) | (1L << (DOUBLE - 66)) | (1L << (DSINTERVAL_UNCONSTRAINED - 66)) | (1L << (EACH - 66)) | (1L << (ELEMENT - 66)) | (1L << (EMPTY - 66)) | (1L << (ENABLE - 66)) | (1L << (ENCODING - 66)) | (1L << (ENTITYESCAPING - 66)) | (1L << (ERR - 66)) | (1L << (ERRORS - 66)) | (1L << (ESCAPE - 66)) | (1L << (EVALNAME - 66)) | (1L << (EXCEPTION - 66)) | (1L << (EXCEPTION_INIT - 66)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)) | (1L << (EXIT - 130)) | (1L << (EXPLAIN - 130)) | (1L << (EXTERNAL - 130)) | (1L << (EXTRACT - 130)) | (1L << (FAILURE - 130)) | (1L << (FINAL - 130)) | (1L << (FIRST - 130)) | (1L << (FIRST_VALUE - 130)) | (1L << (FLOAT - 130)) | (1L << (FOLLOWING - 130)) | (1L << (FOLLOWS - 130)) | (1L << (FORALL - 130)) | (1L << (FORCE - 130)) | (1L << (FULL - 130)) | (1L << (FUNCTION - 130)) | (1L << (GROUPING - 130)) | (1L << (HASH - 130)) | (1L << (HIDE - 130)) | (1L << (HOUR - 130)) | (1L << (IGNORE - 130)) | (1L << (IMMEDIATE - 130)) | (1L << (INCLUDE - 130)) | (1L << (INCLUDING - 130)) | (1L << (INCREMENT - 130)) | (1L << (INDENT - 130)) | (1L << (INDEXED - 130)) | (1L << (INDICATOR - 130)) | (1L << (INDICES - 130)) | (1L << (INFINITE - 130)) | (1L << (INLINE - 130)) | (1L << (INNER - 130)) | (1L << (INOUT - 130)) | (1L << (INSTANTIABLE - 130)) | (1L << (INSTEAD - 130)) | (1L << (INT - 130)) | (1L << (INTEGER - 130)) | (1L << (INTERVAL - 130)) | (1L << (INVALIDATE - 130)) | (1L << (ISOLATION - 130)) | (1L << (ITERATE - 130)) | (1L << (JAVA - 130)) | (1L << (JOIN - 130)) | (1L << (KEEP - 130)) | (1L << (LANGUAGE - 130)))) != 0) || ((((_la - 194)) & ~0x3f) == 0 && ((1L << (_la - 194)) & ((1L << (LAST - 194)) | (1L << (LAST_VALUE - 194)) | (1L << (LEADING - 194)) | (1L << (LEFT - 194)) | (1L << (LEVEL - 194)) | (1L << (LIBRARY - 194)) | (1L << (LIKE2 - 194)) | (1L << (LIKE4 - 194)) | (1L << (LIKEC - 194)) | (1L << (LIMIT - 194)) | (1L << (LOCAL - 194)) | (1L << (LOCKED - 194)) | (1L << (LOG - 194)) | (1L << (LOGOFF - 194)) | (1L << (LOGON - 194)) | (1L << (LONG - 194)) | (1L << (LOOP - 194)) | (1L << (MAIN - 194)) | (1L << (MAP - 194)) | (1L << (MATCHED - 194)) | (1L << (MAXVALUE - 194)) | (1L << (MEASURES - 194)) | (1L << (MEMBER - 194)) | (1L << (MERGE - 194)) | (1L << (MINUTE - 194)) | (1L << (MINVALUE - 194)) | (1L << (MLSLABEL - 194)) | (1L << (MODEL - 194)) | (1L << (MODIFY - 194)) | (1L << (MONTH - 194)) | (1L << (MULTISET - 194)) | (1L << (NAME - 194)) | (1L << (NAN - 194)) | (1L << (NATURAL - 194)) | (1L << (NATURALN - 194)) | (1L << (NAV - 194)) | (1L << (NCHAR - 194)) | (1L << (NCHAR_CS - 194)) | (1L << (NCLOB - 194)) | (1L << (NESTED - 194)) | (1L << (NEW - 194)) | (1L << (NO - 194)) | (1L << (NOAUDIT - 194)) | (1L << (NOCOPY - 194)) | (1L << (NOCYCLE - 194)) | (1L << (NOENTITYESCAPING - 194)) | (1L << (NONE - 194)) | (1L << (NOSCHEMACHECK - 194)) | (1L << (NULLS - 194)) | (1L << (NUMBER - 194)) | (1L << (NUMERIC - 194)) | (1L << (NVARCHAR2 - 194)) | (1L << (OBJECT - 194)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (OFF - 259)) | (1L << (OID - 259)) | (1L << (OLD - 259)) | (1L << (ONLY - 259)) | (1L << (OPEN - 259)) | (1L << (ORADATA - 259)) | (1L << (ORDINALITY - 259)) | (1L << (OSERROR - 259)) | (1L << (OUT - 259)) | (1L << (OUTER - 259)) | (1L << (OVER - 259)) | (1L << (OVERRIDING - 259)) | (1L << (PACKAGE - 259)) | (1L << (PARALLEL_ENABLE - 259)) | (1L << (PARAMETERS - 259)) | (1L << (PARENT - 259)) | (1L << (PARTITION - 259)) | (1L << (PASSING - 259)) | (1L << (PATH - 259)) | (1L << (PIPELINED - 259)) | (1L << (PLAN - 259)) | (1L << (PLS_INTEGER - 259)) | (1L << (POSITIVE - 259)) | (1L << (POSITIVEN - 259)) | (1L << (PRAGMA - 259)) | (1L << (PRECEDING - 259)) | (1L << (PRECISION - 259)) | (1L << (PRESENT - 259)) | (1L << (PROCEDURE - 259)) | (1L << (RAISE - 259)) | (1L << (RANGE - 259)) | (1L << (RAW - 259)) | (1L << (READ - 259)) | (1L << (REAL - 259)) | (1L << (RECORD - 259)) | (1L << (REF - 259)) | (1L << (REFERENCE - 259)) | (1L << (REFERENCING - 259)) | (1L << (REJECT - 259)) | (1L << (RELIES_ON - 259)) | (1L << (RENAME - 259)) | (1L << (REPLACE - 259)) | (1L << (RESPECT - 259)) | (1L << (RESTRICT_REFERENCES - 259)) | (1L << (RESULT - 259)) | (1L << (RESULT_CACHE - 259)) | (1L << (RETURN - 259)) | (1L << (RETURNING - 259)) | (1L << (REUSE - 259)) | (1L << (REVERSE - 259)) | (1L << (RIGHT - 259)))) != 0) || ((((_la - 323)) & ~0x3f) == 0 && ((1L << (_la - 323)) & ((1L << (ROLLBACK - 323)) | (1L << (ROLLUP - 323)) | (1L << (ROW - 323)) | (1L << (ROWID - 323)) | (1L << (ROWS - 323)) | (1L << (RULES - 323)) | (1L << (SAMPLE - 323)) | (1L << (SAVE - 323)) | (1L << (SAVEPOINT - 323)) | (1L << (SCHEMA - 323)) | (1L << (SCHEMACHECK - 323)) | (1L << (SCN - 323)) | (1L << (SECOND - 323)) | (1L << (SEED - 323)) | (1L << (SEGMENT - 323)) | (1L << (SELF - 323)) | (1L << (SEQUENTIAL - 323)) | (1L << (SERIALIZABLE - 323)) | (1L << (SERIALLY_REUSABLE - 323)) | (1L << (SERVERERROR - 323)) | (1L << (SESSIONTIMEZONE - 323)) | (1L << (SET - 323)) | (1L << (SETS - 323)) | (1L << (SETTINGS - 323)) | (1L << (SHOW - 323)) | (1L << (SHUTDOWN - 323)) | (1L << (SIBLINGS - 323)) | (1L << (SIGNTYPE - 323)) | (1L << (SIMPLE_INTEGER - 323)) | (1L << (SINGLE - 323)) | (1L << (SKIP_ - 323)) | (1L << (SMALLINT - 323)) | (1L << (SNAPSHOT - 323)) | (1L << (SOME - 323)) | (1L << (SPECIFICATION - 323)) | (1L << (SQLDATA - 323)) | (1L << (SQLERROR - 323)) | (1L << (STANDALONE - 323)) | (1L << (STARTUP - 323)) | (1L << (STATEMENT - 323)) | (1L << (STATEMENT_ID - 323)) | (1L << (STATIC - 323)) | (1L << (STATISTICS - 323)) | (1L << (STRING - 323)) | (1L << (SUBMULTISET - 323)) | (1L << (SUBPARTITION - 323)) | (1L << (SUBSTITUTABLE - 323)) | (1L << (SUBTYPE - 323)) | (1L << (SUCCESS - 323)) | (1L << (SUSPEND - 323)) | (1L << (TIME - 323)) | (1L << (TIMESTAMP - 323)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_UNCONSTRAINED - 323)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TIMEZONE_ABBR - 387)) | (1L << (TIMEZONE_HOUR - 387)) | (1L << (TIMEZONE_MINUTE - 387)) | (1L << (TIMEZONE_REGION - 387)) | (1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (YMINTERVAL_UNCONSTRAINED - 451)) | (1L << (ZONE - 451)) | (1L << (PREDICTION - 451)) | (1L << (PREDICTION_BOUNDS - 451)) | (1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (COVAR_ - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (REGR_ - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (TRIM - 451)) | (1L << (SUM - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (VARIANCE - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
					{
					{
					State = 1744; declare_spec();
					}
					}
					State = 1749;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 1750; body();
				State = 1751; Match(SEMICOLON);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Func_decl_in_typeContext : ParserRuleContext {
		public IReadOnlyList<Declare_specContext> declare_spec() {
			return GetRuleContexts<Declare_specContext>();
		}
		public IReadOnlyList<Type_elements_parameterContext> type_elements_parameter() {
			return GetRuleContexts<Type_elements_parameterContext>();
		}
		public ITerminalNode DECLARE() { return GetToken(plsqlParser.DECLARE, 0); }
		public Call_specContext call_spec() {
			return GetRuleContext<Call_specContext>(0);
		}
		public Type_elements_parameterContext type_elements_parameter(int i) {
			return GetRuleContext<Type_elements_parameterContext>(i);
		}
		public Declare_specContext declare_spec(int i) {
			return GetRuleContext<Declare_specContext>(i);
		}
		public ITerminalNode AS() { return GetToken(plsqlParser.AS, 0); }
		public Function_nameContext function_name() {
			return GetRuleContext<Function_nameContext>(0);
		}
		public ITerminalNode FUNCTION() { return GetToken(plsqlParser.FUNCTION, 0); }
		public ITerminalNode RETURN() { return GetToken(plsqlParser.RETURN, 0); }
		public ITerminalNode IS() { return GetToken(plsqlParser.IS, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public BodyContext body() {
			return GetRuleContext<BodyContext>(0);
		}
		public Func_decl_in_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_func_decl_in_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterFunc_decl_in_type(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitFunc_decl_in_type(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunc_decl_in_type(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Func_decl_in_typeContext func_decl_in_type() {
		Func_decl_in_typeContext _localctx = new Func_decl_in_typeContext(_ctx, State);
		EnterRule(_localctx, 136, RULE_func_decl_in_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1755; Match(FUNCTION);
			State = 1756; function_name();
			State = 1768;
			_la = _input.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 1757; Match(LEFT_PAREN);
				State = 1758; type_elements_parameter();
				State = 1763;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 1759; Match(COMMA);
					State = 1760; type_elements_parameter();
					}
					}
					State = 1765;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 1766; Match(RIGHT_PAREN);
				}
			}

			State = 1770; Match(RETURN);
			State = 1771; type_spec();
			State = 1772;
			_la = _input.La(1);
			if ( !(_la==AS || _la==IS) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			State = 1786;
			switch ( Interpreter.AdaptivePredict(_input,146,_ctx) ) {
			case 1:
				{
				State = 1773; call_spec();
				}
				break;

			case 2:
				{
				State = 1775;
				_la = _input.La(1);
				if (_la==DECLARE) {
					{
					State = 1774; Match(DECLARE);
					}
				}

				State = 1780;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (CONSTANT - 66)) | (1L << (CONSTRAINT - 66)) | (1L << (CONSTRAINTS - 66)) | (1L << (CONSTRUCTOR - 66)) | (1L << (CONTENT - 66)) | (1L << (CONTEXT - 66)) | (1L << (CONTINUE - 66)) | (1L << (CONVERT - 66)) | (1L << (CORRUPT_XID - 66)) | (1L << (CORRUPT_XID_ALL - 66)) | (1L << (COST - 66)) | (1L << (COUNT - 66)) | (1L << (CROSS - 66)) | (1L << (CUBE - 66)) | (1L << (CURRENT_USER - 66)) | (1L << (CURSOR - 66)) | (1L << (CUSTOMDATUM - 66)) | (1L << (CYCLE - 66)) | (1L << (DATA - 66)) | (1L << (DATABASE - 66)) | (1L << (DAY - 66)) | (1L << (DB_ROLE_CHANGE - 66)) | (1L << (DBTIMEZONE - 66)) | (1L << (DDL - 66)) | (1L << (DEBUG - 66)) | (1L << (DEC - 66)) | (1L << (DECIMAL - 66)) | (1L << (DECOMPOSE - 66)) | (1L << (DECREMENT - 66)) | (1L << (DEFAULTS - 66)) | (1L << (DEFERRED - 66)) | (1L << (DEFINER - 66)) | (1L << (DETERMINISTIC - 66)) | (1L << (DIMENSION - 66)) | (1L << (DISABLE - 66)) | (1L << (DISASSOCIATE - 66)) | (1L << (DOCUMENT - 66)) | (1L << (DOUBLE - 66)) | (1L << (DSINTERVAL_UNCONSTRAINED - 66)) | (1L << (EACH - 66)) | (1L << (ELEMENT - 66)) | (1L << (EMPTY - 66)) | (1L << (ENABLE - 66)) | (1L << (ENCODING - 66)) | (1L << (ENTITYESCAPING - 66)) | (1L << (ERR - 66)) | (1L << (ERRORS - 66)) | (1L << (ESCAPE - 66)) | (1L << (EVALNAME - 66)) | (1L << (EXCEPTION - 66)) | (1L << (EXCEPTION_INIT - 66)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)) | (1L << (EXIT - 130)) | (1L << (EXPLAIN - 130)) | (1L << (EXTERNAL - 130)) | (1L << (EXTRACT - 130)) | (1L << (FAILURE - 130)) | (1L << (FINAL - 130)) | (1L << (FIRST - 130)) | (1L << (FIRST_VALUE - 130)) | (1L << (FLOAT - 130)) | (1L << (FOLLOWING - 130)) | (1L << (FOLLOWS - 130)) | (1L << (FORALL - 130)) | (1L << (FORCE - 130)) | (1L << (FULL - 130)) | (1L << (FUNCTION - 130)) | (1L << (GROUPING - 130)) | (1L << (HASH - 130)) | (1L << (HIDE - 130)) | (1L << (HOUR - 130)) | (1L << (IGNORE - 130)) | (1L << (IMMEDIATE - 130)) | (1L << (INCLUDE - 130)) | (1L << (INCLUDING - 130)) | (1L << (INCREMENT - 130)) | (1L << (INDENT - 130)) | (1L << (INDEXED - 130)) | (1L << (INDICATOR - 130)) | (1L << (INDICES - 130)) | (1L << (INFINITE - 130)) | (1L << (INLINE - 130)) | (1L << (INNER - 130)) | (1L << (INOUT - 130)) | (1L << (INSTANTIABLE - 130)) | (1L << (INSTEAD - 130)) | (1L << (INT - 130)) | (1L << (INTEGER - 130)) | (1L << (INTERVAL - 130)) | (1L << (INVALIDATE - 130)) | (1L << (ISOLATION - 130)) | (1L << (ITERATE - 130)) | (1L << (JAVA - 130)) | (1L << (JOIN - 130)) | (1L << (KEEP - 130)) | (1L << (LANGUAGE - 130)))) != 0) || ((((_la - 194)) & ~0x3f) == 0 && ((1L << (_la - 194)) & ((1L << (LAST - 194)) | (1L << (LAST_VALUE - 194)) | (1L << (LEADING - 194)) | (1L << (LEFT - 194)) | (1L << (LEVEL - 194)) | (1L << (LIBRARY - 194)) | (1L << (LIKE2 - 194)) | (1L << (LIKE4 - 194)) | (1L << (LIKEC - 194)) | (1L << (LIMIT - 194)) | (1L << (LOCAL - 194)) | (1L << (LOCKED - 194)) | (1L << (LOG - 194)) | (1L << (LOGOFF - 194)) | (1L << (LOGON - 194)) | (1L << (LONG - 194)) | (1L << (LOOP - 194)) | (1L << (MAIN - 194)) | (1L << (MAP - 194)) | (1L << (MATCHED - 194)) | (1L << (MAXVALUE - 194)) | (1L << (MEASURES - 194)) | (1L << (MEMBER - 194)) | (1L << (MERGE - 194)) | (1L << (MINUTE - 194)) | (1L << (MINVALUE - 194)) | (1L << (MLSLABEL - 194)) | (1L << (MODEL - 194)) | (1L << (MODIFY - 194)) | (1L << (MONTH - 194)) | (1L << (MULTISET - 194)) | (1L << (NAME - 194)) | (1L << (NAN - 194)) | (1L << (NATURAL - 194)) | (1L << (NATURALN - 194)) | (1L << (NAV - 194)) | (1L << (NCHAR - 194)) | (1L << (NCHAR_CS - 194)) | (1L << (NCLOB - 194)) | (1L << (NESTED - 194)) | (1L << (NEW - 194)) | (1L << (NO - 194)) | (1L << (NOAUDIT - 194)) | (1L << (NOCOPY - 194)) | (1L << (NOCYCLE - 194)) | (1L << (NOENTITYESCAPING - 194)) | (1L << (NONE - 194)) | (1L << (NOSCHEMACHECK - 194)) | (1L << (NULLS - 194)) | (1L << (NUMBER - 194)) | (1L << (NUMERIC - 194)) | (1L << (NVARCHAR2 - 194)) | (1L << (OBJECT - 194)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (OFF - 259)) | (1L << (OID - 259)) | (1L << (OLD - 259)) | (1L << (ONLY - 259)) | (1L << (OPEN - 259)) | (1L << (ORADATA - 259)) | (1L << (ORDINALITY - 259)) | (1L << (OSERROR - 259)) | (1L << (OUT - 259)) | (1L << (OUTER - 259)) | (1L << (OVER - 259)) | (1L << (OVERRIDING - 259)) | (1L << (PACKAGE - 259)) | (1L << (PARALLEL_ENABLE - 259)) | (1L << (PARAMETERS - 259)) | (1L << (PARENT - 259)) | (1L << (PARTITION - 259)) | (1L << (PASSING - 259)) | (1L << (PATH - 259)) | (1L << (PIPELINED - 259)) | (1L << (PLAN - 259)) | (1L << (PLS_INTEGER - 259)) | (1L << (POSITIVE - 259)) | (1L << (POSITIVEN - 259)) | (1L << (PRAGMA - 259)) | (1L << (PRECEDING - 259)) | (1L << (PRECISION - 259)) | (1L << (PRESENT - 259)) | (1L << (PROCEDURE - 259)) | (1L << (RAISE - 259)) | (1L << (RANGE - 259)) | (1L << (RAW - 259)) | (1L << (READ - 259)) | (1L << (REAL - 259)) | (1L << (RECORD - 259)) | (1L << (REF - 259)) | (1L << (REFERENCE - 259)) | (1L << (REFERENCING - 259)) | (1L << (REJECT - 259)) | (1L << (RELIES_ON - 259)) | (1L << (RENAME - 259)) | (1L << (REPLACE - 259)) | (1L << (RESPECT - 259)) | (1L << (RESTRICT_REFERENCES - 259)) | (1L << (RESULT - 259)) | (1L << (RESULT_CACHE - 259)) | (1L << (RETURN - 259)) | (1L << (RETURNING - 259)) | (1L << (REUSE - 259)) | (1L << (REVERSE - 259)) | (1L << (RIGHT - 259)))) != 0) || ((((_la - 323)) & ~0x3f) == 0 && ((1L << (_la - 323)) & ((1L << (ROLLBACK - 323)) | (1L << (ROLLUP - 323)) | (1L << (ROW - 323)) | (1L << (ROWID - 323)) | (1L << (ROWS - 323)) | (1L << (RULES - 323)) | (1L << (SAMPLE - 323)) | (1L << (SAVE - 323)) | (1L << (SAVEPOINT - 323)) | (1L << (SCHEMA - 323)) | (1L << (SCHEMACHECK - 323)) | (1L << (SCN - 323)) | (1L << (SECOND - 323)) | (1L << (SEED - 323)) | (1L << (SEGMENT - 323)) | (1L << (SELF - 323)) | (1L << (SEQUENTIAL - 323)) | (1L << (SERIALIZABLE - 323)) | (1L << (SERIALLY_REUSABLE - 323)) | (1L << (SERVERERROR - 323)) | (1L << (SESSIONTIMEZONE - 323)) | (1L << (SET - 323)) | (1L << (SETS - 323)) | (1L << (SETTINGS - 323)) | (1L << (SHOW - 323)) | (1L << (SHUTDOWN - 323)) | (1L << (SIBLINGS - 323)) | (1L << (SIGNTYPE - 323)) | (1L << (SIMPLE_INTEGER - 323)) | (1L << (SINGLE - 323)) | (1L << (SKIP_ - 323)) | (1L << (SMALLINT - 323)) | (1L << (SNAPSHOT - 323)) | (1L << (SOME - 323)) | (1L << (SPECIFICATION - 323)) | (1L << (SQLDATA - 323)) | (1L << (SQLERROR - 323)) | (1L << (STANDALONE - 323)) | (1L << (STARTUP - 323)) | (1L << (STATEMENT - 323)) | (1L << (STATEMENT_ID - 323)) | (1L << (STATIC - 323)) | (1L << (STATISTICS - 323)) | (1L << (STRING - 323)) | (1L << (SUBMULTISET - 323)) | (1L << (SUBPARTITION - 323)) | (1L << (SUBSTITUTABLE - 323)) | (1L << (SUBTYPE - 323)) | (1L << (SUCCESS - 323)) | (1L << (SUSPEND - 323)) | (1L << (TIME - 323)) | (1L << (TIMESTAMP - 323)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_UNCONSTRAINED - 323)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TIMEZONE_ABBR - 387)) | (1L << (TIMEZONE_HOUR - 387)) | (1L << (TIMEZONE_MINUTE - 387)) | (1L << (TIMEZONE_REGION - 387)) | (1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (YMINTERVAL_UNCONSTRAINED - 451)) | (1L << (ZONE - 451)) | (1L << (PREDICTION - 451)) | (1L << (PREDICTION_BOUNDS - 451)) | (1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (COVAR_ - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (REGR_ - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (TRIM - 451)) | (1L << (SUM - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (VARIANCE - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
					{
					{
					State = 1777; declare_spec();
					}
					}
					State = 1782;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 1783; body();
				State = 1784; Match(SEMICOLON);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Constructor_declarationContext : ParserRuleContext {
		public IReadOnlyList<Declare_specContext> declare_spec() {
			return GetRuleContexts<Declare_specContext>();
		}
		public IReadOnlyList<ITerminalNode> SELF() { return GetTokens(plsqlParser.SELF); }
		public ITerminalNode AS(int i) {
			return GetToken(plsqlParser.AS, i);
		}
		public IReadOnlyList<Type_elements_parameterContext> type_elements_parameter() {
			return GetRuleContexts<Type_elements_parameterContext>();
		}
		public ITerminalNode DECLARE() { return GetToken(plsqlParser.DECLARE, 0); }
		public Type_specContext type_spec(int i) {
			return GetRuleContext<Type_specContext>(i);
		}
		public Call_specContext call_spec() {
			return GetRuleContext<Call_specContext>(0);
		}
		public Type_elements_parameterContext type_elements_parameter(int i) {
			return GetRuleContext<Type_elements_parameterContext>(i);
		}
		public Declare_specContext declare_spec(int i) {
			return GetRuleContext<Declare_specContext>(i);
		}
		public ITerminalNode INSTANTIABLE() { return GetToken(plsqlParser.INSTANTIABLE, 0); }
		public ITerminalNode CONSTRUCTOR() { return GetToken(plsqlParser.CONSTRUCTOR, 0); }
		public IReadOnlyList<ITerminalNode> AS() { return GetTokens(plsqlParser.AS); }
		public ITerminalNode IN() { return GetToken(plsqlParser.IN, 0); }
		public ITerminalNode FUNCTION() { return GetToken(plsqlParser.FUNCTION, 0); }
		public ITerminalNode RETURN() { return GetToken(plsqlParser.RETURN, 0); }
		public ITerminalNode FINAL() { return GetToken(plsqlParser.FINAL, 0); }
		public ITerminalNode IS() { return GetToken(plsqlParser.IS, 0); }
		public IReadOnlyList<Type_specContext> type_spec() {
			return GetRuleContexts<Type_specContext>();
		}
		public ITerminalNode SELF(int i) {
			return GetToken(plsqlParser.SELF, i);
		}
		public BodyContext body() {
			return GetRuleContext<BodyContext>(0);
		}
		public ITerminalNode RESULT() { return GetToken(plsqlParser.RESULT, 0); }
		public ITerminalNode OUT() { return GetToken(plsqlParser.OUT, 0); }
		public Constructor_declarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constructor_declaration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterConstructor_declaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitConstructor_declaration(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstructor_declaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Constructor_declarationContext constructor_declaration() {
		Constructor_declarationContext _localctx = new Constructor_declarationContext(_ctx, State);
		EnterRule(_localctx, 138, RULE_constructor_declaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1789;
			_la = _input.La(1);
			if (_la==FINAL) {
				{
				State = 1788; Match(FINAL);
				}
			}

			State = 1792;
			_la = _input.La(1);
			if (_la==INSTANTIABLE) {
				{
				State = 1791; Match(INSTANTIABLE);
				}
			}

			State = 1794; Match(CONSTRUCTOR);
			State = 1795; Match(FUNCTION);
			State = 1796; type_spec();
			State = 1814;
			_la = _input.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 1797; Match(LEFT_PAREN);
				{
				State = 1798; Match(SELF);
				State = 1799; Match(IN);
				State = 1800; Match(OUT);
				State = 1801; type_spec();
				State = 1802; Match(COMMA);
				}
				State = 1804; type_elements_parameter();
				State = 1809;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 1805; Match(COMMA);
					State = 1806; type_elements_parameter();
					}
					}
					State = 1811;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 1812; Match(RIGHT_PAREN);
				}
			}

			State = 1816; Match(RETURN);
			State = 1817; Match(SELF);
			State = 1818; Match(AS);
			State = 1819; Match(RESULT);
			State = 1820;
			_la = _input.La(1);
			if ( !(_la==AS || _la==IS) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			State = 1834;
			switch ( Interpreter.AdaptivePredict(_input,153,_ctx) ) {
			case 1:
				{
				State = 1821; call_spec();
				}
				break;

			case 2:
				{
				State = 1823;
				_la = _input.La(1);
				if (_la==DECLARE) {
					{
					State = 1822; Match(DECLARE);
					}
				}

				State = 1828;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (CONSTANT - 66)) | (1L << (CONSTRAINT - 66)) | (1L << (CONSTRAINTS - 66)) | (1L << (CONSTRUCTOR - 66)) | (1L << (CONTENT - 66)) | (1L << (CONTEXT - 66)) | (1L << (CONTINUE - 66)) | (1L << (CONVERT - 66)) | (1L << (CORRUPT_XID - 66)) | (1L << (CORRUPT_XID_ALL - 66)) | (1L << (COST - 66)) | (1L << (COUNT - 66)) | (1L << (CROSS - 66)) | (1L << (CUBE - 66)) | (1L << (CURRENT_USER - 66)) | (1L << (CURSOR - 66)) | (1L << (CUSTOMDATUM - 66)) | (1L << (CYCLE - 66)) | (1L << (DATA - 66)) | (1L << (DATABASE - 66)) | (1L << (DAY - 66)) | (1L << (DB_ROLE_CHANGE - 66)) | (1L << (DBTIMEZONE - 66)) | (1L << (DDL - 66)) | (1L << (DEBUG - 66)) | (1L << (DEC - 66)) | (1L << (DECIMAL - 66)) | (1L << (DECOMPOSE - 66)) | (1L << (DECREMENT - 66)) | (1L << (DEFAULTS - 66)) | (1L << (DEFERRED - 66)) | (1L << (DEFINER - 66)) | (1L << (DETERMINISTIC - 66)) | (1L << (DIMENSION - 66)) | (1L << (DISABLE - 66)) | (1L << (DISASSOCIATE - 66)) | (1L << (DOCUMENT - 66)) | (1L << (DOUBLE - 66)) | (1L << (DSINTERVAL_UNCONSTRAINED - 66)) | (1L << (EACH - 66)) | (1L << (ELEMENT - 66)) | (1L << (EMPTY - 66)) | (1L << (ENABLE - 66)) | (1L << (ENCODING - 66)) | (1L << (ENTITYESCAPING - 66)) | (1L << (ERR - 66)) | (1L << (ERRORS - 66)) | (1L << (ESCAPE - 66)) | (1L << (EVALNAME - 66)) | (1L << (EXCEPTION - 66)) | (1L << (EXCEPTION_INIT - 66)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)) | (1L << (EXIT - 130)) | (1L << (EXPLAIN - 130)) | (1L << (EXTERNAL - 130)) | (1L << (EXTRACT - 130)) | (1L << (FAILURE - 130)) | (1L << (FINAL - 130)) | (1L << (FIRST - 130)) | (1L << (FIRST_VALUE - 130)) | (1L << (FLOAT - 130)) | (1L << (FOLLOWING - 130)) | (1L << (FOLLOWS - 130)) | (1L << (FORALL - 130)) | (1L << (FORCE - 130)) | (1L << (FULL - 130)) | (1L << (FUNCTION - 130)) | (1L << (GROUPING - 130)) | (1L << (HASH - 130)) | (1L << (HIDE - 130)) | (1L << (HOUR - 130)) | (1L << (IGNORE - 130)) | (1L << (IMMEDIATE - 130)) | (1L << (INCLUDE - 130)) | (1L << (INCLUDING - 130)) | (1L << (INCREMENT - 130)) | (1L << (INDENT - 130)) | (1L << (INDEXED - 130)) | (1L << (INDICATOR - 130)) | (1L << (INDICES - 130)) | (1L << (INFINITE - 130)) | (1L << (INLINE - 130)) | (1L << (INNER - 130)) | (1L << (INOUT - 130)) | (1L << (INSTANTIABLE - 130)) | (1L << (INSTEAD - 130)) | (1L << (INT - 130)) | (1L << (INTEGER - 130)) | (1L << (INTERVAL - 130)) | (1L << (INVALIDATE - 130)) | (1L << (ISOLATION - 130)) | (1L << (ITERATE - 130)) | (1L << (JAVA - 130)) | (1L << (JOIN - 130)) | (1L << (KEEP - 130)) | (1L << (LANGUAGE - 130)))) != 0) || ((((_la - 194)) & ~0x3f) == 0 && ((1L << (_la - 194)) & ((1L << (LAST - 194)) | (1L << (LAST_VALUE - 194)) | (1L << (LEADING - 194)) | (1L << (LEFT - 194)) | (1L << (LEVEL - 194)) | (1L << (LIBRARY - 194)) | (1L << (LIKE2 - 194)) | (1L << (LIKE4 - 194)) | (1L << (LIKEC - 194)) | (1L << (LIMIT - 194)) | (1L << (LOCAL - 194)) | (1L << (LOCKED - 194)) | (1L << (LOG - 194)) | (1L << (LOGOFF - 194)) | (1L << (LOGON - 194)) | (1L << (LONG - 194)) | (1L << (LOOP - 194)) | (1L << (MAIN - 194)) | (1L << (MAP - 194)) | (1L << (MATCHED - 194)) | (1L << (MAXVALUE - 194)) | (1L << (MEASURES - 194)) | (1L << (MEMBER - 194)) | (1L << (MERGE - 194)) | (1L << (MINUTE - 194)) | (1L << (MINVALUE - 194)) | (1L << (MLSLABEL - 194)) | (1L << (MODEL - 194)) | (1L << (MODIFY - 194)) | (1L << (MONTH - 194)) | (1L << (MULTISET - 194)) | (1L << (NAME - 194)) | (1L << (NAN - 194)) | (1L << (NATURAL - 194)) | (1L << (NATURALN - 194)) | (1L << (NAV - 194)) | (1L << (NCHAR - 194)) | (1L << (NCHAR_CS - 194)) | (1L << (NCLOB - 194)) | (1L << (NESTED - 194)) | (1L << (NEW - 194)) | (1L << (NO - 194)) | (1L << (NOAUDIT - 194)) | (1L << (NOCOPY - 194)) | (1L << (NOCYCLE - 194)) | (1L << (NOENTITYESCAPING - 194)) | (1L << (NONE - 194)) | (1L << (NOSCHEMACHECK - 194)) | (1L << (NULLS - 194)) | (1L << (NUMBER - 194)) | (1L << (NUMERIC - 194)) | (1L << (NVARCHAR2 - 194)) | (1L << (OBJECT - 194)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (OFF - 259)) | (1L << (OID - 259)) | (1L << (OLD - 259)) | (1L << (ONLY - 259)) | (1L << (OPEN - 259)) | (1L << (ORADATA - 259)) | (1L << (ORDINALITY - 259)) | (1L << (OSERROR - 259)) | (1L << (OUT - 259)) | (1L << (OUTER - 259)) | (1L << (OVER - 259)) | (1L << (OVERRIDING - 259)) | (1L << (PACKAGE - 259)) | (1L << (PARALLEL_ENABLE - 259)) | (1L << (PARAMETERS - 259)) | (1L << (PARENT - 259)) | (1L << (PARTITION - 259)) | (1L << (PASSING - 259)) | (1L << (PATH - 259)) | (1L << (PIPELINED - 259)) | (1L << (PLAN - 259)) | (1L << (PLS_INTEGER - 259)) | (1L << (POSITIVE - 259)) | (1L << (POSITIVEN - 259)) | (1L << (PRAGMA - 259)) | (1L << (PRECEDING - 259)) | (1L << (PRECISION - 259)) | (1L << (PRESENT - 259)) | (1L << (PROCEDURE - 259)) | (1L << (RAISE - 259)) | (1L << (RANGE - 259)) | (1L << (RAW - 259)) | (1L << (READ - 259)) | (1L << (REAL - 259)) | (1L << (RECORD - 259)) | (1L << (REF - 259)) | (1L << (REFERENCE - 259)) | (1L << (REFERENCING - 259)) | (1L << (REJECT - 259)) | (1L << (RELIES_ON - 259)) | (1L << (RENAME - 259)) | (1L << (REPLACE - 259)) | (1L << (RESPECT - 259)) | (1L << (RESTRICT_REFERENCES - 259)) | (1L << (RESULT - 259)) | (1L << (RESULT_CACHE - 259)) | (1L << (RETURN - 259)) | (1L << (RETURNING - 259)) | (1L << (REUSE - 259)) | (1L << (REVERSE - 259)) | (1L << (RIGHT - 259)))) != 0) || ((((_la - 323)) & ~0x3f) == 0 && ((1L << (_la - 323)) & ((1L << (ROLLBACK - 323)) | (1L << (ROLLUP - 323)) | (1L << (ROW - 323)) | (1L << (ROWID - 323)) | (1L << (ROWS - 323)) | (1L << (RULES - 323)) | (1L << (SAMPLE - 323)) | (1L << (SAVE - 323)) | (1L << (SAVEPOINT - 323)) | (1L << (SCHEMA - 323)) | (1L << (SCHEMACHECK - 323)) | (1L << (SCN - 323)) | (1L << (SECOND - 323)) | (1L << (SEED - 323)) | (1L << (SEGMENT - 323)) | (1L << (SELF - 323)) | (1L << (SEQUENTIAL - 323)) | (1L << (SERIALIZABLE - 323)) | (1L << (SERIALLY_REUSABLE - 323)) | (1L << (SERVERERROR - 323)) | (1L << (SESSIONTIMEZONE - 323)) | (1L << (SET - 323)) | (1L << (SETS - 323)) | (1L << (SETTINGS - 323)) | (1L << (SHOW - 323)) | (1L << (SHUTDOWN - 323)) | (1L << (SIBLINGS - 323)) | (1L << (SIGNTYPE - 323)) | (1L << (SIMPLE_INTEGER - 323)) | (1L << (SINGLE - 323)) | (1L << (SKIP_ - 323)) | (1L << (SMALLINT - 323)) | (1L << (SNAPSHOT - 323)) | (1L << (SOME - 323)) | (1L << (SPECIFICATION - 323)) | (1L << (SQLDATA - 323)) | (1L << (SQLERROR - 323)) | (1L << (STANDALONE - 323)) | (1L << (STARTUP - 323)) | (1L << (STATEMENT - 323)) | (1L << (STATEMENT_ID - 323)) | (1L << (STATIC - 323)) | (1L << (STATISTICS - 323)) | (1L << (STRING - 323)) | (1L << (SUBMULTISET - 323)) | (1L << (SUBPARTITION - 323)) | (1L << (SUBSTITUTABLE - 323)) | (1L << (SUBTYPE - 323)) | (1L << (SUCCESS - 323)) | (1L << (SUSPEND - 323)) | (1L << (TIME - 323)) | (1L << (TIMESTAMP - 323)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_UNCONSTRAINED - 323)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TIMEZONE_ABBR - 387)) | (1L << (TIMEZONE_HOUR - 387)) | (1L << (TIMEZONE_MINUTE - 387)) | (1L << (TIMEZONE_REGION - 387)) | (1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (YMINTERVAL_UNCONSTRAINED - 451)) | (1L << (ZONE - 451)) | (1L << (PREDICTION - 451)) | (1L << (PREDICTION_BOUNDS - 451)) | (1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (COVAR_ - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (REGR_ - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (TRIM - 451)) | (1L << (SUM - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (VARIANCE - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
					{
					{
					State = 1825; declare_spec();
					}
					}
					State = 1830;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 1831; body();
				State = 1832; Match(SEMICOLON);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Modifier_clauseContext : ParserRuleContext {
		public ITerminalNode NOT() { return GetToken(plsqlParser.NOT, 0); }
		public ITerminalNode FINAL() { return GetToken(plsqlParser.FINAL, 0); }
		public ITerminalNode OVERRIDING() { return GetToken(plsqlParser.OVERRIDING, 0); }
		public ITerminalNode INSTANTIABLE() { return GetToken(plsqlParser.INSTANTIABLE, 0); }
		public Modifier_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_modifier_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterModifier_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitModifier_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModifier_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Modifier_clauseContext modifier_clause() {
		Modifier_clauseContext _localctx = new Modifier_clauseContext(_ctx, State);
		EnterRule(_localctx, 140, RULE_modifier_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1837;
			_la = _input.La(1);
			if (_la==NOT) {
				{
				State = 1836; Match(NOT);
				}
			}

			State = 1839;
			_la = _input.La(1);
			if ( !(_la==FINAL || _la==INSTANTIABLE || _la==OVERRIDING) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Object_member_specContext : ParserRuleContext {
		public Element_specContext element_spec() {
			return GetRuleContext<Element_specContext>(0);
		}
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Sqlj_object_type_attrContext sqlj_object_type_attr() {
			return GetRuleContext<Sqlj_object_type_attrContext>(0);
		}
		public Object_member_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_object_member_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterObject_member_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitObject_member_spec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitObject_member_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Object_member_specContext object_member_spec() {
		Object_member_specContext _localctx = new Object_member_specContext(_ctx, State);
		EnterRule(_localctx, 142, RULE_object_member_spec);
		int _la;
		try {
			State = 1847;
			switch ( Interpreter.AdaptivePredict(_input,156,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1841; identifier();
				State = 1842; type_spec();
				State = 1844;
				_la = _input.La(1);
				if (_la==EXTERNAL) {
					{
					State = 1843; sqlj_object_type_attr();
					}
				}

				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1846; element_spec();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Sqlj_object_type_attrContext : ParserRuleContext {
		public ITerminalNode EXTERNAL() { return GetToken(plsqlParser.EXTERNAL, 0); }
		public ITerminalNode NAME() { return GetToken(plsqlParser.NAME, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Sqlj_object_type_attrContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sqlj_object_type_attr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSqlj_object_type_attr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSqlj_object_type_attr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSqlj_object_type_attr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Sqlj_object_type_attrContext sqlj_object_type_attr() {
		Sqlj_object_type_attrContext _localctx = new Sqlj_object_type_attrContext(_ctx, State);
		EnterRule(_localctx, 144, RULE_sqlj_object_type_attr);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1849; Match(EXTERNAL);
			State = 1850; Match(NAME);
			State = 1851; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Element_specContext : ParserRuleContext {
		public IReadOnlyList<Element_spec_optionsContext> element_spec_options() {
			return GetRuleContexts<Element_spec_optionsContext>();
		}
		public Modifier_clauseContext modifier_clause() {
			return GetRuleContext<Modifier_clauseContext>(0);
		}
		public Pragma_clauseContext pragma_clause() {
			return GetRuleContext<Pragma_clauseContext>(0);
		}
		public Element_spec_optionsContext element_spec_options(int i) {
			return GetRuleContext<Element_spec_optionsContext>(i);
		}
		public Element_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_element_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterElement_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitElement_spec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElement_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Element_specContext element_spec() {
		Element_specContext _localctx = new Element_specContext(_ctx, State);
		EnterRule(_localctx, 146, RULE_element_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1854;
			switch ( Interpreter.AdaptivePredict(_input,157,_ctx) ) {
			case 1:
				{
				State = 1853; modifier_clause();
				}
				break;
			}
			State = 1857;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 1856; element_spec_options();
				}
				}
				State = 1859;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==CONSTRUCTOR || _la==FINAL || _la==INSTANTIABLE || ((((_la - 214)) & ~0x3f) == 0 && ((1L << (_la - 214)) & ((1L << (MAP - 214)) | (1L << (MEMBER - 214)) | (1L << (ORDER - 214)))) != 0) || _la==STATIC );
			State = 1863;
			switch ( Interpreter.AdaptivePredict(_input,159,_ctx) ) {
			case 1:
				{
				State = 1861; Match(COMMA);
				State = 1862; pragma_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Element_spec_optionsContext : ParserRuleContext {
		public Constructor_specContext constructor_spec() {
			return GetRuleContext<Constructor_specContext>(0);
		}
		public Subprogram_specContext subprogram_spec() {
			return GetRuleContext<Subprogram_specContext>(0);
		}
		public Map_order_function_specContext map_order_function_spec() {
			return GetRuleContext<Map_order_function_specContext>(0);
		}
		public Element_spec_optionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_element_spec_options; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterElement_spec_options(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitElement_spec_options(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElement_spec_options(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Element_spec_optionsContext element_spec_options() {
		Element_spec_optionsContext _localctx = new Element_spec_optionsContext(_ctx, State);
		EnterRule(_localctx, 148, RULE_element_spec_options);
		try {
			State = 1868;
			switch (_input.La(1)) {
			case MEMBER:
			case STATIC:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1865; subprogram_spec();
				}
				break;
			case CONSTRUCTOR:
			case FINAL:
			case INSTANTIABLE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1866; constructor_spec();
				}
				break;
			case MAP:
			case ORDER:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1867; map_order_function_spec();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Subprogram_specContext : ParserRuleContext {
		public ITerminalNode STATIC() { return GetToken(plsqlParser.STATIC, 0); }
		public Type_procedure_specContext type_procedure_spec() {
			return GetRuleContext<Type_procedure_specContext>(0);
		}
		public Type_function_specContext type_function_spec() {
			return GetRuleContext<Type_function_specContext>(0);
		}
		public ITerminalNode MEMBER() { return GetToken(plsqlParser.MEMBER, 0); }
		public Subprogram_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subprogram_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSubprogram_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSubprogram_spec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubprogram_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Subprogram_specContext subprogram_spec() {
		Subprogram_specContext _localctx = new Subprogram_specContext(_ctx, State);
		EnterRule(_localctx, 150, RULE_subprogram_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1870;
			_la = _input.La(1);
			if ( !(_la==MEMBER || _la==STATIC) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			State = 1873;
			switch (_input.La(1)) {
			case PROCEDURE:
				{
				State = 1871; type_procedure_spec();
				}
				break;
			case FUNCTION:
				{
				State = 1872; type_function_spec();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Type_procedure_specContext : ParserRuleContext {
		public ITerminalNode IS() { return GetToken(plsqlParser.IS, 0); }
		public IReadOnlyList<Type_elements_parameterContext> type_elements_parameter() {
			return GetRuleContexts<Type_elements_parameterContext>();
		}
		public Call_specContext call_spec() {
			return GetRuleContext<Call_specContext>(0);
		}
		public ITerminalNode PROCEDURE() { return GetToken(plsqlParser.PROCEDURE, 0); }
		public Type_elements_parameterContext type_elements_parameter(int i) {
			return GetRuleContext<Type_elements_parameterContext>(i);
		}
		public ITerminalNode AS() { return GetToken(plsqlParser.AS, 0); }
		public Procedure_nameContext procedure_name() {
			return GetRuleContext<Procedure_nameContext>(0);
		}
		public Type_procedure_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_procedure_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterType_procedure_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitType_procedure_spec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_procedure_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Type_procedure_specContext type_procedure_spec() {
		Type_procedure_specContext _localctx = new Type_procedure_specContext(_ctx, State);
		EnterRule(_localctx, 152, RULE_type_procedure_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1875; Match(PROCEDURE);
			State = 1876; procedure_name();
			State = 1877; Match(LEFT_PAREN);
			State = 1878; type_elements_parameter();
			State = 1883;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 1879; Match(COMMA);
				State = 1880; type_elements_parameter();
				}
				}
				State = 1885;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 1886; Match(RIGHT_PAREN);
			State = 1889;
			_la = _input.La(1);
			if (_la==AS || _la==IS) {
				{
				State = 1887;
				_la = _input.La(1);
				if ( !(_la==AS || _la==IS) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				State = 1888; call_spec();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Type_function_specContext : ParserRuleContext {
		public ITerminalNode SELF() { return GetToken(plsqlParser.SELF, 0); }
		public ITerminalNode AS(int i) {
			return GetToken(plsqlParser.AS, i);
		}
		public ITerminalNode EXTERNAL() { return GetToken(plsqlParser.EXTERNAL, 0); }
		public IReadOnlyList<Type_elements_parameterContext> type_elements_parameter() {
			return GetRuleContexts<Type_elements_parameterContext>();
		}
		public Call_specContext call_spec() {
			return GetRuleContext<Call_specContext>(0);
		}
		public Type_elements_parameterContext type_elements_parameter(int i) {
			return GetRuleContext<Type_elements_parameterContext>(i);
		}
		public IReadOnlyList<ITerminalNode> AS() { return GetTokens(plsqlParser.AS); }
		public Function_nameContext function_name() {
			return GetRuleContext<Function_nameContext>(0);
		}
		public ITerminalNode FUNCTION() { return GetToken(plsqlParser.FUNCTION, 0); }
		public ITerminalNode RETURN() { return GetToken(plsqlParser.RETURN, 0); }
		public ITerminalNode IS() { return GetToken(plsqlParser.IS, 0); }
		public ITerminalNode NAME() { return GetToken(plsqlParser.NAME, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode VARIABLE() { return GetToken(plsqlParser.VARIABLE, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode RESULT() { return GetToken(plsqlParser.RESULT, 0); }
		public Type_function_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_function_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterType_function_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitType_function_spec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_function_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Type_function_specContext type_function_spec() {
		Type_function_specContext _localctx = new Type_function_specContext(_ctx, State);
		EnterRule(_localctx, 154, RULE_type_function_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1891; Match(FUNCTION);
			State = 1892; function_name();
			State = 1904;
			_la = _input.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 1893; Match(LEFT_PAREN);
				State = 1894; type_elements_parameter();
				State = 1899;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 1895; Match(COMMA);
					State = 1896; type_elements_parameter();
					}
					}
					State = 1901;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 1902; Match(RIGHT_PAREN);
				}
			}

			State = 1906; Match(RETURN);
			State = 1911;
			switch ( Interpreter.AdaptivePredict(_input,166,_ctx) ) {
			case 1:
				{
				State = 1907; type_spec();
				}
				break;

			case 2:
				{
				State = 1908; Match(SELF);
				State = 1909; Match(AS);
				State = 1910; Match(RESULT);
				}
				break;
			}
			State = 1921;
			switch (_input.La(1)) {
			case AS:
			case IS:
				{
				State = 1913;
				_la = _input.La(1);
				if ( !(_la==AS || _la==IS) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				State = 1914; call_spec();
				}
				break;
			case EXTERNAL:
				{
				State = 1915; Match(EXTERNAL);
				State = 1917;
				_la = _input.La(1);
				if (_la==VARIABLE) {
					{
					State = 1916; Match(VARIABLE);
					}
				}

				State = 1919; Match(NAME);
				State = 1920; expression();
				}
				break;
			case CASCADE:
			case CONSTRUCTOR:
			case FINAL:
			case INSTANTIABLE:
			case INVALIDATE:
			case MAP:
			case MEMBER:
			case ORDER:
			case STATIC:
			case RIGHT_PAREN:
			case COMMA:
			case SEMICOLON:
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Constructor_specContext : ParserRuleContext {
		public IReadOnlyList<ITerminalNode> SELF() { return GetTokens(plsqlParser.SELF); }
		public ITerminalNode AS(int i) {
			return GetToken(plsqlParser.AS, i);
		}
		public IReadOnlyList<Type_elements_parameterContext> type_elements_parameter() {
			return GetRuleContexts<Type_elements_parameterContext>();
		}
		public Type_specContext type_spec(int i) {
			return GetRuleContext<Type_specContext>(i);
		}
		public Call_specContext call_spec() {
			return GetRuleContext<Call_specContext>(0);
		}
		public Type_elements_parameterContext type_elements_parameter(int i) {
			return GetRuleContext<Type_elements_parameterContext>(i);
		}
		public ITerminalNode INSTANTIABLE() { return GetToken(plsqlParser.INSTANTIABLE, 0); }
		public ITerminalNode CONSTRUCTOR() { return GetToken(plsqlParser.CONSTRUCTOR, 0); }
		public IReadOnlyList<ITerminalNode> AS() { return GetTokens(plsqlParser.AS); }
		public ITerminalNode IN() { return GetToken(plsqlParser.IN, 0); }
		public ITerminalNode FUNCTION() { return GetToken(plsqlParser.FUNCTION, 0); }
		public ITerminalNode RETURN() { return GetToken(plsqlParser.RETURN, 0); }
		public ITerminalNode FINAL() { return GetToken(plsqlParser.FINAL, 0); }
		public ITerminalNode IS() { return GetToken(plsqlParser.IS, 0); }
		public IReadOnlyList<Type_specContext> type_spec() {
			return GetRuleContexts<Type_specContext>();
		}
		public ITerminalNode SELF(int i) {
			return GetToken(plsqlParser.SELF, i);
		}
		public ITerminalNode RESULT() { return GetToken(plsqlParser.RESULT, 0); }
		public ITerminalNode OUT() { return GetToken(plsqlParser.OUT, 0); }
		public Constructor_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constructor_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterConstructor_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitConstructor_spec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstructor_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Constructor_specContext constructor_spec() {
		Constructor_specContext _localctx = new Constructor_specContext(_ctx, State);
		EnterRule(_localctx, 156, RULE_constructor_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1924;
			_la = _input.La(1);
			if (_la==FINAL) {
				{
				State = 1923; Match(FINAL);
				}
			}

			State = 1927;
			_la = _input.La(1);
			if (_la==INSTANTIABLE) {
				{
				State = 1926; Match(INSTANTIABLE);
				}
			}

			State = 1929; Match(CONSTRUCTOR);
			State = 1930; Match(FUNCTION);
			State = 1931; type_spec();
			State = 1949;
			_la = _input.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 1932; Match(LEFT_PAREN);
				{
				State = 1933; Match(SELF);
				State = 1934; Match(IN);
				State = 1935; Match(OUT);
				State = 1936; type_spec();
				State = 1937; Match(COMMA);
				}
				State = 1939; type_elements_parameter();
				State = 1944;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 1940; Match(COMMA);
					State = 1941; type_elements_parameter();
					}
					}
					State = 1946;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 1947; Match(RIGHT_PAREN);
				}
			}

			State = 1951; Match(RETURN);
			State = 1952; Match(SELF);
			State = 1953; Match(AS);
			State = 1954; Match(RESULT);
			State = 1957;
			_la = _input.La(1);
			if (_la==AS || _la==IS) {
				{
				State = 1955;
				_la = _input.La(1);
				if ( !(_la==AS || _la==IS) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				State = 1956; call_spec();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Map_order_function_specContext : ParserRuleContext {
		public ITerminalNode MAP() { return GetToken(plsqlParser.MAP, 0); }
		public ITerminalNode ORDER() { return GetToken(plsqlParser.ORDER, 0); }
		public Type_function_specContext type_function_spec() {
			return GetRuleContext<Type_function_specContext>(0);
		}
		public ITerminalNode MEMBER() { return GetToken(plsqlParser.MEMBER, 0); }
		public Map_order_function_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_map_order_function_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterMap_order_function_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitMap_order_function_spec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMap_order_function_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Map_order_function_specContext map_order_function_spec() {
		Map_order_function_specContext _localctx = new Map_order_function_specContext(_ctx, State);
		EnterRule(_localctx, 158, RULE_map_order_function_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1959;
			_la = _input.La(1);
			if ( !(_la==MAP || _la==ORDER) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			State = 1960; Match(MEMBER);
			State = 1961; type_function_spec();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Pragma_clauseContext : ParserRuleContext {
		public ITerminalNode RESTRICT_REFERENCES() { return GetToken(plsqlParser.RESTRICT_REFERENCES, 0); }
		public IReadOnlyList<Pragma_elementsContext> pragma_elements() {
			return GetRuleContexts<Pragma_elementsContext>();
		}
		public ITerminalNode PRAGMA() { return GetToken(plsqlParser.PRAGMA, 0); }
		public Pragma_elementsContext pragma_elements(int i) {
			return GetRuleContext<Pragma_elementsContext>(i);
		}
		public Pragma_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pragma_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterPragma_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitPragma_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPragma_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Pragma_clauseContext pragma_clause() {
		Pragma_clauseContext _localctx = new Pragma_clauseContext(_ctx, State);
		EnterRule(_localctx, 160, RULE_pragma_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1963; Match(PRAGMA);
			State = 1964; Match(RESTRICT_REFERENCES);
			State = 1965; Match(LEFT_PAREN);
			State = 1966; pragma_elements();
			State = 1971;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 1967; Match(COMMA);
				State = 1968; pragma_elements();
				}
				}
				State = 1973;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 1974; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Pragma_elementsContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode DEFAULT() { return GetToken(plsqlParser.DEFAULT, 0); }
		public Pragma_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pragma_elements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterPragma_elements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitPragma_elements(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPragma_elements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Pragma_elementsContext pragma_elements() {
		Pragma_elementsContext _localctx = new Pragma_elementsContext(_ctx, State);
		EnterRule(_localctx, 162, RULE_pragma_elements);
		try {
			State = 1978;
			switch (_input.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROW_NUMBER:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1976; identifier();
				}
				break;
			case DEFAULT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1977; Match(DEFAULT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Type_elements_parameterContext : ParserRuleContext {
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public Parameter_nameContext parameter_name() {
			return GetRuleContext<Parameter_nameContext>(0);
		}
		public Type_elements_parameterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_elements_parameter; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterType_elements_parameter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitType_elements_parameter(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_elements_parameter(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Type_elements_parameterContext type_elements_parameter() {
		Type_elements_parameterContext _localctx = new Type_elements_parameterContext(_ctx, State);
		EnterRule(_localctx, 164, RULE_type_elements_parameter);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1980; parameter_name();
			State = 1981; type_spec();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Drop_sequenceContext : ParserRuleContext {
		public ITerminalNode SEQUENCE() { return GetToken(plsqlParser.SEQUENCE, 0); }
		public ITerminalNode DROP() { return GetToken(plsqlParser.DROP, 0); }
		public Sequence_nameContext sequence_name() {
			return GetRuleContext<Sequence_nameContext>(0);
		}
		public Drop_sequenceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_drop_sequence; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterDrop_sequence(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitDrop_sequence(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDrop_sequence(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Drop_sequenceContext drop_sequence() {
		Drop_sequenceContext _localctx = new Drop_sequenceContext(_ctx, State);
		EnterRule(_localctx, 166, RULE_drop_sequence);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1983; Match(DROP);
			State = 1984; Match(SEQUENCE);
			State = 1985; sequence_name();
			State = 1986; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_sequenceContext : ParserRuleContext {
		public ITerminalNode SEQUENCE() { return GetToken(plsqlParser.SEQUENCE, 0); }
		public Sequence_specContext sequence_spec(int i) {
			return GetRuleContext<Sequence_specContext>(i);
		}
		public ITerminalNode ALTER() { return GetToken(plsqlParser.ALTER, 0); }
		public Sequence_nameContext sequence_name() {
			return GetRuleContext<Sequence_nameContext>(0);
		}
		public IReadOnlyList<Sequence_specContext> sequence_spec() {
			return GetRuleContexts<Sequence_specContext>();
		}
		public Alter_sequenceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_sequence; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterAlter_sequence(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitAlter_sequence(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlter_sequence(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Alter_sequenceContext alter_sequence() {
		Alter_sequenceContext _localctx = new Alter_sequenceContext(_ctx, State);
		EnterRule(_localctx, 168, RULE_alter_sequence);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1988; Match(ALTER);
			State = 1989; Match(SEQUENCE);
			State = 1990; sequence_name();
			State = 1992;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 1991; sequence_spec();
				}
				}
				State = 1994;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==CACHE || _la==CYCLE || ((((_la - 168)) & ~0x3f) == 0 && ((1L << (_la - 168)) & ((1L << (INCREMENT - 168)) | (1L << (MAXVALUE - 168)) | (1L << (MINVALUE - 168)))) != 0) || ((((_la - 241)) & ~0x3f) == 0 && ((1L << (_la - 241)) & ((1L << (NOCACHE - 241)) | (1L << (NOCYCLE - 241)) | (1L << (NOMAXVALUE - 241)) | (1L << (NOMINVALUE - 241)) | (1L << (NOORDER - 241)) | (1L << (ORDER - 241)))) != 0) );
			State = 1996; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Create_sequenceContext : ParserRuleContext {
		public ITerminalNode SEQUENCE() { return GetToken(plsqlParser.SEQUENCE, 0); }
		public Sequence_specContext sequence_spec(int i) {
			return GetRuleContext<Sequence_specContext>(i);
		}
		public Sequence_start_clauseContext sequence_start_clause(int i) {
			return GetRuleContext<Sequence_start_clauseContext>(i);
		}
		public ITerminalNode CREATE() { return GetToken(plsqlParser.CREATE, 0); }
		public Sequence_nameContext sequence_name() {
			return GetRuleContext<Sequence_nameContext>(0);
		}
		public IReadOnlyList<Sequence_specContext> sequence_spec() {
			return GetRuleContexts<Sequence_specContext>();
		}
		public IReadOnlyList<Sequence_start_clauseContext> sequence_start_clause() {
			return GetRuleContexts<Sequence_start_clauseContext>();
		}
		public Create_sequenceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_create_sequence; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCreate_sequence(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCreate_sequence(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreate_sequence(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Create_sequenceContext create_sequence() {
		Create_sequenceContext _localctx = new Create_sequenceContext(_ctx, State);
		EnterRule(_localctx, 170, RULE_create_sequence);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1998; Match(CREATE);
			State = 1999; Match(SEQUENCE);
			State = 2000; sequence_name();
			State = 2005;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==CACHE || _la==CYCLE || ((((_la - 168)) & ~0x3f) == 0 && ((1L << (_la - 168)) & ((1L << (INCREMENT - 168)) | (1L << (MAXVALUE - 168)) | (1L << (MINVALUE - 168)))) != 0) || ((((_la - 241)) & ~0x3f) == 0 && ((1L << (_la - 241)) & ((1L << (NOCACHE - 241)) | (1L << (NOCYCLE - 241)) | (1L << (NOMAXVALUE - 241)) | (1L << (NOMINVALUE - 241)) | (1L << (NOORDER - 241)) | (1L << (ORDER - 241)))) != 0) || _la==START) {
				{
				State = 2003;
				switch (_input.La(1)) {
				case START:
					{
					State = 2001; sequence_start_clause();
					}
					break;
				case CACHE:
				case CYCLE:
				case INCREMENT:
				case MAXVALUE:
				case MINVALUE:
				case NOCACHE:
				case NOCYCLE:
				case NOMAXVALUE:
				case NOMINVALUE:
				case NOORDER:
				case ORDER:
					{
					State = 2002; sequence_spec();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 2007;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 2008; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Sequence_specContext : ParserRuleContext {
		public ITerminalNode NOMINVALUE() { return GetToken(plsqlParser.NOMINVALUE, 0); }
		public ITerminalNode MAXVALUE() { return GetToken(plsqlParser.MAXVALUE, 0); }
		public ITerminalNode NOORDER() { return GetToken(plsqlParser.NOORDER, 0); }
		public ITerminalNode UNSIGNED_INTEGER() { return GetToken(plsqlParser.UNSIGNED_INTEGER, 0); }
		public ITerminalNode CACHE() { return GetToken(plsqlParser.CACHE, 0); }
		public ITerminalNode NOMAXVALUE() { return GetToken(plsqlParser.NOMAXVALUE, 0); }
		public ITerminalNode ORDER() { return GetToken(plsqlParser.ORDER, 0); }
		public ITerminalNode NOCYCLE() { return GetToken(plsqlParser.NOCYCLE, 0); }
		public ITerminalNode MINVALUE() { return GetToken(plsqlParser.MINVALUE, 0); }
		public ITerminalNode INCREMENT() { return GetToken(plsqlParser.INCREMENT, 0); }
		public ITerminalNode CYCLE() { return GetToken(plsqlParser.CYCLE, 0); }
		public ITerminalNode BY() { return GetToken(plsqlParser.BY, 0); }
		public ITerminalNode NOCACHE() { return GetToken(plsqlParser.NOCACHE, 0); }
		public Sequence_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sequence_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSequence_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSequence_spec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSequence_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Sequence_specContext sequence_spec() {
		Sequence_specContext _localctx = new Sequence_specContext(_ctx, State);
		EnterRule(_localctx, 172, RULE_sequence_spec);
		try {
			State = 2026;
			switch (_input.La(1)) {
			case INCREMENT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2010; Match(INCREMENT);
				State = 2011; Match(BY);
				State = 2012; Match(UNSIGNED_INTEGER);
				}
				break;
			case MAXVALUE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2013; Match(MAXVALUE);
				State = 2014; Match(UNSIGNED_INTEGER);
				}
				break;
			case NOMAXVALUE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2015; Match(NOMAXVALUE);
				}
				break;
			case MINVALUE:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2016; Match(MINVALUE);
				State = 2017; Match(UNSIGNED_INTEGER);
				}
				break;
			case NOMINVALUE:
				EnterOuterAlt(_localctx, 5);
				{
				State = 2018; Match(NOMINVALUE);
				}
				break;
			case CYCLE:
				EnterOuterAlt(_localctx, 6);
				{
				State = 2019; Match(CYCLE);
				}
				break;
			case NOCYCLE:
				EnterOuterAlt(_localctx, 7);
				{
				State = 2020; Match(NOCYCLE);
				}
				break;
			case CACHE:
				EnterOuterAlt(_localctx, 8);
				{
				State = 2021; Match(CACHE);
				State = 2022; Match(UNSIGNED_INTEGER);
				}
				break;
			case NOCACHE:
				EnterOuterAlt(_localctx, 9);
				{
				State = 2023; Match(NOCACHE);
				}
				break;
			case ORDER:
				EnterOuterAlt(_localctx, 10);
				{
				State = 2024; Match(ORDER);
				}
				break;
			case NOORDER:
				EnterOuterAlt(_localctx, 11);
				{
				State = 2025; Match(NOORDER);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Sequence_start_clauseContext : ParserRuleContext {
		public ITerminalNode WITH() { return GetToken(plsqlParser.WITH, 0); }
		public ITerminalNode UNSIGNED_INTEGER() { return GetToken(plsqlParser.UNSIGNED_INTEGER, 0); }
		public ITerminalNode START() { return GetToken(plsqlParser.START, 0); }
		public Sequence_start_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sequence_start_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSequence_start_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSequence_start_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSequence_start_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Sequence_start_clauseContext sequence_start_clause() {
		Sequence_start_clauseContext _localctx = new Sequence_start_clauseContext(_ctx, State);
		EnterRule(_localctx, 174, RULE_sequence_start_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2028; Match(START);
			State = 2029; Match(WITH);
			State = 2030; Match(UNSIGNED_INTEGER);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Invoker_rights_clauseContext : ParserRuleContext {
		public ITerminalNode AUTHID() { return GetToken(plsqlParser.AUTHID, 0); }
		public ITerminalNode CURRENT_USER() { return GetToken(plsqlParser.CURRENT_USER, 0); }
		public ITerminalNode DEFINER() { return GetToken(plsqlParser.DEFINER, 0); }
		public Invoker_rights_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_invoker_rights_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterInvoker_rights_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitInvoker_rights_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInvoker_rights_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Invoker_rights_clauseContext invoker_rights_clause() {
		Invoker_rights_clauseContext _localctx = new Invoker_rights_clauseContext(_ctx, State);
		EnterRule(_localctx, 176, RULE_invoker_rights_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2032; Match(AUTHID);
			State = 2033;
			_la = _input.La(1);
			if ( !(_la==CURRENT_USER || _la==DEFINER) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Compiler_parameters_clauseContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Compiler_parameters_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compiler_parameters_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCompiler_parameters_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCompiler_parameters_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompiler_parameters_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Compiler_parameters_clauseContext compiler_parameters_clause() {
		Compiler_parameters_clauseContext _localctx = new Compiler_parameters_clauseContext(_ctx, State);
		EnterRule(_localctx, 178, RULE_compiler_parameters_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2035; identifier();
			State = 2036; Match(EQUALS_OP);
			State = 2037; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Call_specContext : ParserRuleContext {
		public Java_specContext java_spec() {
			return GetRuleContext<Java_specContext>(0);
		}
		public ITerminalNode LANGUAGE() { return GetToken(plsqlParser.LANGUAGE, 0); }
		public C_specContext c_spec() {
			return GetRuleContext<C_specContext>(0);
		}
		public Call_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_call_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCall_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCall_spec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCall_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Call_specContext call_spec() {
		Call_specContext _localctx = new Call_specContext(_ctx, State);
		EnterRule(_localctx, 180, RULE_call_spec);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2039; Match(LANGUAGE);
			State = 2042;
			switch (_input.La(1)) {
			case JAVA:
				{
				State = 2040; java_spec();
				}
				break;
			case C_LETTER:
				{
				State = 2041; c_spec();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Java_specContext : ParserRuleContext {
		public ITerminalNode NAME() { return GetToken(plsqlParser.NAME, 0); }
		public ITerminalNode CHAR_STRING() { return GetToken(plsqlParser.CHAR_STRING, 0); }
		public ITerminalNode JAVA() { return GetToken(plsqlParser.JAVA, 0); }
		public Java_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_java_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterJava_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitJava_spec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitJava_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Java_specContext java_spec() {
		Java_specContext _localctx = new Java_specContext(_ctx, State);
		EnterRule(_localctx, 182, RULE_java_spec);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2044; Match(JAVA);
			State = 2045; Match(NAME);
			State = 2046; Match(CHAR_STRING);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class C_specContext : ParserRuleContext {
		public ITerminalNode C_LETTER() { return GetToken(plsqlParser.C_LETTER, 0); }
		public ITerminalNode WITH() { return GetToken(plsqlParser.WITH, 0); }
		public ITerminalNode NAME() { return GetToken(plsqlParser.NAME, 0); }
		public ITerminalNode CHAR_STRING() { return GetToken(plsqlParser.CHAR_STRING, 0); }
		public C_parameters_clauseContext c_parameters_clause() {
			return GetRuleContext<C_parameters_clauseContext>(0);
		}
		public ITerminalNode LIBRARY() { return GetToken(plsqlParser.LIBRARY, 0); }
		public C_agent_in_clauseContext c_agent_in_clause() {
			return GetRuleContext<C_agent_in_clauseContext>(0);
		}
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode CONTEXT() { return GetToken(plsqlParser.CONTEXT, 0); }
		public C_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_c_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterC_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitC_spec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitC_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public C_specContext c_spec() {
		C_specContext _localctx = new C_specContext(_ctx, State);
		EnterRule(_localctx, 184, RULE_c_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2048; Match(C_LETTER);
			State = 2051;
			_la = _input.La(1);
			if (_la==NAME) {
				{
				State = 2049; Match(NAME);
				State = 2050; Match(CHAR_STRING);
				}
			}

			State = 2053; Match(LIBRARY);
			State = 2054; identifier();
			State = 2056;
			_la = _input.La(1);
			if (_la==AGENT) {
				{
				State = 2055; c_agent_in_clause();
				}
			}

			State = 2060;
			_la = _input.La(1);
			if (_la==WITH) {
				{
				State = 2058; Match(WITH);
				State = 2059; Match(CONTEXT);
				}
			}

			State = 2063;
			_la = _input.La(1);
			if (_la==PARAMETERS) {
				{
				State = 2062; c_parameters_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class C_agent_in_clauseContext : ParserRuleContext {
		public ITerminalNode AGENT() { return GetToken(plsqlParser.AGENT, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode IN() { return GetToken(plsqlParser.IN, 0); }
		public C_agent_in_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_c_agent_in_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterC_agent_in_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitC_agent_in_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitC_agent_in_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public C_agent_in_clauseContext c_agent_in_clause() {
		C_agent_in_clauseContext _localctx = new C_agent_in_clauseContext(_ctx, State);
		EnterRule(_localctx, 186, RULE_c_agent_in_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2065; Match(AGENT);
			State = 2066; Match(IN);
			State = 2067; Match(LEFT_PAREN);
			State = 2068; expression();
			State = 2073;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 2069; Match(COMMA);
				State = 2070; expression();
				}
				}
				State = 2075;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 2076; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class C_parameters_clauseContext : ParserRuleContext {
		public ITerminalNode PARAMETERS() { return GetToken(plsqlParser.PARAMETERS, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public C_parameters_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_c_parameters_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterC_parameters_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitC_parameters_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitC_parameters_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public C_parameters_clauseContext c_parameters_clause() {
		C_parameters_clauseContext _localctx = new C_parameters_clauseContext(_ctx, State);
		EnterRule(_localctx, 188, RULE_c_parameters_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2078; Match(PARAMETERS);
			State = 2079; Match(LEFT_PAREN);
			State = 2091;
			switch (_input.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALL:
			case ANALYZE:
			case ANY:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CASE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COALESCE:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DISTINCT:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FALSE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NOT:
			case NULL:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIOR:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUE:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case DECODE:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case NVL:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROUND:
			case ROW_NUMBER:
			case SUBSTR:
			case TO_CHAR:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case NATIONAL_CHAR_STRING_LIT:
			case UNSIGNED_INTEGER:
			case APPROXIMATE_NUM_LIT:
			case CHAR_STRING:
			case DELIMITED_ID:
			case LEFT_PAREN:
			case PLUS_SIGN:
			case MINUS_SIGN:
			case BINDVAR:
			case COLON:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 2080; expression();
				State = 2085;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 2081; Match(COMMA);
					State = 2082; expression();
					}
					}
					State = 2087;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
				break;
			case PERIOD:
				{
				State = 2088; Match(PERIOD);
				State = 2089; Match(PERIOD);
				State = 2090; Match(PERIOD);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2093; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParameterContext : ParserRuleContext {
		public ITerminalNode NOCOPY(int i) {
			return GetToken(plsqlParser.NOCOPY, i);
		}
		public Default_value_partContext default_value_part() {
			return GetRuleContext<Default_value_partContext>(0);
		}
		public ITerminalNode IN(int i) {
			return GetToken(plsqlParser.IN, i);
		}
		public IReadOnlyList<ITerminalNode> NOCOPY() { return GetTokens(plsqlParser.NOCOPY); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode INOUT(int i) {
			return GetToken(plsqlParser.INOUT, i);
		}
		public Parameter_nameContext parameter_name() {
			return GetRuleContext<Parameter_nameContext>(0);
		}
		public IReadOnlyList<ITerminalNode> INOUT() { return GetTokens(plsqlParser.INOUT); }
		public IReadOnlyList<ITerminalNode> IN() { return GetTokens(plsqlParser.IN); }
		public ITerminalNode OUT(int i) {
			return GetToken(plsqlParser.OUT, i);
		}
		public IReadOnlyList<ITerminalNode> OUT() { return GetTokens(plsqlParser.OUT); }
		public ParameterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameter; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterParameter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitParameter(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameter(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParameterContext parameter() {
		ParameterContext _localctx = new ParameterContext(_ctx, State);
		EnterRule(_localctx, 190, RULE_parameter);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2095; parameter_name();
			State = 2099;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,188,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 2096;
					_la = _input.La(1);
					if ( !(_la==IN || _la==INOUT || _la==NOCOPY || _la==OUT) ) {
					_errHandler.RecoverInline(this);
					}
					Consume();
					}
					} 
				}
				State = 2101;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,188,_ctx);
			}
			State = 2103;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (CONSTANT - 66)) | (1L << (CONSTRAINT - 66)) | (1L << (CONSTRAINTS - 66)) | (1L << (CONSTRUCTOR - 66)) | (1L << (CONTENT - 66)) | (1L << (CONTEXT - 66)) | (1L << (CONTINUE - 66)) | (1L << (CONVERT - 66)) | (1L << (CORRUPT_XID - 66)) | (1L << (CORRUPT_XID_ALL - 66)) | (1L << (COST - 66)) | (1L << (COUNT - 66)) | (1L << (CROSS - 66)) | (1L << (CUBE - 66)) | (1L << (CURRENT_USER - 66)) | (1L << (CURSOR - 66)) | (1L << (CUSTOMDATUM - 66)) | (1L << (CYCLE - 66)) | (1L << (DATA - 66)) | (1L << (DATABASE - 66)) | (1L << (DATE - 66)) | (1L << (DAY - 66)) | (1L << (DB_ROLE_CHANGE - 66)) | (1L << (DBTIMEZONE - 66)) | (1L << (DDL - 66)) | (1L << (DEBUG - 66)) | (1L << (DEC - 66)) | (1L << (DECIMAL - 66)) | (1L << (DECOMPOSE - 66)) | (1L << (DECREMENT - 66)) | (1L << (DEFAULTS - 66)) | (1L << (DEFERRED - 66)) | (1L << (DEFINER - 66)) | (1L << (DETERMINISTIC - 66)) | (1L << (DIMENSION - 66)) | (1L << (DISABLE - 66)) | (1L << (DISASSOCIATE - 66)) | (1L << (DOCUMENT - 66)) | (1L << (DOUBLE - 66)) | (1L << (DSINTERVAL_UNCONSTRAINED - 66)) | (1L << (EACH - 66)) | (1L << (ELEMENT - 66)) | (1L << (EMPTY - 66)) | (1L << (ENABLE - 66)) | (1L << (ENCODING - 66)) | (1L << (ENTITYESCAPING - 66)) | (1L << (ERR - 66)) | (1L << (ERRORS - 66)) | (1L << (ESCAPE - 66)) | (1L << (EVALNAME - 66)) | (1L << (EXCEPTION - 66)) | (1L << (EXCEPTION_INIT - 66)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)) | (1L << (EXIT - 130)) | (1L << (EXPLAIN - 130)) | (1L << (EXTERNAL - 130)) | (1L << (EXTRACT - 130)) | (1L << (FAILURE - 130)) | (1L << (FINAL - 130)) | (1L << (FIRST - 130)) | (1L << (FIRST_VALUE - 130)) | (1L << (FLOAT - 130)) | (1L << (FOLLOWING - 130)) | (1L << (FOLLOWS - 130)) | (1L << (FORALL - 130)) | (1L << (FORCE - 130)) | (1L << (FULL - 130)) | (1L << (FUNCTION - 130)) | (1L << (GROUPING - 130)) | (1L << (HASH - 130)) | (1L << (HIDE - 130)) | (1L << (HOUR - 130)) | (1L << (IGNORE - 130)) | (1L << (IMMEDIATE - 130)) | (1L << (INCLUDE - 130)) | (1L << (INCLUDING - 130)) | (1L << (INCREMENT - 130)) | (1L << (INDENT - 130)) | (1L << (INDEXED - 130)) | (1L << (INDICATOR - 130)) | (1L << (INDICES - 130)) | (1L << (INFINITE - 130)) | (1L << (INLINE - 130)) | (1L << (INNER - 130)) | (1L << (INOUT - 130)) | (1L << (INSTANTIABLE - 130)) | (1L << (INSTEAD - 130)) | (1L << (INT - 130)) | (1L << (INTEGER - 130)) | (1L << (INTERVAL - 130)) | (1L << (INVALIDATE - 130)) | (1L << (ISOLATION - 130)) | (1L << (ITERATE - 130)) | (1L << (JAVA - 130)) | (1L << (JOIN - 130)) | (1L << (KEEP - 130)) | (1L << (LANGUAGE - 130)))) != 0) || ((((_la - 194)) & ~0x3f) == 0 && ((1L << (_la - 194)) & ((1L << (LAST - 194)) | (1L << (LAST_VALUE - 194)) | (1L << (LEADING - 194)) | (1L << (LEFT - 194)) | (1L << (LEVEL - 194)) | (1L << (LIBRARY - 194)) | (1L << (LIKE2 - 194)) | (1L << (LIKE4 - 194)) | (1L << (LIKEC - 194)) | (1L << (LIMIT - 194)) | (1L << (LOCAL - 194)) | (1L << (LOCKED - 194)) | (1L << (LOG - 194)) | (1L << (LOGOFF - 194)) | (1L << (LOGON - 194)) | (1L << (LONG - 194)) | (1L << (LOOP - 194)) | (1L << (MAIN - 194)) | (1L << (MAP - 194)) | (1L << (MATCHED - 194)) | (1L << (MAXVALUE - 194)) | (1L << (MEASURES - 194)) | (1L << (MEMBER - 194)) | (1L << (MERGE - 194)) | (1L << (MINUTE - 194)) | (1L << (MINVALUE - 194)) | (1L << (MLSLABEL - 194)) | (1L << (MODEL - 194)) | (1L << (MODIFY - 194)) | (1L << (MONTH - 194)) | (1L << (MULTISET - 194)) | (1L << (NAME - 194)) | (1L << (NAN - 194)) | (1L << (NATURAL - 194)) | (1L << (NATURALN - 194)) | (1L << (NAV - 194)) | (1L << (NCHAR - 194)) | (1L << (NCHAR_CS - 194)) | (1L << (NCLOB - 194)) | (1L << (NESTED - 194)) | (1L << (NEW - 194)) | (1L << (NO - 194)) | (1L << (NOAUDIT - 194)) | (1L << (NOCOPY - 194)) | (1L << (NOCYCLE - 194)) | (1L << (NOENTITYESCAPING - 194)) | (1L << (NONE - 194)) | (1L << (NOSCHEMACHECK - 194)) | (1L << (NULLS - 194)) | (1L << (NUMBER - 194)) | (1L << (NUMERIC - 194)) | (1L << (NVARCHAR2 - 194)) | (1L << (OBJECT - 194)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (OFF - 259)) | (1L << (OID - 259)) | (1L << (OLD - 259)) | (1L << (ONLY - 259)) | (1L << (OPEN - 259)) | (1L << (ORADATA - 259)) | (1L << (ORDINALITY - 259)) | (1L << (OSERROR - 259)) | (1L << (OUT - 259)) | (1L << (OUTER - 259)) | (1L << (OVER - 259)) | (1L << (OVERRIDING - 259)) | (1L << (PACKAGE - 259)) | (1L << (PARALLEL_ENABLE - 259)) | (1L << (PARAMETERS - 259)) | (1L << (PARENT - 259)) | (1L << (PARTITION - 259)) | (1L << (PASSING - 259)) | (1L << (PATH - 259)) | (1L << (PIPELINED - 259)) | (1L << (PLAN - 259)) | (1L << (PLS_INTEGER - 259)) | (1L << (POSITIVE - 259)) | (1L << (POSITIVEN - 259)) | (1L << (PRAGMA - 259)) | (1L << (PRECEDING - 259)) | (1L << (PRECISION - 259)) | (1L << (PRESENT - 259)) | (1L << (RAISE - 259)) | (1L << (RANGE - 259)) | (1L << (RAW - 259)) | (1L << (READ - 259)) | (1L << (REAL - 259)) | (1L << (RECORD - 259)) | (1L << (REF - 259)) | (1L << (REFERENCE - 259)) | (1L << (REFERENCING - 259)) | (1L << (REJECT - 259)) | (1L << (RELIES_ON - 259)) | (1L << (RENAME - 259)) | (1L << (REPLACE - 259)) | (1L << (RESPECT - 259)) | (1L << (RESTRICT_REFERENCES - 259)) | (1L << (RESULT - 259)) | (1L << (RESULT_CACHE - 259)) | (1L << (RETURN - 259)) | (1L << (RETURNING - 259)) | (1L << (REUSE - 259)) | (1L << (REVERSE - 259)) | (1L << (RIGHT - 259)))) != 0) || ((((_la - 323)) & ~0x3f) == 0 && ((1L << (_la - 323)) & ((1L << (ROLLBACK - 323)) | (1L << (ROLLUP - 323)) | (1L << (ROW - 323)) | (1L << (ROWID - 323)) | (1L << (ROWS - 323)) | (1L << (RULES - 323)) | (1L << (SAMPLE - 323)) | (1L << (SAVE - 323)) | (1L << (SAVEPOINT - 323)) | (1L << (SCHEMA - 323)) | (1L << (SCHEMACHECK - 323)) | (1L << (SCN - 323)) | (1L << (SECOND - 323)) | (1L << (SEED - 323)) | (1L << (SEGMENT - 323)) | (1L << (SELF - 323)) | (1L << (SEQUENTIAL - 323)) | (1L << (SERIALIZABLE - 323)) | (1L << (SERIALLY_REUSABLE - 323)) | (1L << (SERVERERROR - 323)) | (1L << (SESSIONTIMEZONE - 323)) | (1L << (SET - 323)) | (1L << (SETS - 323)) | (1L << (SETTINGS - 323)) | (1L << (SHOW - 323)) | (1L << (SHUTDOWN - 323)) | (1L << (SIBLINGS - 323)) | (1L << (SIGNTYPE - 323)) | (1L << (SIMPLE_INTEGER - 323)) | (1L << (SINGLE - 323)) | (1L << (SKIP_ - 323)) | (1L << (SMALLINT - 323)) | (1L << (SNAPSHOT - 323)) | (1L << (SOME - 323)) | (1L << (SPECIFICATION - 323)) | (1L << (SQLDATA - 323)) | (1L << (SQLERROR - 323)) | (1L << (STANDALONE - 323)) | (1L << (STARTUP - 323)) | (1L << (STATEMENT - 323)) | (1L << (STATEMENT_ID - 323)) | (1L << (STATIC - 323)) | (1L << (STATISTICS - 323)) | (1L << (STRING - 323)) | (1L << (SUBMULTISET - 323)) | (1L << (SUBPARTITION - 323)) | (1L << (SUBSTITUTABLE - 323)) | (1L << (SUBTYPE - 323)) | (1L << (SUCCESS - 323)) | (1L << (SUSPEND - 323)) | (1L << (TIME - 323)) | (1L << (TIMESTAMP - 323)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_UNCONSTRAINED - 323)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TIMEZONE_ABBR - 387)) | (1L << (TIMEZONE_HOUR - 387)) | (1L << (TIMEZONE_MINUTE - 387)) | (1L << (TIMEZONE_REGION - 387)) | (1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (YMINTERVAL_UNCONSTRAINED - 451)) | (1L << (ZONE - 451)) | (1L << (PREDICTION - 451)) | (1L << (PREDICTION_BOUNDS - 451)) | (1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (COVAR_ - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (REGR_ - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (TRIM - 451)) | (1L << (SUM - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (VARIANCE - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==REGULAR_ID) {
				{
				State = 2102; type_spec();
				}
			}

			State = 2106;
			_la = _input.La(1);
			if (_la==DEFAULT || _la==ASSIGN_OP) {
				{
				State = 2105; default_value_part();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Default_value_partContext : ParserRuleContext {
		public ITerminalNode ASSIGN_OP() { return GetToken(plsqlParser.ASSIGN_OP, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode DEFAULT() { return GetToken(plsqlParser.DEFAULT, 0); }
		public Default_value_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_default_value_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterDefault_value_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitDefault_value_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDefault_value_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Default_value_partContext default_value_part() {
		Default_value_partContext _localctx = new Default_value_partContext(_ctx, State);
		EnterRule(_localctx, 192, RULE_default_value_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2108;
			_la = _input.La(1);
			if ( !(_la==DEFAULT || _la==ASSIGN_OP) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			State = 2109; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Declare_specContext : ParserRuleContext {
		public Function_specContext function_spec() {
			return GetRuleContext<Function_specContext>(0);
		}
		public Pragma_declarationContext pragma_declaration() {
			return GetRuleContext<Pragma_declarationContext>(0);
		}
		public Subtype_declarationContext subtype_declaration() {
			return GetRuleContext<Subtype_declarationContext>(0);
		}
		public Function_bodyContext function_body() {
			return GetRuleContext<Function_bodyContext>(0);
		}
		public Cursor_declarationContext cursor_declaration() {
			return GetRuleContext<Cursor_declarationContext>(0);
		}
		public Variable_declarationContext variable_declaration() {
			return GetRuleContext<Variable_declarationContext>(0);
		}
		public Exception_declarationContext exception_declaration() {
			return GetRuleContext<Exception_declarationContext>(0);
		}
		public Procedure_specContext procedure_spec() {
			return GetRuleContext<Procedure_specContext>(0);
		}
		public Type_declarationContext type_declaration() {
			return GetRuleContext<Type_declarationContext>(0);
		}
		public Procedure_bodyContext procedure_body() {
			return GetRuleContext<Procedure_bodyContext>(0);
		}
		public Declare_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declare_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterDeclare_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitDeclare_spec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclare_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Declare_specContext declare_spec() {
		Declare_specContext _localctx = new Declare_specContext(_ctx, State);
		EnterRule(_localctx, 194, RULE_declare_spec);
		try {
			State = 2121;
			switch ( Interpreter.AdaptivePredict(_input,191,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2111; variable_declaration();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2112; subtype_declaration();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2113; cursor_declaration();
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2114; exception_declaration();
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 2115; pragma_declaration();
				}
				break;

			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 2116; type_declaration();
				}
				break;

			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 2117; procedure_spec();
				}
				break;

			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 2118; function_spec();
				}
				break;

			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 2119; procedure_body();
				}
				break;

			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 2120; function_body();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Variable_declarationContext : ParserRuleContext {
		public ITerminalNode NOT() { return GetToken(plsqlParser.NOT, 0); }
		public Default_value_partContext default_value_part() {
			return GetRuleContext<Default_value_partContext>(0);
		}
		public ITerminalNode NULL() { return GetToken(plsqlParser.NULL, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode CONSTANT() { return GetToken(plsqlParser.CONSTANT, 0); }
		public Variable_declarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_variable_declaration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterVariable_declaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitVariable_declaration(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVariable_declaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Variable_declarationContext variable_declaration() {
		Variable_declarationContext _localctx = new Variable_declarationContext(_ctx, State);
		EnterRule(_localctx, 196, RULE_variable_declaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2123; identifier();
			State = 2125;
			switch ( Interpreter.AdaptivePredict(_input,192,_ctx) ) {
			case 1:
				{
				State = 2124; Match(CONSTANT);
				}
				break;
			}
			State = 2127; type_spec();
			State = 2130;
			_la = _input.La(1);
			if (_la==NOT) {
				{
				State = 2128; Match(NOT);
				State = 2129; Match(NULL);
				}
			}

			State = 2133;
			_la = _input.La(1);
			if (_la==DEFAULT || _la==ASSIGN_OP) {
				{
				State = 2132; default_value_part();
				}
			}

			State = 2135; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Subtype_declarationContext : ParserRuleContext {
		public ITerminalNode NOT() { return GetToken(plsqlParser.NOT, 0); }
		public ITerminalNode IS() { return GetToken(plsqlParser.IS, 0); }
		public ITerminalNode RANGE() { return GetToken(plsqlParser.RANGE, 0); }
		public ITerminalNode NULL() { return GetToken(plsqlParser.NULL, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode SUBTYPE() { return GetToken(plsqlParser.SUBTYPE, 0); }
		public Subtype_declarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subtype_declaration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSubtype_declaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSubtype_declaration(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubtype_declaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Subtype_declarationContext subtype_declaration() {
		Subtype_declarationContext _localctx = new Subtype_declarationContext(_ctx, State);
		EnterRule(_localctx, 198, RULE_subtype_declaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2137; Match(SUBTYPE);
			State = 2138; identifier();
			State = 2139; Match(IS);
			State = 2140; type_spec();
			State = 2146;
			_la = _input.La(1);
			if (_la==RANGE) {
				{
				State = 2141; Match(RANGE);
				State = 2142; expression();
				State = 2143; Match(T__0);
				State = 2144; expression();
				}
			}

			State = 2150;
			_la = _input.La(1);
			if (_la==NOT) {
				{
				State = 2148; Match(NOT);
				State = 2149; Match(NULL);
				}
			}

			State = 2152; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cursor_declarationContext : ParserRuleContext {
		public ITerminalNode CURSOR() { return GetToken(plsqlParser.CURSOR, 0); }
		public IReadOnlyList<Parameter_specContext> parameter_spec() {
			return GetRuleContexts<Parameter_specContext>();
		}
		public ITerminalNode RETURN() { return GetToken(plsqlParser.RETURN, 0); }
		public ITerminalNode IS() { return GetToken(plsqlParser.IS, 0); }
		public Select_statementContext select_statement() {
			return GetRuleContext<Select_statementContext>(0);
		}
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public Parameter_specContext parameter_spec(int i) {
			return GetRuleContext<Parameter_specContext>(i);
		}
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Cursor_declarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cursor_declaration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCursor_declaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCursor_declaration(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCursor_declaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Cursor_declarationContext cursor_declaration() {
		Cursor_declarationContext _localctx = new Cursor_declarationContext(_ctx, State);
		EnterRule(_localctx, 200, RULE_cursor_declaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2154; Match(CURSOR);
			State = 2155; identifier();
			State = 2167;
			_la = _input.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 2156; Match(LEFT_PAREN);
				State = 2157; parameter_spec();
				State = 2162;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 2158; Match(COMMA);
					State = 2159; parameter_spec();
					}
					}
					State = 2164;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 2165; Match(RIGHT_PAREN);
				}
			}

			State = 2171;
			_la = _input.La(1);
			if (_la==RETURN) {
				{
				State = 2169; Match(RETURN);
				State = 2170; type_spec();
				}
			}

			State = 2175;
			_la = _input.La(1);
			if (_la==IS) {
				{
				State = 2173; Match(IS);
				State = 2174; select_statement();
				}
			}

			State = 2177; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Parameter_specContext : ParserRuleContext {
		public Default_value_partContext default_value_part() {
			return GetRuleContext<Default_value_partContext>(0);
		}
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public Parameter_nameContext parameter_name() {
			return GetRuleContext<Parameter_nameContext>(0);
		}
		public ITerminalNode IN() { return GetToken(plsqlParser.IN, 0); }
		public Parameter_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameter_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterParameter_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitParameter_spec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameter_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Parameter_specContext parameter_spec() {
		Parameter_specContext _localctx = new Parameter_specContext(_ctx, State);
		EnterRule(_localctx, 202, RULE_parameter_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2179; parameter_name();
			State = 2184;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (CONSTANT - 66)) | (1L << (CONSTRAINT - 66)) | (1L << (CONSTRAINTS - 66)) | (1L << (CONSTRUCTOR - 66)) | (1L << (CONTENT - 66)) | (1L << (CONTEXT - 66)) | (1L << (CONTINUE - 66)) | (1L << (CONVERT - 66)) | (1L << (CORRUPT_XID - 66)) | (1L << (CORRUPT_XID_ALL - 66)) | (1L << (COST - 66)) | (1L << (COUNT - 66)) | (1L << (CROSS - 66)) | (1L << (CUBE - 66)) | (1L << (CURRENT_USER - 66)) | (1L << (CURSOR - 66)) | (1L << (CUSTOMDATUM - 66)) | (1L << (CYCLE - 66)) | (1L << (DATA - 66)) | (1L << (DATABASE - 66)) | (1L << (DATE - 66)) | (1L << (DAY - 66)) | (1L << (DB_ROLE_CHANGE - 66)) | (1L << (DBTIMEZONE - 66)) | (1L << (DDL - 66)) | (1L << (DEBUG - 66)) | (1L << (DEC - 66)) | (1L << (DECIMAL - 66)) | (1L << (DECOMPOSE - 66)) | (1L << (DECREMENT - 66)) | (1L << (DEFAULTS - 66)) | (1L << (DEFERRED - 66)) | (1L << (DEFINER - 66)) | (1L << (DETERMINISTIC - 66)) | (1L << (DIMENSION - 66)) | (1L << (DISABLE - 66)) | (1L << (DISASSOCIATE - 66)) | (1L << (DOCUMENT - 66)) | (1L << (DOUBLE - 66)) | (1L << (DSINTERVAL_UNCONSTRAINED - 66)) | (1L << (EACH - 66)) | (1L << (ELEMENT - 66)) | (1L << (EMPTY - 66)) | (1L << (ENABLE - 66)) | (1L << (ENCODING - 66)) | (1L << (ENTITYESCAPING - 66)) | (1L << (ERR - 66)) | (1L << (ERRORS - 66)) | (1L << (ESCAPE - 66)) | (1L << (EVALNAME - 66)) | (1L << (EXCEPTION - 66)) | (1L << (EXCEPTION_INIT - 66)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)) | (1L << (EXIT - 130)) | (1L << (EXPLAIN - 130)) | (1L << (EXTERNAL - 130)) | (1L << (EXTRACT - 130)) | (1L << (FAILURE - 130)) | (1L << (FINAL - 130)) | (1L << (FIRST - 130)) | (1L << (FIRST_VALUE - 130)) | (1L << (FLOAT - 130)) | (1L << (FOLLOWING - 130)) | (1L << (FOLLOWS - 130)) | (1L << (FORALL - 130)) | (1L << (FORCE - 130)) | (1L << (FULL - 130)) | (1L << (FUNCTION - 130)) | (1L << (GROUPING - 130)) | (1L << (HASH - 130)) | (1L << (HIDE - 130)) | (1L << (HOUR - 130)) | (1L << (IGNORE - 130)) | (1L << (IMMEDIATE - 130)) | (1L << (IN - 130)) | (1L << (INCLUDE - 130)) | (1L << (INCLUDING - 130)) | (1L << (INCREMENT - 130)) | (1L << (INDENT - 130)) | (1L << (INDEXED - 130)) | (1L << (INDICATOR - 130)) | (1L << (INDICES - 130)) | (1L << (INFINITE - 130)) | (1L << (INLINE - 130)) | (1L << (INNER - 130)) | (1L << (INOUT - 130)) | (1L << (INSTANTIABLE - 130)) | (1L << (INSTEAD - 130)) | (1L << (INT - 130)) | (1L << (INTEGER - 130)) | (1L << (INTERVAL - 130)) | (1L << (INVALIDATE - 130)) | (1L << (ISOLATION - 130)) | (1L << (ITERATE - 130)) | (1L << (JAVA - 130)) | (1L << (JOIN - 130)) | (1L << (KEEP - 130)) | (1L << (LANGUAGE - 130)))) != 0) || ((((_la - 194)) & ~0x3f) == 0 && ((1L << (_la - 194)) & ((1L << (LAST - 194)) | (1L << (LAST_VALUE - 194)) | (1L << (LEADING - 194)) | (1L << (LEFT - 194)) | (1L << (LEVEL - 194)) | (1L << (LIBRARY - 194)) | (1L << (LIKE2 - 194)) | (1L << (LIKE4 - 194)) | (1L << (LIKEC - 194)) | (1L << (LIMIT - 194)) | (1L << (LOCAL - 194)) | (1L << (LOCKED - 194)) | (1L << (LOG - 194)) | (1L << (LOGOFF - 194)) | (1L << (LOGON - 194)) | (1L << (LONG - 194)) | (1L << (LOOP - 194)) | (1L << (MAIN - 194)) | (1L << (MAP - 194)) | (1L << (MATCHED - 194)) | (1L << (MAXVALUE - 194)) | (1L << (MEASURES - 194)) | (1L << (MEMBER - 194)) | (1L << (MERGE - 194)) | (1L << (MINUTE - 194)) | (1L << (MINVALUE - 194)) | (1L << (MLSLABEL - 194)) | (1L << (MODEL - 194)) | (1L << (MODIFY - 194)) | (1L << (MONTH - 194)) | (1L << (MULTISET - 194)) | (1L << (NAME - 194)) | (1L << (NAN - 194)) | (1L << (NATURAL - 194)) | (1L << (NATURALN - 194)) | (1L << (NAV - 194)) | (1L << (NCHAR - 194)) | (1L << (NCHAR_CS - 194)) | (1L << (NCLOB - 194)) | (1L << (NESTED - 194)) | (1L << (NEW - 194)) | (1L << (NO - 194)) | (1L << (NOAUDIT - 194)) | (1L << (NOCOPY - 194)) | (1L << (NOCYCLE - 194)) | (1L << (NOENTITYESCAPING - 194)) | (1L << (NONE - 194)) | (1L << (NOSCHEMACHECK - 194)) | (1L << (NULLS - 194)) | (1L << (NUMBER - 194)) | (1L << (NUMERIC - 194)) | (1L << (NVARCHAR2 - 194)) | (1L << (OBJECT - 194)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (OFF - 259)) | (1L << (OID - 259)) | (1L << (OLD - 259)) | (1L << (ONLY - 259)) | (1L << (OPEN - 259)) | (1L << (ORADATA - 259)) | (1L << (ORDINALITY - 259)) | (1L << (OSERROR - 259)) | (1L << (OUT - 259)) | (1L << (OUTER - 259)) | (1L << (OVER - 259)) | (1L << (OVERRIDING - 259)) | (1L << (PACKAGE - 259)) | (1L << (PARALLEL_ENABLE - 259)) | (1L << (PARAMETERS - 259)) | (1L << (PARENT - 259)) | (1L << (PARTITION - 259)) | (1L << (PASSING - 259)) | (1L << (PATH - 259)) | (1L << (PIPELINED - 259)) | (1L << (PLAN - 259)) | (1L << (PLS_INTEGER - 259)) | (1L << (POSITIVE - 259)) | (1L << (POSITIVEN - 259)) | (1L << (PRAGMA - 259)) | (1L << (PRECEDING - 259)) | (1L << (PRECISION - 259)) | (1L << (PRESENT - 259)) | (1L << (RAISE - 259)) | (1L << (RANGE - 259)) | (1L << (RAW - 259)) | (1L << (READ - 259)) | (1L << (REAL - 259)) | (1L << (RECORD - 259)) | (1L << (REF - 259)) | (1L << (REFERENCE - 259)) | (1L << (REFERENCING - 259)) | (1L << (REJECT - 259)) | (1L << (RELIES_ON - 259)) | (1L << (RENAME - 259)) | (1L << (REPLACE - 259)) | (1L << (RESPECT - 259)) | (1L << (RESTRICT_REFERENCES - 259)) | (1L << (RESULT - 259)) | (1L << (RESULT_CACHE - 259)) | (1L << (RETURN - 259)) | (1L << (RETURNING - 259)) | (1L << (REUSE - 259)) | (1L << (REVERSE - 259)) | (1L << (RIGHT - 259)))) != 0) || ((((_la - 323)) & ~0x3f) == 0 && ((1L << (_la - 323)) & ((1L << (ROLLBACK - 323)) | (1L << (ROLLUP - 323)) | (1L << (ROW - 323)) | (1L << (ROWID - 323)) | (1L << (ROWS - 323)) | (1L << (RULES - 323)) | (1L << (SAMPLE - 323)) | (1L << (SAVE - 323)) | (1L << (SAVEPOINT - 323)) | (1L << (SCHEMA - 323)) | (1L << (SCHEMACHECK - 323)) | (1L << (SCN - 323)) | (1L << (SECOND - 323)) | (1L << (SEED - 323)) | (1L << (SEGMENT - 323)) | (1L << (SELF - 323)) | (1L << (SEQUENTIAL - 323)) | (1L << (SERIALIZABLE - 323)) | (1L << (SERIALLY_REUSABLE - 323)) | (1L << (SERVERERROR - 323)) | (1L << (SESSIONTIMEZONE - 323)) | (1L << (SET - 323)) | (1L << (SETS - 323)) | (1L << (SETTINGS - 323)) | (1L << (SHOW - 323)) | (1L << (SHUTDOWN - 323)) | (1L << (SIBLINGS - 323)) | (1L << (SIGNTYPE - 323)) | (1L << (SIMPLE_INTEGER - 323)) | (1L << (SINGLE - 323)) | (1L << (SKIP_ - 323)) | (1L << (SMALLINT - 323)) | (1L << (SNAPSHOT - 323)) | (1L << (SOME - 323)) | (1L << (SPECIFICATION - 323)) | (1L << (SQLDATA - 323)) | (1L << (SQLERROR - 323)) | (1L << (STANDALONE - 323)) | (1L << (STARTUP - 323)) | (1L << (STATEMENT - 323)) | (1L << (STATEMENT_ID - 323)) | (1L << (STATIC - 323)) | (1L << (STATISTICS - 323)) | (1L << (STRING - 323)) | (1L << (SUBMULTISET - 323)) | (1L << (SUBPARTITION - 323)) | (1L << (SUBSTITUTABLE - 323)) | (1L << (SUBTYPE - 323)) | (1L << (SUCCESS - 323)) | (1L << (SUSPEND - 323)) | (1L << (TIME - 323)) | (1L << (TIMESTAMP - 323)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_UNCONSTRAINED - 323)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TIMEZONE_ABBR - 387)) | (1L << (TIMEZONE_HOUR - 387)) | (1L << (TIMEZONE_MINUTE - 387)) | (1L << (TIMEZONE_REGION - 387)) | (1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (YMINTERVAL_UNCONSTRAINED - 451)) | (1L << (ZONE - 451)) | (1L << (PREDICTION - 451)) | (1L << (PREDICTION_BOUNDS - 451)) | (1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (COVAR_ - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (REGR_ - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (TRIM - 451)) | (1L << (SUM - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (VARIANCE - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==REGULAR_ID) {
				{
				State = 2181;
				_la = _input.La(1);
				if (_la==IN) {
					{
					State = 2180; Match(IN);
					}
				}

				State = 2183; type_spec();
				}
			}

			State = 2187;
			_la = _input.La(1);
			if (_la==DEFAULT || _la==ASSIGN_OP) {
				{
				State = 2186; default_value_part();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Exception_declarationContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode EXCEPTION() { return GetToken(plsqlParser.EXCEPTION, 0); }
		public Exception_declarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exception_declaration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterException_declaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitException_declaration(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitException_declaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Exception_declarationContext exception_declaration() {
		Exception_declarationContext _localctx = new Exception_declarationContext(_ctx, State);
		EnterRule(_localctx, 204, RULE_exception_declaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2189; identifier();
			State = 2190; Match(EXCEPTION);
			State = 2191; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Pragma_declarationContext : ParserRuleContext {
		public IdentifierContext id1;
		public ITerminalNode RESTRICT_REFERENCES() { return GetToken(plsqlParser.RESTRICT_REFERENCES, 0); }
		public IdentifierContext identifier(int i) {
			return GetRuleContext<IdentifierContext>(i);
		}
		public ITerminalNode SERIALLY_REUSABLE() { return GetToken(plsqlParser.SERIALLY_REUSABLE, 0); }
		public ITerminalNode AUTONOMOUS_TRANSACTION() { return GetToken(plsqlParser.AUTONOMOUS_TRANSACTION, 0); }
		public ITerminalNode EXCEPTION_INIT() { return GetToken(plsqlParser.EXCEPTION_INIT, 0); }
		public ITerminalNode INLINE() { return GetToken(plsqlParser.INLINE, 0); }
		public ITerminalNode PRAGMA() { return GetToken(plsqlParser.PRAGMA, 0); }
		public Exception_nameContext exception_name() {
			return GetRuleContext<Exception_nameContext>(0);
		}
		public IReadOnlyList<IdentifierContext> identifier() {
			return GetRuleContexts<IdentifierContext>();
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode DEFAULT() { return GetToken(plsqlParser.DEFAULT, 0); }
		public Numeric_negativeContext numeric_negative() {
			return GetRuleContext<Numeric_negativeContext>(0);
		}
		public Pragma_declarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pragma_declaration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterPragma_declaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitPragma_declaration(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPragma_declaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Pragma_declarationContext pragma_declaration() {
		Pragma_declarationContext _localctx = new Pragma_declarationContext(_ctx, State);
		EnterRule(_localctx, 206, RULE_pragma_declaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2193; Match(PRAGMA);
			State = 2224;
			switch (_input.La(1)) {
			case SERIALLY_REUSABLE:
				{
				State = 2194; Match(SERIALLY_REUSABLE);
				}
				break;
			case AUTONOMOUS_TRANSACTION:
				{
				State = 2195; Match(AUTONOMOUS_TRANSACTION);
				}
				break;
			case EXCEPTION_INIT:
				{
				State = 2196; Match(EXCEPTION_INIT);
				State = 2197; Match(LEFT_PAREN);
				State = 2198; exception_name();
				State = 2199; Match(COMMA);
				State = 2200; numeric_negative();
				State = 2201; Match(RIGHT_PAREN);
				}
				break;
			case INLINE:
				{
				State = 2203; Match(INLINE);
				State = 2204; Match(LEFT_PAREN);
				State = 2205; _localctx.id1 = identifier();
				State = 2206; Match(COMMA);
				State = 2207; expression();
				State = 2208; Match(RIGHT_PAREN);
				}
				break;
			case RESTRICT_REFERENCES:
				{
				State = 2210; Match(RESTRICT_REFERENCES);
				State = 2211; Match(LEFT_PAREN);
				State = 2214;
				switch (_input.La(1)) {
				case A_LETTER:
				case ADD:
				case AFTER:
				case AGENT:
				case AGGREGATE:
				case ANALYZE:
				case ARRAY:
				case ASSOCIATE:
				case AT:
				case ATTRIBUTE:
				case AUDIT:
				case AUTHID:
				case AUTO:
				case AUTOMATIC:
				case AUTONOMOUS_TRANSACTION:
				case BATCH:
				case BEFORE:
				case BFILE:
				case BINARY_DOUBLE:
				case BINARY_FLOAT:
				case BINARY_INTEGER:
				case BLOB:
				case BLOCK:
				case BODY:
				case BOOLEAN:
				case BOTH:
				case BULK:
				case BYTE:
				case C_LETTER:
				case CALL:
				case CANONICAL:
				case CASCADE:
				case CAST:
				case CHAR:
				case CHAR_CS:
				case CHARACTER:
				case CHR:
				case CLOB:
				case CLOSE:
				case CLUSTER:
				case COLLECT:
				case COLUMNS:
				case COMMENT:
				case COMMIT:
				case COMMITTED:
				case COMPATIBILITY:
				case COMPILE:
				case COMPOUND:
				case CONSTANT:
				case CONSTRAINT:
				case CONSTRAINTS:
				case CONSTRUCTOR:
				case CONTENT:
				case CONTEXT:
				case CONTINUE:
				case CONVERT:
				case CORRUPT_XID:
				case CORRUPT_XID_ALL:
				case COST:
				case COUNT:
				case CROSS:
				case CUBE:
				case CURRENT_USER:
				case CURSOR:
				case CUSTOMDATUM:
				case CYCLE:
				case DATA:
				case DATABASE:
				case DAY:
				case DB_ROLE_CHANGE:
				case DBTIMEZONE:
				case DDL:
				case DEBUG:
				case DEC:
				case DECIMAL:
				case DECOMPOSE:
				case DECREMENT:
				case DEFAULTS:
				case DEFERRED:
				case DEFINER:
				case DETERMINISTIC:
				case DIMENSION:
				case DISABLE:
				case DISASSOCIATE:
				case DOCUMENT:
				case DOUBLE:
				case DSINTERVAL_UNCONSTRAINED:
				case EACH:
				case ELEMENT:
				case EMPTY:
				case ENABLE:
				case ENCODING:
				case ENTITYESCAPING:
				case ERR:
				case ERRORS:
				case ESCAPE:
				case EVALNAME:
				case EXCEPTION:
				case EXCEPTION_INIT:
				case EXCEPTIONS:
				case EXCLUDE:
				case EXECUTE:
				case EXIT:
				case EXPLAIN:
				case EXTERNAL:
				case EXTRACT:
				case FAILURE:
				case FINAL:
				case FIRST:
				case FIRST_VALUE:
				case FLOAT:
				case FOLLOWING:
				case FOLLOWS:
				case FORALL:
				case FORCE:
				case FULL:
				case FUNCTION:
				case GROUPING:
				case HASH:
				case HIDE:
				case HOUR:
				case IGNORE:
				case IMMEDIATE:
				case INCLUDE:
				case INCLUDING:
				case INCREMENT:
				case INDENT:
				case INDEXED:
				case INDICATOR:
				case INDICES:
				case INFINITE:
				case INLINE:
				case INNER:
				case INOUT:
				case INSTANTIABLE:
				case INSTEAD:
				case INT:
				case INTEGER:
				case INTERVAL:
				case INVALIDATE:
				case ISOLATION:
				case ITERATE:
				case JAVA:
				case JOIN:
				case KEEP:
				case LANGUAGE:
				case LAST:
				case LAST_VALUE:
				case LEADING:
				case LEFT:
				case LEVEL:
				case LIBRARY:
				case LIKE2:
				case LIKE4:
				case LIKEC:
				case LIMIT:
				case LOCAL:
				case LOCKED:
				case LOG:
				case LOGOFF:
				case LOGON:
				case LONG:
				case LOOP:
				case MAIN:
				case MAP:
				case MATCHED:
				case MAXVALUE:
				case MEASURES:
				case MEMBER:
				case MERGE:
				case MINUTE:
				case MINVALUE:
				case MLSLABEL:
				case MODEL:
				case MODIFY:
				case MONTH:
				case MULTISET:
				case NAME:
				case NAN:
				case NATURAL:
				case NATURALN:
				case NAV:
				case NCHAR:
				case NCHAR_CS:
				case NCLOB:
				case NESTED:
				case NEW:
				case NO:
				case NOAUDIT:
				case NOCOPY:
				case NOCYCLE:
				case NOENTITYESCAPING:
				case NONE:
				case NOSCHEMACHECK:
				case NULLS:
				case NUMBER:
				case NUMERIC:
				case NVARCHAR2:
				case OBJECT:
				case OFF:
				case OID:
				case OLD:
				case ONLY:
				case OPEN:
				case ORADATA:
				case ORDINALITY:
				case OSERROR:
				case OUT:
				case OUTER:
				case OVER:
				case OVERRIDING:
				case PACKAGE:
				case PARALLEL_ENABLE:
				case PARAMETERS:
				case PARENT:
				case PARTITION:
				case PASSING:
				case PATH:
				case PIPELINED:
				case PLAN:
				case PLS_INTEGER:
				case POSITIVE:
				case POSITIVEN:
				case PRAGMA:
				case PRECEDING:
				case PRECISION:
				case PRESENT:
				case RAISE:
				case RANGE:
				case RAW:
				case READ:
				case REAL:
				case RECORD:
				case REF:
				case REFERENCE:
				case REFERENCING:
				case REJECT:
				case RELIES_ON:
				case RENAME:
				case REPLACE:
				case RESPECT:
				case RESTRICT_REFERENCES:
				case RESULT:
				case RESULT_CACHE:
				case RETURN:
				case RETURNING:
				case REUSE:
				case REVERSE:
				case RIGHT:
				case ROLLBACK:
				case ROLLUP:
				case ROW:
				case ROWID:
				case ROWS:
				case RULES:
				case SAMPLE:
				case SAVE:
				case SAVEPOINT:
				case SCHEMA:
				case SCHEMACHECK:
				case SCN:
				case SECOND:
				case SEED:
				case SEGMENT:
				case SELF:
				case SEQUENTIAL:
				case SERIALIZABLE:
				case SERIALLY_REUSABLE:
				case SERVERERROR:
				case SESSIONTIMEZONE:
				case SET:
				case SETS:
				case SETTINGS:
				case SHOW:
				case SHUTDOWN:
				case SIBLINGS:
				case SIGNTYPE:
				case SIMPLE_INTEGER:
				case SINGLE:
				case SKIP_:
				case SMALLINT:
				case SNAPSHOT:
				case SOME:
				case SPECIFICATION:
				case SQLDATA:
				case SQLERROR:
				case STANDALONE:
				case STARTUP:
				case STATEMENT:
				case STATEMENT_ID:
				case STATIC:
				case STATISTICS:
				case STRING:
				case SUBMULTISET:
				case SUBPARTITION:
				case SUBSTITUTABLE:
				case SUBTYPE:
				case SUCCESS:
				case SUSPEND:
				case TIME:
				case TIMESTAMP:
				case TIMESTAMP_LTZ_UNCONSTRAINED:
				case TIMESTAMP_TZ_UNCONSTRAINED:
				case TIMESTAMP_UNCONSTRAINED:
				case TIMEZONE_ABBR:
				case TIMEZONE_HOUR:
				case TIMEZONE_MINUTE:
				case TIMEZONE_REGION:
				case TRAILING:
				case TRANSACTION:
				case TRANSLATE:
				case TREAT:
				case TRIGGER:
				case TRUNCATE:
				case TYPE:
				case UNBOUNDED:
				case UNDER:
				case UNLIMITED:
				case UNTIL:
				case UPDATED:
				case UPSERT:
				case UROWID:
				case USE:
				case VALIDATE:
				case VALUE:
				case VARCHAR:
				case VARCHAR2:
				case VARIABLE:
				case VARRAY:
				case VARYING:
				case VERSION:
				case VERSIONS:
				case WAIT:
				case WARNING:
				case WELLFORMED:
				case WHENEVER:
				case WHILE:
				case WITHIN:
				case WORK:
				case WRITE:
				case XML:
				case XMLAGG:
				case XMLATTRIBUTES:
				case XMLCAST:
				case XMLCOLATTVAL:
				case XMLELEMENT:
				case XMLEXISTS:
				case XMLFOREST:
				case XMLNAMESPACES:
				case XMLPARSE:
				case XMLPI:
				case XMLQUERY:
				case XMLROOT:
				case XMLSERIALIZE:
				case XMLTABLE:
				case YEAR:
				case YES:
				case YMINTERVAL_UNCONSTRAINED:
				case ZONE:
				case PREDICTION:
				case PREDICTION_BOUNDS:
				case PREDICTION_COST:
				case PREDICTION_DETAILS:
				case PREDICTION_PROBABILITY:
				case PREDICTION_SET:
				case CUME_DIST:
				case DENSE_RANK:
				case LISTAGG:
				case PERCENT_RANK:
				case PERCENTILE_CONT:
				case PERCENTILE_DISC:
				case RANK:
				case AVG:
				case CORR:
				case COVAR_:
				case LAG:
				case LEAD:
				case MAX:
				case MEDIAN:
				case MIN:
				case NTILE:
				case RATIO_TO_REPORT:
				case REGR_:
				case ROW_NUMBER:
				case TRIM:
				case SUM:
				case STDDEV:
				case VAR_:
				case VARIANCE:
				case DELIMITED_ID:
				case INTRODUCER:
				case REGULAR_ID:
					{
					State = 2212; identifier();
					}
					break;
				case DEFAULT:
					{
					State = 2213; Match(DEFAULT);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 2218;
				_errHandler.Sync(this);
				_la = _input.La(1);
				do {
					{
					{
					State = 2216; Match(COMMA);
					State = 2217; identifier();
					}
					}
					State = 2220;
					_errHandler.Sync(this);
					_la = _input.La(1);
				} while ( _la==COMMA );
				State = 2222; Match(RIGHT_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2226; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Record_type_defContext : ParserRuleContext {
		public IReadOnlyList<Field_specContext> field_spec() {
			return GetRuleContexts<Field_specContext>();
		}
		public ITerminalNode RECORD() { return GetToken(plsqlParser.RECORD, 0); }
		public Field_specContext field_spec(int i) {
			return GetRuleContext<Field_specContext>(i);
		}
		public Record_type_defContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_record_type_def; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterRecord_type_def(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitRecord_type_def(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRecord_type_def(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Record_type_defContext record_type_def() {
		Record_type_defContext _localctx = new Record_type_defContext(_ctx, State);
		EnterRule(_localctx, 208, RULE_record_type_def);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2228; Match(RECORD);
			State = 2229; Match(LEFT_PAREN);
			State = 2230; field_spec();
			State = 2235;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 2231; Match(COMMA);
				State = 2232; field_spec();
				}
				}
				State = 2237;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 2238; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Field_specContext : ParserRuleContext {
		public ITerminalNode NOT() { return GetToken(plsqlParser.NOT, 0); }
		public Default_value_partContext default_value_part() {
			return GetRuleContext<Default_value_partContext>(0);
		}
		public Column_nameContext column_name() {
			return GetRuleContext<Column_nameContext>(0);
		}
		public ITerminalNode NULL() { return GetToken(plsqlParser.NULL, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public Field_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_field_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterField_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitField_spec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitField_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Field_specContext field_spec() {
		Field_specContext _localctx = new Field_specContext(_ctx, State);
		EnterRule(_localctx, 210, RULE_field_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2240; column_name();
			State = 2242;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (CONSTANT - 66)) | (1L << (CONSTRAINT - 66)) | (1L << (CONSTRAINTS - 66)) | (1L << (CONSTRUCTOR - 66)) | (1L << (CONTENT - 66)) | (1L << (CONTEXT - 66)) | (1L << (CONTINUE - 66)) | (1L << (CONVERT - 66)) | (1L << (CORRUPT_XID - 66)) | (1L << (CORRUPT_XID_ALL - 66)) | (1L << (COST - 66)) | (1L << (COUNT - 66)) | (1L << (CROSS - 66)) | (1L << (CUBE - 66)) | (1L << (CURRENT_USER - 66)) | (1L << (CURSOR - 66)) | (1L << (CUSTOMDATUM - 66)) | (1L << (CYCLE - 66)) | (1L << (DATA - 66)) | (1L << (DATABASE - 66)) | (1L << (DATE - 66)) | (1L << (DAY - 66)) | (1L << (DB_ROLE_CHANGE - 66)) | (1L << (DBTIMEZONE - 66)) | (1L << (DDL - 66)) | (1L << (DEBUG - 66)) | (1L << (DEC - 66)) | (1L << (DECIMAL - 66)) | (1L << (DECOMPOSE - 66)) | (1L << (DECREMENT - 66)) | (1L << (DEFAULTS - 66)) | (1L << (DEFERRED - 66)) | (1L << (DEFINER - 66)) | (1L << (DETERMINISTIC - 66)) | (1L << (DIMENSION - 66)) | (1L << (DISABLE - 66)) | (1L << (DISASSOCIATE - 66)) | (1L << (DOCUMENT - 66)) | (1L << (DOUBLE - 66)) | (1L << (DSINTERVAL_UNCONSTRAINED - 66)) | (1L << (EACH - 66)) | (1L << (ELEMENT - 66)) | (1L << (EMPTY - 66)) | (1L << (ENABLE - 66)) | (1L << (ENCODING - 66)) | (1L << (ENTITYESCAPING - 66)) | (1L << (ERR - 66)) | (1L << (ERRORS - 66)) | (1L << (ESCAPE - 66)) | (1L << (EVALNAME - 66)) | (1L << (EXCEPTION - 66)) | (1L << (EXCEPTION_INIT - 66)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)) | (1L << (EXIT - 130)) | (1L << (EXPLAIN - 130)) | (1L << (EXTERNAL - 130)) | (1L << (EXTRACT - 130)) | (1L << (FAILURE - 130)) | (1L << (FINAL - 130)) | (1L << (FIRST - 130)) | (1L << (FIRST_VALUE - 130)) | (1L << (FLOAT - 130)) | (1L << (FOLLOWING - 130)) | (1L << (FOLLOWS - 130)) | (1L << (FORALL - 130)) | (1L << (FORCE - 130)) | (1L << (FULL - 130)) | (1L << (FUNCTION - 130)) | (1L << (GROUPING - 130)) | (1L << (HASH - 130)) | (1L << (HIDE - 130)) | (1L << (HOUR - 130)) | (1L << (IGNORE - 130)) | (1L << (IMMEDIATE - 130)) | (1L << (INCLUDE - 130)) | (1L << (INCLUDING - 130)) | (1L << (INCREMENT - 130)) | (1L << (INDENT - 130)) | (1L << (INDEXED - 130)) | (1L << (INDICATOR - 130)) | (1L << (INDICES - 130)) | (1L << (INFINITE - 130)) | (1L << (INLINE - 130)) | (1L << (INNER - 130)) | (1L << (INOUT - 130)) | (1L << (INSTANTIABLE - 130)) | (1L << (INSTEAD - 130)) | (1L << (INT - 130)) | (1L << (INTEGER - 130)) | (1L << (INTERVAL - 130)) | (1L << (INVALIDATE - 130)) | (1L << (ISOLATION - 130)) | (1L << (ITERATE - 130)) | (1L << (JAVA - 130)) | (1L << (JOIN - 130)) | (1L << (KEEP - 130)) | (1L << (LANGUAGE - 130)))) != 0) || ((((_la - 194)) & ~0x3f) == 0 && ((1L << (_la - 194)) & ((1L << (LAST - 194)) | (1L << (LAST_VALUE - 194)) | (1L << (LEADING - 194)) | (1L << (LEFT - 194)) | (1L << (LEVEL - 194)) | (1L << (LIBRARY - 194)) | (1L << (LIKE2 - 194)) | (1L << (LIKE4 - 194)) | (1L << (LIKEC - 194)) | (1L << (LIMIT - 194)) | (1L << (LOCAL - 194)) | (1L << (LOCKED - 194)) | (1L << (LOG - 194)) | (1L << (LOGOFF - 194)) | (1L << (LOGON - 194)) | (1L << (LONG - 194)) | (1L << (LOOP - 194)) | (1L << (MAIN - 194)) | (1L << (MAP - 194)) | (1L << (MATCHED - 194)) | (1L << (MAXVALUE - 194)) | (1L << (MEASURES - 194)) | (1L << (MEMBER - 194)) | (1L << (MERGE - 194)) | (1L << (MINUTE - 194)) | (1L << (MINVALUE - 194)) | (1L << (MLSLABEL - 194)) | (1L << (MODEL - 194)) | (1L << (MODIFY - 194)) | (1L << (MONTH - 194)) | (1L << (MULTISET - 194)) | (1L << (NAME - 194)) | (1L << (NAN - 194)) | (1L << (NATURAL - 194)) | (1L << (NATURALN - 194)) | (1L << (NAV - 194)) | (1L << (NCHAR - 194)) | (1L << (NCHAR_CS - 194)) | (1L << (NCLOB - 194)) | (1L << (NESTED - 194)) | (1L << (NEW - 194)) | (1L << (NO - 194)) | (1L << (NOAUDIT - 194)) | (1L << (NOCOPY - 194)) | (1L << (NOCYCLE - 194)) | (1L << (NOENTITYESCAPING - 194)) | (1L << (NONE - 194)) | (1L << (NOSCHEMACHECK - 194)) | (1L << (NULLS - 194)) | (1L << (NUMBER - 194)) | (1L << (NUMERIC - 194)) | (1L << (NVARCHAR2 - 194)) | (1L << (OBJECT - 194)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (OFF - 259)) | (1L << (OID - 259)) | (1L << (OLD - 259)) | (1L << (ONLY - 259)) | (1L << (OPEN - 259)) | (1L << (ORADATA - 259)) | (1L << (ORDINALITY - 259)) | (1L << (OSERROR - 259)) | (1L << (OUT - 259)) | (1L << (OUTER - 259)) | (1L << (OVER - 259)) | (1L << (OVERRIDING - 259)) | (1L << (PACKAGE - 259)) | (1L << (PARALLEL_ENABLE - 259)) | (1L << (PARAMETERS - 259)) | (1L << (PARENT - 259)) | (1L << (PARTITION - 259)) | (1L << (PASSING - 259)) | (1L << (PATH - 259)) | (1L << (PIPELINED - 259)) | (1L << (PLAN - 259)) | (1L << (PLS_INTEGER - 259)) | (1L << (POSITIVE - 259)) | (1L << (POSITIVEN - 259)) | (1L << (PRAGMA - 259)) | (1L << (PRECEDING - 259)) | (1L << (PRECISION - 259)) | (1L << (PRESENT - 259)) | (1L << (RAISE - 259)) | (1L << (RANGE - 259)) | (1L << (RAW - 259)) | (1L << (READ - 259)) | (1L << (REAL - 259)) | (1L << (RECORD - 259)) | (1L << (REF - 259)) | (1L << (REFERENCE - 259)) | (1L << (REFERENCING - 259)) | (1L << (REJECT - 259)) | (1L << (RELIES_ON - 259)) | (1L << (RENAME - 259)) | (1L << (REPLACE - 259)) | (1L << (RESPECT - 259)) | (1L << (RESTRICT_REFERENCES - 259)) | (1L << (RESULT - 259)) | (1L << (RESULT_CACHE - 259)) | (1L << (RETURN - 259)) | (1L << (RETURNING - 259)) | (1L << (REUSE - 259)) | (1L << (REVERSE - 259)) | (1L << (RIGHT - 259)))) != 0) || ((((_la - 323)) & ~0x3f) == 0 && ((1L << (_la - 323)) & ((1L << (ROLLBACK - 323)) | (1L << (ROLLUP - 323)) | (1L << (ROW - 323)) | (1L << (ROWID - 323)) | (1L << (ROWS - 323)) | (1L << (RULES - 323)) | (1L << (SAMPLE - 323)) | (1L << (SAVE - 323)) | (1L << (SAVEPOINT - 323)) | (1L << (SCHEMA - 323)) | (1L << (SCHEMACHECK - 323)) | (1L << (SCN - 323)) | (1L << (SECOND - 323)) | (1L << (SEED - 323)) | (1L << (SEGMENT - 323)) | (1L << (SELF - 323)) | (1L << (SEQUENTIAL - 323)) | (1L << (SERIALIZABLE - 323)) | (1L << (SERIALLY_REUSABLE - 323)) | (1L << (SERVERERROR - 323)) | (1L << (SESSIONTIMEZONE - 323)) | (1L << (SET - 323)) | (1L << (SETS - 323)) | (1L << (SETTINGS - 323)) | (1L << (SHOW - 323)) | (1L << (SHUTDOWN - 323)) | (1L << (SIBLINGS - 323)) | (1L << (SIGNTYPE - 323)) | (1L << (SIMPLE_INTEGER - 323)) | (1L << (SINGLE - 323)) | (1L << (SKIP_ - 323)) | (1L << (SMALLINT - 323)) | (1L << (SNAPSHOT - 323)) | (1L << (SOME - 323)) | (1L << (SPECIFICATION - 323)) | (1L << (SQLDATA - 323)) | (1L << (SQLERROR - 323)) | (1L << (STANDALONE - 323)) | (1L << (STARTUP - 323)) | (1L << (STATEMENT - 323)) | (1L << (STATEMENT_ID - 323)) | (1L << (STATIC - 323)) | (1L << (STATISTICS - 323)) | (1L << (STRING - 323)) | (1L << (SUBMULTISET - 323)) | (1L << (SUBPARTITION - 323)) | (1L << (SUBSTITUTABLE - 323)) | (1L << (SUBTYPE - 323)) | (1L << (SUCCESS - 323)) | (1L << (SUSPEND - 323)) | (1L << (TIME - 323)) | (1L << (TIMESTAMP - 323)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_UNCONSTRAINED - 323)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TIMEZONE_ABBR - 387)) | (1L << (TIMEZONE_HOUR - 387)) | (1L << (TIMEZONE_MINUTE - 387)) | (1L << (TIMEZONE_REGION - 387)) | (1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (YMINTERVAL_UNCONSTRAINED - 451)) | (1L << (ZONE - 451)) | (1L << (PREDICTION - 451)) | (1L << (PREDICTION_BOUNDS - 451)) | (1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (COVAR_ - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (REGR_ - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (TRIM - 451)) | (1L << (SUM - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (VARIANCE - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==REGULAR_ID) {
				{
				State = 2241; type_spec();
				}
			}

			State = 2246;
			_la = _input.La(1);
			if (_la==NOT) {
				{
				State = 2244; Match(NOT);
				State = 2245; Match(NULL);
				}
			}

			State = 2249;
			_la = _input.La(1);
			if (_la==DEFAULT || _la==ASSIGN_OP) {
				{
				State = 2248; default_value_part();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Ref_cursor_type_defContext : ParserRuleContext {
		public ITerminalNode CURSOR() { return GetToken(plsqlParser.CURSOR, 0); }
		public ITerminalNode RETURN() { return GetToken(plsqlParser.RETURN, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode REF() { return GetToken(plsqlParser.REF, 0); }
		public Ref_cursor_type_defContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ref_cursor_type_def; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterRef_cursor_type_def(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitRef_cursor_type_def(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRef_cursor_type_def(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Ref_cursor_type_defContext ref_cursor_type_def() {
		Ref_cursor_type_defContext _localctx = new Ref_cursor_type_defContext(_ctx, State);
		EnterRule(_localctx, 212, RULE_ref_cursor_type_def);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2251; Match(REF);
			State = 2252; Match(CURSOR);
			State = 2255;
			_la = _input.La(1);
			if (_la==RETURN) {
				{
				State = 2253; Match(RETURN);
				State = 2254; type_spec();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Type_declarationContext : ParserRuleContext {
		public Varray_type_defContext varray_type_def() {
			return GetRuleContext<Varray_type_defContext>(0);
		}
		public ITerminalNode IS() { return GetToken(plsqlParser.IS, 0); }
		public Record_type_defContext record_type_def() {
			return GetRuleContext<Record_type_defContext>(0);
		}
		public ITerminalNode TYPE() { return GetToken(plsqlParser.TYPE, 0); }
		public Table_type_defContext table_type_def() {
			return GetRuleContext<Table_type_defContext>(0);
		}
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Ref_cursor_type_defContext ref_cursor_type_def() {
			return GetRuleContext<Ref_cursor_type_defContext>(0);
		}
		public Type_declarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_declaration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterType_declaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitType_declaration(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_declaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Type_declarationContext type_declaration() {
		Type_declarationContext _localctx = new Type_declarationContext(_ctx, State);
		EnterRule(_localctx, 214, RULE_type_declaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2257; Match(TYPE);
			State = 2258; identifier();
			State = 2259; Match(IS);
			State = 2264;
			switch (_input.La(1)) {
			case TABLE:
				{
				State = 2260; table_type_def();
				}
				break;
			case VARRAY:
			case VARYING:
				{
				State = 2261; varray_type_def();
				}
				break;
			case RECORD:
				{
				State = 2262; record_type_def();
				}
				break;
			case REF:
				{
				State = 2263; ref_cursor_type_def();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2266; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_type_defContext : ParserRuleContext {
		public Table_indexed_by_partContext table_indexed_by_part() {
			return GetRuleContext<Table_indexed_by_partContext>(0);
		}
		public ITerminalNode NOT() { return GetToken(plsqlParser.NOT, 0); }
		public ITerminalNode NULL() { return GetToken(plsqlParser.NULL, 0); }
		public ITerminalNode OF() { return GetToken(plsqlParser.OF, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode TABLE() { return GetToken(plsqlParser.TABLE, 0); }
		public Table_type_defContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_type_def; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterTable_type_def(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitTable_type_def(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTable_type_def(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Table_type_defContext table_type_def() {
		Table_type_defContext _localctx = new Table_type_defContext(_ctx, State);
		EnterRule(_localctx, 216, RULE_table_type_def);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2268; Match(TABLE);
			State = 2269; Match(OF);
			State = 2270; type_spec();
			State = 2272;
			_la = _input.La(1);
			if (_la==INDEX || _la==INDEXED) {
				{
				State = 2271; table_indexed_by_part();
				}
			}

			State = 2276;
			_la = _input.La(1);
			if (_la==NOT) {
				{
				State = 2274; Match(NOT);
				State = 2275; Match(NULL);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_indexed_by_partContext : ParserRuleContext {
		public IToken idx1;
		public IToken idx2;
		public ITerminalNode INDEX() { return GetToken(plsqlParser.INDEX, 0); }
		public ITerminalNode INDEXED() { return GetToken(plsqlParser.INDEXED, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode BY() { return GetToken(plsqlParser.BY, 0); }
		public Table_indexed_by_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_indexed_by_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterTable_indexed_by_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitTable_indexed_by_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTable_indexed_by_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Table_indexed_by_partContext table_indexed_by_part() {
		Table_indexed_by_partContext _localctx = new Table_indexed_by_partContext(_ctx, State);
		EnterRule(_localctx, 218, RULE_table_indexed_by_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2280;
			switch (_input.La(1)) {
			case INDEXED:
				{
				State = 2278; _localctx.idx1 = Match(INDEXED);
				}
				break;
			case INDEX:
				{
				State = 2279; _localctx.idx2 = Match(INDEX);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2282; Match(BY);
			State = 2283; type_spec();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Varray_type_defContext : ParserRuleContext {
		public ITerminalNode NOT() { return GetToken(plsqlParser.NOT, 0); }
		public ITerminalNode ARRAY() { return GetToken(plsqlParser.ARRAY, 0); }
		public ITerminalNode NULL() { return GetToken(plsqlParser.NULL, 0); }
		public ITerminalNode OF() { return GetToken(plsqlParser.OF, 0); }
		public ITerminalNode VARYING() { return GetToken(plsqlParser.VARYING, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode VARRAY() { return GetToken(plsqlParser.VARRAY, 0); }
		public Varray_type_defContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_varray_type_def; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterVarray_type_def(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitVarray_type_def(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVarray_type_def(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Varray_type_defContext varray_type_def() {
		Varray_type_defContext _localctx = new Varray_type_defContext(_ctx, State);
		EnterRule(_localctx, 220, RULE_varray_type_def);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2288;
			switch (_input.La(1)) {
			case VARRAY:
				{
				State = 2285; Match(VARRAY);
				}
				break;
			case VARYING:
				{
				State = 2286; Match(VARYING);
				State = 2287; Match(ARRAY);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2290; Match(LEFT_PAREN);
			State = 2291; expression();
			State = 2292; Match(RIGHT_PAREN);
			State = 2293; Match(OF);
			State = 2294; type_spec();
			State = 2297;
			switch ( Interpreter.AdaptivePredict(_input,217,_ctx) ) {
			case 1:
				{
				State = 2295; Match(NOT);
				State = 2296; Match(NULL);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Seq_of_statementsContext : ParserRuleContext {
		public ITerminalNode Eof(int i) {
			return GetToken(plsqlParser.Eof, i);
		}
		public Label_declarationContext label_declaration(int i) {
			return GetRuleContext<Label_declarationContext>(i);
		}
		public IReadOnlyList<ITerminalNode> Eof() { return GetTokens(plsqlParser.Eof); }
		public IReadOnlyList<Label_declarationContext> label_declaration() {
			return GetRuleContexts<Label_declarationContext>();
		}
		public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		public IReadOnlyList<StatementContext> statement() {
			return GetRuleContexts<StatementContext>();
		}
		public Seq_of_statementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_seq_of_statements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSeq_of_statements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSeq_of_statements(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSeq_of_statements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Seq_of_statementsContext seq_of_statements() {
		Seq_of_statementsContext _localctx = new Seq_of_statementsContext(_ctx, State);
		EnterRule(_localctx, 222, RULE_seq_of_statements);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2303;
			_errHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					State = 2303;
					switch (_input.La(1)) {
					case A_LETTER:
					case ADD:
					case AFTER:
					case AGENT:
					case AGGREGATE:
					case ALTER:
					case ANALYZE:
					case ARRAY:
					case ASSOCIATE:
					case AT:
					case ATTRIBUTE:
					case AUDIT:
					case AUTHID:
					case AUTO:
					case AUTOMATIC:
					case AUTONOMOUS_TRANSACTION:
					case BATCH:
					case BEFORE:
					case BEGIN:
					case BFILE:
					case BINARY_DOUBLE:
					case BINARY_FLOAT:
					case BINARY_INTEGER:
					case BLOB:
					case BLOCK:
					case BODY:
					case BOOLEAN:
					case BOTH:
					case BULK:
					case BYTE:
					case C_LETTER:
					case CALL:
					case CANONICAL:
					case CASCADE:
					case CASE:
					case CAST:
					case CHAR:
					case CHAR_CS:
					case CHARACTER:
					case CHR:
					case CLOB:
					case CLOSE:
					case CLUSTER:
					case COLLECT:
					case COLUMNS:
					case COMMENT:
					case COMMIT:
					case COMMITTED:
					case COMPATIBILITY:
					case COMPILE:
					case COMPOUND:
					case CONSTANT:
					case CONSTRAINT:
					case CONSTRAINTS:
					case CONSTRUCTOR:
					case CONTENT:
					case CONTEXT:
					case CONTINUE:
					case CONVERT:
					case CORRUPT_XID:
					case CORRUPT_XID_ALL:
					case COST:
					case COUNT:
					case CREATE:
					case CROSS:
					case CUBE:
					case CURRENT_USER:
					case CURSOR:
					case CUSTOMDATUM:
					case CYCLE:
					case DATA:
					case DATABASE:
					case DAY:
					case DB_ROLE_CHANGE:
					case DBTIMEZONE:
					case DDL:
					case DEBUG:
					case DEC:
					case DECIMAL:
					case DECLARE:
					case DECOMPOSE:
					case DECREMENT:
					case DEFAULTS:
					case DEFERRED:
					case DEFINER:
					case DELETE:
					case DETERMINISTIC:
					case DIMENSION:
					case DISABLE:
					case DISASSOCIATE:
					case DOCUMENT:
					case DOUBLE:
					case DSINTERVAL_UNCONSTRAINED:
					case EACH:
					case ELEMENT:
					case EMPTY:
					case ENABLE:
					case ENCODING:
					case ENTITYESCAPING:
					case ERR:
					case ERRORS:
					case ESCAPE:
					case EVALNAME:
					case EXCEPTION:
					case EXCEPTION_INIT:
					case EXCEPTIONS:
					case EXCLUDE:
					case EXECUTE:
					case EXIT:
					case EXPLAIN:
					case EXTERNAL:
					case EXTRACT:
					case FAILURE:
					case FETCH:
					case FINAL:
					case FIRST:
					case FIRST_VALUE:
					case FLOAT:
					case FOLLOWING:
					case FOLLOWS:
					case FOR:
					case FORALL:
					case FORCE:
					case FULL:
					case FUNCTION:
					case GOTO:
					case GRANT:
					case GROUPING:
					case HASH:
					case HIDE:
					case HOUR:
					case IF:
					case IGNORE:
					case IMMEDIATE:
					case INCLUDE:
					case INCLUDING:
					case INCREMENT:
					case INDENT:
					case INDEXED:
					case INDICATOR:
					case INDICES:
					case INFINITE:
					case INLINE:
					case INNER:
					case INOUT:
					case INSERT:
					case INSTANTIABLE:
					case INSTEAD:
					case INT:
					case INTEGER:
					case INTERVAL:
					case INVALIDATE:
					case ISOLATION:
					case ITERATE:
					case JAVA:
					case JOIN:
					case KEEP:
					case LANGUAGE:
					case LAST:
					case LAST_VALUE:
					case LEADING:
					case LEFT:
					case LEVEL:
					case LIBRARY:
					case LIKE2:
					case LIKE4:
					case LIKEC:
					case LIMIT:
					case LOCAL:
					case LOCK:
					case LOCKED:
					case LOG:
					case LOGOFF:
					case LOGON:
					case LONG:
					case LOOP:
					case MAIN:
					case MAP:
					case MATCHED:
					case MAXVALUE:
					case MEASURES:
					case MEMBER:
					case MERGE:
					case MINUTE:
					case MINVALUE:
					case MLSLABEL:
					case MODEL:
					case MODIFY:
					case MONTH:
					case MULTISET:
					case NAME:
					case NAN:
					case NATURAL:
					case NATURALN:
					case NAV:
					case NCHAR:
					case NCHAR_CS:
					case NCLOB:
					case NESTED:
					case NEW:
					case NO:
					case NOAUDIT:
					case NOCOPY:
					case NOCYCLE:
					case NOENTITYESCAPING:
					case NONE:
					case NOSCHEMACHECK:
					case NULL:
					case NULLS:
					case NUMBER:
					case NUMERIC:
					case NVARCHAR2:
					case OBJECT:
					case OFF:
					case OID:
					case OLD:
					case ONLY:
					case OPEN:
					case ORADATA:
					case ORDINALITY:
					case OSERROR:
					case OUT:
					case OUTER:
					case OVER:
					case OVERRIDING:
					case PACKAGE:
					case PARALLEL_ENABLE:
					case PARAMETERS:
					case PARENT:
					case PARTITION:
					case PASSING:
					case PATH:
					case PIPELINED:
					case PLAN:
					case PLS_INTEGER:
					case POSITIVE:
					case POSITIVEN:
					case PRAGMA:
					case PRECEDING:
					case PRECISION:
					case PRESENT:
					case PROCEDURE:
					case RAISE:
					case RANGE:
					case RAW:
					case READ:
					case REAL:
					case RECORD:
					case REF:
					case REFERENCE:
					case REFERENCING:
					case REJECT:
					case RELIES_ON:
					case RENAME:
					case REPLACE:
					case RESPECT:
					case RESTRICT_REFERENCES:
					case RESULT:
					case RESULT_CACHE:
					case RETURN:
					case RETURNING:
					case REUSE:
					case REVERSE:
					case RIGHT:
					case ROLLBACK:
					case ROLLUP:
					case ROW:
					case ROWID:
					case ROWS:
					case RULES:
					case SAMPLE:
					case SAVE:
					case SAVEPOINT:
					case SCHEMA:
					case SCHEMACHECK:
					case SCN:
					case SECOND:
					case SEED:
					case SEGMENT:
					case SELECT:
					case SELF:
					case SEQUENTIAL:
					case SERIALIZABLE:
					case SERIALLY_REUSABLE:
					case SERVERERROR:
					case SESSIONTIMEZONE:
					case SET:
					case SETS:
					case SETTINGS:
					case SHOW:
					case SHUTDOWN:
					case SIBLINGS:
					case SIGNTYPE:
					case SIMPLE_INTEGER:
					case SINGLE:
					case SKIP_:
					case SMALLINT:
					case SNAPSHOT:
					case SOME:
					case SPECIFICATION:
					case SQLDATA:
					case SQLERROR:
					case STANDALONE:
					case STARTUP:
					case STATEMENT:
					case STATEMENT_ID:
					case STATIC:
					case STATISTICS:
					case STRING:
					case SUBMULTISET:
					case SUBPARTITION:
					case SUBSTITUTABLE:
					case SUBTYPE:
					case SUCCESS:
					case SUSPEND:
					case TIME:
					case TIMESTAMP:
					case TIMESTAMP_LTZ_UNCONSTRAINED:
					case TIMESTAMP_TZ_UNCONSTRAINED:
					case TIMESTAMP_UNCONSTRAINED:
					case TIMEZONE_ABBR:
					case TIMEZONE_HOUR:
					case TIMEZONE_MINUTE:
					case TIMEZONE_REGION:
					case TRAILING:
					case TRANSACTION:
					case TRANSLATE:
					case TREAT:
					case TRIGGER:
					case TRUNCATE:
					case TYPE:
					case UNBOUNDED:
					case UNDER:
					case UNLIMITED:
					case UNTIL:
					case UPDATE:
					case UPDATED:
					case UPSERT:
					case UROWID:
					case USE:
					case VALIDATE:
					case VALUE:
					case VARCHAR:
					case VARCHAR2:
					case VARIABLE:
					case VARRAY:
					case VARYING:
					case VERSION:
					case VERSIONS:
					case WAIT:
					case WARNING:
					case WELLFORMED:
					case WHENEVER:
					case WHILE:
					case WITH:
					case WITHIN:
					case WORK:
					case WRITE:
					case XML:
					case XMLAGG:
					case XMLATTRIBUTES:
					case XMLCAST:
					case XMLCOLATTVAL:
					case XMLELEMENT:
					case XMLEXISTS:
					case XMLFOREST:
					case XMLNAMESPACES:
					case XMLPARSE:
					case XMLPI:
					case XMLQUERY:
					case XMLROOT:
					case XMLSERIALIZE:
					case XMLTABLE:
					case YEAR:
					case YES:
					case YMINTERVAL_UNCONSTRAINED:
					case ZONE:
					case PREDICTION:
					case PREDICTION_BOUNDS:
					case PREDICTION_COST:
					case PREDICTION_DETAILS:
					case PREDICTION_PROBABILITY:
					case PREDICTION_SET:
					case CUME_DIST:
					case DENSE_RANK:
					case LISTAGG:
					case PERCENT_RANK:
					case PERCENTILE_CONT:
					case PERCENTILE_DISC:
					case RANK:
					case AVG:
					case CORR:
					case COVAR_:
					case LAG:
					case LEAD:
					case MAX:
					case MEDIAN:
					case MIN:
					case NTILE:
					case RATIO_TO_REPORT:
					case REGR_:
					case ROW_NUMBER:
					case TRIM:
					case SUM:
					case STDDEV:
					case VAR_:
					case VARIANCE:
					case DELIMITED_ID:
					case LEFT_PAREN:
					case BINDVAR:
					case COLON:
					case INTRODUCER:
					case REGULAR_ID:
						{
						State = 2299; statement();
						State = 2300;
						_la = _input.La(1);
						if ( !(_la==Eof || _la==SEMICOLON) ) {
						_errHandler.RecoverInline(this);
						}
						Consume();
						}
						break;
					case LESS_THAN_OP:
						{
						State = 2302; label_declaration();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 2305;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,219,_ctx);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Label_declarationContext : ParserRuleContext {
		public IToken ltp1;
		public Label_nameContext label_name() {
			return GetRuleContext<Label_nameContext>(0);
		}
		public Label_declarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_label_declaration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterLabel_declaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitLabel_declaration(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLabel_declaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Label_declarationContext label_declaration() {
		Label_declarationContext _localctx = new Label_declarationContext(_ctx, State);
		EnterRule(_localctx, 224, RULE_label_declaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2307; _localctx.ltp1 = Match(LESS_THAN_OP);
			State = 2308; Match(LESS_THAN_OP);
			State = 2309; label_name();
			State = 2310; Match(GREATER_THAN_OP);
			State = 2311; Match(GREATER_THAN_OP);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementContext : ParserRuleContext {
		public Function_callContext function_call() {
			return GetRuleContext<Function_callContext>(0);
		}
		public Null_statementContext null_statement() {
			return GetRuleContext<Null_statementContext>(0);
		}
		public Return_statementContext return_statement() {
			return GetRuleContext<Return_statementContext>(0);
		}
		public Raise_statementContext raise_statement() {
			return GetRuleContext<Raise_statementContext>(0);
		}
		public ITerminalNode GRANT() { return GetToken(plsqlParser.GRANT, 0); }
		public ITerminalNode ALL() { return GetToken(plsqlParser.ALL, 0); }
		public Loop_statementContext loop_statement() {
			return GetRuleContext<Loop_statementContext>(0);
		}
		public Case_statementContext case_statement() {
			return GetRuleContext<Case_statementContext>(0);
		}
		public Sql_statementContext sql_statement() {
			return GetRuleContext<Sql_statementContext>(0);
		}
		public Forall_statementContext forall_statement() {
			return GetRuleContext<Forall_statementContext>(0);
		}
		public ITerminalNode TRUNCATE() { return GetToken(plsqlParser.TRUNCATE, 0); }
		public If_statementContext if_statement() {
			return GetRuleContext<If_statementContext>(0);
		}
		public Swallow_to_semiContext swallow_to_semi() {
			return GetRuleContext<Swallow_to_semiContext>(0);
		}
		public Continue_statementContext continue_statement() {
			return GetRuleContext<Continue_statementContext>(0);
		}
		public Exit_statementContext exit_statement() {
			return GetRuleContext<Exit_statementContext>(0);
		}
		public Assignment_statementContext assignment_statement() {
			return GetRuleContext<Assignment_statementContext>(0);
		}
		public ITerminalNode CREATE() { return GetToken(plsqlParser.CREATE, 0); }
		public ITerminalNode ALTER() { return GetToken(plsqlParser.ALTER, 0); }
		public Goto_statementContext goto_statement() {
			return GetRuleContext<Goto_statementContext>(0);
		}
		public BodyContext body() {
			return GetRuleContext<BodyContext>(0);
		}
		public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		public StatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementContext statement() {
		StatementContext _localctx = new StatementContext(_ctx, State);
		EnterRule(_localctx, 226, RULE_statement);
		try {
			State = 2339;
			switch ( Interpreter.AdaptivePredict(_input,221,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2313; Match(CREATE);
				State = 2314; swallow_to_semi();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2315; Match(ALTER);
				State = 2316; swallow_to_semi();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2317; Match(GRANT);
				State = 2319;
				switch ( Interpreter.AdaptivePredict(_input,220,_ctx) ) {
				case 1:
					{
					State = 2318; Match(ALL);
					}
					break;
				}
				State = 2321; swallow_to_semi();
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2322; Match(TRUNCATE);
				State = 2323; swallow_to_semi();
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 2324; body();
				}
				break;

			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 2325; block();
				}
				break;

			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 2326; assignment_statement();
				}
				break;

			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 2327; continue_statement();
				}
				break;

			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 2328; exit_statement();
				}
				break;

			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 2329; goto_statement();
				}
				break;

			case 11:
				EnterOuterAlt(_localctx, 11);
				{
				State = 2330; if_statement();
				}
				break;

			case 12:
				EnterOuterAlt(_localctx, 12);
				{
				State = 2331; loop_statement();
				}
				break;

			case 13:
				EnterOuterAlt(_localctx, 13);
				{
				State = 2332; forall_statement();
				}
				break;

			case 14:
				EnterOuterAlt(_localctx, 14);
				{
				State = 2333; null_statement();
				}
				break;

			case 15:
				EnterOuterAlt(_localctx, 15);
				{
				State = 2334; raise_statement();
				}
				break;

			case 16:
				EnterOuterAlt(_localctx, 16);
				{
				State = 2335; return_statement();
				}
				break;

			case 17:
				EnterOuterAlt(_localctx, 17);
				{
				State = 2336; case_statement();
				}
				break;

			case 18:
				EnterOuterAlt(_localctx, 18);
				{
				State = 2337; sql_statement();
				}
				break;

			case 19:
				EnterOuterAlt(_localctx, 19);
				{
				State = 2338; function_call();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Assignment_statementContext : ParserRuleContext {
		public Bind_variableContext bind_variable() {
			return GetRuleContext<Bind_variableContext>(0);
		}
		public ITerminalNode ASSIGN_OP() { return GetToken(plsqlParser.ASSIGN_OP, 0); }
		public General_elementContext general_element() {
			return GetRuleContext<General_elementContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Assignment_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_assignment_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterAssignment_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitAssignment_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAssignment_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Assignment_statementContext assignment_statement() {
		Assignment_statementContext _localctx = new Assignment_statementContext(_ctx, State);
		EnterRule(_localctx, 228, RULE_assignment_statement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2343;
			switch (_input.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROW_NUMBER:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 2341; general_element();
				}
				break;
			case BINDVAR:
			case COLON:
				{
				State = 2342; bind_variable();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2345; Match(ASSIGN_OP);
			State = 2346; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Continue_statementContext : ParserRuleContext {
		public Label_nameContext label_name() {
			return GetRuleContext<Label_nameContext>(0);
		}
		public ITerminalNode CONTINUE() { return GetToken(plsqlParser.CONTINUE, 0); }
		public ITerminalNode WHEN() { return GetToken(plsqlParser.WHEN, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public Continue_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_continue_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterContinue_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitContinue_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitContinue_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Continue_statementContext continue_statement() {
		Continue_statementContext _localctx = new Continue_statementContext(_ctx, State);
		EnterRule(_localctx, 230, RULE_continue_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2348; Match(CONTINUE);
			State = 2350;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (CONSTANT - 66)) | (1L << (CONSTRAINT - 66)) | (1L << (CONSTRAINTS - 66)) | (1L << (CONSTRUCTOR - 66)) | (1L << (CONTENT - 66)) | (1L << (CONTEXT - 66)) | (1L << (CONTINUE - 66)) | (1L << (CONVERT - 66)) | (1L << (CORRUPT_XID - 66)) | (1L << (CORRUPT_XID_ALL - 66)) | (1L << (COST - 66)) | (1L << (COUNT - 66)) | (1L << (CROSS - 66)) | (1L << (CUBE - 66)) | (1L << (CURRENT_USER - 66)) | (1L << (CURSOR - 66)) | (1L << (CUSTOMDATUM - 66)) | (1L << (CYCLE - 66)) | (1L << (DATA - 66)) | (1L << (DATABASE - 66)) | (1L << (DAY - 66)) | (1L << (DB_ROLE_CHANGE - 66)) | (1L << (DBTIMEZONE - 66)) | (1L << (DDL - 66)) | (1L << (DEBUG - 66)) | (1L << (DEC - 66)) | (1L << (DECIMAL - 66)) | (1L << (DECOMPOSE - 66)) | (1L << (DECREMENT - 66)) | (1L << (DEFAULTS - 66)) | (1L << (DEFERRED - 66)) | (1L << (DEFINER - 66)) | (1L << (DETERMINISTIC - 66)) | (1L << (DIMENSION - 66)) | (1L << (DISABLE - 66)) | (1L << (DISASSOCIATE - 66)) | (1L << (DOCUMENT - 66)) | (1L << (DOUBLE - 66)) | (1L << (DSINTERVAL_UNCONSTRAINED - 66)) | (1L << (EACH - 66)) | (1L << (ELEMENT - 66)) | (1L << (EMPTY - 66)) | (1L << (ENABLE - 66)) | (1L << (ENCODING - 66)) | (1L << (ENTITYESCAPING - 66)) | (1L << (ERR - 66)) | (1L << (ERRORS - 66)) | (1L << (ESCAPE - 66)) | (1L << (EVALNAME - 66)) | (1L << (EXCEPTION - 66)) | (1L << (EXCEPTION_INIT - 66)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)) | (1L << (EXIT - 130)) | (1L << (EXPLAIN - 130)) | (1L << (EXTERNAL - 130)) | (1L << (EXTRACT - 130)) | (1L << (FAILURE - 130)) | (1L << (FINAL - 130)) | (1L << (FIRST - 130)) | (1L << (FIRST_VALUE - 130)) | (1L << (FLOAT - 130)) | (1L << (FOLLOWING - 130)) | (1L << (FOLLOWS - 130)) | (1L << (FORALL - 130)) | (1L << (FORCE - 130)) | (1L << (FULL - 130)) | (1L << (FUNCTION - 130)) | (1L << (GROUPING - 130)) | (1L << (HASH - 130)) | (1L << (HIDE - 130)) | (1L << (HOUR - 130)) | (1L << (IGNORE - 130)) | (1L << (IMMEDIATE - 130)) | (1L << (INCLUDE - 130)) | (1L << (INCLUDING - 130)) | (1L << (INCREMENT - 130)) | (1L << (INDENT - 130)) | (1L << (INDEXED - 130)) | (1L << (INDICATOR - 130)) | (1L << (INDICES - 130)) | (1L << (INFINITE - 130)) | (1L << (INLINE - 130)) | (1L << (INNER - 130)) | (1L << (INOUT - 130)) | (1L << (INSTANTIABLE - 130)) | (1L << (INSTEAD - 130)) | (1L << (INT - 130)) | (1L << (INTEGER - 130)) | (1L << (INTERVAL - 130)) | (1L << (INVALIDATE - 130)) | (1L << (ISOLATION - 130)) | (1L << (ITERATE - 130)) | (1L << (JAVA - 130)) | (1L << (JOIN - 130)) | (1L << (KEEP - 130)) | (1L << (LANGUAGE - 130)))) != 0) || ((((_la - 194)) & ~0x3f) == 0 && ((1L << (_la - 194)) & ((1L << (LAST - 194)) | (1L << (LAST_VALUE - 194)) | (1L << (LEADING - 194)) | (1L << (LEFT - 194)) | (1L << (LEVEL - 194)) | (1L << (LIBRARY - 194)) | (1L << (LIKE2 - 194)) | (1L << (LIKE4 - 194)) | (1L << (LIKEC - 194)) | (1L << (LIMIT - 194)) | (1L << (LOCAL - 194)) | (1L << (LOCKED - 194)) | (1L << (LOG - 194)) | (1L << (LOGOFF - 194)) | (1L << (LOGON - 194)) | (1L << (LONG - 194)) | (1L << (LOOP - 194)) | (1L << (MAIN - 194)) | (1L << (MAP - 194)) | (1L << (MATCHED - 194)) | (1L << (MAXVALUE - 194)) | (1L << (MEASURES - 194)) | (1L << (MEMBER - 194)) | (1L << (MERGE - 194)) | (1L << (MINUTE - 194)) | (1L << (MINVALUE - 194)) | (1L << (MLSLABEL - 194)) | (1L << (MODEL - 194)) | (1L << (MODIFY - 194)) | (1L << (MONTH - 194)) | (1L << (MULTISET - 194)) | (1L << (NAME - 194)) | (1L << (NAN - 194)) | (1L << (NATURAL - 194)) | (1L << (NATURALN - 194)) | (1L << (NAV - 194)) | (1L << (NCHAR - 194)) | (1L << (NCHAR_CS - 194)) | (1L << (NCLOB - 194)) | (1L << (NESTED - 194)) | (1L << (NEW - 194)) | (1L << (NO - 194)) | (1L << (NOAUDIT - 194)) | (1L << (NOCOPY - 194)) | (1L << (NOCYCLE - 194)) | (1L << (NOENTITYESCAPING - 194)) | (1L << (NONE - 194)) | (1L << (NOSCHEMACHECK - 194)) | (1L << (NULLS - 194)) | (1L << (NUMBER - 194)) | (1L << (NUMERIC - 194)) | (1L << (NVARCHAR2 - 194)) | (1L << (OBJECT - 194)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (OFF - 259)) | (1L << (OID - 259)) | (1L << (OLD - 259)) | (1L << (ONLY - 259)) | (1L << (OPEN - 259)) | (1L << (ORADATA - 259)) | (1L << (ORDINALITY - 259)) | (1L << (OSERROR - 259)) | (1L << (OUT - 259)) | (1L << (OUTER - 259)) | (1L << (OVER - 259)) | (1L << (OVERRIDING - 259)) | (1L << (PACKAGE - 259)) | (1L << (PARALLEL_ENABLE - 259)) | (1L << (PARAMETERS - 259)) | (1L << (PARENT - 259)) | (1L << (PARTITION - 259)) | (1L << (PASSING - 259)) | (1L << (PATH - 259)) | (1L << (PIPELINED - 259)) | (1L << (PLAN - 259)) | (1L << (PLS_INTEGER - 259)) | (1L << (POSITIVE - 259)) | (1L << (POSITIVEN - 259)) | (1L << (PRAGMA - 259)) | (1L << (PRECEDING - 259)) | (1L << (PRECISION - 259)) | (1L << (PRESENT - 259)) | (1L << (RAISE - 259)) | (1L << (RANGE - 259)) | (1L << (RAW - 259)) | (1L << (READ - 259)) | (1L << (REAL - 259)) | (1L << (RECORD - 259)) | (1L << (REF - 259)) | (1L << (REFERENCE - 259)) | (1L << (REFERENCING - 259)) | (1L << (REJECT - 259)) | (1L << (RELIES_ON - 259)) | (1L << (RENAME - 259)) | (1L << (REPLACE - 259)) | (1L << (RESPECT - 259)) | (1L << (RESTRICT_REFERENCES - 259)) | (1L << (RESULT - 259)) | (1L << (RESULT_CACHE - 259)) | (1L << (RETURN - 259)) | (1L << (RETURNING - 259)) | (1L << (REUSE - 259)) | (1L << (REVERSE - 259)) | (1L << (RIGHT - 259)))) != 0) || ((((_la - 323)) & ~0x3f) == 0 && ((1L << (_la - 323)) & ((1L << (ROLLBACK - 323)) | (1L << (ROLLUP - 323)) | (1L << (ROW - 323)) | (1L << (ROWID - 323)) | (1L << (ROWS - 323)) | (1L << (RULES - 323)) | (1L << (SAMPLE - 323)) | (1L << (SAVE - 323)) | (1L << (SAVEPOINT - 323)) | (1L << (SCHEMA - 323)) | (1L << (SCHEMACHECK - 323)) | (1L << (SCN - 323)) | (1L << (SECOND - 323)) | (1L << (SEED - 323)) | (1L << (SEGMENT - 323)) | (1L << (SELF - 323)) | (1L << (SEQUENTIAL - 323)) | (1L << (SERIALIZABLE - 323)) | (1L << (SERIALLY_REUSABLE - 323)) | (1L << (SERVERERROR - 323)) | (1L << (SESSIONTIMEZONE - 323)) | (1L << (SET - 323)) | (1L << (SETS - 323)) | (1L << (SETTINGS - 323)) | (1L << (SHOW - 323)) | (1L << (SHUTDOWN - 323)) | (1L << (SIBLINGS - 323)) | (1L << (SIGNTYPE - 323)) | (1L << (SIMPLE_INTEGER - 323)) | (1L << (SINGLE - 323)) | (1L << (SKIP_ - 323)) | (1L << (SMALLINT - 323)) | (1L << (SNAPSHOT - 323)) | (1L << (SOME - 323)) | (1L << (SPECIFICATION - 323)) | (1L << (SQLDATA - 323)) | (1L << (SQLERROR - 323)) | (1L << (STANDALONE - 323)) | (1L << (STARTUP - 323)) | (1L << (STATEMENT - 323)) | (1L << (STATEMENT_ID - 323)) | (1L << (STATIC - 323)) | (1L << (STATISTICS - 323)) | (1L << (STRING - 323)) | (1L << (SUBMULTISET - 323)) | (1L << (SUBPARTITION - 323)) | (1L << (SUBSTITUTABLE - 323)) | (1L << (SUBTYPE - 323)) | (1L << (SUCCESS - 323)) | (1L << (SUSPEND - 323)) | (1L << (TIME - 323)) | (1L << (TIMESTAMP - 323)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_UNCONSTRAINED - 323)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TIMEZONE_ABBR - 387)) | (1L << (TIMEZONE_HOUR - 387)) | (1L << (TIMEZONE_MINUTE - 387)) | (1L << (TIMEZONE_REGION - 387)) | (1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (YMINTERVAL_UNCONSTRAINED - 451)) | (1L << (ZONE - 451)) | (1L << (PREDICTION - 451)) | (1L << (PREDICTION_BOUNDS - 451)) | (1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (COVAR_ - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (REGR_ - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (TRIM - 451)) | (1L << (SUM - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (VARIANCE - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==REGULAR_ID) {
				{
				State = 2349; label_name();
				}
			}

			State = 2354;
			_la = _input.La(1);
			if (_la==WHEN) {
				{
				State = 2352; Match(WHEN);
				State = 2353; condition();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Exit_statementContext : ParserRuleContext {
		public Label_nameContext label_name() {
			return GetRuleContext<Label_nameContext>(0);
		}
		public ITerminalNode WHEN() { return GetToken(plsqlParser.WHEN, 0); }
		public ITerminalNode EXIT() { return GetToken(plsqlParser.EXIT, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public Exit_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exit_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterExit_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitExit_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExit_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Exit_statementContext exit_statement() {
		Exit_statementContext _localctx = new Exit_statementContext(_ctx, State);
		EnterRule(_localctx, 232, RULE_exit_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2356; Match(EXIT);
			State = 2358;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (CONSTANT - 66)) | (1L << (CONSTRAINT - 66)) | (1L << (CONSTRAINTS - 66)) | (1L << (CONSTRUCTOR - 66)) | (1L << (CONTENT - 66)) | (1L << (CONTEXT - 66)) | (1L << (CONTINUE - 66)) | (1L << (CONVERT - 66)) | (1L << (CORRUPT_XID - 66)) | (1L << (CORRUPT_XID_ALL - 66)) | (1L << (COST - 66)) | (1L << (COUNT - 66)) | (1L << (CROSS - 66)) | (1L << (CUBE - 66)) | (1L << (CURRENT_USER - 66)) | (1L << (CURSOR - 66)) | (1L << (CUSTOMDATUM - 66)) | (1L << (CYCLE - 66)) | (1L << (DATA - 66)) | (1L << (DATABASE - 66)) | (1L << (DAY - 66)) | (1L << (DB_ROLE_CHANGE - 66)) | (1L << (DBTIMEZONE - 66)) | (1L << (DDL - 66)) | (1L << (DEBUG - 66)) | (1L << (DEC - 66)) | (1L << (DECIMAL - 66)) | (1L << (DECOMPOSE - 66)) | (1L << (DECREMENT - 66)) | (1L << (DEFAULTS - 66)) | (1L << (DEFERRED - 66)) | (1L << (DEFINER - 66)) | (1L << (DETERMINISTIC - 66)) | (1L << (DIMENSION - 66)) | (1L << (DISABLE - 66)) | (1L << (DISASSOCIATE - 66)) | (1L << (DOCUMENT - 66)) | (1L << (DOUBLE - 66)) | (1L << (DSINTERVAL_UNCONSTRAINED - 66)) | (1L << (EACH - 66)) | (1L << (ELEMENT - 66)) | (1L << (EMPTY - 66)) | (1L << (ENABLE - 66)) | (1L << (ENCODING - 66)) | (1L << (ENTITYESCAPING - 66)) | (1L << (ERR - 66)) | (1L << (ERRORS - 66)) | (1L << (ESCAPE - 66)) | (1L << (EVALNAME - 66)) | (1L << (EXCEPTION - 66)) | (1L << (EXCEPTION_INIT - 66)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)) | (1L << (EXIT - 130)) | (1L << (EXPLAIN - 130)) | (1L << (EXTERNAL - 130)) | (1L << (EXTRACT - 130)) | (1L << (FAILURE - 130)) | (1L << (FINAL - 130)) | (1L << (FIRST - 130)) | (1L << (FIRST_VALUE - 130)) | (1L << (FLOAT - 130)) | (1L << (FOLLOWING - 130)) | (1L << (FOLLOWS - 130)) | (1L << (FORALL - 130)) | (1L << (FORCE - 130)) | (1L << (FULL - 130)) | (1L << (FUNCTION - 130)) | (1L << (GROUPING - 130)) | (1L << (HASH - 130)) | (1L << (HIDE - 130)) | (1L << (HOUR - 130)) | (1L << (IGNORE - 130)) | (1L << (IMMEDIATE - 130)) | (1L << (INCLUDE - 130)) | (1L << (INCLUDING - 130)) | (1L << (INCREMENT - 130)) | (1L << (INDENT - 130)) | (1L << (INDEXED - 130)) | (1L << (INDICATOR - 130)) | (1L << (INDICES - 130)) | (1L << (INFINITE - 130)) | (1L << (INLINE - 130)) | (1L << (INNER - 130)) | (1L << (INOUT - 130)) | (1L << (INSTANTIABLE - 130)) | (1L << (INSTEAD - 130)) | (1L << (INT - 130)) | (1L << (INTEGER - 130)) | (1L << (INTERVAL - 130)) | (1L << (INVALIDATE - 130)) | (1L << (ISOLATION - 130)) | (1L << (ITERATE - 130)) | (1L << (JAVA - 130)) | (1L << (JOIN - 130)) | (1L << (KEEP - 130)) | (1L << (LANGUAGE - 130)))) != 0) || ((((_la - 194)) & ~0x3f) == 0 && ((1L << (_la - 194)) & ((1L << (LAST - 194)) | (1L << (LAST_VALUE - 194)) | (1L << (LEADING - 194)) | (1L << (LEFT - 194)) | (1L << (LEVEL - 194)) | (1L << (LIBRARY - 194)) | (1L << (LIKE2 - 194)) | (1L << (LIKE4 - 194)) | (1L << (LIKEC - 194)) | (1L << (LIMIT - 194)) | (1L << (LOCAL - 194)) | (1L << (LOCKED - 194)) | (1L << (LOG - 194)) | (1L << (LOGOFF - 194)) | (1L << (LOGON - 194)) | (1L << (LONG - 194)) | (1L << (LOOP - 194)) | (1L << (MAIN - 194)) | (1L << (MAP - 194)) | (1L << (MATCHED - 194)) | (1L << (MAXVALUE - 194)) | (1L << (MEASURES - 194)) | (1L << (MEMBER - 194)) | (1L << (MERGE - 194)) | (1L << (MINUTE - 194)) | (1L << (MINVALUE - 194)) | (1L << (MLSLABEL - 194)) | (1L << (MODEL - 194)) | (1L << (MODIFY - 194)) | (1L << (MONTH - 194)) | (1L << (MULTISET - 194)) | (1L << (NAME - 194)) | (1L << (NAN - 194)) | (1L << (NATURAL - 194)) | (1L << (NATURALN - 194)) | (1L << (NAV - 194)) | (1L << (NCHAR - 194)) | (1L << (NCHAR_CS - 194)) | (1L << (NCLOB - 194)) | (1L << (NESTED - 194)) | (1L << (NEW - 194)) | (1L << (NO - 194)) | (1L << (NOAUDIT - 194)) | (1L << (NOCOPY - 194)) | (1L << (NOCYCLE - 194)) | (1L << (NOENTITYESCAPING - 194)) | (1L << (NONE - 194)) | (1L << (NOSCHEMACHECK - 194)) | (1L << (NULLS - 194)) | (1L << (NUMBER - 194)) | (1L << (NUMERIC - 194)) | (1L << (NVARCHAR2 - 194)) | (1L << (OBJECT - 194)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (OFF - 259)) | (1L << (OID - 259)) | (1L << (OLD - 259)) | (1L << (ONLY - 259)) | (1L << (OPEN - 259)) | (1L << (ORADATA - 259)) | (1L << (ORDINALITY - 259)) | (1L << (OSERROR - 259)) | (1L << (OUT - 259)) | (1L << (OUTER - 259)) | (1L << (OVER - 259)) | (1L << (OVERRIDING - 259)) | (1L << (PACKAGE - 259)) | (1L << (PARALLEL_ENABLE - 259)) | (1L << (PARAMETERS - 259)) | (1L << (PARENT - 259)) | (1L << (PARTITION - 259)) | (1L << (PASSING - 259)) | (1L << (PATH - 259)) | (1L << (PIPELINED - 259)) | (1L << (PLAN - 259)) | (1L << (PLS_INTEGER - 259)) | (1L << (POSITIVE - 259)) | (1L << (POSITIVEN - 259)) | (1L << (PRAGMA - 259)) | (1L << (PRECEDING - 259)) | (1L << (PRECISION - 259)) | (1L << (PRESENT - 259)) | (1L << (RAISE - 259)) | (1L << (RANGE - 259)) | (1L << (RAW - 259)) | (1L << (READ - 259)) | (1L << (REAL - 259)) | (1L << (RECORD - 259)) | (1L << (REF - 259)) | (1L << (REFERENCE - 259)) | (1L << (REFERENCING - 259)) | (1L << (REJECT - 259)) | (1L << (RELIES_ON - 259)) | (1L << (RENAME - 259)) | (1L << (REPLACE - 259)) | (1L << (RESPECT - 259)) | (1L << (RESTRICT_REFERENCES - 259)) | (1L << (RESULT - 259)) | (1L << (RESULT_CACHE - 259)) | (1L << (RETURN - 259)) | (1L << (RETURNING - 259)) | (1L << (REUSE - 259)) | (1L << (REVERSE - 259)) | (1L << (RIGHT - 259)))) != 0) || ((((_la - 323)) & ~0x3f) == 0 && ((1L << (_la - 323)) & ((1L << (ROLLBACK - 323)) | (1L << (ROLLUP - 323)) | (1L << (ROW - 323)) | (1L << (ROWID - 323)) | (1L << (ROWS - 323)) | (1L << (RULES - 323)) | (1L << (SAMPLE - 323)) | (1L << (SAVE - 323)) | (1L << (SAVEPOINT - 323)) | (1L << (SCHEMA - 323)) | (1L << (SCHEMACHECK - 323)) | (1L << (SCN - 323)) | (1L << (SECOND - 323)) | (1L << (SEED - 323)) | (1L << (SEGMENT - 323)) | (1L << (SELF - 323)) | (1L << (SEQUENTIAL - 323)) | (1L << (SERIALIZABLE - 323)) | (1L << (SERIALLY_REUSABLE - 323)) | (1L << (SERVERERROR - 323)) | (1L << (SESSIONTIMEZONE - 323)) | (1L << (SET - 323)) | (1L << (SETS - 323)) | (1L << (SETTINGS - 323)) | (1L << (SHOW - 323)) | (1L << (SHUTDOWN - 323)) | (1L << (SIBLINGS - 323)) | (1L << (SIGNTYPE - 323)) | (1L << (SIMPLE_INTEGER - 323)) | (1L << (SINGLE - 323)) | (1L << (SKIP_ - 323)) | (1L << (SMALLINT - 323)) | (1L << (SNAPSHOT - 323)) | (1L << (SOME - 323)) | (1L << (SPECIFICATION - 323)) | (1L << (SQLDATA - 323)) | (1L << (SQLERROR - 323)) | (1L << (STANDALONE - 323)) | (1L << (STARTUP - 323)) | (1L << (STATEMENT - 323)) | (1L << (STATEMENT_ID - 323)) | (1L << (STATIC - 323)) | (1L << (STATISTICS - 323)) | (1L << (STRING - 323)) | (1L << (SUBMULTISET - 323)) | (1L << (SUBPARTITION - 323)) | (1L << (SUBSTITUTABLE - 323)) | (1L << (SUBTYPE - 323)) | (1L << (SUCCESS - 323)) | (1L << (SUSPEND - 323)) | (1L << (TIME - 323)) | (1L << (TIMESTAMP - 323)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_UNCONSTRAINED - 323)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TIMEZONE_ABBR - 387)) | (1L << (TIMEZONE_HOUR - 387)) | (1L << (TIMEZONE_MINUTE - 387)) | (1L << (TIMEZONE_REGION - 387)) | (1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (YMINTERVAL_UNCONSTRAINED - 451)) | (1L << (ZONE - 451)) | (1L << (PREDICTION - 451)) | (1L << (PREDICTION_BOUNDS - 451)) | (1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (COVAR_ - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (REGR_ - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (TRIM - 451)) | (1L << (SUM - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (VARIANCE - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==REGULAR_ID) {
				{
				State = 2357; label_name();
				}
			}

			State = 2362;
			_la = _input.La(1);
			if (_la==WHEN) {
				{
				State = 2360; Match(WHEN);
				State = 2361; condition();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Goto_statementContext : ParserRuleContext {
		public Label_nameContext label_name() {
			return GetRuleContext<Label_nameContext>(0);
		}
		public ITerminalNode GOTO() { return GetToken(plsqlParser.GOTO, 0); }
		public Goto_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_goto_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterGoto_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitGoto_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGoto_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Goto_statementContext goto_statement() {
		Goto_statementContext _localctx = new Goto_statementContext(_ctx, State);
		EnterRule(_localctx, 234, RULE_goto_statement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2364; Match(GOTO);
			State = 2365; label_name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class If_statementContext : ParserRuleContext {
		public Seq_of_statementsContext seq_of_statements() {
			return GetRuleContext<Seq_of_statementsContext>(0);
		}
		public IReadOnlyList<ITerminalNode> IF() { return GetTokens(plsqlParser.IF); }
		public ITerminalNode IF(int i) {
			return GetToken(plsqlParser.IF, i);
		}
		public ITerminalNode THEN() { return GetToken(plsqlParser.THEN, 0); }
		public IReadOnlyList<Elsif_partContext> elsif_part() {
			return GetRuleContexts<Elsif_partContext>();
		}
		public Elsif_partContext elsif_part(int i) {
			return GetRuleContext<Elsif_partContext>(i);
		}
		public ITerminalNode END() { return GetToken(plsqlParser.END, 0); }
		public Else_partContext else_part() {
			return GetRuleContext<Else_partContext>(0);
		}
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public If_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_if_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterIf_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitIf_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIf_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public If_statementContext if_statement() {
		If_statementContext _localctx = new If_statementContext(_ctx, State);
		EnterRule(_localctx, 236, RULE_if_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2367; Match(IF);
			State = 2368; condition();
			State = 2369; Match(THEN);
			State = 2370; seq_of_statements();
			State = 2374;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==ELSIF) {
				{
				{
				State = 2371; elsif_part();
				}
				}
				State = 2376;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 2378;
			_la = _input.La(1);
			if (_la==ELSE) {
				{
				State = 2377; else_part();
				}
			}

			State = 2380; Match(END);
			State = 2381; Match(IF);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Elsif_partContext : ParserRuleContext {
		public Seq_of_statementsContext seq_of_statements() {
			return GetRuleContext<Seq_of_statementsContext>(0);
		}
		public ITerminalNode ELSIF() { return GetToken(plsqlParser.ELSIF, 0); }
		public ITerminalNode THEN() { return GetToken(plsqlParser.THEN, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public Elsif_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elsif_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterElsif_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitElsif_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElsif_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Elsif_partContext elsif_part() {
		Elsif_partContext _localctx = new Elsif_partContext(_ctx, State);
		EnterRule(_localctx, 238, RULE_elsif_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2383; Match(ELSIF);
			State = 2384; condition();
			State = 2385; Match(THEN);
			State = 2386; seq_of_statements();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Else_partContext : ParserRuleContext {
		public Seq_of_statementsContext seq_of_statements() {
			return GetRuleContext<Seq_of_statementsContext>(0);
		}
		public ITerminalNode ELSE() { return GetToken(plsqlParser.ELSE, 0); }
		public Else_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_else_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterElse_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitElse_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElse_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Else_partContext else_part() {
		Else_partContext _localctx = new Else_partContext(_ctx, State);
		EnterRule(_localctx, 240, RULE_else_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2388; Match(ELSE);
			State = 2389; seq_of_statements();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Loop_statementContext : ParserRuleContext {
		public Seq_of_statementsContext seq_of_statements() {
			return GetRuleContext<Seq_of_statementsContext>(0);
		}
		public IReadOnlyList<ITerminalNode> LOOP() { return GetTokens(plsqlParser.LOOP); }
		public IReadOnlyList<Label_nameContext> label_name() {
			return GetRuleContexts<Label_nameContext>();
		}
		public Label_nameContext label_name(int i) {
			return GetRuleContext<Label_nameContext>(i);
		}
		public ITerminalNode FOR() { return GetToken(plsqlParser.FOR, 0); }
		public ITerminalNode END() { return GetToken(plsqlParser.END, 0); }
		public ITerminalNode LOOP(int i) {
			return GetToken(plsqlParser.LOOP, i);
		}
		public ITerminalNode WHILE() { return GetToken(plsqlParser.WHILE, 0); }
		public Cursor_loop_paramContext cursor_loop_param() {
			return GetRuleContext<Cursor_loop_paramContext>(0);
		}
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public Loop_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loop_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterLoop_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitLoop_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLoop_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Loop_statementContext loop_statement() {
		Loop_statementContext _localctx = new Loop_statementContext(_ctx, State);
		EnterRule(_localctx, 242, RULE_loop_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2392;
			switch ( Interpreter.AdaptivePredict(_input,229,_ctx) ) {
			case 1:
				{
				State = 2391; label_name();
				}
				break;
			}
			State = 2398;
			switch (_input.La(1)) {
			case WHILE:
				{
				State = 2394; Match(WHILE);
				State = 2395; condition();
				}
				break;
			case FOR:
				{
				State = 2396; Match(FOR);
				State = 2397; cursor_loop_param();
				}
				break;
			case LOOP:
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2400; Match(LOOP);
			State = 2401; seq_of_statements();
			State = 2402; Match(END);
			State = 2403; Match(LOOP);
			State = 2405;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (CONSTANT - 66)) | (1L << (CONSTRAINT - 66)) | (1L << (CONSTRAINTS - 66)) | (1L << (CONSTRUCTOR - 66)) | (1L << (CONTENT - 66)) | (1L << (CONTEXT - 66)) | (1L << (CONTINUE - 66)) | (1L << (CONVERT - 66)) | (1L << (CORRUPT_XID - 66)) | (1L << (CORRUPT_XID_ALL - 66)) | (1L << (COST - 66)) | (1L << (COUNT - 66)) | (1L << (CROSS - 66)) | (1L << (CUBE - 66)) | (1L << (CURRENT_USER - 66)) | (1L << (CURSOR - 66)) | (1L << (CUSTOMDATUM - 66)) | (1L << (CYCLE - 66)) | (1L << (DATA - 66)) | (1L << (DATABASE - 66)) | (1L << (DAY - 66)) | (1L << (DB_ROLE_CHANGE - 66)) | (1L << (DBTIMEZONE - 66)) | (1L << (DDL - 66)) | (1L << (DEBUG - 66)) | (1L << (DEC - 66)) | (1L << (DECIMAL - 66)) | (1L << (DECOMPOSE - 66)) | (1L << (DECREMENT - 66)) | (1L << (DEFAULTS - 66)) | (1L << (DEFERRED - 66)) | (1L << (DEFINER - 66)) | (1L << (DETERMINISTIC - 66)) | (1L << (DIMENSION - 66)) | (1L << (DISABLE - 66)) | (1L << (DISASSOCIATE - 66)) | (1L << (DOCUMENT - 66)) | (1L << (DOUBLE - 66)) | (1L << (DSINTERVAL_UNCONSTRAINED - 66)) | (1L << (EACH - 66)) | (1L << (ELEMENT - 66)) | (1L << (EMPTY - 66)) | (1L << (ENABLE - 66)) | (1L << (ENCODING - 66)) | (1L << (ENTITYESCAPING - 66)) | (1L << (ERR - 66)) | (1L << (ERRORS - 66)) | (1L << (ESCAPE - 66)) | (1L << (EVALNAME - 66)) | (1L << (EXCEPTION - 66)) | (1L << (EXCEPTION_INIT - 66)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)) | (1L << (EXIT - 130)) | (1L << (EXPLAIN - 130)) | (1L << (EXTERNAL - 130)) | (1L << (EXTRACT - 130)) | (1L << (FAILURE - 130)) | (1L << (FINAL - 130)) | (1L << (FIRST - 130)) | (1L << (FIRST_VALUE - 130)) | (1L << (FLOAT - 130)) | (1L << (FOLLOWING - 130)) | (1L << (FOLLOWS - 130)) | (1L << (FORALL - 130)) | (1L << (FORCE - 130)) | (1L << (FULL - 130)) | (1L << (FUNCTION - 130)) | (1L << (GROUPING - 130)) | (1L << (HASH - 130)) | (1L << (HIDE - 130)) | (1L << (HOUR - 130)) | (1L << (IGNORE - 130)) | (1L << (IMMEDIATE - 130)) | (1L << (INCLUDE - 130)) | (1L << (INCLUDING - 130)) | (1L << (INCREMENT - 130)) | (1L << (INDENT - 130)) | (1L << (INDEXED - 130)) | (1L << (INDICATOR - 130)) | (1L << (INDICES - 130)) | (1L << (INFINITE - 130)) | (1L << (INLINE - 130)) | (1L << (INNER - 130)) | (1L << (INOUT - 130)) | (1L << (INSTANTIABLE - 130)) | (1L << (INSTEAD - 130)) | (1L << (INT - 130)) | (1L << (INTEGER - 130)) | (1L << (INTERVAL - 130)) | (1L << (INVALIDATE - 130)) | (1L << (ISOLATION - 130)) | (1L << (ITERATE - 130)) | (1L << (JAVA - 130)) | (1L << (JOIN - 130)) | (1L << (KEEP - 130)) | (1L << (LANGUAGE - 130)))) != 0) || ((((_la - 194)) & ~0x3f) == 0 && ((1L << (_la - 194)) & ((1L << (LAST - 194)) | (1L << (LAST_VALUE - 194)) | (1L << (LEADING - 194)) | (1L << (LEFT - 194)) | (1L << (LEVEL - 194)) | (1L << (LIBRARY - 194)) | (1L << (LIKE2 - 194)) | (1L << (LIKE4 - 194)) | (1L << (LIKEC - 194)) | (1L << (LIMIT - 194)) | (1L << (LOCAL - 194)) | (1L << (LOCKED - 194)) | (1L << (LOG - 194)) | (1L << (LOGOFF - 194)) | (1L << (LOGON - 194)) | (1L << (LONG - 194)) | (1L << (LOOP - 194)) | (1L << (MAIN - 194)) | (1L << (MAP - 194)) | (1L << (MATCHED - 194)) | (1L << (MAXVALUE - 194)) | (1L << (MEASURES - 194)) | (1L << (MEMBER - 194)) | (1L << (MERGE - 194)) | (1L << (MINUTE - 194)) | (1L << (MINVALUE - 194)) | (1L << (MLSLABEL - 194)) | (1L << (MODEL - 194)) | (1L << (MODIFY - 194)) | (1L << (MONTH - 194)) | (1L << (MULTISET - 194)) | (1L << (NAME - 194)) | (1L << (NAN - 194)) | (1L << (NATURAL - 194)) | (1L << (NATURALN - 194)) | (1L << (NAV - 194)) | (1L << (NCHAR - 194)) | (1L << (NCHAR_CS - 194)) | (1L << (NCLOB - 194)) | (1L << (NESTED - 194)) | (1L << (NEW - 194)) | (1L << (NO - 194)) | (1L << (NOAUDIT - 194)) | (1L << (NOCOPY - 194)) | (1L << (NOCYCLE - 194)) | (1L << (NOENTITYESCAPING - 194)) | (1L << (NONE - 194)) | (1L << (NOSCHEMACHECK - 194)) | (1L << (NULLS - 194)) | (1L << (NUMBER - 194)) | (1L << (NUMERIC - 194)) | (1L << (NVARCHAR2 - 194)) | (1L << (OBJECT - 194)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (OFF - 259)) | (1L << (OID - 259)) | (1L << (OLD - 259)) | (1L << (ONLY - 259)) | (1L << (OPEN - 259)) | (1L << (ORADATA - 259)) | (1L << (ORDINALITY - 259)) | (1L << (OSERROR - 259)) | (1L << (OUT - 259)) | (1L << (OUTER - 259)) | (1L << (OVER - 259)) | (1L << (OVERRIDING - 259)) | (1L << (PACKAGE - 259)) | (1L << (PARALLEL_ENABLE - 259)) | (1L << (PARAMETERS - 259)) | (1L << (PARENT - 259)) | (1L << (PARTITION - 259)) | (1L << (PASSING - 259)) | (1L << (PATH - 259)) | (1L << (PIPELINED - 259)) | (1L << (PLAN - 259)) | (1L << (PLS_INTEGER - 259)) | (1L << (POSITIVE - 259)) | (1L << (POSITIVEN - 259)) | (1L << (PRAGMA - 259)) | (1L << (PRECEDING - 259)) | (1L << (PRECISION - 259)) | (1L << (PRESENT - 259)) | (1L << (RAISE - 259)) | (1L << (RANGE - 259)) | (1L << (RAW - 259)) | (1L << (READ - 259)) | (1L << (REAL - 259)) | (1L << (RECORD - 259)) | (1L << (REF - 259)) | (1L << (REFERENCE - 259)) | (1L << (REFERENCING - 259)) | (1L << (REJECT - 259)) | (1L << (RELIES_ON - 259)) | (1L << (RENAME - 259)) | (1L << (REPLACE - 259)) | (1L << (RESPECT - 259)) | (1L << (RESTRICT_REFERENCES - 259)) | (1L << (RESULT - 259)) | (1L << (RESULT_CACHE - 259)) | (1L << (RETURN - 259)) | (1L << (RETURNING - 259)) | (1L << (REUSE - 259)) | (1L << (REVERSE - 259)) | (1L << (RIGHT - 259)))) != 0) || ((((_la - 323)) & ~0x3f) == 0 && ((1L << (_la - 323)) & ((1L << (ROLLBACK - 323)) | (1L << (ROLLUP - 323)) | (1L << (ROW - 323)) | (1L << (ROWID - 323)) | (1L << (ROWS - 323)) | (1L << (RULES - 323)) | (1L << (SAMPLE - 323)) | (1L << (SAVE - 323)) | (1L << (SAVEPOINT - 323)) | (1L << (SCHEMA - 323)) | (1L << (SCHEMACHECK - 323)) | (1L << (SCN - 323)) | (1L << (SECOND - 323)) | (1L << (SEED - 323)) | (1L << (SEGMENT - 323)) | (1L << (SELF - 323)) | (1L << (SEQUENTIAL - 323)) | (1L << (SERIALIZABLE - 323)) | (1L << (SERIALLY_REUSABLE - 323)) | (1L << (SERVERERROR - 323)) | (1L << (SESSIONTIMEZONE - 323)) | (1L << (SET - 323)) | (1L << (SETS - 323)) | (1L << (SETTINGS - 323)) | (1L << (SHOW - 323)) | (1L << (SHUTDOWN - 323)) | (1L << (SIBLINGS - 323)) | (1L << (SIGNTYPE - 323)) | (1L << (SIMPLE_INTEGER - 323)) | (1L << (SINGLE - 323)) | (1L << (SKIP_ - 323)) | (1L << (SMALLINT - 323)) | (1L << (SNAPSHOT - 323)) | (1L << (SOME - 323)) | (1L << (SPECIFICATION - 323)) | (1L << (SQLDATA - 323)) | (1L << (SQLERROR - 323)) | (1L << (STANDALONE - 323)) | (1L << (STARTUP - 323)) | (1L << (STATEMENT - 323)) | (1L << (STATEMENT_ID - 323)) | (1L << (STATIC - 323)) | (1L << (STATISTICS - 323)) | (1L << (STRING - 323)) | (1L << (SUBMULTISET - 323)) | (1L << (SUBPARTITION - 323)) | (1L << (SUBSTITUTABLE - 323)) | (1L << (SUBTYPE - 323)) | (1L << (SUCCESS - 323)) | (1L << (SUSPEND - 323)) | (1L << (TIME - 323)) | (1L << (TIMESTAMP - 323)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_UNCONSTRAINED - 323)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TIMEZONE_ABBR - 387)) | (1L << (TIMEZONE_HOUR - 387)) | (1L << (TIMEZONE_MINUTE - 387)) | (1L << (TIMEZONE_REGION - 387)) | (1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (YMINTERVAL_UNCONSTRAINED - 451)) | (1L << (ZONE - 451)) | (1L << (PREDICTION - 451)) | (1L << (PREDICTION_BOUNDS - 451)) | (1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (COVAR_ - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (REGR_ - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (TRIM - 451)) | (1L << (SUM - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (VARIANCE - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==REGULAR_ID) {
				{
				State = 2404; label_name();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cursor_loop_paramContext : ParserRuleContext {
		public IToken range;
		public Expression_listContext expression_list() {
			return GetRuleContext<Expression_listContext>(0);
		}
		public Select_statementContext select_statement() {
			return GetRuleContext<Select_statementContext>(0);
		}
		public Upper_boundContext upper_bound() {
			return GetRuleContext<Upper_boundContext>(0);
		}
		public Cursor_nameContext cursor_name() {
			return GetRuleContext<Cursor_nameContext>(0);
		}
		public Index_nameContext index_name() {
			return GetRuleContext<Index_nameContext>(0);
		}
		public ITerminalNode REVERSE() { return GetToken(plsqlParser.REVERSE, 0); }
		public Lower_boundContext lower_bound() {
			return GetRuleContext<Lower_boundContext>(0);
		}
		public Record_nameContext record_name() {
			return GetRuleContext<Record_nameContext>(0);
		}
		public ITerminalNode IN() { return GetToken(plsqlParser.IN, 0); }
		public Cursor_loop_paramContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cursor_loop_param; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCursor_loop_param(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCursor_loop_param(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCursor_loop_param(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Cursor_loop_paramContext cursor_loop_param() {
		Cursor_loop_paramContext _localctx = new Cursor_loop_paramContext(_ctx, State);
		EnterRule(_localctx, 244, RULE_cursor_loop_param);
		int _la;
		try {
			State = 2428;
			switch ( Interpreter.AdaptivePredict(_input,235,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2407; index_name();
				State = 2408; Match(IN);
				State = 2410;
				switch ( Interpreter.AdaptivePredict(_input,232,_ctx) ) {
				case 1:
					{
					State = 2409; Match(REVERSE);
					}
					break;
				}
				State = 2412; lower_bound();
				State = 2413; _localctx.range = Match(T__0);
				State = 2414; upper_bound();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2416; record_name();
				State = 2417; Match(IN);
				State = 2426;
				switch (_input.La(1)) {
				case A_LETTER:
				case ADD:
				case AFTER:
				case AGENT:
				case AGGREGATE:
				case ANALYZE:
				case ARRAY:
				case ASSOCIATE:
				case AT:
				case ATTRIBUTE:
				case AUDIT:
				case AUTHID:
				case AUTO:
				case AUTOMATIC:
				case AUTONOMOUS_TRANSACTION:
				case BATCH:
				case BEFORE:
				case BFILE:
				case BINARY_DOUBLE:
				case BINARY_FLOAT:
				case BINARY_INTEGER:
				case BLOB:
				case BLOCK:
				case BODY:
				case BOOLEAN:
				case BOTH:
				case BULK:
				case BYTE:
				case C_LETTER:
				case CALL:
				case CANONICAL:
				case CASCADE:
				case CAST:
				case CHAR:
				case CHAR_CS:
				case CHARACTER:
				case CHR:
				case CLOB:
				case CLOSE:
				case CLUSTER:
				case COLLECT:
				case COLUMNS:
				case COMMENT:
				case COMMIT:
				case COMMITTED:
				case COMPATIBILITY:
				case COMPILE:
				case COMPOUND:
				case CONSTANT:
				case CONSTRAINT:
				case CONSTRAINTS:
				case CONSTRUCTOR:
				case CONTENT:
				case CONTEXT:
				case CONTINUE:
				case CONVERT:
				case CORRUPT_XID:
				case CORRUPT_XID_ALL:
				case COST:
				case COUNT:
				case CROSS:
				case CUBE:
				case CURRENT_USER:
				case CURSOR:
				case CUSTOMDATUM:
				case CYCLE:
				case DATA:
				case DATABASE:
				case DAY:
				case DB_ROLE_CHANGE:
				case DBTIMEZONE:
				case DDL:
				case DEBUG:
				case DEC:
				case DECIMAL:
				case DECOMPOSE:
				case DECREMENT:
				case DEFAULTS:
				case DEFERRED:
				case DEFINER:
				case DETERMINISTIC:
				case DIMENSION:
				case DISABLE:
				case DISASSOCIATE:
				case DOCUMENT:
				case DOUBLE:
				case DSINTERVAL_UNCONSTRAINED:
				case EACH:
				case ELEMENT:
				case EMPTY:
				case ENABLE:
				case ENCODING:
				case ENTITYESCAPING:
				case ERR:
				case ERRORS:
				case ESCAPE:
				case EVALNAME:
				case EXCEPTION:
				case EXCEPTION_INIT:
				case EXCEPTIONS:
				case EXCLUDE:
				case EXECUTE:
				case EXIT:
				case EXPLAIN:
				case EXTERNAL:
				case EXTRACT:
				case FAILURE:
				case FINAL:
				case FIRST:
				case FIRST_VALUE:
				case FLOAT:
				case FOLLOWING:
				case FOLLOWS:
				case FORALL:
				case FORCE:
				case FULL:
				case FUNCTION:
				case GROUPING:
				case HASH:
				case HIDE:
				case HOUR:
				case IGNORE:
				case IMMEDIATE:
				case INCLUDE:
				case INCLUDING:
				case INCREMENT:
				case INDENT:
				case INDEXED:
				case INDICATOR:
				case INDICES:
				case INFINITE:
				case INLINE:
				case INNER:
				case INOUT:
				case INSTANTIABLE:
				case INSTEAD:
				case INT:
				case INTEGER:
				case INTERVAL:
				case INVALIDATE:
				case ISOLATION:
				case ITERATE:
				case JAVA:
				case JOIN:
				case KEEP:
				case LANGUAGE:
				case LAST:
				case LAST_VALUE:
				case LEADING:
				case LEFT:
				case LEVEL:
				case LIBRARY:
				case LIKE2:
				case LIKE4:
				case LIKEC:
				case LIMIT:
				case LOCAL:
				case LOCKED:
				case LOG:
				case LOGOFF:
				case LOGON:
				case LONG:
				case LOOP:
				case MAIN:
				case MAP:
				case MATCHED:
				case MAXVALUE:
				case MEASURES:
				case MEMBER:
				case MERGE:
				case MINUTE:
				case MINVALUE:
				case MLSLABEL:
				case MODEL:
				case MODIFY:
				case MONTH:
				case MULTISET:
				case NAME:
				case NAN:
				case NATURAL:
				case NATURALN:
				case NAV:
				case NCHAR:
				case NCHAR_CS:
				case NCLOB:
				case NESTED:
				case NEW:
				case NO:
				case NOAUDIT:
				case NOCOPY:
				case NOCYCLE:
				case NOENTITYESCAPING:
				case NONE:
				case NOSCHEMACHECK:
				case NULLS:
				case NUMBER:
				case NUMERIC:
				case NVARCHAR2:
				case OBJECT:
				case OFF:
				case OID:
				case OLD:
				case ONLY:
				case OPEN:
				case ORADATA:
				case ORDINALITY:
				case OSERROR:
				case OUT:
				case OUTER:
				case OVER:
				case OVERRIDING:
				case PACKAGE:
				case PARALLEL_ENABLE:
				case PARAMETERS:
				case PARENT:
				case PARTITION:
				case PASSING:
				case PATH:
				case PIPELINED:
				case PLAN:
				case PLS_INTEGER:
				case POSITIVE:
				case POSITIVEN:
				case PRAGMA:
				case PRECEDING:
				case PRECISION:
				case PRESENT:
				case RAISE:
				case RANGE:
				case RAW:
				case READ:
				case REAL:
				case RECORD:
				case REF:
				case REFERENCE:
				case REFERENCING:
				case REJECT:
				case RELIES_ON:
				case RENAME:
				case REPLACE:
				case RESPECT:
				case RESTRICT_REFERENCES:
				case RESULT:
				case RESULT_CACHE:
				case RETURN:
				case RETURNING:
				case REUSE:
				case REVERSE:
				case RIGHT:
				case ROLLBACK:
				case ROLLUP:
				case ROW:
				case ROWID:
				case ROWS:
				case RULES:
				case SAMPLE:
				case SAVE:
				case SAVEPOINT:
				case SCHEMA:
				case SCHEMACHECK:
				case SCN:
				case SECOND:
				case SEED:
				case SEGMENT:
				case SELF:
				case SEQUENTIAL:
				case SERIALIZABLE:
				case SERIALLY_REUSABLE:
				case SERVERERROR:
				case SESSIONTIMEZONE:
				case SET:
				case SETS:
				case SETTINGS:
				case SHOW:
				case SHUTDOWN:
				case SIBLINGS:
				case SIGNTYPE:
				case SIMPLE_INTEGER:
				case SINGLE:
				case SKIP_:
				case SMALLINT:
				case SNAPSHOT:
				case SOME:
				case SPECIFICATION:
				case SQLDATA:
				case SQLERROR:
				case STANDALONE:
				case STARTUP:
				case STATEMENT:
				case STATEMENT_ID:
				case STATIC:
				case STATISTICS:
				case STRING:
				case SUBMULTISET:
				case SUBPARTITION:
				case SUBSTITUTABLE:
				case SUBTYPE:
				case SUCCESS:
				case SUSPEND:
				case TIME:
				case TIMESTAMP:
				case TIMESTAMP_LTZ_UNCONSTRAINED:
				case TIMESTAMP_TZ_UNCONSTRAINED:
				case TIMESTAMP_UNCONSTRAINED:
				case TIMEZONE_ABBR:
				case TIMEZONE_HOUR:
				case TIMEZONE_MINUTE:
				case TIMEZONE_REGION:
				case TRAILING:
				case TRANSACTION:
				case TRANSLATE:
				case TREAT:
				case TRIGGER:
				case TRUNCATE:
				case TYPE:
				case UNBOUNDED:
				case UNDER:
				case UNLIMITED:
				case UNTIL:
				case UPDATED:
				case UPSERT:
				case UROWID:
				case USE:
				case VALIDATE:
				case VALUE:
				case VARCHAR:
				case VARCHAR2:
				case VARIABLE:
				case VARRAY:
				case VARYING:
				case VERSION:
				case VERSIONS:
				case WAIT:
				case WARNING:
				case WELLFORMED:
				case WHENEVER:
				case WHILE:
				case WITHIN:
				case WORK:
				case WRITE:
				case XML:
				case XMLAGG:
				case XMLATTRIBUTES:
				case XMLCAST:
				case XMLCOLATTVAL:
				case XMLELEMENT:
				case XMLEXISTS:
				case XMLFOREST:
				case XMLNAMESPACES:
				case XMLPARSE:
				case XMLPI:
				case XMLQUERY:
				case XMLROOT:
				case XMLSERIALIZE:
				case XMLTABLE:
				case YEAR:
				case YES:
				case YMINTERVAL_UNCONSTRAINED:
				case ZONE:
				case PREDICTION:
				case PREDICTION_BOUNDS:
				case PREDICTION_COST:
				case PREDICTION_DETAILS:
				case PREDICTION_PROBABILITY:
				case PREDICTION_SET:
				case CUME_DIST:
				case DENSE_RANK:
				case LISTAGG:
				case PERCENT_RANK:
				case PERCENTILE_CONT:
				case PERCENTILE_DISC:
				case RANK:
				case AVG:
				case CORR:
				case COVAR_:
				case LAG:
				case LEAD:
				case MAX:
				case MEDIAN:
				case MIN:
				case NTILE:
				case RATIO_TO_REPORT:
				case REGR_:
				case ROW_NUMBER:
				case TRIM:
				case SUM:
				case STDDEV:
				case VAR_:
				case VARIANCE:
				case DELIMITED_ID:
				case BINDVAR:
				case COLON:
				case INTRODUCER:
				case REGULAR_ID:
					{
					State = 2418; cursor_name();
					State = 2420;
					_la = _input.La(1);
					if (_la==LEFT_PAREN) {
						{
						State = 2419; expression_list();
						}
					}

					}
					break;
				case LEFT_PAREN:
					{
					State = 2422; Match(LEFT_PAREN);
					State = 2423; select_statement();
					State = 2424; Match(RIGHT_PAREN);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Forall_statementContext : ParserRuleContext {
		public Bounds_clauseContext bounds_clause() {
			return GetRuleContext<Bounds_clauseContext>(0);
		}
		public Sql_statementContext sql_statement() {
			return GetRuleContext<Sql_statementContext>(0);
		}
		public ITerminalNode EXCEPTIONS() { return GetToken(plsqlParser.EXCEPTIONS, 0); }
		public ITerminalNode SAVE() { return GetToken(plsqlParser.SAVE, 0); }
		public Index_nameContext index_name() {
			return GetRuleContext<Index_nameContext>(0);
		}
		public ITerminalNode FORALL() { return GetToken(plsqlParser.FORALL, 0); }
		public ITerminalNode IN() { return GetToken(plsqlParser.IN, 0); }
		public Forall_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forall_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterForall_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitForall_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitForall_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Forall_statementContext forall_statement() {
		Forall_statementContext _localctx = new Forall_statementContext(_ctx, State);
		EnterRule(_localctx, 246, RULE_forall_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2430; Match(FORALL);
			State = 2431; index_name();
			State = 2432; Match(IN);
			State = 2433; bounds_clause();
			State = 2434; sql_statement();
			State = 2437;
			_la = _input.La(1);
			if (_la==SAVE) {
				{
				State = 2435; Match(SAVE);
				State = 2436; Match(EXCEPTIONS);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Bounds_clauseContext : ParserRuleContext {
		public ITerminalNode VALUES() { return GetToken(plsqlParser.VALUES, 0); }
		public Upper_boundContext upper_bound() {
			return GetRuleContext<Upper_boundContext>(0);
		}
		public ITerminalNode INDICES() { return GetToken(plsqlParser.INDICES, 0); }
		public ITerminalNode OF() { return GetToken(plsqlParser.OF, 0); }
		public Index_nameContext index_name() {
			return GetRuleContext<Index_nameContext>(0);
		}
		public Collection_nameContext collection_name() {
			return GetRuleContext<Collection_nameContext>(0);
		}
		public Lower_boundContext lower_bound() {
			return GetRuleContext<Lower_boundContext>(0);
		}
		public Between_boundContext between_bound() {
			return GetRuleContext<Between_boundContext>(0);
		}
		public Bounds_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bounds_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterBounds_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitBounds_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBounds_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Bounds_clauseContext bounds_clause() {
		Bounds_clauseContext _localctx = new Bounds_clauseContext(_ctx, State);
		EnterRule(_localctx, 248, RULE_bounds_clause);
		int _la;
		try {
			State = 2452;
			switch ( Interpreter.AdaptivePredict(_input,238,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2439; lower_bound();
				State = 2440; Match(T__0);
				State = 2441; upper_bound();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2443; Match(INDICES);
				State = 2444; Match(OF);
				State = 2445; collection_name();
				State = 2447;
				_la = _input.La(1);
				if (_la==BETWEEN) {
					{
					State = 2446; between_bound();
					}
				}

				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2449; Match(VALUES);
				State = 2450; Match(OF);
				State = 2451; index_name();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Between_boundContext : ParserRuleContext {
		public ITerminalNode BETWEEN() { return GetToken(plsqlParser.BETWEEN, 0); }
		public Upper_boundContext upper_bound() {
			return GetRuleContext<Upper_boundContext>(0);
		}
		public ITerminalNode AND() { return GetToken(plsqlParser.AND, 0); }
		public Lower_boundContext lower_bound() {
			return GetRuleContext<Lower_boundContext>(0);
		}
		public Between_boundContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_between_bound; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterBetween_bound(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitBetween_bound(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBetween_bound(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Between_boundContext between_bound() {
		Between_boundContext _localctx = new Between_boundContext(_ctx, State);
		EnterRule(_localctx, 250, RULE_between_bound);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2454; Match(BETWEEN);
			State = 2455; lower_bound();
			State = 2456; Match(AND);
			State = 2457; upper_bound();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Lower_boundContext : ParserRuleContext {
		public ConcatenationContext concatenation() {
			return GetRuleContext<ConcatenationContext>(0);
		}
		public Lower_boundContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lower_bound; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterLower_bound(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitLower_bound(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLower_bound(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Lower_boundContext lower_bound() {
		Lower_boundContext _localctx = new Lower_boundContext(_ctx, State);
		EnterRule(_localctx, 252, RULE_lower_bound);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2459; concatenation();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Upper_boundContext : ParserRuleContext {
		public ConcatenationContext concatenation() {
			return GetRuleContext<ConcatenationContext>(0);
		}
		public Upper_boundContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_upper_bound; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterUpper_bound(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitUpper_bound(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUpper_bound(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Upper_boundContext upper_bound() {
		Upper_boundContext _localctx = new Upper_boundContext(_ctx, State);
		EnterRule(_localctx, 254, RULE_upper_bound);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2461; concatenation();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Null_statementContext : ParserRuleContext {
		public ITerminalNode NULL() { return GetToken(plsqlParser.NULL, 0); }
		public Null_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_null_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterNull_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitNull_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNull_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Null_statementContext null_statement() {
		Null_statementContext _localctx = new Null_statementContext(_ctx, State);
		EnterRule(_localctx, 256, RULE_null_statement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2463; Match(NULL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Raise_statementContext : ParserRuleContext {
		public ITerminalNode RAISE() { return GetToken(plsqlParser.RAISE, 0); }
		public Exception_nameContext exception_name() {
			return GetRuleContext<Exception_nameContext>(0);
		}
		public Raise_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_raise_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterRaise_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitRaise_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRaise_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Raise_statementContext raise_statement() {
		Raise_statementContext _localctx = new Raise_statementContext(_ctx, State);
		EnterRule(_localctx, 258, RULE_raise_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2465; Match(RAISE);
			State = 2467;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (CONSTANT - 66)) | (1L << (CONSTRAINT - 66)) | (1L << (CONSTRAINTS - 66)) | (1L << (CONSTRUCTOR - 66)) | (1L << (CONTENT - 66)) | (1L << (CONTEXT - 66)) | (1L << (CONTINUE - 66)) | (1L << (CONVERT - 66)) | (1L << (CORRUPT_XID - 66)) | (1L << (CORRUPT_XID_ALL - 66)) | (1L << (COST - 66)) | (1L << (COUNT - 66)) | (1L << (CROSS - 66)) | (1L << (CUBE - 66)) | (1L << (CURRENT_USER - 66)) | (1L << (CURSOR - 66)) | (1L << (CUSTOMDATUM - 66)) | (1L << (CYCLE - 66)) | (1L << (DATA - 66)) | (1L << (DATABASE - 66)) | (1L << (DAY - 66)) | (1L << (DB_ROLE_CHANGE - 66)) | (1L << (DBTIMEZONE - 66)) | (1L << (DDL - 66)) | (1L << (DEBUG - 66)) | (1L << (DEC - 66)) | (1L << (DECIMAL - 66)) | (1L << (DECOMPOSE - 66)) | (1L << (DECREMENT - 66)) | (1L << (DEFAULTS - 66)) | (1L << (DEFERRED - 66)) | (1L << (DEFINER - 66)) | (1L << (DETERMINISTIC - 66)) | (1L << (DIMENSION - 66)) | (1L << (DISABLE - 66)) | (1L << (DISASSOCIATE - 66)) | (1L << (DOCUMENT - 66)) | (1L << (DOUBLE - 66)) | (1L << (DSINTERVAL_UNCONSTRAINED - 66)) | (1L << (EACH - 66)) | (1L << (ELEMENT - 66)) | (1L << (EMPTY - 66)) | (1L << (ENABLE - 66)) | (1L << (ENCODING - 66)) | (1L << (ENTITYESCAPING - 66)) | (1L << (ERR - 66)) | (1L << (ERRORS - 66)) | (1L << (ESCAPE - 66)) | (1L << (EVALNAME - 66)) | (1L << (EXCEPTION - 66)) | (1L << (EXCEPTION_INIT - 66)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)) | (1L << (EXIT - 130)) | (1L << (EXPLAIN - 130)) | (1L << (EXTERNAL - 130)) | (1L << (EXTRACT - 130)) | (1L << (FAILURE - 130)) | (1L << (FINAL - 130)) | (1L << (FIRST - 130)) | (1L << (FIRST_VALUE - 130)) | (1L << (FLOAT - 130)) | (1L << (FOLLOWING - 130)) | (1L << (FOLLOWS - 130)) | (1L << (FORALL - 130)) | (1L << (FORCE - 130)) | (1L << (FULL - 130)) | (1L << (FUNCTION - 130)) | (1L << (GROUPING - 130)) | (1L << (HASH - 130)) | (1L << (HIDE - 130)) | (1L << (HOUR - 130)) | (1L << (IGNORE - 130)) | (1L << (IMMEDIATE - 130)) | (1L << (INCLUDE - 130)) | (1L << (INCLUDING - 130)) | (1L << (INCREMENT - 130)) | (1L << (INDENT - 130)) | (1L << (INDEXED - 130)) | (1L << (INDICATOR - 130)) | (1L << (INDICES - 130)) | (1L << (INFINITE - 130)) | (1L << (INLINE - 130)) | (1L << (INNER - 130)) | (1L << (INOUT - 130)) | (1L << (INSTANTIABLE - 130)) | (1L << (INSTEAD - 130)) | (1L << (INT - 130)) | (1L << (INTEGER - 130)) | (1L << (INTERVAL - 130)) | (1L << (INVALIDATE - 130)) | (1L << (ISOLATION - 130)) | (1L << (ITERATE - 130)) | (1L << (JAVA - 130)) | (1L << (JOIN - 130)) | (1L << (KEEP - 130)) | (1L << (LANGUAGE - 130)))) != 0) || ((((_la - 194)) & ~0x3f) == 0 && ((1L << (_la - 194)) & ((1L << (LAST - 194)) | (1L << (LAST_VALUE - 194)) | (1L << (LEADING - 194)) | (1L << (LEFT - 194)) | (1L << (LEVEL - 194)) | (1L << (LIBRARY - 194)) | (1L << (LIKE2 - 194)) | (1L << (LIKE4 - 194)) | (1L << (LIKEC - 194)) | (1L << (LIMIT - 194)) | (1L << (LOCAL - 194)) | (1L << (LOCKED - 194)) | (1L << (LOG - 194)) | (1L << (LOGOFF - 194)) | (1L << (LOGON - 194)) | (1L << (LONG - 194)) | (1L << (LOOP - 194)) | (1L << (MAIN - 194)) | (1L << (MAP - 194)) | (1L << (MATCHED - 194)) | (1L << (MAXVALUE - 194)) | (1L << (MEASURES - 194)) | (1L << (MEMBER - 194)) | (1L << (MERGE - 194)) | (1L << (MINUTE - 194)) | (1L << (MINVALUE - 194)) | (1L << (MLSLABEL - 194)) | (1L << (MODEL - 194)) | (1L << (MODIFY - 194)) | (1L << (MONTH - 194)) | (1L << (MULTISET - 194)) | (1L << (NAME - 194)) | (1L << (NAN - 194)) | (1L << (NATURAL - 194)) | (1L << (NATURALN - 194)) | (1L << (NAV - 194)) | (1L << (NCHAR - 194)) | (1L << (NCHAR_CS - 194)) | (1L << (NCLOB - 194)) | (1L << (NESTED - 194)) | (1L << (NEW - 194)) | (1L << (NO - 194)) | (1L << (NOAUDIT - 194)) | (1L << (NOCOPY - 194)) | (1L << (NOCYCLE - 194)) | (1L << (NOENTITYESCAPING - 194)) | (1L << (NONE - 194)) | (1L << (NOSCHEMACHECK - 194)) | (1L << (NULLS - 194)) | (1L << (NUMBER - 194)) | (1L << (NUMERIC - 194)) | (1L << (NVARCHAR2 - 194)) | (1L << (OBJECT - 194)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (OFF - 259)) | (1L << (OID - 259)) | (1L << (OLD - 259)) | (1L << (ONLY - 259)) | (1L << (OPEN - 259)) | (1L << (ORADATA - 259)) | (1L << (ORDINALITY - 259)) | (1L << (OSERROR - 259)) | (1L << (OUT - 259)) | (1L << (OUTER - 259)) | (1L << (OVER - 259)) | (1L << (OVERRIDING - 259)) | (1L << (PACKAGE - 259)) | (1L << (PARALLEL_ENABLE - 259)) | (1L << (PARAMETERS - 259)) | (1L << (PARENT - 259)) | (1L << (PARTITION - 259)) | (1L << (PASSING - 259)) | (1L << (PATH - 259)) | (1L << (PIPELINED - 259)) | (1L << (PLAN - 259)) | (1L << (PLS_INTEGER - 259)) | (1L << (POSITIVE - 259)) | (1L << (POSITIVEN - 259)) | (1L << (PRAGMA - 259)) | (1L << (PRECEDING - 259)) | (1L << (PRECISION - 259)) | (1L << (PRESENT - 259)) | (1L << (RAISE - 259)) | (1L << (RANGE - 259)) | (1L << (RAW - 259)) | (1L << (READ - 259)) | (1L << (REAL - 259)) | (1L << (RECORD - 259)) | (1L << (REF - 259)) | (1L << (REFERENCE - 259)) | (1L << (REFERENCING - 259)) | (1L << (REJECT - 259)) | (1L << (RELIES_ON - 259)) | (1L << (RENAME - 259)) | (1L << (REPLACE - 259)) | (1L << (RESPECT - 259)) | (1L << (RESTRICT_REFERENCES - 259)) | (1L << (RESULT - 259)) | (1L << (RESULT_CACHE - 259)) | (1L << (RETURN - 259)) | (1L << (RETURNING - 259)) | (1L << (REUSE - 259)) | (1L << (REVERSE - 259)) | (1L << (RIGHT - 259)))) != 0) || ((((_la - 323)) & ~0x3f) == 0 && ((1L << (_la - 323)) & ((1L << (ROLLBACK - 323)) | (1L << (ROLLUP - 323)) | (1L << (ROW - 323)) | (1L << (ROWID - 323)) | (1L << (ROWS - 323)) | (1L << (RULES - 323)) | (1L << (SAMPLE - 323)) | (1L << (SAVE - 323)) | (1L << (SAVEPOINT - 323)) | (1L << (SCHEMA - 323)) | (1L << (SCHEMACHECK - 323)) | (1L << (SCN - 323)) | (1L << (SECOND - 323)) | (1L << (SEED - 323)) | (1L << (SEGMENT - 323)) | (1L << (SELF - 323)) | (1L << (SEQUENTIAL - 323)) | (1L << (SERIALIZABLE - 323)) | (1L << (SERIALLY_REUSABLE - 323)) | (1L << (SERVERERROR - 323)) | (1L << (SESSIONTIMEZONE - 323)) | (1L << (SET - 323)) | (1L << (SETS - 323)) | (1L << (SETTINGS - 323)) | (1L << (SHOW - 323)) | (1L << (SHUTDOWN - 323)) | (1L << (SIBLINGS - 323)) | (1L << (SIGNTYPE - 323)) | (1L << (SIMPLE_INTEGER - 323)) | (1L << (SINGLE - 323)) | (1L << (SKIP_ - 323)) | (1L << (SMALLINT - 323)) | (1L << (SNAPSHOT - 323)) | (1L << (SOME - 323)) | (1L << (SPECIFICATION - 323)) | (1L << (SQLDATA - 323)) | (1L << (SQLERROR - 323)) | (1L << (STANDALONE - 323)) | (1L << (STARTUP - 323)) | (1L << (STATEMENT - 323)) | (1L << (STATEMENT_ID - 323)) | (1L << (STATIC - 323)) | (1L << (STATISTICS - 323)) | (1L << (STRING - 323)) | (1L << (SUBMULTISET - 323)) | (1L << (SUBPARTITION - 323)) | (1L << (SUBSTITUTABLE - 323)) | (1L << (SUBTYPE - 323)) | (1L << (SUCCESS - 323)) | (1L << (SUSPEND - 323)) | (1L << (TIME - 323)) | (1L << (TIMESTAMP - 323)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_UNCONSTRAINED - 323)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TIMEZONE_ABBR - 387)) | (1L << (TIMEZONE_HOUR - 387)) | (1L << (TIMEZONE_MINUTE - 387)) | (1L << (TIMEZONE_REGION - 387)) | (1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (YMINTERVAL_UNCONSTRAINED - 451)) | (1L << (ZONE - 451)) | (1L << (PREDICTION - 451)) | (1L << (PREDICTION_BOUNDS - 451)) | (1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (COVAR_ - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (REGR_ - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (TRIM - 451)) | (1L << (SUM - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (VARIANCE - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 2466; exception_name();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Return_statementContext : ParserRuleContext {
		public ITerminalNode RETURN() { return GetToken(plsqlParser.RETURN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Return_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_return_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterReturn_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitReturn_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReturn_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Return_statementContext return_statement() {
		Return_statementContext _localctx = new Return_statementContext(_ctx, State);
		EnterRule(_localctx, 260, RULE_return_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2469; Match(RETURN);
			State = 2471;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALL) | (1L << ANALYZE) | (1L << ANY) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COALESCE) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & ((1L << (CONNECT_BY_ROOT - 65)) | (1L << (CONSTANT - 65)) | (1L << (CONSTRAINT - 65)) | (1L << (CONSTRAINTS - 65)) | (1L << (CONSTRUCTOR - 65)) | (1L << (CONTENT - 65)) | (1L << (CONTEXT - 65)) | (1L << (CONTINUE - 65)) | (1L << (CONVERT - 65)) | (1L << (CORRUPT_XID - 65)) | (1L << (CORRUPT_XID_ALL - 65)) | (1L << (COST - 65)) | (1L << (COUNT - 65)) | (1L << (CROSS - 65)) | (1L << (CUBE - 65)) | (1L << (CURRENT_USER - 65)) | (1L << (CURSOR - 65)) | (1L << (CUSTOMDATUM - 65)) | (1L << (CYCLE - 65)) | (1L << (DATA - 65)) | (1L << (DATABASE - 65)) | (1L << (DATE - 65)) | (1L << (DAY - 65)) | (1L << (DB_ROLE_CHANGE - 65)) | (1L << (DBTIMEZONE - 65)) | (1L << (DDL - 65)) | (1L << (DEBUG - 65)) | (1L << (DEC - 65)) | (1L << (DECIMAL - 65)) | (1L << (DECOMPOSE - 65)) | (1L << (DECREMENT - 65)) | (1L << (DEFAULT - 65)) | (1L << (DEFAULTS - 65)) | (1L << (DEFERRED - 65)) | (1L << (DEFINER - 65)) | (1L << (DETERMINISTIC - 65)) | (1L << (DIMENSION - 65)) | (1L << (DISABLE - 65)) | (1L << (DISASSOCIATE - 65)) | (1L << (DISTINCT - 65)) | (1L << (DOCUMENT - 65)) | (1L << (DOUBLE - 65)) | (1L << (DSINTERVAL_UNCONSTRAINED - 65)) | (1L << (EACH - 65)) | (1L << (ELEMENT - 65)) | (1L << (EMPTY - 65)) | (1L << (ENABLE - 65)) | (1L << (ENCODING - 65)) | (1L << (ENTITYESCAPING - 65)) | (1L << (ERR - 65)) | (1L << (ERRORS - 65)) | (1L << (ESCAPE - 65)) | (1L << (EVALNAME - 65)) | (1L << (EXCEPTION - 65)))) != 0) || ((((_la - 129)) & ~0x3f) == 0 && ((1L << (_la - 129)) & ((1L << (EXCEPTION_INIT - 129)) | (1L << (EXCEPTIONS - 129)) | (1L << (EXCLUDE - 129)) | (1L << (EXECUTE - 129)) | (1L << (EXISTS - 129)) | (1L << (EXIT - 129)) | (1L << (EXPLAIN - 129)) | (1L << (EXTERNAL - 129)) | (1L << (EXTRACT - 129)) | (1L << (FAILURE - 129)) | (1L << (FALSE - 129)) | (1L << (FINAL - 129)) | (1L << (FIRST - 129)) | (1L << (FIRST_VALUE - 129)) | (1L << (FLOAT - 129)) | (1L << (FOLLOWING - 129)) | (1L << (FOLLOWS - 129)) | (1L << (FORALL - 129)) | (1L << (FORCE - 129)) | (1L << (FULL - 129)) | (1L << (FUNCTION - 129)) | (1L << (GROUPING - 129)) | (1L << (HASH - 129)) | (1L << (HIDE - 129)) | (1L << (HOUR - 129)) | (1L << (IGNORE - 129)) | (1L << (IMMEDIATE - 129)) | (1L << (INCLUDE - 129)) | (1L << (INCLUDING - 129)) | (1L << (INCREMENT - 129)) | (1L << (INDENT - 129)) | (1L << (INDEXED - 129)) | (1L << (INDICATOR - 129)) | (1L << (INDICES - 129)) | (1L << (INFINITE - 129)) | (1L << (INLINE - 129)) | (1L << (INNER - 129)) | (1L << (INOUT - 129)) | (1L << (INSTANTIABLE - 129)) | (1L << (INSTEAD - 129)) | (1L << (INT - 129)) | (1L << (INTEGER - 129)) | (1L << (INTERVAL - 129)) | (1L << (INVALIDATE - 129)) | (1L << (ISOLATION - 129)) | (1L << (ITERATE - 129)) | (1L << (JAVA - 129)) | (1L << (JOIN - 129)) | (1L << (KEEP - 129)))) != 0) || ((((_la - 193)) & ~0x3f) == 0 && ((1L << (_la - 193)) & ((1L << (LANGUAGE - 193)) | (1L << (LAST - 193)) | (1L << (LAST_VALUE - 193)) | (1L << (LEADING - 193)) | (1L << (LEFT - 193)) | (1L << (LEVEL - 193)) | (1L << (LIBRARY - 193)) | (1L << (LIKE2 - 193)) | (1L << (LIKE4 - 193)) | (1L << (LIKEC - 193)) | (1L << (LIMIT - 193)) | (1L << (LOCAL - 193)) | (1L << (LOCKED - 193)) | (1L << (LOG - 193)) | (1L << (LOGOFF - 193)) | (1L << (LOGON - 193)) | (1L << (LONG - 193)) | (1L << (LOOP - 193)) | (1L << (MAIN - 193)) | (1L << (MAP - 193)) | (1L << (MATCHED - 193)) | (1L << (MAXVALUE - 193)) | (1L << (MEASURES - 193)) | (1L << (MEMBER - 193)) | (1L << (MERGE - 193)) | (1L << (MINUTE - 193)) | (1L << (MINVALUE - 193)) | (1L << (MLSLABEL - 193)) | (1L << (MODEL - 193)) | (1L << (MODIFY - 193)) | (1L << (MONTH - 193)) | (1L << (MULTISET - 193)) | (1L << (NAME - 193)) | (1L << (NAN - 193)) | (1L << (NATURAL - 193)) | (1L << (NATURALN - 193)) | (1L << (NAV - 193)) | (1L << (NCHAR - 193)) | (1L << (NCHAR_CS - 193)) | (1L << (NCLOB - 193)) | (1L << (NESTED - 193)) | (1L << (NEW - 193)) | (1L << (NO - 193)) | (1L << (NOAUDIT - 193)) | (1L << (NOCOPY - 193)) | (1L << (NOCYCLE - 193)) | (1L << (NOENTITYESCAPING - 193)) | (1L << (NONE - 193)) | (1L << (NOSCHEMACHECK - 193)) | (1L << (NOT - 193)) | (1L << (NULL - 193)) | (1L << (NULLS - 193)) | (1L << (NUMBER - 193)) | (1L << (NUMERIC - 193)) | (1L << (NVARCHAR2 - 193)))) != 0) || ((((_la - 257)) & ~0x3f) == 0 && ((1L << (_la - 257)) & ((1L << (OBJECT - 257)) | (1L << (OFF - 257)) | (1L << (OID - 257)) | (1L << (OLD - 257)) | (1L << (ONLY - 257)) | (1L << (OPEN - 257)) | (1L << (ORADATA - 257)) | (1L << (ORDINALITY - 257)) | (1L << (OSERROR - 257)) | (1L << (OUT - 257)) | (1L << (OUTER - 257)) | (1L << (OVER - 257)) | (1L << (OVERRIDING - 257)) | (1L << (PACKAGE - 257)) | (1L << (PARALLEL_ENABLE - 257)) | (1L << (PARAMETERS - 257)) | (1L << (PARENT - 257)) | (1L << (PARTITION - 257)) | (1L << (PASSING - 257)) | (1L << (PATH - 257)) | (1L << (PIPELINED - 257)) | (1L << (PLAN - 257)) | (1L << (PLS_INTEGER - 257)) | (1L << (POSITIVE - 257)) | (1L << (POSITIVEN - 257)) | (1L << (PRAGMA - 257)) | (1L << (PRECEDING - 257)) | (1L << (PRECISION - 257)) | (1L << (PRESENT - 257)) | (1L << (PRIOR - 257)) | (1L << (RAISE - 257)) | (1L << (RANGE - 257)) | (1L << (RAW - 257)) | (1L << (READ - 257)) | (1L << (REAL - 257)) | (1L << (RECORD - 257)) | (1L << (REF - 257)) | (1L << (REFERENCE - 257)) | (1L << (REFERENCING - 257)) | (1L << (REJECT - 257)) | (1L << (RELIES_ON - 257)) | (1L << (RENAME - 257)) | (1L << (REPLACE - 257)) | (1L << (RESPECT - 257)) | (1L << (RESTRICT_REFERENCES - 257)) | (1L << (RESULT - 257)) | (1L << (RESULT_CACHE - 257)) | (1L << (RETURN - 257)) | (1L << (RETURNING - 257)) | (1L << (REUSE - 257)) | (1L << (REVERSE - 257)))) != 0) || ((((_la - 322)) & ~0x3f) == 0 && ((1L << (_la - 322)) & ((1L << (RIGHT - 322)) | (1L << (ROLLBACK - 322)) | (1L << (ROLLUP - 322)) | (1L << (ROW - 322)) | (1L << (ROWID - 322)) | (1L << (ROWS - 322)) | (1L << (RULES - 322)) | (1L << (SAMPLE - 322)) | (1L << (SAVE - 322)) | (1L << (SAVEPOINT - 322)) | (1L << (SCHEMA - 322)) | (1L << (SCHEMACHECK - 322)) | (1L << (SCN - 322)) | (1L << (SECOND - 322)) | (1L << (SEED - 322)) | (1L << (SEGMENT - 322)) | (1L << (SELF - 322)) | (1L << (SEQUENTIAL - 322)) | (1L << (SERIALIZABLE - 322)) | (1L << (SERIALLY_REUSABLE - 322)) | (1L << (SERVERERROR - 322)) | (1L << (SESSIONTIMEZONE - 322)) | (1L << (SET - 322)) | (1L << (SETS - 322)) | (1L << (SETTINGS - 322)) | (1L << (SHOW - 322)) | (1L << (SHUTDOWN - 322)) | (1L << (SIBLINGS - 322)) | (1L << (SIGNTYPE - 322)) | (1L << (SIMPLE_INTEGER - 322)) | (1L << (SINGLE - 322)) | (1L << (SKIP_ - 322)) | (1L << (SMALLINT - 322)) | (1L << (SNAPSHOT - 322)) | (1L << (SOME - 322)) | (1L << (SPECIFICATION - 322)) | (1L << (SQLDATA - 322)) | (1L << (SQLERROR - 322)) | (1L << (STANDALONE - 322)) | (1L << (STARTUP - 322)) | (1L << (STATEMENT - 322)) | (1L << (STATEMENT_ID - 322)) | (1L << (STATIC - 322)) | (1L << (STATISTICS - 322)) | (1L << (STRING - 322)) | (1L << (SUBMULTISET - 322)) | (1L << (SUBPARTITION - 322)) | (1L << (SUBSTITUTABLE - 322)) | (1L << (SUBTYPE - 322)) | (1L << (SUCCESS - 322)) | (1L << (SUSPEND - 322)) | (1L << (TIME - 322)) | (1L << (TIMESTAMP - 322)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 322)))) != 0) || ((((_la - 386)) & ~0x3f) == 0 && ((1L << (_la - 386)) & ((1L << (TIMESTAMP_UNCONSTRAINED - 386)) | (1L << (TIMEZONE_ABBR - 386)) | (1L << (TIMEZONE_HOUR - 386)) | (1L << (TIMEZONE_MINUTE - 386)) | (1L << (TIMEZONE_REGION - 386)) | (1L << (TRAILING - 386)) | (1L << (TRANSACTION - 386)) | (1L << (TRANSLATE - 386)) | (1L << (TREAT - 386)) | (1L << (TRIGGER - 386)) | (1L << (TRUE - 386)) | (1L << (TRUNCATE - 386)) | (1L << (TYPE - 386)) | (1L << (UNBOUNDED - 386)) | (1L << (UNDER - 386)) | (1L << (UNLIMITED - 386)) | (1L << (UNTIL - 386)) | (1L << (UPDATED - 386)) | (1L << (UPSERT - 386)) | (1L << (UROWID - 386)) | (1L << (USE - 386)) | (1L << (VALIDATE - 386)) | (1L << (VALUE - 386)) | (1L << (VARCHAR - 386)) | (1L << (VARCHAR2 - 386)) | (1L << (VARIABLE - 386)) | (1L << (VARRAY - 386)) | (1L << (VARYING - 386)) | (1L << (VERSION - 386)) | (1L << (VERSIONS - 386)) | (1L << (WAIT - 386)) | (1L << (WARNING - 386)) | (1L << (WELLFORMED - 386)) | (1L << (WHENEVER - 386)) | (1L << (WHILE - 386)) | (1L << (WITHIN - 386)) | (1L << (WORK - 386)) | (1L << (WRITE - 386)) | (1L << (XML - 386)) | (1L << (XMLAGG - 386)) | (1L << (XMLATTRIBUTES - 386)) | (1L << (XMLCAST - 386)) | (1L << (XMLCOLATTVAL - 386)) | (1L << (XMLELEMENT - 386)) | (1L << (XMLEXISTS - 386)) | (1L << (XMLFOREST - 386)) | (1L << (XMLNAMESPACES - 386)) | (1L << (XMLPARSE - 386)) | (1L << (XMLPI - 386)) | (1L << (XMLQUERY - 386)) | (1L << (XMLROOT - 386)) | (1L << (XMLSERIALIZE - 386)) | (1L << (XMLTABLE - 386)) | (1L << (YEAR - 386)))) != 0) || ((((_la - 450)) & ~0x3f) == 0 && ((1L << (_la - 450)) & ((1L << (YES - 450)) | (1L << (YMINTERVAL_UNCONSTRAINED - 450)) | (1L << (ZONE - 450)) | (1L << (PREDICTION - 450)) | (1L << (PREDICTION_BOUNDS - 450)) | (1L << (PREDICTION_COST - 450)) | (1L << (PREDICTION_DETAILS - 450)) | (1L << (PREDICTION_PROBABILITY - 450)) | (1L << (PREDICTION_SET - 450)) | (1L << (CUME_DIST - 450)) | (1L << (DENSE_RANK - 450)) | (1L << (LISTAGG - 450)) | (1L << (PERCENT_RANK - 450)) | (1L << (PERCENTILE_CONT - 450)) | (1L << (PERCENTILE_DISC - 450)) | (1L << (RANK - 450)) | (1L << (AVG - 450)) | (1L << (CORR - 450)) | (1L << (COVAR_ - 450)) | (1L << (DECODE - 450)) | (1L << (LAG - 450)) | (1L << (LEAD - 450)) | (1L << (MAX - 450)) | (1L << (MEDIAN - 450)) | (1L << (MIN - 450)) | (1L << (NTILE - 450)) | (1L << (NVL - 450)) | (1L << (RATIO_TO_REPORT - 450)) | (1L << (REGR_ - 450)) | (1L << (ROUND - 450)) | (1L << (ROW_NUMBER - 450)) | (1L << (SUBSTR - 450)) | (1L << (TO_CHAR - 450)) | (1L << (TRIM - 450)) | (1L << (SUM - 450)) | (1L << (STDDEV - 450)) | (1L << (VAR_ - 450)) | (1L << (VARIANCE - 450)) | (1L << (NATIONAL_CHAR_STRING_LIT - 450)) | (1L << (UNSIGNED_INTEGER - 450)) | (1L << (APPROXIMATE_NUM_LIT - 450)) | (1L << (CHAR_STRING - 450)) | (1L << (DELIMITED_ID - 450)) | (1L << (LEFT_PAREN - 450)) | (1L << (PLUS_SIGN - 450)) | (1L << (MINUS_SIGN - 450)) | (1L << (BINDVAR - 450)) | (1L << (COLON - 450)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 2470; expression();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Function_callContext : ParserRuleContext {
		public ITerminalNode CALL() { return GetToken(plsqlParser.CALL, 0); }
		public Function_argumentContext function_argument() {
			return GetRuleContext<Function_argumentContext>(0);
		}
		public Routine_nameContext routine_name() {
			return GetRuleContext<Routine_nameContext>(0);
		}
		public Function_callContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function_call; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterFunction_call(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitFunction_call(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction_call(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Function_callContext function_call() {
		Function_callContext _localctx = new Function_callContext(_ctx, State);
		EnterRule(_localctx, 262, RULE_function_call);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2474;
			switch ( Interpreter.AdaptivePredict(_input,241,_ctx) ) {
			case 1:
				{
				State = 2473; Match(CALL);
				}
				break;
			}
			State = 2476; routine_name();
			State = 2478;
			_la = _input.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 2477; function_argument();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BodyContext : ParserRuleContext {
		public Seq_of_statementsContext seq_of_statements() {
			return GetRuleContext<Seq_of_statementsContext>(0);
		}
		public Label_nameContext label_name() {
			return GetRuleContext<Label_nameContext>(0);
		}
		public IReadOnlyList<Exception_handlerContext> exception_handler() {
			return GetRuleContexts<Exception_handlerContext>();
		}
		public ITerminalNode BEGIN() { return GetToken(plsqlParser.BEGIN, 0); }
		public ITerminalNode END() { return GetToken(plsqlParser.END, 0); }
		public Exception_handlerContext exception_handler(int i) {
			return GetRuleContext<Exception_handlerContext>(i);
		}
		public ITerminalNode EXCEPTION() { return GetToken(plsqlParser.EXCEPTION, 0); }
		public BodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_body; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterBody(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitBody(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBody(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BodyContext body() {
		BodyContext _localctx = new BodyContext(_ctx, State);
		EnterRule(_localctx, 264, RULE_body);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2480; Match(BEGIN);
			State = 2481; seq_of_statements();
			State = 2488;
			_la = _input.La(1);
			if (_la==EXCEPTION) {
				{
				State = 2482; Match(EXCEPTION);
				State = 2484;
				_errHandler.Sync(this);
				_la = _input.La(1);
				do {
					{
					{
					State = 2483; exception_handler();
					}
					}
					State = 2486;
					_errHandler.Sync(this);
					_la = _input.La(1);
				} while ( _la==WHEN );
				}
			}

			State = 2490; Match(END);
			State = 2492;
			switch ( Interpreter.AdaptivePredict(_input,245,_ctx) ) {
			case 1:
				{
				State = 2491; label_name();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Exception_handlerContext : ParserRuleContext {
		public Seq_of_statementsContext seq_of_statements() {
			return GetRuleContext<Seq_of_statementsContext>(0);
		}
		public Exception_nameContext exception_name(int i) {
			return GetRuleContext<Exception_nameContext>(i);
		}
		public ITerminalNode THEN() { return GetToken(plsqlParser.THEN, 0); }
		public ITerminalNode WHEN() { return GetToken(plsqlParser.WHEN, 0); }
		public IReadOnlyList<Exception_nameContext> exception_name() {
			return GetRuleContexts<Exception_nameContext>();
		}
		public IReadOnlyList<ITerminalNode> OR() { return GetTokens(plsqlParser.OR); }
		public ITerminalNode OR(int i) {
			return GetToken(plsqlParser.OR, i);
		}
		public Exception_handlerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exception_handler; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterException_handler(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitException_handler(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitException_handler(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Exception_handlerContext exception_handler() {
		Exception_handlerContext _localctx = new Exception_handlerContext(_ctx, State);
		EnterRule(_localctx, 266, RULE_exception_handler);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2494; Match(WHEN);
			State = 2495; exception_name();
			State = 2500;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==OR) {
				{
				{
				State = 2496; Match(OR);
				State = 2497; exception_name();
				}
				}
				State = 2502;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 2503; Match(THEN);
			State = 2504; seq_of_statements();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Trigger_blockContext : ParserRuleContext {
		public IReadOnlyList<Declare_specContext> declare_spec() {
			return GetRuleContexts<Declare_specContext>();
		}
		public ITerminalNode DECLARE() { return GetToken(plsqlParser.DECLARE, 0); }
		public Declare_specContext declare_spec(int i) {
			return GetRuleContext<Declare_specContext>(i);
		}
		public BodyContext body() {
			return GetRuleContext<BodyContext>(0);
		}
		public Trigger_blockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_trigger_block; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterTrigger_block(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitTrigger_block(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTrigger_block(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Trigger_blockContext trigger_block() {
		Trigger_blockContext _localctx = new Trigger_blockContext(_ctx, State);
		EnterRule(_localctx, 268, RULE_trigger_block);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2514;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (CONSTANT - 66)) | (1L << (CONSTRAINT - 66)) | (1L << (CONSTRAINTS - 66)) | (1L << (CONSTRUCTOR - 66)) | (1L << (CONTENT - 66)) | (1L << (CONTEXT - 66)) | (1L << (CONTINUE - 66)) | (1L << (CONVERT - 66)) | (1L << (CORRUPT_XID - 66)) | (1L << (CORRUPT_XID_ALL - 66)) | (1L << (COST - 66)) | (1L << (COUNT - 66)) | (1L << (CROSS - 66)) | (1L << (CUBE - 66)) | (1L << (CURRENT_USER - 66)) | (1L << (CURSOR - 66)) | (1L << (CUSTOMDATUM - 66)) | (1L << (CYCLE - 66)) | (1L << (DATA - 66)) | (1L << (DATABASE - 66)) | (1L << (DAY - 66)) | (1L << (DB_ROLE_CHANGE - 66)) | (1L << (DBTIMEZONE - 66)) | (1L << (DDL - 66)) | (1L << (DEBUG - 66)) | (1L << (DEC - 66)) | (1L << (DECIMAL - 66)) | (1L << (DECLARE - 66)) | (1L << (DECOMPOSE - 66)) | (1L << (DECREMENT - 66)) | (1L << (DEFAULTS - 66)) | (1L << (DEFERRED - 66)) | (1L << (DEFINER - 66)) | (1L << (DETERMINISTIC - 66)) | (1L << (DIMENSION - 66)) | (1L << (DISABLE - 66)) | (1L << (DISASSOCIATE - 66)) | (1L << (DOCUMENT - 66)) | (1L << (DOUBLE - 66)) | (1L << (DSINTERVAL_UNCONSTRAINED - 66)) | (1L << (EACH - 66)) | (1L << (ELEMENT - 66)) | (1L << (EMPTY - 66)) | (1L << (ENABLE - 66)) | (1L << (ENCODING - 66)) | (1L << (ENTITYESCAPING - 66)) | (1L << (ERR - 66)) | (1L << (ERRORS - 66)) | (1L << (ESCAPE - 66)) | (1L << (EVALNAME - 66)) | (1L << (EXCEPTION - 66)) | (1L << (EXCEPTION_INIT - 66)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)) | (1L << (EXIT - 130)) | (1L << (EXPLAIN - 130)) | (1L << (EXTERNAL - 130)) | (1L << (EXTRACT - 130)) | (1L << (FAILURE - 130)) | (1L << (FINAL - 130)) | (1L << (FIRST - 130)) | (1L << (FIRST_VALUE - 130)) | (1L << (FLOAT - 130)) | (1L << (FOLLOWING - 130)) | (1L << (FOLLOWS - 130)) | (1L << (FORALL - 130)) | (1L << (FORCE - 130)) | (1L << (FULL - 130)) | (1L << (FUNCTION - 130)) | (1L << (GROUPING - 130)) | (1L << (HASH - 130)) | (1L << (HIDE - 130)) | (1L << (HOUR - 130)) | (1L << (IGNORE - 130)) | (1L << (IMMEDIATE - 130)) | (1L << (INCLUDE - 130)) | (1L << (INCLUDING - 130)) | (1L << (INCREMENT - 130)) | (1L << (INDENT - 130)) | (1L << (INDEXED - 130)) | (1L << (INDICATOR - 130)) | (1L << (INDICES - 130)) | (1L << (INFINITE - 130)) | (1L << (INLINE - 130)) | (1L << (INNER - 130)) | (1L << (INOUT - 130)) | (1L << (INSTANTIABLE - 130)) | (1L << (INSTEAD - 130)) | (1L << (INT - 130)) | (1L << (INTEGER - 130)) | (1L << (INTERVAL - 130)) | (1L << (INVALIDATE - 130)) | (1L << (ISOLATION - 130)) | (1L << (ITERATE - 130)) | (1L << (JAVA - 130)) | (1L << (JOIN - 130)) | (1L << (KEEP - 130)) | (1L << (LANGUAGE - 130)))) != 0) || ((((_la - 194)) & ~0x3f) == 0 && ((1L << (_la - 194)) & ((1L << (LAST - 194)) | (1L << (LAST_VALUE - 194)) | (1L << (LEADING - 194)) | (1L << (LEFT - 194)) | (1L << (LEVEL - 194)) | (1L << (LIBRARY - 194)) | (1L << (LIKE2 - 194)) | (1L << (LIKE4 - 194)) | (1L << (LIKEC - 194)) | (1L << (LIMIT - 194)) | (1L << (LOCAL - 194)) | (1L << (LOCKED - 194)) | (1L << (LOG - 194)) | (1L << (LOGOFF - 194)) | (1L << (LOGON - 194)) | (1L << (LONG - 194)) | (1L << (LOOP - 194)) | (1L << (MAIN - 194)) | (1L << (MAP - 194)) | (1L << (MATCHED - 194)) | (1L << (MAXVALUE - 194)) | (1L << (MEASURES - 194)) | (1L << (MEMBER - 194)) | (1L << (MERGE - 194)) | (1L << (MINUTE - 194)) | (1L << (MINVALUE - 194)) | (1L << (MLSLABEL - 194)) | (1L << (MODEL - 194)) | (1L << (MODIFY - 194)) | (1L << (MONTH - 194)) | (1L << (MULTISET - 194)) | (1L << (NAME - 194)) | (1L << (NAN - 194)) | (1L << (NATURAL - 194)) | (1L << (NATURALN - 194)) | (1L << (NAV - 194)) | (1L << (NCHAR - 194)) | (1L << (NCHAR_CS - 194)) | (1L << (NCLOB - 194)) | (1L << (NESTED - 194)) | (1L << (NEW - 194)) | (1L << (NO - 194)) | (1L << (NOAUDIT - 194)) | (1L << (NOCOPY - 194)) | (1L << (NOCYCLE - 194)) | (1L << (NOENTITYESCAPING - 194)) | (1L << (NONE - 194)) | (1L << (NOSCHEMACHECK - 194)) | (1L << (NULLS - 194)) | (1L << (NUMBER - 194)) | (1L << (NUMERIC - 194)) | (1L << (NVARCHAR2 - 194)) | (1L << (OBJECT - 194)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (OFF - 259)) | (1L << (OID - 259)) | (1L << (OLD - 259)) | (1L << (ONLY - 259)) | (1L << (OPEN - 259)) | (1L << (ORADATA - 259)) | (1L << (ORDINALITY - 259)) | (1L << (OSERROR - 259)) | (1L << (OUT - 259)) | (1L << (OUTER - 259)) | (1L << (OVER - 259)) | (1L << (OVERRIDING - 259)) | (1L << (PACKAGE - 259)) | (1L << (PARALLEL_ENABLE - 259)) | (1L << (PARAMETERS - 259)) | (1L << (PARENT - 259)) | (1L << (PARTITION - 259)) | (1L << (PASSING - 259)) | (1L << (PATH - 259)) | (1L << (PIPELINED - 259)) | (1L << (PLAN - 259)) | (1L << (PLS_INTEGER - 259)) | (1L << (POSITIVE - 259)) | (1L << (POSITIVEN - 259)) | (1L << (PRAGMA - 259)) | (1L << (PRECEDING - 259)) | (1L << (PRECISION - 259)) | (1L << (PRESENT - 259)) | (1L << (PROCEDURE - 259)) | (1L << (RAISE - 259)) | (1L << (RANGE - 259)) | (1L << (RAW - 259)) | (1L << (READ - 259)) | (1L << (REAL - 259)) | (1L << (RECORD - 259)) | (1L << (REF - 259)) | (1L << (REFERENCE - 259)) | (1L << (REFERENCING - 259)) | (1L << (REJECT - 259)) | (1L << (RELIES_ON - 259)) | (1L << (RENAME - 259)) | (1L << (REPLACE - 259)) | (1L << (RESPECT - 259)) | (1L << (RESTRICT_REFERENCES - 259)) | (1L << (RESULT - 259)) | (1L << (RESULT_CACHE - 259)) | (1L << (RETURN - 259)) | (1L << (RETURNING - 259)) | (1L << (REUSE - 259)) | (1L << (REVERSE - 259)) | (1L << (RIGHT - 259)))) != 0) || ((((_la - 323)) & ~0x3f) == 0 && ((1L << (_la - 323)) & ((1L << (ROLLBACK - 323)) | (1L << (ROLLUP - 323)) | (1L << (ROW - 323)) | (1L << (ROWID - 323)) | (1L << (ROWS - 323)) | (1L << (RULES - 323)) | (1L << (SAMPLE - 323)) | (1L << (SAVE - 323)) | (1L << (SAVEPOINT - 323)) | (1L << (SCHEMA - 323)) | (1L << (SCHEMACHECK - 323)) | (1L << (SCN - 323)) | (1L << (SECOND - 323)) | (1L << (SEED - 323)) | (1L << (SEGMENT - 323)) | (1L << (SELF - 323)) | (1L << (SEQUENTIAL - 323)) | (1L << (SERIALIZABLE - 323)) | (1L << (SERIALLY_REUSABLE - 323)) | (1L << (SERVERERROR - 323)) | (1L << (SESSIONTIMEZONE - 323)) | (1L << (SET - 323)) | (1L << (SETS - 323)) | (1L << (SETTINGS - 323)) | (1L << (SHOW - 323)) | (1L << (SHUTDOWN - 323)) | (1L << (SIBLINGS - 323)) | (1L << (SIGNTYPE - 323)) | (1L << (SIMPLE_INTEGER - 323)) | (1L << (SINGLE - 323)) | (1L << (SKIP_ - 323)) | (1L << (SMALLINT - 323)) | (1L << (SNAPSHOT - 323)) | (1L << (SOME - 323)) | (1L << (SPECIFICATION - 323)) | (1L << (SQLDATA - 323)) | (1L << (SQLERROR - 323)) | (1L << (STANDALONE - 323)) | (1L << (STARTUP - 323)) | (1L << (STATEMENT - 323)) | (1L << (STATEMENT_ID - 323)) | (1L << (STATIC - 323)) | (1L << (STATISTICS - 323)) | (1L << (STRING - 323)) | (1L << (SUBMULTISET - 323)) | (1L << (SUBPARTITION - 323)) | (1L << (SUBSTITUTABLE - 323)) | (1L << (SUBTYPE - 323)) | (1L << (SUCCESS - 323)) | (1L << (SUSPEND - 323)) | (1L << (TIME - 323)) | (1L << (TIMESTAMP - 323)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_UNCONSTRAINED - 323)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TIMEZONE_ABBR - 387)) | (1L << (TIMEZONE_HOUR - 387)) | (1L << (TIMEZONE_MINUTE - 387)) | (1L << (TIMEZONE_REGION - 387)) | (1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (YMINTERVAL_UNCONSTRAINED - 451)) | (1L << (ZONE - 451)) | (1L << (PREDICTION - 451)) | (1L << (PREDICTION_BOUNDS - 451)) | (1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (COVAR_ - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (REGR_ - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (TRIM - 451)) | (1L << (SUM - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (VARIANCE - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 2507;
				_la = _input.La(1);
				if (_la==DECLARE) {
					{
					State = 2506; Match(DECLARE);
					}
				}

				State = 2510;
				_errHandler.Sync(this);
				_la = _input.La(1);
				do {
					{
					{
					State = 2509; declare_spec();
					}
					}
					State = 2512;
					_errHandler.Sync(this);
					_la = _input.La(1);
				} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (CONSTANT - 66)) | (1L << (CONSTRAINT - 66)) | (1L << (CONSTRAINTS - 66)) | (1L << (CONSTRUCTOR - 66)) | (1L << (CONTENT - 66)) | (1L << (CONTEXT - 66)) | (1L << (CONTINUE - 66)) | (1L << (CONVERT - 66)) | (1L << (CORRUPT_XID - 66)) | (1L << (CORRUPT_XID_ALL - 66)) | (1L << (COST - 66)) | (1L << (COUNT - 66)) | (1L << (CROSS - 66)) | (1L << (CUBE - 66)) | (1L << (CURRENT_USER - 66)) | (1L << (CURSOR - 66)) | (1L << (CUSTOMDATUM - 66)) | (1L << (CYCLE - 66)) | (1L << (DATA - 66)) | (1L << (DATABASE - 66)) | (1L << (DAY - 66)) | (1L << (DB_ROLE_CHANGE - 66)) | (1L << (DBTIMEZONE - 66)) | (1L << (DDL - 66)) | (1L << (DEBUG - 66)) | (1L << (DEC - 66)) | (1L << (DECIMAL - 66)) | (1L << (DECOMPOSE - 66)) | (1L << (DECREMENT - 66)) | (1L << (DEFAULTS - 66)) | (1L << (DEFERRED - 66)) | (1L << (DEFINER - 66)) | (1L << (DETERMINISTIC - 66)) | (1L << (DIMENSION - 66)) | (1L << (DISABLE - 66)) | (1L << (DISASSOCIATE - 66)) | (1L << (DOCUMENT - 66)) | (1L << (DOUBLE - 66)) | (1L << (DSINTERVAL_UNCONSTRAINED - 66)) | (1L << (EACH - 66)) | (1L << (ELEMENT - 66)) | (1L << (EMPTY - 66)) | (1L << (ENABLE - 66)) | (1L << (ENCODING - 66)) | (1L << (ENTITYESCAPING - 66)) | (1L << (ERR - 66)) | (1L << (ERRORS - 66)) | (1L << (ESCAPE - 66)) | (1L << (EVALNAME - 66)) | (1L << (EXCEPTION - 66)) | (1L << (EXCEPTION_INIT - 66)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)) | (1L << (EXIT - 130)) | (1L << (EXPLAIN - 130)) | (1L << (EXTERNAL - 130)) | (1L << (EXTRACT - 130)) | (1L << (FAILURE - 130)) | (1L << (FINAL - 130)) | (1L << (FIRST - 130)) | (1L << (FIRST_VALUE - 130)) | (1L << (FLOAT - 130)) | (1L << (FOLLOWING - 130)) | (1L << (FOLLOWS - 130)) | (1L << (FORALL - 130)) | (1L << (FORCE - 130)) | (1L << (FULL - 130)) | (1L << (FUNCTION - 130)) | (1L << (GROUPING - 130)) | (1L << (HASH - 130)) | (1L << (HIDE - 130)) | (1L << (HOUR - 130)) | (1L << (IGNORE - 130)) | (1L << (IMMEDIATE - 130)) | (1L << (INCLUDE - 130)) | (1L << (INCLUDING - 130)) | (1L << (INCREMENT - 130)) | (1L << (INDENT - 130)) | (1L << (INDEXED - 130)) | (1L << (INDICATOR - 130)) | (1L << (INDICES - 130)) | (1L << (INFINITE - 130)) | (1L << (INLINE - 130)) | (1L << (INNER - 130)) | (1L << (INOUT - 130)) | (1L << (INSTANTIABLE - 130)) | (1L << (INSTEAD - 130)) | (1L << (INT - 130)) | (1L << (INTEGER - 130)) | (1L << (INTERVAL - 130)) | (1L << (INVALIDATE - 130)) | (1L << (ISOLATION - 130)) | (1L << (ITERATE - 130)) | (1L << (JAVA - 130)) | (1L << (JOIN - 130)) | (1L << (KEEP - 130)) | (1L << (LANGUAGE - 130)))) != 0) || ((((_la - 194)) & ~0x3f) == 0 && ((1L << (_la - 194)) & ((1L << (LAST - 194)) | (1L << (LAST_VALUE - 194)) | (1L << (LEADING - 194)) | (1L << (LEFT - 194)) | (1L << (LEVEL - 194)) | (1L << (LIBRARY - 194)) | (1L << (LIKE2 - 194)) | (1L << (LIKE4 - 194)) | (1L << (LIKEC - 194)) | (1L << (LIMIT - 194)) | (1L << (LOCAL - 194)) | (1L << (LOCKED - 194)) | (1L << (LOG - 194)) | (1L << (LOGOFF - 194)) | (1L << (LOGON - 194)) | (1L << (LONG - 194)) | (1L << (LOOP - 194)) | (1L << (MAIN - 194)) | (1L << (MAP - 194)) | (1L << (MATCHED - 194)) | (1L << (MAXVALUE - 194)) | (1L << (MEASURES - 194)) | (1L << (MEMBER - 194)) | (1L << (MERGE - 194)) | (1L << (MINUTE - 194)) | (1L << (MINVALUE - 194)) | (1L << (MLSLABEL - 194)) | (1L << (MODEL - 194)) | (1L << (MODIFY - 194)) | (1L << (MONTH - 194)) | (1L << (MULTISET - 194)) | (1L << (NAME - 194)) | (1L << (NAN - 194)) | (1L << (NATURAL - 194)) | (1L << (NATURALN - 194)) | (1L << (NAV - 194)) | (1L << (NCHAR - 194)) | (1L << (NCHAR_CS - 194)) | (1L << (NCLOB - 194)) | (1L << (NESTED - 194)) | (1L << (NEW - 194)) | (1L << (NO - 194)) | (1L << (NOAUDIT - 194)) | (1L << (NOCOPY - 194)) | (1L << (NOCYCLE - 194)) | (1L << (NOENTITYESCAPING - 194)) | (1L << (NONE - 194)) | (1L << (NOSCHEMACHECK - 194)) | (1L << (NULLS - 194)) | (1L << (NUMBER - 194)) | (1L << (NUMERIC - 194)) | (1L << (NVARCHAR2 - 194)) | (1L << (OBJECT - 194)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (OFF - 259)) | (1L << (OID - 259)) | (1L << (OLD - 259)) | (1L << (ONLY - 259)) | (1L << (OPEN - 259)) | (1L << (ORADATA - 259)) | (1L << (ORDINALITY - 259)) | (1L << (OSERROR - 259)) | (1L << (OUT - 259)) | (1L << (OUTER - 259)) | (1L << (OVER - 259)) | (1L << (OVERRIDING - 259)) | (1L << (PACKAGE - 259)) | (1L << (PARALLEL_ENABLE - 259)) | (1L << (PARAMETERS - 259)) | (1L << (PARENT - 259)) | (1L << (PARTITION - 259)) | (1L << (PASSING - 259)) | (1L << (PATH - 259)) | (1L << (PIPELINED - 259)) | (1L << (PLAN - 259)) | (1L << (PLS_INTEGER - 259)) | (1L << (POSITIVE - 259)) | (1L << (POSITIVEN - 259)) | (1L << (PRAGMA - 259)) | (1L << (PRECEDING - 259)) | (1L << (PRECISION - 259)) | (1L << (PRESENT - 259)) | (1L << (PROCEDURE - 259)) | (1L << (RAISE - 259)) | (1L << (RANGE - 259)) | (1L << (RAW - 259)) | (1L << (READ - 259)) | (1L << (REAL - 259)) | (1L << (RECORD - 259)) | (1L << (REF - 259)) | (1L << (REFERENCE - 259)) | (1L << (REFERENCING - 259)) | (1L << (REJECT - 259)) | (1L << (RELIES_ON - 259)) | (1L << (RENAME - 259)) | (1L << (REPLACE - 259)) | (1L << (RESPECT - 259)) | (1L << (RESTRICT_REFERENCES - 259)) | (1L << (RESULT - 259)) | (1L << (RESULT_CACHE - 259)) | (1L << (RETURN - 259)) | (1L << (RETURNING - 259)) | (1L << (REUSE - 259)) | (1L << (REVERSE - 259)) | (1L << (RIGHT - 259)))) != 0) || ((((_la - 323)) & ~0x3f) == 0 && ((1L << (_la - 323)) & ((1L << (ROLLBACK - 323)) | (1L << (ROLLUP - 323)) | (1L << (ROW - 323)) | (1L << (ROWID - 323)) | (1L << (ROWS - 323)) | (1L << (RULES - 323)) | (1L << (SAMPLE - 323)) | (1L << (SAVE - 323)) | (1L << (SAVEPOINT - 323)) | (1L << (SCHEMA - 323)) | (1L << (SCHEMACHECK - 323)) | (1L << (SCN - 323)) | (1L << (SECOND - 323)) | (1L << (SEED - 323)) | (1L << (SEGMENT - 323)) | (1L << (SELF - 323)) | (1L << (SEQUENTIAL - 323)) | (1L << (SERIALIZABLE - 323)) | (1L << (SERIALLY_REUSABLE - 323)) | (1L << (SERVERERROR - 323)) | (1L << (SESSIONTIMEZONE - 323)) | (1L << (SET - 323)) | (1L << (SETS - 323)) | (1L << (SETTINGS - 323)) | (1L << (SHOW - 323)) | (1L << (SHUTDOWN - 323)) | (1L << (SIBLINGS - 323)) | (1L << (SIGNTYPE - 323)) | (1L << (SIMPLE_INTEGER - 323)) | (1L << (SINGLE - 323)) | (1L << (SKIP_ - 323)) | (1L << (SMALLINT - 323)) | (1L << (SNAPSHOT - 323)) | (1L << (SOME - 323)) | (1L << (SPECIFICATION - 323)) | (1L << (SQLDATA - 323)) | (1L << (SQLERROR - 323)) | (1L << (STANDALONE - 323)) | (1L << (STARTUP - 323)) | (1L << (STATEMENT - 323)) | (1L << (STATEMENT_ID - 323)) | (1L << (STATIC - 323)) | (1L << (STATISTICS - 323)) | (1L << (STRING - 323)) | (1L << (SUBMULTISET - 323)) | (1L << (SUBPARTITION - 323)) | (1L << (SUBSTITUTABLE - 323)) | (1L << (SUBTYPE - 323)) | (1L << (SUCCESS - 323)) | (1L << (SUSPEND - 323)) | (1L << (TIME - 323)) | (1L << (TIMESTAMP - 323)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_UNCONSTRAINED - 323)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TIMEZONE_ABBR - 387)) | (1L << (TIMEZONE_HOUR - 387)) | (1L << (TIMEZONE_MINUTE - 387)) | (1L << (TIMEZONE_REGION - 387)) | (1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (YMINTERVAL_UNCONSTRAINED - 451)) | (1L << (ZONE - 451)) | (1L << (PREDICTION - 451)) | (1L << (PREDICTION_BOUNDS - 451)) | (1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (COVAR_ - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (REGR_ - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (TRIM - 451)) | (1L << (SUM - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (VARIANCE - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID );
				}
			}

			State = 2516; body();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockContext : ParserRuleContext {
		public IReadOnlyList<Declare_specContext> declare_spec() {
			return GetRuleContexts<Declare_specContext>();
		}
		public ITerminalNode DECLARE() { return GetToken(plsqlParser.DECLARE, 0); }
		public Declare_specContext declare_spec(int i) {
			return GetRuleContext<Declare_specContext>(i);
		}
		public BodyContext body() {
			return GetRuleContext<BodyContext>(0);
		}
		public BlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_block; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterBlock(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitBlock(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockContext block() {
		BlockContext _localctx = new BlockContext(_ctx, State);
		EnterRule(_localctx, 270, RULE_block);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2519;
			_la = _input.La(1);
			if (_la==DECLARE) {
				{
				State = 2518; Match(DECLARE);
				}
			}

			State = 2522;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 2521; declare_spec();
				}
				}
				State = 2524;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (CONSTANT - 66)) | (1L << (CONSTRAINT - 66)) | (1L << (CONSTRAINTS - 66)) | (1L << (CONSTRUCTOR - 66)) | (1L << (CONTENT - 66)) | (1L << (CONTEXT - 66)) | (1L << (CONTINUE - 66)) | (1L << (CONVERT - 66)) | (1L << (CORRUPT_XID - 66)) | (1L << (CORRUPT_XID_ALL - 66)) | (1L << (COST - 66)) | (1L << (COUNT - 66)) | (1L << (CROSS - 66)) | (1L << (CUBE - 66)) | (1L << (CURRENT_USER - 66)) | (1L << (CURSOR - 66)) | (1L << (CUSTOMDATUM - 66)) | (1L << (CYCLE - 66)) | (1L << (DATA - 66)) | (1L << (DATABASE - 66)) | (1L << (DAY - 66)) | (1L << (DB_ROLE_CHANGE - 66)) | (1L << (DBTIMEZONE - 66)) | (1L << (DDL - 66)) | (1L << (DEBUG - 66)) | (1L << (DEC - 66)) | (1L << (DECIMAL - 66)) | (1L << (DECOMPOSE - 66)) | (1L << (DECREMENT - 66)) | (1L << (DEFAULTS - 66)) | (1L << (DEFERRED - 66)) | (1L << (DEFINER - 66)) | (1L << (DETERMINISTIC - 66)) | (1L << (DIMENSION - 66)) | (1L << (DISABLE - 66)) | (1L << (DISASSOCIATE - 66)) | (1L << (DOCUMENT - 66)) | (1L << (DOUBLE - 66)) | (1L << (DSINTERVAL_UNCONSTRAINED - 66)) | (1L << (EACH - 66)) | (1L << (ELEMENT - 66)) | (1L << (EMPTY - 66)) | (1L << (ENABLE - 66)) | (1L << (ENCODING - 66)) | (1L << (ENTITYESCAPING - 66)) | (1L << (ERR - 66)) | (1L << (ERRORS - 66)) | (1L << (ESCAPE - 66)) | (1L << (EVALNAME - 66)) | (1L << (EXCEPTION - 66)) | (1L << (EXCEPTION_INIT - 66)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)) | (1L << (EXIT - 130)) | (1L << (EXPLAIN - 130)) | (1L << (EXTERNAL - 130)) | (1L << (EXTRACT - 130)) | (1L << (FAILURE - 130)) | (1L << (FINAL - 130)) | (1L << (FIRST - 130)) | (1L << (FIRST_VALUE - 130)) | (1L << (FLOAT - 130)) | (1L << (FOLLOWING - 130)) | (1L << (FOLLOWS - 130)) | (1L << (FORALL - 130)) | (1L << (FORCE - 130)) | (1L << (FULL - 130)) | (1L << (FUNCTION - 130)) | (1L << (GROUPING - 130)) | (1L << (HASH - 130)) | (1L << (HIDE - 130)) | (1L << (HOUR - 130)) | (1L << (IGNORE - 130)) | (1L << (IMMEDIATE - 130)) | (1L << (INCLUDE - 130)) | (1L << (INCLUDING - 130)) | (1L << (INCREMENT - 130)) | (1L << (INDENT - 130)) | (1L << (INDEXED - 130)) | (1L << (INDICATOR - 130)) | (1L << (INDICES - 130)) | (1L << (INFINITE - 130)) | (1L << (INLINE - 130)) | (1L << (INNER - 130)) | (1L << (INOUT - 130)) | (1L << (INSTANTIABLE - 130)) | (1L << (INSTEAD - 130)) | (1L << (INT - 130)) | (1L << (INTEGER - 130)) | (1L << (INTERVAL - 130)) | (1L << (INVALIDATE - 130)) | (1L << (ISOLATION - 130)) | (1L << (ITERATE - 130)) | (1L << (JAVA - 130)) | (1L << (JOIN - 130)) | (1L << (KEEP - 130)) | (1L << (LANGUAGE - 130)))) != 0) || ((((_la - 194)) & ~0x3f) == 0 && ((1L << (_la - 194)) & ((1L << (LAST - 194)) | (1L << (LAST_VALUE - 194)) | (1L << (LEADING - 194)) | (1L << (LEFT - 194)) | (1L << (LEVEL - 194)) | (1L << (LIBRARY - 194)) | (1L << (LIKE2 - 194)) | (1L << (LIKE4 - 194)) | (1L << (LIKEC - 194)) | (1L << (LIMIT - 194)) | (1L << (LOCAL - 194)) | (1L << (LOCKED - 194)) | (1L << (LOG - 194)) | (1L << (LOGOFF - 194)) | (1L << (LOGON - 194)) | (1L << (LONG - 194)) | (1L << (LOOP - 194)) | (1L << (MAIN - 194)) | (1L << (MAP - 194)) | (1L << (MATCHED - 194)) | (1L << (MAXVALUE - 194)) | (1L << (MEASURES - 194)) | (1L << (MEMBER - 194)) | (1L << (MERGE - 194)) | (1L << (MINUTE - 194)) | (1L << (MINVALUE - 194)) | (1L << (MLSLABEL - 194)) | (1L << (MODEL - 194)) | (1L << (MODIFY - 194)) | (1L << (MONTH - 194)) | (1L << (MULTISET - 194)) | (1L << (NAME - 194)) | (1L << (NAN - 194)) | (1L << (NATURAL - 194)) | (1L << (NATURALN - 194)) | (1L << (NAV - 194)) | (1L << (NCHAR - 194)) | (1L << (NCHAR_CS - 194)) | (1L << (NCLOB - 194)) | (1L << (NESTED - 194)) | (1L << (NEW - 194)) | (1L << (NO - 194)) | (1L << (NOAUDIT - 194)) | (1L << (NOCOPY - 194)) | (1L << (NOCYCLE - 194)) | (1L << (NOENTITYESCAPING - 194)) | (1L << (NONE - 194)) | (1L << (NOSCHEMACHECK - 194)) | (1L << (NULLS - 194)) | (1L << (NUMBER - 194)) | (1L << (NUMERIC - 194)) | (1L << (NVARCHAR2 - 194)) | (1L << (OBJECT - 194)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (OFF - 259)) | (1L << (OID - 259)) | (1L << (OLD - 259)) | (1L << (ONLY - 259)) | (1L << (OPEN - 259)) | (1L << (ORADATA - 259)) | (1L << (ORDINALITY - 259)) | (1L << (OSERROR - 259)) | (1L << (OUT - 259)) | (1L << (OUTER - 259)) | (1L << (OVER - 259)) | (1L << (OVERRIDING - 259)) | (1L << (PACKAGE - 259)) | (1L << (PARALLEL_ENABLE - 259)) | (1L << (PARAMETERS - 259)) | (1L << (PARENT - 259)) | (1L << (PARTITION - 259)) | (1L << (PASSING - 259)) | (1L << (PATH - 259)) | (1L << (PIPELINED - 259)) | (1L << (PLAN - 259)) | (1L << (PLS_INTEGER - 259)) | (1L << (POSITIVE - 259)) | (1L << (POSITIVEN - 259)) | (1L << (PRAGMA - 259)) | (1L << (PRECEDING - 259)) | (1L << (PRECISION - 259)) | (1L << (PRESENT - 259)) | (1L << (PROCEDURE - 259)) | (1L << (RAISE - 259)) | (1L << (RANGE - 259)) | (1L << (RAW - 259)) | (1L << (READ - 259)) | (1L << (REAL - 259)) | (1L << (RECORD - 259)) | (1L << (REF - 259)) | (1L << (REFERENCE - 259)) | (1L << (REFERENCING - 259)) | (1L << (REJECT - 259)) | (1L << (RELIES_ON - 259)) | (1L << (RENAME - 259)) | (1L << (REPLACE - 259)) | (1L << (RESPECT - 259)) | (1L << (RESTRICT_REFERENCES - 259)) | (1L << (RESULT - 259)) | (1L << (RESULT_CACHE - 259)) | (1L << (RETURN - 259)) | (1L << (RETURNING - 259)) | (1L << (REUSE - 259)) | (1L << (REVERSE - 259)) | (1L << (RIGHT - 259)))) != 0) || ((((_la - 323)) & ~0x3f) == 0 && ((1L << (_la - 323)) & ((1L << (ROLLBACK - 323)) | (1L << (ROLLUP - 323)) | (1L << (ROW - 323)) | (1L << (ROWID - 323)) | (1L << (ROWS - 323)) | (1L << (RULES - 323)) | (1L << (SAMPLE - 323)) | (1L << (SAVE - 323)) | (1L << (SAVEPOINT - 323)) | (1L << (SCHEMA - 323)) | (1L << (SCHEMACHECK - 323)) | (1L << (SCN - 323)) | (1L << (SECOND - 323)) | (1L << (SEED - 323)) | (1L << (SEGMENT - 323)) | (1L << (SELF - 323)) | (1L << (SEQUENTIAL - 323)) | (1L << (SERIALIZABLE - 323)) | (1L << (SERIALLY_REUSABLE - 323)) | (1L << (SERVERERROR - 323)) | (1L << (SESSIONTIMEZONE - 323)) | (1L << (SET - 323)) | (1L << (SETS - 323)) | (1L << (SETTINGS - 323)) | (1L << (SHOW - 323)) | (1L << (SHUTDOWN - 323)) | (1L << (SIBLINGS - 323)) | (1L << (SIGNTYPE - 323)) | (1L << (SIMPLE_INTEGER - 323)) | (1L << (SINGLE - 323)) | (1L << (SKIP_ - 323)) | (1L << (SMALLINT - 323)) | (1L << (SNAPSHOT - 323)) | (1L << (SOME - 323)) | (1L << (SPECIFICATION - 323)) | (1L << (SQLDATA - 323)) | (1L << (SQLERROR - 323)) | (1L << (STANDALONE - 323)) | (1L << (STARTUP - 323)) | (1L << (STATEMENT - 323)) | (1L << (STATEMENT_ID - 323)) | (1L << (STATIC - 323)) | (1L << (STATISTICS - 323)) | (1L << (STRING - 323)) | (1L << (SUBMULTISET - 323)) | (1L << (SUBPARTITION - 323)) | (1L << (SUBSTITUTABLE - 323)) | (1L << (SUBTYPE - 323)) | (1L << (SUCCESS - 323)) | (1L << (SUSPEND - 323)) | (1L << (TIME - 323)) | (1L << (TIMESTAMP - 323)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_UNCONSTRAINED - 323)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TIMEZONE_ABBR - 387)) | (1L << (TIMEZONE_HOUR - 387)) | (1L << (TIMEZONE_MINUTE - 387)) | (1L << (TIMEZONE_REGION - 387)) | (1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (YMINTERVAL_UNCONSTRAINED - 451)) | (1L << (ZONE - 451)) | (1L << (PREDICTION - 451)) | (1L << (PREDICTION_BOUNDS - 451)) | (1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (COVAR_ - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (REGR_ - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (TRIM - 451)) | (1L << (SUM - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (VARIANCE - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID );
			State = 2526; body();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Sql_statementContext : ParserRuleContext {
		public Transaction_control_statementsContext transaction_control_statements() {
			return GetRuleContext<Transaction_control_statementsContext>(0);
		}
		public Execute_immediateContext execute_immediate() {
			return GetRuleContext<Execute_immediateContext>(0);
		}
		public Cursor_manipulation_statementsContext cursor_manipulation_statements() {
			return GetRuleContext<Cursor_manipulation_statementsContext>(0);
		}
		public Data_manipulation_language_statementsContext data_manipulation_language_statements() {
			return GetRuleContext<Data_manipulation_language_statementsContext>(0);
		}
		public Sql_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sql_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSql_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSql_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSql_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Sql_statementContext sql_statement() {
		Sql_statementContext _localctx = new Sql_statementContext(_ctx, State);
		EnterRule(_localctx, 272, RULE_sql_statement);
		try {
			State = 2532;
			switch (_input.La(1)) {
			case EXECUTE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2528; execute_immediate();
				}
				break;
			case DELETE:
			case EXPLAIN:
			case INSERT:
			case LOCK:
			case MERGE:
			case SELECT:
			case UPDATE:
			case WITH:
			case LEFT_PAREN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2529; data_manipulation_language_statements();
				}
				break;
			case CLOSE:
			case FETCH:
			case OPEN:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2530; cursor_manipulation_statements();
				}
				break;
			case COMMIT:
			case ROLLBACK:
			case SAVEPOINT:
			case SET:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2531; transaction_control_statements();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Execute_immediateContext : ParserRuleContext {
		public Dynamic_returning_clauseContext dynamic_returning_clause() {
			return GetRuleContext<Dynamic_returning_clauseContext>(0);
		}
		public ITerminalNode IMMEDIATE() { return GetToken(plsqlParser.IMMEDIATE, 0); }
		public Using_clauseContext using_clause() {
			return GetRuleContext<Using_clauseContext>(0);
		}
		public Into_clauseContext into_clause() {
			return GetRuleContext<Into_clauseContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode EXECUTE() { return GetToken(plsqlParser.EXECUTE, 0); }
		public Execute_immediateContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_execute_immediate; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterExecute_immediate(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitExecute_immediate(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExecute_immediate(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Execute_immediateContext execute_immediate() {
		Execute_immediateContext _localctx = new Execute_immediateContext(_ctx, State);
		EnterRule(_localctx, 274, RULE_execute_immediate);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2534; Match(EXECUTE);
			State = 2535; Match(IMMEDIATE);
			State = 2536; expression();
			State = 2546;
			switch (_input.La(1)) {
			case BULK:
			case INTO:
				{
				State = 2537; into_clause();
				State = 2539;
				_la = _input.La(1);
				if (_la==USING) {
					{
					State = 2538; using_clause();
					}
				}

				}
				break;
			case USING:
				{
				State = 2541; using_clause();
				State = 2543;
				_la = _input.La(1);
				if (_la==RETURN || _la==RETURNING) {
					{
					State = 2542; dynamic_returning_clause();
					}
				}

				}
				break;
			case RETURN:
			case RETURNING:
				{
				State = 2545; dynamic_returning_clause();
				}
				break;
			case Eof:
			case SAVE:
			case SEMICOLON:
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Dynamic_returning_clauseContext : ParserRuleContext {
		public ITerminalNode RETURN() { return GetToken(plsqlParser.RETURN, 0); }
		public Into_clauseContext into_clause() {
			return GetRuleContext<Into_clauseContext>(0);
		}
		public ITerminalNode RETURNING() { return GetToken(plsqlParser.RETURNING, 0); }
		public Dynamic_returning_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dynamic_returning_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterDynamic_returning_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitDynamic_returning_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDynamic_returning_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Dynamic_returning_clauseContext dynamic_returning_clause() {
		Dynamic_returning_clauseContext _localctx = new Dynamic_returning_clauseContext(_ctx, State);
		EnterRule(_localctx, 276, RULE_dynamic_returning_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2548;
			_la = _input.La(1);
			if ( !(_la==RETURN || _la==RETURNING) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			State = 2549; into_clause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Data_manipulation_language_statementsContext : ParserRuleContext {
		public Merge_statementContext merge_statement() {
			return GetRuleContext<Merge_statementContext>(0);
		}
		public Update_statementContext update_statement() {
			return GetRuleContext<Update_statementContext>(0);
		}
		public Select_statementContext select_statement() {
			return GetRuleContext<Select_statementContext>(0);
		}
		public Insert_statementContext insert_statement() {
			return GetRuleContext<Insert_statementContext>(0);
		}
		public Delete_statementContext delete_statement() {
			return GetRuleContext<Delete_statementContext>(0);
		}
		public Lock_table_statementContext lock_table_statement() {
			return GetRuleContext<Lock_table_statementContext>(0);
		}
		public Explain_statementContext explain_statement() {
			return GetRuleContext<Explain_statementContext>(0);
		}
		public Data_manipulation_language_statementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_data_manipulation_language_statements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterData_manipulation_language_statements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitData_manipulation_language_statements(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitData_manipulation_language_statements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Data_manipulation_language_statementsContext data_manipulation_language_statements() {
		Data_manipulation_language_statementsContext _localctx = new Data_manipulation_language_statementsContext(_ctx, State);
		EnterRule(_localctx, 278, RULE_data_manipulation_language_statements);
		try {
			State = 2558;
			switch (_input.La(1)) {
			case MERGE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2551; merge_statement();
				}
				break;
			case LOCK:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2552; lock_table_statement();
				}
				break;
			case SELECT:
			case WITH:
			case LEFT_PAREN:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2553; select_statement();
				}
				break;
			case UPDATE:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2554; update_statement();
				}
				break;
			case DELETE:
				EnterOuterAlt(_localctx, 5);
				{
				State = 2555; delete_statement();
				}
				break;
			case INSERT:
				EnterOuterAlt(_localctx, 6);
				{
				State = 2556; insert_statement();
				}
				break;
			case EXPLAIN:
				EnterOuterAlt(_localctx, 7);
				{
				State = 2557; explain_statement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cursor_manipulation_statementsContext : ParserRuleContext {
		public Close_statementContext close_statement() {
			return GetRuleContext<Close_statementContext>(0);
		}
		public Open_for_statementContext open_for_statement() {
			return GetRuleContext<Open_for_statementContext>(0);
		}
		public Open_statementContext open_statement() {
			return GetRuleContext<Open_statementContext>(0);
		}
		public Fetch_statementContext fetch_statement() {
			return GetRuleContext<Fetch_statementContext>(0);
		}
		public Cursor_manipulation_statementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cursor_manipulation_statements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCursor_manipulation_statements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCursor_manipulation_statements(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCursor_manipulation_statements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Cursor_manipulation_statementsContext cursor_manipulation_statements() {
		Cursor_manipulation_statementsContext _localctx = new Cursor_manipulation_statementsContext(_ctx, State);
		EnterRule(_localctx, 280, RULE_cursor_manipulation_statements);
		try {
			State = 2564;
			switch ( Interpreter.AdaptivePredict(_input,257,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2560; close_statement();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2561; open_statement();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2562; fetch_statement();
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2563; open_for_statement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Close_statementContext : ParserRuleContext {
		public Cursor_nameContext cursor_name() {
			return GetRuleContext<Cursor_nameContext>(0);
		}
		public ITerminalNode CLOSE() { return GetToken(plsqlParser.CLOSE, 0); }
		public Close_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_close_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterClose_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitClose_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitClose_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Close_statementContext close_statement() {
		Close_statementContext _localctx = new Close_statementContext(_ctx, State);
		EnterRule(_localctx, 282, RULE_close_statement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2566; Match(CLOSE);
			State = 2567; cursor_name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Open_statementContext : ParserRuleContext {
		public Expression_listContext expression_list() {
			return GetRuleContext<Expression_listContext>(0);
		}
		public ITerminalNode OPEN() { return GetToken(plsqlParser.OPEN, 0); }
		public Cursor_nameContext cursor_name() {
			return GetRuleContext<Cursor_nameContext>(0);
		}
		public Open_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_open_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterOpen_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitOpen_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpen_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Open_statementContext open_statement() {
		Open_statementContext _localctx = new Open_statementContext(_ctx, State);
		EnterRule(_localctx, 284, RULE_open_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2569; Match(OPEN);
			State = 2570; cursor_name();
			State = 2572;
			_la = _input.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 2571; expression_list();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Fetch_statementContext : ParserRuleContext {
		public IToken it1;
		public ITerminalNode BULK() { return GetToken(plsqlParser.BULK, 0); }
		public Cursor_nameContext cursor_name() {
			return GetRuleContext<Cursor_nameContext>(0);
		}
		public Variable_nameContext variable_name(int i) {
			return GetRuleContext<Variable_nameContext>(i);
		}
		public ITerminalNode COLLECT() { return GetToken(plsqlParser.COLLECT, 0); }
		public ITerminalNode FETCH() { return GetToken(plsqlParser.FETCH, 0); }
		public IReadOnlyList<Variable_nameContext> variable_name() {
			return GetRuleContexts<Variable_nameContext>();
		}
		public ITerminalNode INTO() { return GetToken(plsqlParser.INTO, 0); }
		public Fetch_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fetch_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterFetch_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitFetch_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFetch_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Fetch_statementContext fetch_statement() {
		Fetch_statementContext _localctx = new Fetch_statementContext(_ctx, State);
		EnterRule(_localctx, 286, RULE_fetch_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2574; Match(FETCH);
			State = 2575; cursor_name();
			State = 2596;
			switch (_input.La(1)) {
			case INTO:
				{
				State = 2576; _localctx.it1 = Match(INTO);
				State = 2577; variable_name();
				State = 2582;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 2578; Match(COMMA);
					State = 2579; variable_name();
					}
					}
					State = 2584;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
				break;
			case BULK:
				{
				State = 2585; Match(BULK);
				State = 2586; Match(COLLECT);
				State = 2587; Match(INTO);
				State = 2588; variable_name();
				State = 2593;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 2589; Match(COMMA);
					State = 2590; variable_name();
					}
					}
					State = 2595;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Open_for_statementContext : ParserRuleContext {
		public ITerminalNode OPEN() { return GetToken(plsqlParser.OPEN, 0); }
		public Select_statementContext select_statement() {
			return GetRuleContext<Select_statementContext>(0);
		}
		public Using_clauseContext using_clause() {
			return GetRuleContext<Using_clauseContext>(0);
		}
		public ITerminalNode FOR() { return GetToken(plsqlParser.FOR, 0); }
		public Variable_nameContext variable_name() {
			return GetRuleContext<Variable_nameContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Open_for_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_open_for_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterOpen_for_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitOpen_for_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpen_for_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Open_for_statementContext open_for_statement() {
		Open_for_statementContext _localctx = new Open_for_statementContext(_ctx, State);
		EnterRule(_localctx, 288, RULE_open_for_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2598; Match(OPEN);
			State = 2599; variable_name();
			State = 2600; Match(FOR);
			State = 2603;
			switch ( Interpreter.AdaptivePredict(_input,262,_ctx) ) {
			case 1:
				{
				State = 2601; select_statement();
				}
				break;

			case 2:
				{
				State = 2602; expression();
				}
				break;
			}
			State = 2606;
			_la = _input.La(1);
			if (_la==USING) {
				{
				State = 2605; using_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Transaction_control_statementsContext : ParserRuleContext {
		public Set_transaction_commandContext set_transaction_command() {
			return GetRuleContext<Set_transaction_commandContext>(0);
		}
		public Rollback_statementContext rollback_statement() {
			return GetRuleContext<Rollback_statementContext>(0);
		}
		public Set_constraint_commandContext set_constraint_command() {
			return GetRuleContext<Set_constraint_commandContext>(0);
		}
		public Commit_statementContext commit_statement() {
			return GetRuleContext<Commit_statementContext>(0);
		}
		public Savepoint_statementContext savepoint_statement() {
			return GetRuleContext<Savepoint_statementContext>(0);
		}
		public Transaction_control_statementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_transaction_control_statements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterTransaction_control_statements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitTransaction_control_statements(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTransaction_control_statements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Transaction_control_statementsContext transaction_control_statements() {
		Transaction_control_statementsContext _localctx = new Transaction_control_statementsContext(_ctx, State);
		EnterRule(_localctx, 290, RULE_transaction_control_statements);
		try {
			State = 2613;
			switch ( Interpreter.AdaptivePredict(_input,264,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2608; set_transaction_command();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2609; set_constraint_command();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2610; commit_statement();
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2611; rollback_statement();
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 2612; savepoint_statement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Set_transaction_commandContext : ParserRuleContext {
		public ITerminalNode SEGMENT() { return GetToken(plsqlParser.SEGMENT, 0); }
		public Rollback_segment_nameContext rollback_segment_name() {
			return GetRuleContext<Rollback_segment_nameContext>(0);
		}
		public ITerminalNode LEVEL() { return GetToken(plsqlParser.LEVEL, 0); }
		public Quoted_stringContext quoted_string() {
			return GetRuleContext<Quoted_stringContext>(0);
		}
		public ITerminalNode WRITE() { return GetToken(plsqlParser.WRITE, 0); }
		public ITerminalNode TRANSACTION() { return GetToken(plsqlParser.TRANSACTION, 0); }
		public ITerminalNode READ() { return GetToken(plsqlParser.READ, 0); }
		public ITerminalNode USE() { return GetToken(plsqlParser.USE, 0); }
		public ITerminalNode COMMITTED() { return GetToken(plsqlParser.COMMITTED, 0); }
		public ITerminalNode NAME() { return GetToken(plsqlParser.NAME, 0); }
		public ITerminalNode ISOLATION() { return GetToken(plsqlParser.ISOLATION, 0); }
		public ITerminalNode ONLY() { return GetToken(plsqlParser.ONLY, 0); }
		public ITerminalNode SET() { return GetToken(plsqlParser.SET, 0); }
		public ITerminalNode SERIALIZABLE() { return GetToken(plsqlParser.SERIALIZABLE, 0); }
		public ITerminalNode ROLLBACK() { return GetToken(plsqlParser.ROLLBACK, 0); }
		public Set_transaction_commandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_set_transaction_command; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSet_transaction_command(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSet_transaction_command(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSet_transaction_command(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Set_transaction_commandContext set_transaction_command() {
		Set_transaction_commandContext _localctx = new Set_transaction_commandContext(_ctx, State);
		EnterRule(_localctx, 292, RULE_set_transaction_command);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2615; Match(SET);
			State = 2616; Match(TRANSACTION);
			State = 2630;
			switch (_input.La(1)) {
			case READ:
				{
				State = 2617; Match(READ);
				State = 2618;
				_la = _input.La(1);
				if ( !(_la==ONLY || _la==WRITE) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				}
				break;
			case ISOLATION:
				{
				State = 2619; Match(ISOLATION);
				State = 2620; Match(LEVEL);
				State = 2624;
				switch (_input.La(1)) {
				case SERIALIZABLE:
					{
					State = 2621; Match(SERIALIZABLE);
					}
					break;
				case READ:
					{
					State = 2622; Match(READ);
					State = 2623; Match(COMMITTED);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case USE:
				{
				State = 2626; Match(USE);
				State = 2627; Match(ROLLBACK);
				State = 2628; Match(SEGMENT);
				State = 2629; rollback_segment_name();
				}
				break;
			case Eof:
			case NAME:
			case SAVE:
			case SEMICOLON:
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2634;
			_la = _input.La(1);
			if (_la==NAME) {
				{
				State = 2632; Match(NAME);
				State = 2633; quoted_string();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Set_constraint_commandContext : ParserRuleContext {
		public ITerminalNode DEFERRED() { return GetToken(plsqlParser.DEFERRED, 0); }
		public ITerminalNode CONSTRAINTS() { return GetToken(plsqlParser.CONSTRAINTS, 0); }
		public ITerminalNode IMMEDIATE() { return GetToken(plsqlParser.IMMEDIATE, 0); }
		public Constraint_nameContext constraint_name(int i) {
			return GetRuleContext<Constraint_nameContext>(i);
		}
		public ITerminalNode CONSTRAINT() { return GetToken(plsqlParser.CONSTRAINT, 0); }
		public ITerminalNode SET() { return GetToken(plsqlParser.SET, 0); }
		public ITerminalNode ALL() { return GetToken(plsqlParser.ALL, 0); }
		public IReadOnlyList<Constraint_nameContext> constraint_name() {
			return GetRuleContexts<Constraint_nameContext>();
		}
		public Set_constraint_commandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_set_constraint_command; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSet_constraint_command(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSet_constraint_command(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSet_constraint_command(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Set_constraint_commandContext set_constraint_command() {
		Set_constraint_commandContext _localctx = new Set_constraint_commandContext(_ctx, State);
		EnterRule(_localctx, 294, RULE_set_constraint_command);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2636; Match(SET);
			State = 2637;
			_la = _input.La(1);
			if ( !(_la==CONSTRAINT || _la==CONSTRAINTS) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			State = 2647;
			switch (_input.La(1)) {
			case ALL:
				{
				State = 2638; Match(ALL);
				}
				break;
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROW_NUMBER:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 2639; constraint_name();
				State = 2644;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 2640; Match(COMMA);
					State = 2641; constraint_name();
					}
					}
					State = 2646;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2649;
			_la = _input.La(1);
			if ( !(_la==DEFERRED || _la==IMMEDIATE) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Commit_statementContext : ParserRuleContext {
		public ITerminalNode COMMENT() { return GetToken(plsqlParser.COMMENT, 0); }
		public ITerminalNode CORRUPT_XID_ALL() { return GetToken(plsqlParser.CORRUPT_XID_ALL, 0); }
		public ITerminalNode WORK() { return GetToken(plsqlParser.WORK, 0); }
		public ITerminalNode FORCE() { return GetToken(plsqlParser.FORCE, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public Write_clauseContext write_clause() {
			return GetRuleContext<Write_clauseContext>(0);
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode COMMIT() { return GetToken(plsqlParser.COMMIT, 0); }
		public ITerminalNode CORRUPT_XID() { return GetToken(plsqlParser.CORRUPT_XID, 0); }
		public Commit_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_commit_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCommit_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCommit_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCommit_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Commit_statementContext commit_statement() {
		Commit_statementContext _localctx = new Commit_statementContext(_ctx, State);
		EnterRule(_localctx, 296, RULE_commit_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2651; Match(COMMIT);
			State = 2653;
			_la = _input.La(1);
			if (_la==WORK) {
				{
				State = 2652; Match(WORK);
				}
			}

			State = 2668;
			switch (_input.La(1)) {
			case COMMENT:
				{
				State = 2655; Match(COMMENT);
				State = 2656; expression();
				}
				break;
			case FORCE:
				{
				State = 2657; Match(FORCE);
				State = 2666;
				switch ( Interpreter.AdaptivePredict(_input,272,_ctx) ) {
				case 1:
					{
					State = 2658; Match(CORRUPT_XID);
					State = 2659; expression();
					}
					break;

				case 2:
					{
					State = 2660; Match(CORRUPT_XID_ALL);
					}
					break;

				case 3:
					{
					State = 2661; expression();
					State = 2664;
					_la = _input.La(1);
					if (_la==COMMA) {
						{
						State = 2662; Match(COMMA);
						State = 2663; expression();
						}
					}

					}
					break;
				}
				}
				break;
			case Eof:
			case SAVE:
			case WRITE:
			case SEMICOLON:
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2671;
			_la = _input.La(1);
			if (_la==WRITE) {
				{
				State = 2670; write_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Write_clauseContext : ParserRuleContext {
		public ITerminalNode IMMEDIATE() { return GetToken(plsqlParser.IMMEDIATE, 0); }
		public ITerminalNode WRITE() { return GetToken(plsqlParser.WRITE, 0); }
		public ITerminalNode NOWAIT() { return GetToken(plsqlParser.NOWAIT, 0); }
		public ITerminalNode BATCH() { return GetToken(plsqlParser.BATCH, 0); }
		public ITerminalNode WAIT() { return GetToken(plsqlParser.WAIT, 0); }
		public Write_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_write_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterWrite_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitWrite_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWrite_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Write_clauseContext write_clause() {
		Write_clauseContext _localctx = new Write_clauseContext(_ctx, State);
		EnterRule(_localctx, 298, RULE_write_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2673; Match(WRITE);
			State = 2675;
			_la = _input.La(1);
			if (_la==NOWAIT || _la==WAIT) {
				{
				State = 2674;
				_la = _input.La(1);
				if ( !(_la==NOWAIT || _la==WAIT) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				}
			}

			State = 2678;
			_la = _input.La(1);
			if (_la==BATCH || _la==IMMEDIATE) {
				{
				State = 2677;
				_la = _input.La(1);
				if ( !(_la==BATCH || _la==IMMEDIATE) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Rollback_statementContext : ParserRuleContext {
		public ITerminalNode WORK() { return GetToken(plsqlParser.WORK, 0); }
		public Savepoint_nameContext savepoint_name() {
			return GetRuleContext<Savepoint_nameContext>(0);
		}
		public Quoted_stringContext quoted_string() {
			return GetRuleContext<Quoted_stringContext>(0);
		}
		public ITerminalNode SAVEPOINT() { return GetToken(plsqlParser.SAVEPOINT, 0); }
		public ITerminalNode FORCE() { return GetToken(plsqlParser.FORCE, 0); }
		public ITerminalNode TO() { return GetToken(plsqlParser.TO, 0); }
		public ITerminalNode ROLLBACK() { return GetToken(plsqlParser.ROLLBACK, 0); }
		public Rollback_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rollback_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterRollback_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitRollback_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRollback_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Rollback_statementContext rollback_statement() {
		Rollback_statementContext _localctx = new Rollback_statementContext(_ctx, State);
		EnterRule(_localctx, 300, RULE_rollback_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2680; Match(ROLLBACK);
			State = 2682;
			_la = _input.La(1);
			if (_la==WORK) {
				{
				State = 2681; Match(WORK);
				}
			}

			State = 2691;
			switch (_input.La(1)) {
			case TO:
				{
				State = 2684; Match(TO);
				State = 2686;
				switch ( Interpreter.AdaptivePredict(_input,278,_ctx) ) {
				case 1:
					{
					State = 2685; Match(SAVEPOINT);
					}
					break;
				}
				State = 2688; savepoint_name();
				}
				break;
			case FORCE:
				{
				State = 2689; Match(FORCE);
				State = 2690; quoted_string();
				}
				break;
			case Eof:
			case SAVE:
			case SEMICOLON:
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Savepoint_statementContext : ParserRuleContext {
		public ITerminalNode SAVEPOINT() { return GetToken(plsqlParser.SAVEPOINT, 0); }
		public Savepoint_nameContext savepoint_name() {
			return GetRuleContext<Savepoint_nameContext>(0);
		}
		public Savepoint_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_savepoint_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSavepoint_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSavepoint_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSavepoint_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Savepoint_statementContext savepoint_statement() {
		Savepoint_statementContext _localctx = new Savepoint_statementContext(_ctx, State);
		EnterRule(_localctx, 302, RULE_savepoint_statement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2693; Match(SAVEPOINT);
			State = 2694; savepoint_name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Explain_statementContext : ParserRuleContext {
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public Select_statementContext select_statement() {
			return GetRuleContext<Select_statementContext>(0);
		}
		public Insert_statementContext insert_statement() {
			return GetRuleContext<Insert_statementContext>(0);
		}
		public Quoted_stringContext quoted_string() {
			return GetRuleContext<Quoted_stringContext>(0);
		}
		public ITerminalNode FOR() { return GetToken(plsqlParser.FOR, 0); }
		public ITerminalNode PLAN() { return GetToken(plsqlParser.PLAN, 0); }
		public ITerminalNode EXPLAIN() { return GetToken(plsqlParser.EXPLAIN, 0); }
		public ITerminalNode INTO() { return GetToken(plsqlParser.INTO, 0); }
		public Merge_statementContext merge_statement() {
			return GetRuleContext<Merge_statementContext>(0);
		}
		public Update_statementContext update_statement() {
			return GetRuleContext<Update_statementContext>(0);
		}
		public Delete_statementContext delete_statement() {
			return GetRuleContext<Delete_statementContext>(0);
		}
		public ITerminalNode STATEMENT_ID() { return GetToken(plsqlParser.STATEMENT_ID, 0); }
		public ITerminalNode SET() { return GetToken(plsqlParser.SET, 0); }
		public Explain_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_explain_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterExplain_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitExplain_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExplain_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Explain_statementContext explain_statement() {
		Explain_statementContext _localctx = new Explain_statementContext(_ctx, State);
		EnterRule(_localctx, 304, RULE_explain_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2696; Match(EXPLAIN);
			State = 2697; Match(PLAN);
			State = 2702;
			_la = _input.La(1);
			if (_la==SET) {
				{
				State = 2698; Match(SET);
				State = 2699; Match(STATEMENT_ID);
				State = 2700; Match(EQUALS_OP);
				State = 2701; quoted_string();
				}
			}

			State = 2706;
			_la = _input.La(1);
			if (_la==INTO) {
				{
				State = 2704; Match(INTO);
				State = 2705; tableview_name();
				}
			}

			State = 2708; Match(FOR);
			State = 2714;
			switch (_input.La(1)) {
			case SELECT:
			case WITH:
			case LEFT_PAREN:
				{
				State = 2709; select_statement();
				}
				break;
			case UPDATE:
				{
				State = 2710; update_statement();
				}
				break;
			case DELETE:
				{
				State = 2711; delete_statement();
				}
				break;
			case INSERT:
				{
				State = 2712; insert_statement();
				}
				break;
			case MERGE:
				{
				State = 2713; merge_statement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Select_statementContext : ParserRuleContext {
		public For_update_clauseContext for_update_clause(int i) {
			return GetRuleContext<For_update_clauseContext>(i);
		}
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public IReadOnlyList<For_update_clauseContext> for_update_clause() {
			return GetRuleContexts<For_update_clauseContext>();
		}
		public Order_by_clauseContext order_by_clause(int i) {
			return GetRuleContext<Order_by_clauseContext>(i);
		}
		public IReadOnlyList<Order_by_clauseContext> order_by_clause() {
			return GetRuleContexts<Order_by_clauseContext>();
		}
		public Subquery_factoring_clauseContext subquery_factoring_clause() {
			return GetRuleContext<Subquery_factoring_clauseContext>(0);
		}
		public Select_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_select_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSelect_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSelect_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelect_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Select_statementContext select_statement() {
		Select_statementContext _localctx = new Select_statementContext(_ctx, State);
		EnterRule(_localctx, 306, RULE_select_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2717;
			_la = _input.La(1);
			if (_la==WITH) {
				{
				State = 2716; subquery_factoring_clause();
				}
			}

			State = 2719; subquery();
			State = 2724;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==FOR || _la==ORDER) {
				{
				State = 2722;
				switch (_input.La(1)) {
				case FOR:
					{
					State = 2720; for_update_clause();
					}
					break;
				case ORDER:
					{
					State = 2721; order_by_clause();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 2726;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Subquery_factoring_clauseContext : ParserRuleContext {
		public ITerminalNode WITH() { return GetToken(plsqlParser.WITH, 0); }
		public Factoring_elementContext factoring_element(int i) {
			return GetRuleContext<Factoring_elementContext>(i);
		}
		public IReadOnlyList<Factoring_elementContext> factoring_element() {
			return GetRuleContexts<Factoring_elementContext>();
		}
		public Subquery_factoring_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subquery_factoring_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSubquery_factoring_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSubquery_factoring_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubquery_factoring_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Subquery_factoring_clauseContext subquery_factoring_clause() {
		Subquery_factoring_clauseContext _localctx = new Subquery_factoring_clauseContext(_ctx, State);
		EnterRule(_localctx, 308, RULE_subquery_factoring_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2727; Match(WITH);
			State = 2728; factoring_element();
			State = 2733;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 2729; Match(COMMA);
				State = 2730; factoring_element();
				}
				}
				State = 2735;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Factoring_elementContext : ParserRuleContext {
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public IReadOnlyList<Column_nameContext> column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public Cycle_clauseContext cycle_clause() {
			return GetRuleContext<Cycle_clauseContext>(0);
		}
		public Order_by_clauseContext order_by_clause() {
			return GetRuleContext<Order_by_clauseContext>(0);
		}
		public Search_clauseContext search_clause() {
			return GetRuleContext<Search_clauseContext>(0);
		}
		public Query_nameContext query_name() {
			return GetRuleContext<Query_nameContext>(0);
		}
		public ITerminalNode AS() { return GetToken(plsqlParser.AS, 0); }
		public Factoring_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_factoring_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterFactoring_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitFactoring_element(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFactoring_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Factoring_elementContext factoring_element() {
		Factoring_elementContext _localctx = new Factoring_elementContext(_ctx, State);
		EnterRule(_localctx, 310, RULE_factoring_element);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2736; query_name();
			State = 2748;
			_la = _input.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 2737; Match(LEFT_PAREN);
				State = 2738; column_name();
				State = 2743;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 2739; Match(COMMA);
					State = 2740; column_name();
					}
					}
					State = 2745;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 2746; Match(RIGHT_PAREN);
				}
			}

			State = 2750; Match(AS);
			State = 2751; Match(LEFT_PAREN);
			State = 2752; subquery();
			State = 2754;
			_la = _input.La(1);
			if (_la==ORDER) {
				{
				State = 2753; order_by_clause();
				}
			}

			State = 2756; Match(RIGHT_PAREN);
			State = 2758;
			_la = _input.La(1);
			if (_la==SEARCH) {
				{
				State = 2757; search_clause();
				}
			}

			State = 2761;
			_la = _input.La(1);
			if (_la==CYCLE) {
				{
				State = 2760; cycle_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Search_clauseContext : ParserRuleContext {
		public IReadOnlyList<ITerminalNode> ASC() { return GetTokens(plsqlParser.ASC); }
		public ITerminalNode ASC(int i) {
			return GetToken(plsqlParser.ASC, i);
		}
		public IReadOnlyList<ITerminalNode> DESC() { return GetTokens(plsqlParser.DESC); }
		public IReadOnlyList<ITerminalNode> FIRST() { return GetTokens(plsqlParser.FIRST); }
		public IReadOnlyList<ITerminalNode> LAST() { return GetTokens(plsqlParser.LAST); }
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public ITerminalNode SEARCH() { return GetToken(plsqlParser.SEARCH, 0); }
		public IReadOnlyList<Column_nameContext> column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public ITerminalNode DEPTH() { return GetToken(plsqlParser.DEPTH, 0); }
		public ITerminalNode FIRST(int i) {
			return GetToken(plsqlParser.FIRST, i);
		}
		public ITerminalNode LAST(int i) {
			return GetToken(plsqlParser.LAST, i);
		}
		public ITerminalNode DESC(int i) {
			return GetToken(plsqlParser.DESC, i);
		}
		public ITerminalNode NULLS(int i) {
			return GetToken(plsqlParser.NULLS, i);
		}
		public ITerminalNode BREADTH() { return GetToken(plsqlParser.BREADTH, 0); }
		public IReadOnlyList<ITerminalNode> NULLS() { return GetTokens(plsqlParser.NULLS); }
		public ITerminalNode BY() { return GetToken(plsqlParser.BY, 0); }
		public ITerminalNode SET() { return GetToken(plsqlParser.SET, 0); }
		public Search_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_search_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSearch_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSearch_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSearch_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Search_clauseContext search_clause() {
		Search_clauseContext _localctx = new Search_clauseContext(_ctx, State);
		EnterRule(_localctx, 312, RULE_search_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2763; Match(SEARCH);
			State = 2764;
			_la = _input.La(1);
			if ( !(_la==BREADTH || _la==DEPTH) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			State = 2765; Match(FIRST);
			State = 2766; Match(BY);
			State = 2767; column_name();
			State = 2769;
			_la = _input.La(1);
			if (_la==ASC) {
				{
				State = 2768; Match(ASC);
				}
			}

			State = 2772;
			_la = _input.La(1);
			if (_la==DESC) {
				{
				State = 2771; Match(DESC);
				}
			}

			State = 2776;
			switch ( Interpreter.AdaptivePredict(_input,294,_ctx) ) {
			case 1:
				{
				State = 2774; Match(NULLS);
				State = 2775; Match(FIRST);
				}
				break;
			}
			State = 2780;
			_la = _input.La(1);
			if (_la==NULLS) {
				{
				State = 2778; Match(NULLS);
				State = 2779; Match(LAST);
				}
			}

			State = 2800;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 2782; Match(COMMA);
				State = 2783; column_name();
				State = 2785;
				_la = _input.La(1);
				if (_la==ASC) {
					{
					State = 2784; Match(ASC);
					}
				}

				State = 2788;
				_la = _input.La(1);
				if (_la==DESC) {
					{
					State = 2787; Match(DESC);
					}
				}

				State = 2792;
				switch ( Interpreter.AdaptivePredict(_input,298,_ctx) ) {
				case 1:
					{
					State = 2790; Match(NULLS);
					State = 2791; Match(FIRST);
					}
					break;
				}
				State = 2796;
				_la = _input.La(1);
				if (_la==NULLS) {
					{
					State = 2794; Match(NULLS);
					State = 2795; Match(LAST);
					}
				}

				}
				}
				State = 2802;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 2803; Match(SET);
			State = 2804; column_name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cycle_clauseContext : ParserRuleContext {
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public IReadOnlyList<Column_nameContext> column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode TO() { return GetToken(plsqlParser.TO, 0); }
		public ITerminalNode CYCLE() { return GetToken(plsqlParser.CYCLE, 0); }
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode DEFAULT() { return GetToken(plsqlParser.DEFAULT, 0); }
		public ITerminalNode SET() { return GetToken(plsqlParser.SET, 0); }
		public Cycle_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cycle_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCycle_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCycle_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCycle_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Cycle_clauseContext cycle_clause() {
		Cycle_clauseContext _localctx = new Cycle_clauseContext(_ctx, State);
		EnterRule(_localctx, 314, RULE_cycle_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2806; Match(CYCLE);
			State = 2807; column_name();
			State = 2812;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 2808; Match(COMMA);
				State = 2809; column_name();
				}
				}
				State = 2814;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 2815; Match(SET);
			State = 2816; column_name();
			State = 2817; Match(TO);
			State = 2818; expression();
			State = 2819; Match(DEFAULT);
			State = 2820; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubqueryContext : ParserRuleContext {
		public Subquery_operation_partContext subquery_operation_part(int i) {
			return GetRuleContext<Subquery_operation_partContext>(i);
		}
		public Subquery_basic_elementsContext subquery_basic_elements() {
			return GetRuleContext<Subquery_basic_elementsContext>(0);
		}
		public IReadOnlyList<Subquery_operation_partContext> subquery_operation_part() {
			return GetRuleContexts<Subquery_operation_partContext>();
		}
		public SubqueryContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subquery; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSubquery(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSubquery(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubquery(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SubqueryContext subquery() {
		SubqueryContext _localctx = new SubqueryContext(_ctx, State);
		EnterRule(_localctx, 316, RULE_subquery);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2822; subquery_basic_elements();
			State = 2826;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==INTERSECT || _la==MINUS || _la==UNION) {
				{
				{
				State = 2823; subquery_operation_part();
				}
				}
				State = 2828;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Subquery_operation_partContext : ParserRuleContext {
		public ITerminalNode UNION() { return GetToken(plsqlParser.UNION, 0); }
		public Subquery_basic_elementsContext subquery_basic_elements() {
			return GetRuleContext<Subquery_basic_elementsContext>(0);
		}
		public ITerminalNode INTERSECT() { return GetToken(plsqlParser.INTERSECT, 0); }
		public ITerminalNode MINUS() { return GetToken(plsqlParser.MINUS, 0); }
		public ITerminalNode ALL() { return GetToken(plsqlParser.ALL, 0); }
		public Subquery_operation_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subquery_operation_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSubquery_operation_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSubquery_operation_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubquery_operation_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Subquery_operation_partContext subquery_operation_part() {
		Subquery_operation_partContext _localctx = new Subquery_operation_partContext(_ctx, State);
		EnterRule(_localctx, 318, RULE_subquery_operation_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2835;
			switch (_input.La(1)) {
			case UNION:
				{
				State = 2829; Match(UNION);
				State = 2831;
				_la = _input.La(1);
				if (_la==ALL) {
					{
					State = 2830; Match(ALL);
					}
				}

				}
				break;
			case INTERSECT:
				{
				State = 2833; Match(INTERSECT);
				}
				break;
			case MINUS:
				{
				State = 2834; Match(MINUS);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2837; subquery_basic_elements();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Subquery_basic_elementsContext : ParserRuleContext {
		public Query_blockContext query_block() {
			return GetRuleContext<Query_blockContext>(0);
		}
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public Subquery_basic_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subquery_basic_elements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSubquery_basic_elements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSubquery_basic_elements(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubquery_basic_elements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Subquery_basic_elementsContext subquery_basic_elements() {
		Subquery_basic_elementsContext _localctx = new Subquery_basic_elementsContext(_ctx, State);
		EnterRule(_localctx, 320, RULE_subquery_basic_elements);
		try {
			State = 2844;
			switch (_input.La(1)) {
			case SELECT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2839; query_block();
				}
				break;
			case LEFT_PAREN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2840; Match(LEFT_PAREN);
				State = 2841; subquery();
				State = 2842; Match(RIGHT_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Query_blockContext : ParserRuleContext {
		public ITerminalNode UNIQUE() { return GetToken(plsqlParser.UNIQUE, 0); }
		public From_clauseContext from_clause() {
			return GetRuleContext<From_clauseContext>(0);
		}
		public Selected_elementContext selected_element(int i) {
			return GetRuleContext<Selected_elementContext>(i);
		}
		public Hierarchical_query_clauseContext hierarchical_query_clause() {
			return GetRuleContext<Hierarchical_query_clauseContext>(0);
		}
		public Group_by_clauseContext group_by_clause() {
			return GetRuleContext<Group_by_clauseContext>(0);
		}
		public Into_clauseContext into_clause() {
			return GetRuleContext<Into_clauseContext>(0);
		}
		public Where_clauseContext where_clause() {
			return GetRuleContext<Where_clauseContext>(0);
		}
		public IReadOnlyList<Selected_elementContext> selected_element() {
			return GetRuleContexts<Selected_elementContext>();
		}
		public ITerminalNode SELECT() { return GetToken(plsqlParser.SELECT, 0); }
		public ITerminalNode DISTINCT() { return GetToken(plsqlParser.DISTINCT, 0); }
		public Model_clauseContext model_clause() {
			return GetRuleContext<Model_clauseContext>(0);
		}
		public ITerminalNode ALL() { return GetToken(plsqlParser.ALL, 0); }
		public Query_blockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_query_block; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterQuery_block(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitQuery_block(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQuery_block(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Query_blockContext query_block() {
		Query_blockContext _localctx = new Query_blockContext(_ctx, State);
		EnterRule(_localctx, 322, RULE_query_block);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2846; Match(SELECT);
			State = 2848;
			switch ( Interpreter.AdaptivePredict(_input,306,_ctx) ) {
			case 1:
				{
				State = 2847;
				_la = _input.La(1);
				if ( !(_la==ALL || _la==DISTINCT || _la==UNIQUE) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				}
				break;
			}
			State = 2859;
			switch (_input.La(1)) {
			case ASTERISK:
				{
				State = 2850; Match(ASTERISK);
				}
				break;
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALL:
			case ANALYZE:
			case ANY:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CASE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COALESCE:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DISTINCT:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FALSE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NOT:
			case NULL:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIOR:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUE:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case DECODE:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case NVL:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROUND:
			case ROW_NUMBER:
			case SUBSTR:
			case TO_CHAR:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case NATIONAL_CHAR_STRING_LIT:
			case UNSIGNED_INTEGER:
			case APPROXIMATE_NUM_LIT:
			case CHAR_STRING:
			case DELIMITED_ID:
			case LEFT_PAREN:
			case PLUS_SIGN:
			case MINUS_SIGN:
			case BINDVAR:
			case COLON:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 2851; selected_element();
				State = 2856;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 2852; Match(COMMA);
					State = 2853; selected_element();
					}
					}
					State = 2858;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2862;
			_la = _input.La(1);
			if (_la==BULK || _la==INTO) {
				{
				State = 2861; into_clause();
				}
			}

			State = 2864; from_clause();
			State = 2866;
			switch ( Interpreter.AdaptivePredict(_input,310,_ctx) ) {
			case 1:
				{
				State = 2865; where_clause();
				}
				break;
			}
			State = 2869;
			switch ( Interpreter.AdaptivePredict(_input,311,_ctx) ) {
			case 1:
				{
				State = 2868; hierarchical_query_clause();
				}
				break;
			}
			State = 2872;
			switch ( Interpreter.AdaptivePredict(_input,312,_ctx) ) {
			case 1:
				{
				State = 2871; group_by_clause();
				}
				break;
			}
			State = 2875;
			switch ( Interpreter.AdaptivePredict(_input,313,_ctx) ) {
			case 1:
				{
				State = 2874; model_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Selected_elementContext : ParserRuleContext {
		public Select_list_elementsContext select_list_elements() {
			return GetRuleContext<Select_list_elementsContext>(0);
		}
		public Column_aliasContext column_alias() {
			return GetRuleContext<Column_aliasContext>(0);
		}
		public Selected_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selected_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSelected_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSelected_element(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelected_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Selected_elementContext selected_element() {
		Selected_elementContext _localctx = new Selected_elementContext(_ctx, State);
		EnterRule(_localctx, 324, RULE_selected_element);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2877; select_list_elements();
			State = 2879;
			switch ( Interpreter.AdaptivePredict(_input,314,_ctx) ) {
			case 1:
				{
				State = 2878; column_alias();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class From_clauseContext : ParserRuleContext {
		public ITerminalNode FROM() { return GetToken(plsqlParser.FROM, 0); }
		public Table_ref_listContext table_ref_list() {
			return GetRuleContext<Table_ref_listContext>(0);
		}
		public From_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_from_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterFrom_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitFrom_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFrom_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public From_clauseContext from_clause() {
		From_clauseContext _localctx = new From_clauseContext(_ctx, State);
		EnterRule(_localctx, 326, RULE_from_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2881; Match(FROM);
			State = 2882; table_ref_list();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Select_list_elementsContext : ParserRuleContext {
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Select_list_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_select_list_elements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSelect_list_elements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSelect_list_elements(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelect_list_elements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Select_list_elementsContext select_list_elements() {
		Select_list_elementsContext _localctx = new Select_list_elementsContext(_ctx, State);
		EnterRule(_localctx, 328, RULE_select_list_elements);
		try {
			State = 2889;
			switch ( Interpreter.AdaptivePredict(_input,315,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2884; tableview_name();
				State = 2885; Match(PERIOD);
				State = 2886; Match(ASTERISK);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2888; expression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_ref_listContext : ParserRuleContext {
		public Table_refContext table_ref(int i) {
			return GetRuleContext<Table_refContext>(i);
		}
		public IReadOnlyList<Table_refContext> table_ref() {
			return GetRuleContexts<Table_refContext>();
		}
		public Table_ref_listContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_ref_list; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterTable_ref_list(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitTable_ref_list(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTable_ref_list(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Table_ref_listContext table_ref_list() {
		Table_ref_listContext _localctx = new Table_ref_listContext(_ctx, State);
		EnterRule(_localctx, 330, RULE_table_ref_list);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2891; table_ref();
			State = 2896;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,316,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 2892; Match(COMMA);
					State = 2893; table_ref();
					}
					} 
				}
				State = 2898;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,316,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_refContext : ParserRuleContext {
		public Pivot_clauseContext pivot_clause() {
			return GetRuleContext<Pivot_clauseContext>(0);
		}
		public Unpivot_clauseContext unpivot_clause() {
			return GetRuleContext<Unpivot_clauseContext>(0);
		}
		public IReadOnlyList<Join_clauseContext> join_clause() {
			return GetRuleContexts<Join_clauseContext>();
		}
		public Join_clauseContext join_clause(int i) {
			return GetRuleContext<Join_clauseContext>(i);
		}
		public Table_ref_auxContext table_ref_aux() {
			return GetRuleContext<Table_ref_auxContext>(0);
		}
		public Table_refContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_ref; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterTable_ref(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitTable_ref(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTable_ref(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Table_refContext table_ref() {
		Table_refContext _localctx = new Table_refContext(_ctx, State);
		EnterRule(_localctx, 332, RULE_table_ref);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2899; table_ref_aux();
			State = 2903;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,317,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 2900; join_clause();
					}
					} 
				}
				State = 2905;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,317,_ctx);
			}
			State = 2908;
			switch ( Interpreter.AdaptivePredict(_input,318,_ctx) ) {
			case 1:
				{
				State = 2906; pivot_clause();
				}
				break;

			case 2:
				{
				State = 2907; unpivot_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_ref_auxContext : ParserRuleContext {
		public Table_ref_aux_internalContext table_ref_aux_internal() {
			return GetRuleContext<Table_ref_aux_internalContext>(0);
		}
		public Flashback_query_clauseContext flashback_query_clause(int i) {
			return GetRuleContext<Flashback_query_clauseContext>(i);
		}
		public IReadOnlyList<Flashback_query_clauseContext> flashback_query_clause() {
			return GetRuleContexts<Flashback_query_clauseContext>();
		}
		public Table_aliasContext table_alias() {
			return GetRuleContext<Table_aliasContext>(0);
		}
		public Table_ref_auxContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_ref_aux; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterTable_ref_aux(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitTable_ref_aux(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTable_ref_aux(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Table_ref_auxContext table_ref_aux() {
		Table_ref_auxContext _localctx = new Table_ref_auxContext(_ctx, State);
		EnterRule(_localctx, 334, RULE_table_ref_aux);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2910; table_ref_aux_internal();
			State = 2914;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,319,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 2911; flashback_query_clause();
					}
					} 
				}
				State = 2916;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,319,_ctx);
			}
			State = 2918;
			switch ( Interpreter.AdaptivePredict(_input,320,_ctx) ) {
			case 1:
				{
				State = 2917; table_alias();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_ref_aux_internalContext : ParserRuleContext {
		public Table_ref_aux_internalContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_ref_aux_internal; } }
	 
		public Table_ref_aux_internalContext() { }
		public virtual void CopyFrom(Table_ref_aux_internalContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class Table_ref_aux_internal_threeContext : Table_ref_aux_internalContext {
		public Dml_table_expression_clauseContext dml_table_expression_clause() {
			return GetRuleContext<Dml_table_expression_clauseContext>(0);
		}
		public ITerminalNode ONLY() { return GetToken(plsqlParser.ONLY, 0); }
		public Table_ref_aux_internal_threeContext(Table_ref_aux_internalContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterTable_ref_aux_internal_three(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitTable_ref_aux_internal_three(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTable_ref_aux_internal_three(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Table_ref_aux_internal_oneContext : Table_ref_aux_internalContext {
		public Pivot_clauseContext pivot_clause() {
			return GetRuleContext<Pivot_clauseContext>(0);
		}
		public Dml_table_expression_clauseContext dml_table_expression_clause() {
			return GetRuleContext<Dml_table_expression_clauseContext>(0);
		}
		public Unpivot_clauseContext unpivot_clause() {
			return GetRuleContext<Unpivot_clauseContext>(0);
		}
		public Table_ref_aux_internal_oneContext(Table_ref_aux_internalContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterTable_ref_aux_internal_one(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitTable_ref_aux_internal_one(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTable_ref_aux_internal_one(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Table_ref_aux_internal_twoContext : Table_ref_aux_internalContext {
		public Subquery_operation_partContext subquery_operation_part(int i) {
			return GetRuleContext<Subquery_operation_partContext>(i);
		}
		public Pivot_clauseContext pivot_clause() {
			return GetRuleContext<Pivot_clauseContext>(0);
		}
		public IReadOnlyList<Subquery_operation_partContext> subquery_operation_part() {
			return GetRuleContexts<Subquery_operation_partContext>();
		}
		public Table_refContext table_ref() {
			return GetRuleContext<Table_refContext>(0);
		}
		public Unpivot_clauseContext unpivot_clause() {
			return GetRuleContext<Unpivot_clauseContext>(0);
		}
		public Table_ref_aux_internal_twoContext(Table_ref_aux_internalContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterTable_ref_aux_internal_two(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitTable_ref_aux_internal_two(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTable_ref_aux_internal_two(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Table_ref_aux_internalContext table_ref_aux_internal() {
		Table_ref_aux_internalContext _localctx = new Table_ref_aux_internalContext(_ctx, State);
		EnterRule(_localctx, 336, RULE_table_ref_aux_internal);
		int _la;
		try {
			State = 2943;
			switch ( Interpreter.AdaptivePredict(_input,324,_ctx) ) {
			case 1:
				_localctx = new Table_ref_aux_internal_oneContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 2920; dml_table_expression_clause();
				State = 2923;
				switch ( Interpreter.AdaptivePredict(_input,321,_ctx) ) {
				case 1:
					{
					State = 2921; pivot_clause();
					}
					break;

				case 2:
					{
					State = 2922; unpivot_clause();
					}
					break;
				}
				}
				break;

			case 2:
				_localctx = new Table_ref_aux_internal_twoContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 2925; Match(LEFT_PAREN);
				State = 2926; table_ref();
				State = 2930;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==INTERSECT || _la==MINUS || _la==UNION) {
					{
					{
					State = 2927; subquery_operation_part();
					}
					}
					State = 2932;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 2933; Match(RIGHT_PAREN);
				State = 2936;
				switch ( Interpreter.AdaptivePredict(_input,323,_ctx) ) {
				case 1:
					{
					State = 2934; pivot_clause();
					}
					break;

				case 2:
					{
					State = 2935; unpivot_clause();
					}
					break;
				}
				}
				break;

			case 3:
				_localctx = new Table_ref_aux_internal_threeContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 2938; Match(ONLY);
				State = 2939; Match(LEFT_PAREN);
				State = 2940; dml_table_expression_clause();
				State = 2941; Match(RIGHT_PAREN);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Join_clauseContext : ParserRuleContext {
		public IReadOnlyList<Join_on_partContext> join_on_part() {
			return GetRuleContexts<Join_on_partContext>();
		}
		public Outer_join_typeContext outer_join_type() {
			return GetRuleContext<Outer_join_typeContext>(0);
		}
		public Join_using_partContext join_using_part(int i) {
			return GetRuleContext<Join_using_partContext>(i);
		}
		public Query_partition_clauseContext query_partition_clause(int i) {
			return GetRuleContext<Query_partition_clauseContext>(i);
		}
		public ITerminalNode INNER() { return GetToken(plsqlParser.INNER, 0); }
		public ITerminalNode CROSS() { return GetToken(plsqlParser.CROSS, 0); }
		public ITerminalNode NATURAL() { return GetToken(plsqlParser.NATURAL, 0); }
		public IReadOnlyList<Query_partition_clauseContext> query_partition_clause() {
			return GetRuleContexts<Query_partition_clauseContext>();
		}
		public ITerminalNode JOIN() { return GetToken(plsqlParser.JOIN, 0); }
		public Table_ref_auxContext table_ref_aux() {
			return GetRuleContext<Table_ref_auxContext>(0);
		}
		public Join_on_partContext join_on_part(int i) {
			return GetRuleContext<Join_on_partContext>(i);
		}
		public IReadOnlyList<Join_using_partContext> join_using_part() {
			return GetRuleContexts<Join_using_partContext>();
		}
		public Join_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_join_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterJoin_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitJoin_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitJoin_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Join_clauseContext join_clause() {
		Join_clauseContext _localctx = new Join_clauseContext(_ctx, State);
		EnterRule(_localctx, 338, RULE_join_clause);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2946;
			_la = _input.La(1);
			if (_la==PARTITION) {
				{
				State = 2945; query_partition_clause();
				}
			}

			State = 2949;
			_la = _input.La(1);
			if (_la==CROSS || _la==NATURAL) {
				{
				State = 2948;
				_la = _input.La(1);
				if ( !(_la==CROSS || _la==NATURAL) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				}
			}

			State = 2953;
			switch (_input.La(1)) {
			case INNER:
				{
				State = 2951; Match(INNER);
				}
				break;
			case FULL:
			case LEFT:
			case RIGHT:
				{
				State = 2952; outer_join_type();
				}
				break;
			case JOIN:
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2955; Match(JOIN);
			State = 2956; table_ref_aux();
			State = 2958;
			switch ( Interpreter.AdaptivePredict(_input,328,_ctx) ) {
			case 1:
				{
				State = 2957; query_partition_clause();
				}
				break;
			}
			State = 2964;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,330,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					State = 2962;
					switch (_input.La(1)) {
					case ON:
						{
						State = 2960; join_on_part();
						}
						break;
					case USING:
						{
						State = 2961; join_using_part();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					} 
				}
				State = 2966;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,330,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Join_on_partContext : ParserRuleContext {
		public ITerminalNode ON() { return GetToken(plsqlParser.ON, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public Join_on_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_join_on_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterJoin_on_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitJoin_on_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitJoin_on_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Join_on_partContext join_on_part() {
		Join_on_partContext _localctx = new Join_on_partContext(_ctx, State);
		EnterRule(_localctx, 340, RULE_join_on_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2967; Match(ON);
			State = 2968; condition();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Join_using_partContext : ParserRuleContext {
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public IReadOnlyList<Column_nameContext> column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public ITerminalNode USING() { return GetToken(plsqlParser.USING, 0); }
		public Join_using_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_join_using_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterJoin_using_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitJoin_using_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitJoin_using_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Join_using_partContext join_using_part() {
		Join_using_partContext _localctx = new Join_using_partContext(_ctx, State);
		EnterRule(_localctx, 342, RULE_join_using_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2970; Match(USING);
			State = 2971; Match(LEFT_PAREN);
			State = 2972; column_name();
			State = 2977;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 2973; Match(COMMA);
				State = 2974; column_name();
				}
				}
				State = 2979;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 2980; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Outer_join_typeContext : ParserRuleContext {
		public ITerminalNode LEFT() { return GetToken(plsqlParser.LEFT, 0); }
		public ITerminalNode OUTER() { return GetToken(plsqlParser.OUTER, 0); }
		public ITerminalNode RIGHT() { return GetToken(plsqlParser.RIGHT, 0); }
		public ITerminalNode FULL() { return GetToken(plsqlParser.FULL, 0); }
		public Outer_join_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_outer_join_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterOuter_join_type(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitOuter_join_type(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOuter_join_type(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Outer_join_typeContext outer_join_type() {
		Outer_join_typeContext _localctx = new Outer_join_typeContext(_ctx, State);
		EnterRule(_localctx, 344, RULE_outer_join_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2982;
			_la = _input.La(1);
			if ( !(_la==FULL || _la==LEFT || _la==RIGHT) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			State = 2984;
			_la = _input.La(1);
			if (_la==OUTER) {
				{
				State = 2983; Match(OUTER);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Query_partition_clauseContext : ParserRuleContext {
		public Expression_listContext expression_list() {
			return GetRuleContext<Expression_listContext>(0);
		}
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public ITerminalNode PARTITION() { return GetToken(plsqlParser.PARTITION, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode BY() { return GetToken(plsqlParser.BY, 0); }
		public Query_partition_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_query_partition_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterQuery_partition_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitQuery_partition_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQuery_partition_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Query_partition_clauseContext query_partition_clause() {
		Query_partition_clauseContext _localctx = new Query_partition_clauseContext(_ctx, State);
		EnterRule(_localctx, 346, RULE_query_partition_clause);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2986; Match(PARTITION);
			State = 2987; Match(BY);
			State = 3001;
			switch ( Interpreter.AdaptivePredict(_input,334,_ctx) ) {
			case 1:
				{
				State = 2988; Match(LEFT_PAREN);
				State = 2989; subquery();
				State = 2990; Match(RIGHT_PAREN);
				}
				break;

			case 2:
				{
				State = 2992; expression_list();
				}
				break;

			case 3:
				{
				State = 2993; expression();
				State = 2998;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,333,_ctx);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
					if ( _alt==1 ) {
						{
						{
						State = 2994; Match(COMMA);
						State = 2995; expression();
						}
						} 
					}
					State = 3000;
					_errHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(_input,333,_ctx);
				}
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Flashback_query_clauseContext : ParserRuleContext {
		public ITerminalNode VERSIONS() { return GetToken(plsqlParser.VERSIONS, 0); }
		public ITerminalNode SNAPSHOT() { return GetToken(plsqlParser.SNAPSHOT, 0); }
		public ITerminalNode SCN() { return GetToken(plsqlParser.SCN, 0); }
		public ITerminalNode BETWEEN() { return GetToken(plsqlParser.BETWEEN, 0); }
		public ITerminalNode TIMESTAMP() { return GetToken(plsqlParser.TIMESTAMP, 0); }
		public ITerminalNode OF() { return GetToken(plsqlParser.OF, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode AS() { return GetToken(plsqlParser.AS, 0); }
		public Flashback_query_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_flashback_query_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterFlashback_query_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitFlashback_query_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFlashback_query_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Flashback_query_clauseContext flashback_query_clause() {
		Flashback_query_clauseContext _localctx = new Flashback_query_clauseContext(_ctx, State);
		EnterRule(_localctx, 348, RULE_flashback_query_clause);
		int _la;
		try {
			State = 3011;
			switch (_input.La(1)) {
			case VERSIONS:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3003; Match(VERSIONS);
				State = 3004; Match(BETWEEN);
				State = 3005;
				_la = _input.La(1);
				if ( !(_la==SCN || _la==TIMESTAMP) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				State = 3006; expression();
				}
				break;
			case AS:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3007; Match(AS);
				State = 3008; Match(OF);
				State = 3009;
				_la = _input.La(1);
				if ( !(((((_la - 334)) & ~0x3f) == 0 && ((1L << (_la - 334)) & ((1L << (SCN - 334)) | (1L << (SNAPSHOT - 334)) | (1L << (TIMESTAMP - 334)))) != 0)) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				State = 3010; expression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Pivot_clauseContext : ParserRuleContext {
		public IReadOnlyList<Pivot_elementContext> pivot_element() {
			return GetRuleContexts<Pivot_elementContext>();
		}
		public Pivot_elementContext pivot_element(int i) {
			return GetRuleContext<Pivot_elementContext>(i);
		}
		public Pivot_for_clauseContext pivot_for_clause() {
			return GetRuleContext<Pivot_for_clauseContext>(0);
		}
		public ITerminalNode PIVOT() { return GetToken(plsqlParser.PIVOT, 0); }
		public Pivot_in_clauseContext pivot_in_clause() {
			return GetRuleContext<Pivot_in_clauseContext>(0);
		}
		public ITerminalNode XML() { return GetToken(plsqlParser.XML, 0); }
		public Pivot_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pivot_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterPivot_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitPivot_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPivot_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Pivot_clauseContext pivot_clause() {
		Pivot_clauseContext _localctx = new Pivot_clauseContext(_ctx, State);
		EnterRule(_localctx, 350, RULE_pivot_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3013; Match(PIVOT);
			State = 3015;
			_la = _input.La(1);
			if (_la==XML) {
				{
				State = 3014; Match(XML);
				}
			}

			State = 3017; Match(LEFT_PAREN);
			State = 3018; pivot_element();
			State = 3023;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 3019; Match(COMMA);
				State = 3020; pivot_element();
				}
				}
				State = 3025;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 3026; pivot_for_clause();
			State = 3027; pivot_in_clause();
			State = 3028; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Pivot_elementContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Column_aliasContext column_alias() {
			return GetRuleContext<Column_aliasContext>(0);
		}
		public Aggregate_function_nameContext aggregate_function_name() {
			return GetRuleContext<Aggregate_function_nameContext>(0);
		}
		public Pivot_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pivot_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterPivot_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitPivot_element(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPivot_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Pivot_elementContext pivot_element() {
		Pivot_elementContext _localctx = new Pivot_elementContext(_ctx, State);
		EnterRule(_localctx, 352, RULE_pivot_element);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3030; aggregate_function_name();
			State = 3031; Match(LEFT_PAREN);
			State = 3032; expression();
			State = 3033; Match(RIGHT_PAREN);
			State = 3035;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << AS) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (CONSTANT - 66)) | (1L << (CONSTRAINT - 66)) | (1L << (CONSTRAINTS - 66)) | (1L << (CONSTRUCTOR - 66)) | (1L << (CONTENT - 66)) | (1L << (CONTEXT - 66)) | (1L << (CONTINUE - 66)) | (1L << (CONVERT - 66)) | (1L << (CORRUPT_XID - 66)) | (1L << (CORRUPT_XID_ALL - 66)) | (1L << (COST - 66)) | (1L << (COUNT - 66)) | (1L << (CROSS - 66)) | (1L << (CUBE - 66)) | (1L << (CURRENT_USER - 66)) | (1L << (CURSOR - 66)) | (1L << (CUSTOMDATUM - 66)) | (1L << (CYCLE - 66)) | (1L << (DATA - 66)) | (1L << (DATABASE - 66)) | (1L << (DAY - 66)) | (1L << (DB_ROLE_CHANGE - 66)) | (1L << (DBTIMEZONE - 66)) | (1L << (DDL - 66)) | (1L << (DEBUG - 66)) | (1L << (DEC - 66)) | (1L << (DECIMAL - 66)) | (1L << (DECOMPOSE - 66)) | (1L << (DECREMENT - 66)) | (1L << (DEFAULTS - 66)) | (1L << (DEFERRED - 66)) | (1L << (DEFINER - 66)) | (1L << (DETERMINISTIC - 66)) | (1L << (DIMENSION - 66)) | (1L << (DISABLE - 66)) | (1L << (DISASSOCIATE - 66)) | (1L << (DOCUMENT - 66)) | (1L << (DOUBLE - 66)) | (1L << (DSINTERVAL_UNCONSTRAINED - 66)) | (1L << (EACH - 66)) | (1L << (ELEMENT - 66)) | (1L << (EMPTY - 66)) | (1L << (ENABLE - 66)) | (1L << (ENCODING - 66)) | (1L << (ENTITYESCAPING - 66)) | (1L << (ERR - 66)) | (1L << (ERRORS - 66)) | (1L << (ESCAPE - 66)) | (1L << (EVALNAME - 66)) | (1L << (EXCEPTION - 66)) | (1L << (EXCEPTION_INIT - 66)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)) | (1L << (EXIT - 130)) | (1L << (EXPLAIN - 130)) | (1L << (EXTERNAL - 130)) | (1L << (EXTRACT - 130)) | (1L << (FAILURE - 130)) | (1L << (FINAL - 130)) | (1L << (FIRST - 130)) | (1L << (FIRST_VALUE - 130)) | (1L << (FLOAT - 130)) | (1L << (FOLLOWING - 130)) | (1L << (FOLLOWS - 130)) | (1L << (FORALL - 130)) | (1L << (FORCE - 130)) | (1L << (FULL - 130)) | (1L << (FUNCTION - 130)) | (1L << (GROUPING - 130)) | (1L << (HASH - 130)) | (1L << (HIDE - 130)) | (1L << (HOUR - 130)) | (1L << (IGNORE - 130)) | (1L << (IMMEDIATE - 130)) | (1L << (INCLUDE - 130)) | (1L << (INCLUDING - 130)) | (1L << (INCREMENT - 130)) | (1L << (INDENT - 130)) | (1L << (INDEXED - 130)) | (1L << (INDICATOR - 130)) | (1L << (INDICES - 130)) | (1L << (INFINITE - 130)) | (1L << (INLINE - 130)) | (1L << (INNER - 130)) | (1L << (INOUT - 130)) | (1L << (INSTANTIABLE - 130)) | (1L << (INSTEAD - 130)) | (1L << (INT - 130)) | (1L << (INTEGER - 130)) | (1L << (INTERVAL - 130)) | (1L << (INVALIDATE - 130)) | (1L << (ISOLATION - 130)) | (1L << (ITERATE - 130)) | (1L << (JAVA - 130)) | (1L << (JOIN - 130)) | (1L << (KEEP - 130)) | (1L << (LANGUAGE - 130)))) != 0) || ((((_la - 194)) & ~0x3f) == 0 && ((1L << (_la - 194)) & ((1L << (LAST - 194)) | (1L << (LAST_VALUE - 194)) | (1L << (LEADING - 194)) | (1L << (LEFT - 194)) | (1L << (LEVEL - 194)) | (1L << (LIBRARY - 194)) | (1L << (LIKE2 - 194)) | (1L << (LIKE4 - 194)) | (1L << (LIKEC - 194)) | (1L << (LIMIT - 194)) | (1L << (LOCAL - 194)) | (1L << (LOCKED - 194)) | (1L << (LOG - 194)) | (1L << (LOGOFF - 194)) | (1L << (LOGON - 194)) | (1L << (LONG - 194)) | (1L << (LOOP - 194)) | (1L << (MAIN - 194)) | (1L << (MAP - 194)) | (1L << (MATCHED - 194)) | (1L << (MAXVALUE - 194)) | (1L << (MEASURES - 194)) | (1L << (MEMBER - 194)) | (1L << (MERGE - 194)) | (1L << (MINUTE - 194)) | (1L << (MINVALUE - 194)) | (1L << (MLSLABEL - 194)) | (1L << (MODEL - 194)) | (1L << (MODIFY - 194)) | (1L << (MONTH - 194)) | (1L << (MULTISET - 194)) | (1L << (NAME - 194)) | (1L << (NAN - 194)) | (1L << (NATURAL - 194)) | (1L << (NATURALN - 194)) | (1L << (NAV - 194)) | (1L << (NCHAR - 194)) | (1L << (NCHAR_CS - 194)) | (1L << (NCLOB - 194)) | (1L << (NESTED - 194)) | (1L << (NEW - 194)) | (1L << (NO - 194)) | (1L << (NOAUDIT - 194)) | (1L << (NOCOPY - 194)) | (1L << (NOCYCLE - 194)) | (1L << (NOENTITYESCAPING - 194)) | (1L << (NONE - 194)) | (1L << (NOSCHEMACHECK - 194)) | (1L << (NULLS - 194)) | (1L << (NUMBER - 194)) | (1L << (NUMERIC - 194)) | (1L << (NVARCHAR2 - 194)) | (1L << (OBJECT - 194)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (OFF - 259)) | (1L << (OID - 259)) | (1L << (OLD - 259)) | (1L << (ONLY - 259)) | (1L << (OPEN - 259)) | (1L << (ORADATA - 259)) | (1L << (ORDINALITY - 259)) | (1L << (OSERROR - 259)) | (1L << (OUT - 259)) | (1L << (OUTER - 259)) | (1L << (OVER - 259)) | (1L << (OVERRIDING - 259)) | (1L << (PACKAGE - 259)) | (1L << (PARALLEL_ENABLE - 259)) | (1L << (PARAMETERS - 259)) | (1L << (PARENT - 259)) | (1L << (PARTITION - 259)) | (1L << (PASSING - 259)) | (1L << (PATH - 259)) | (1L << (PIPELINED - 259)) | (1L << (PLAN - 259)) | (1L << (PLS_INTEGER - 259)) | (1L << (POSITIVE - 259)) | (1L << (POSITIVEN - 259)) | (1L << (PRAGMA - 259)) | (1L << (PRECEDING - 259)) | (1L << (PRECISION - 259)) | (1L << (PRESENT - 259)) | (1L << (RAISE - 259)) | (1L << (RANGE - 259)) | (1L << (RAW - 259)) | (1L << (READ - 259)) | (1L << (REAL - 259)) | (1L << (RECORD - 259)) | (1L << (REF - 259)) | (1L << (REFERENCE - 259)) | (1L << (REFERENCING - 259)) | (1L << (REJECT - 259)) | (1L << (RELIES_ON - 259)) | (1L << (RENAME - 259)) | (1L << (REPLACE - 259)) | (1L << (RESPECT - 259)) | (1L << (RESTRICT_REFERENCES - 259)) | (1L << (RESULT - 259)) | (1L << (RESULT_CACHE - 259)) | (1L << (RETURN - 259)) | (1L << (RETURNING - 259)) | (1L << (REUSE - 259)) | (1L << (REVERSE - 259)) | (1L << (RIGHT - 259)))) != 0) || ((((_la - 323)) & ~0x3f) == 0 && ((1L << (_la - 323)) & ((1L << (ROLLBACK - 323)) | (1L << (ROLLUP - 323)) | (1L << (ROW - 323)) | (1L << (ROWID - 323)) | (1L << (ROWS - 323)) | (1L << (RULES - 323)) | (1L << (SAMPLE - 323)) | (1L << (SAVE - 323)) | (1L << (SAVEPOINT - 323)) | (1L << (SCHEMA - 323)) | (1L << (SCHEMACHECK - 323)) | (1L << (SCN - 323)) | (1L << (SECOND - 323)) | (1L << (SEED - 323)) | (1L << (SEGMENT - 323)) | (1L << (SELF - 323)) | (1L << (SEQUENTIAL - 323)) | (1L << (SERIALIZABLE - 323)) | (1L << (SERIALLY_REUSABLE - 323)) | (1L << (SERVERERROR - 323)) | (1L << (SESSIONTIMEZONE - 323)) | (1L << (SET - 323)) | (1L << (SETS - 323)) | (1L << (SETTINGS - 323)) | (1L << (SHOW - 323)) | (1L << (SHUTDOWN - 323)) | (1L << (SIBLINGS - 323)) | (1L << (SIGNTYPE - 323)) | (1L << (SIMPLE_INTEGER - 323)) | (1L << (SINGLE - 323)) | (1L << (SKIP_ - 323)) | (1L << (SMALLINT - 323)) | (1L << (SNAPSHOT - 323)) | (1L << (SOME - 323)) | (1L << (SPECIFICATION - 323)) | (1L << (SQLDATA - 323)) | (1L << (SQLERROR - 323)) | (1L << (STANDALONE - 323)) | (1L << (STARTUP - 323)) | (1L << (STATEMENT - 323)) | (1L << (STATEMENT_ID - 323)) | (1L << (STATIC - 323)) | (1L << (STATISTICS - 323)) | (1L << (STRING - 323)) | (1L << (SUBMULTISET - 323)) | (1L << (SUBPARTITION - 323)) | (1L << (SUBSTITUTABLE - 323)) | (1L << (SUBTYPE - 323)) | (1L << (SUCCESS - 323)) | (1L << (SUSPEND - 323)) | (1L << (TIME - 323)) | (1L << (TIMESTAMP - 323)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_UNCONSTRAINED - 323)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TIMEZONE_ABBR - 387)) | (1L << (TIMEZONE_HOUR - 387)) | (1L << (TIMEZONE_MINUTE - 387)) | (1L << (TIMEZONE_REGION - 387)) | (1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (YMINTERVAL_UNCONSTRAINED - 451)) | (1L << (ZONE - 451)) | (1L << (PREDICTION - 451)) | (1L << (PREDICTION_BOUNDS - 451)) | (1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (COVAR_ - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (REGR_ - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (TRIM - 451)) | (1L << (SUM - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (VARIANCE - 451)) | (1L << (NATIONAL_CHAR_STRING_LIT - 451)) | (1L << (CHAR_STRING - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 3034; column_alias();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Pivot_for_clauseContext : ParserRuleContext {
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public IReadOnlyList<Column_nameContext> column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public ITerminalNode FOR() { return GetToken(plsqlParser.FOR, 0); }
		public Pivot_for_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pivot_for_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterPivot_for_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitPivot_for_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPivot_for_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Pivot_for_clauseContext pivot_for_clause() {
		Pivot_for_clauseContext _localctx = new Pivot_for_clauseContext(_ctx, State);
		EnterRule(_localctx, 354, RULE_pivot_for_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3037; Match(FOR);
			State = 3050;
			switch (_input.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROW_NUMBER:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 3038; column_name();
				}
				break;
			case LEFT_PAREN:
				{
				State = 3039; Match(LEFT_PAREN);
				State = 3040; column_name();
				State = 3045;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 3041; Match(COMMA);
					State = 3042; column_name();
					}
					}
					State = 3047;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 3048; Match(RIGHT_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Pivot_in_clauseContext : ParserRuleContext {
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public Pivot_in_clause_elementContext pivot_in_clause_element(int i) {
			return GetRuleContext<Pivot_in_clause_elementContext>(i);
		}
		public ITerminalNode ANY(int i) {
			return GetToken(plsqlParser.ANY, i);
		}
		public IReadOnlyList<Pivot_in_clause_elementContext> pivot_in_clause_element() {
			return GetRuleContexts<Pivot_in_clause_elementContext>();
		}
		public IReadOnlyList<ITerminalNode> ANY() { return GetTokens(plsqlParser.ANY); }
		public ITerminalNode IN() { return GetToken(plsqlParser.IN, 0); }
		public Pivot_in_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pivot_in_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterPivot_in_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitPivot_in_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPivot_in_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Pivot_in_clauseContext pivot_in_clause() {
		Pivot_in_clauseContext _localctx = new Pivot_in_clauseContext(_ctx, State);
		EnterRule(_localctx, 356, RULE_pivot_in_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3052; Match(IN);
			State = 3053; Match(LEFT_PAREN);
			State = 3071;
			switch ( Interpreter.AdaptivePredict(_input,343,_ctx) ) {
			case 1:
				{
				State = 3054; subquery();
				}
				break;

			case 2:
				{
				State = 3055; Match(ANY);
				State = 3060;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 3056; Match(COMMA);
					State = 3057; Match(ANY);
					}
					}
					State = 3062;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
				break;

			case 3:
				{
				State = 3063; pivot_in_clause_element();
				State = 3068;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 3064; Match(COMMA);
					State = 3065; pivot_in_clause_element();
					}
					}
					State = 3070;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
				break;
			}
			State = 3073; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Pivot_in_clause_elementContext : ParserRuleContext {
		public Pivot_in_clause_elementsContext pivot_in_clause_elements() {
			return GetRuleContext<Pivot_in_clause_elementsContext>(0);
		}
		public Column_aliasContext column_alias() {
			return GetRuleContext<Column_aliasContext>(0);
		}
		public Pivot_in_clause_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pivot_in_clause_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterPivot_in_clause_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitPivot_in_clause_element(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPivot_in_clause_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Pivot_in_clause_elementContext pivot_in_clause_element() {
		Pivot_in_clause_elementContext _localctx = new Pivot_in_clause_elementContext(_ctx, State);
		EnterRule(_localctx, 358, RULE_pivot_in_clause_element);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3075; pivot_in_clause_elements();
			State = 3077;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << AS) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (CONSTANT - 66)) | (1L << (CONSTRAINT - 66)) | (1L << (CONSTRAINTS - 66)) | (1L << (CONSTRUCTOR - 66)) | (1L << (CONTENT - 66)) | (1L << (CONTEXT - 66)) | (1L << (CONTINUE - 66)) | (1L << (CONVERT - 66)) | (1L << (CORRUPT_XID - 66)) | (1L << (CORRUPT_XID_ALL - 66)) | (1L << (COST - 66)) | (1L << (COUNT - 66)) | (1L << (CROSS - 66)) | (1L << (CUBE - 66)) | (1L << (CURRENT_USER - 66)) | (1L << (CURSOR - 66)) | (1L << (CUSTOMDATUM - 66)) | (1L << (CYCLE - 66)) | (1L << (DATA - 66)) | (1L << (DATABASE - 66)) | (1L << (DAY - 66)) | (1L << (DB_ROLE_CHANGE - 66)) | (1L << (DBTIMEZONE - 66)) | (1L << (DDL - 66)) | (1L << (DEBUG - 66)) | (1L << (DEC - 66)) | (1L << (DECIMAL - 66)) | (1L << (DECOMPOSE - 66)) | (1L << (DECREMENT - 66)) | (1L << (DEFAULTS - 66)) | (1L << (DEFERRED - 66)) | (1L << (DEFINER - 66)) | (1L << (DETERMINISTIC - 66)) | (1L << (DIMENSION - 66)) | (1L << (DISABLE - 66)) | (1L << (DISASSOCIATE - 66)) | (1L << (DOCUMENT - 66)) | (1L << (DOUBLE - 66)) | (1L << (DSINTERVAL_UNCONSTRAINED - 66)) | (1L << (EACH - 66)) | (1L << (ELEMENT - 66)) | (1L << (EMPTY - 66)) | (1L << (ENABLE - 66)) | (1L << (ENCODING - 66)) | (1L << (ENTITYESCAPING - 66)) | (1L << (ERR - 66)) | (1L << (ERRORS - 66)) | (1L << (ESCAPE - 66)) | (1L << (EVALNAME - 66)) | (1L << (EXCEPTION - 66)) | (1L << (EXCEPTION_INIT - 66)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)) | (1L << (EXIT - 130)) | (1L << (EXPLAIN - 130)) | (1L << (EXTERNAL - 130)) | (1L << (EXTRACT - 130)) | (1L << (FAILURE - 130)) | (1L << (FINAL - 130)) | (1L << (FIRST - 130)) | (1L << (FIRST_VALUE - 130)) | (1L << (FLOAT - 130)) | (1L << (FOLLOWING - 130)) | (1L << (FOLLOWS - 130)) | (1L << (FORALL - 130)) | (1L << (FORCE - 130)) | (1L << (FULL - 130)) | (1L << (FUNCTION - 130)) | (1L << (GROUPING - 130)) | (1L << (HASH - 130)) | (1L << (HIDE - 130)) | (1L << (HOUR - 130)) | (1L << (IGNORE - 130)) | (1L << (IMMEDIATE - 130)) | (1L << (INCLUDE - 130)) | (1L << (INCLUDING - 130)) | (1L << (INCREMENT - 130)) | (1L << (INDENT - 130)) | (1L << (INDEXED - 130)) | (1L << (INDICATOR - 130)) | (1L << (INDICES - 130)) | (1L << (INFINITE - 130)) | (1L << (INLINE - 130)) | (1L << (INNER - 130)) | (1L << (INOUT - 130)) | (1L << (INSTANTIABLE - 130)) | (1L << (INSTEAD - 130)) | (1L << (INT - 130)) | (1L << (INTEGER - 130)) | (1L << (INTERVAL - 130)) | (1L << (INVALIDATE - 130)) | (1L << (ISOLATION - 130)) | (1L << (ITERATE - 130)) | (1L << (JAVA - 130)) | (1L << (JOIN - 130)) | (1L << (KEEP - 130)) | (1L << (LANGUAGE - 130)))) != 0) || ((((_la - 194)) & ~0x3f) == 0 && ((1L << (_la - 194)) & ((1L << (LAST - 194)) | (1L << (LAST_VALUE - 194)) | (1L << (LEADING - 194)) | (1L << (LEFT - 194)) | (1L << (LEVEL - 194)) | (1L << (LIBRARY - 194)) | (1L << (LIKE2 - 194)) | (1L << (LIKE4 - 194)) | (1L << (LIKEC - 194)) | (1L << (LIMIT - 194)) | (1L << (LOCAL - 194)) | (1L << (LOCKED - 194)) | (1L << (LOG - 194)) | (1L << (LOGOFF - 194)) | (1L << (LOGON - 194)) | (1L << (LONG - 194)) | (1L << (LOOP - 194)) | (1L << (MAIN - 194)) | (1L << (MAP - 194)) | (1L << (MATCHED - 194)) | (1L << (MAXVALUE - 194)) | (1L << (MEASURES - 194)) | (1L << (MEMBER - 194)) | (1L << (MERGE - 194)) | (1L << (MINUTE - 194)) | (1L << (MINVALUE - 194)) | (1L << (MLSLABEL - 194)) | (1L << (MODEL - 194)) | (1L << (MODIFY - 194)) | (1L << (MONTH - 194)) | (1L << (MULTISET - 194)) | (1L << (NAME - 194)) | (1L << (NAN - 194)) | (1L << (NATURAL - 194)) | (1L << (NATURALN - 194)) | (1L << (NAV - 194)) | (1L << (NCHAR - 194)) | (1L << (NCHAR_CS - 194)) | (1L << (NCLOB - 194)) | (1L << (NESTED - 194)) | (1L << (NEW - 194)) | (1L << (NO - 194)) | (1L << (NOAUDIT - 194)) | (1L << (NOCOPY - 194)) | (1L << (NOCYCLE - 194)) | (1L << (NOENTITYESCAPING - 194)) | (1L << (NONE - 194)) | (1L << (NOSCHEMACHECK - 194)) | (1L << (NULLS - 194)) | (1L << (NUMBER - 194)) | (1L << (NUMERIC - 194)) | (1L << (NVARCHAR2 - 194)) | (1L << (OBJECT - 194)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (OFF - 259)) | (1L << (OID - 259)) | (1L << (OLD - 259)) | (1L << (ONLY - 259)) | (1L << (OPEN - 259)) | (1L << (ORADATA - 259)) | (1L << (ORDINALITY - 259)) | (1L << (OSERROR - 259)) | (1L << (OUT - 259)) | (1L << (OUTER - 259)) | (1L << (OVER - 259)) | (1L << (OVERRIDING - 259)) | (1L << (PACKAGE - 259)) | (1L << (PARALLEL_ENABLE - 259)) | (1L << (PARAMETERS - 259)) | (1L << (PARENT - 259)) | (1L << (PARTITION - 259)) | (1L << (PASSING - 259)) | (1L << (PATH - 259)) | (1L << (PIPELINED - 259)) | (1L << (PLAN - 259)) | (1L << (PLS_INTEGER - 259)) | (1L << (POSITIVE - 259)) | (1L << (POSITIVEN - 259)) | (1L << (PRAGMA - 259)) | (1L << (PRECEDING - 259)) | (1L << (PRECISION - 259)) | (1L << (PRESENT - 259)) | (1L << (RAISE - 259)) | (1L << (RANGE - 259)) | (1L << (RAW - 259)) | (1L << (READ - 259)) | (1L << (REAL - 259)) | (1L << (RECORD - 259)) | (1L << (REF - 259)) | (1L << (REFERENCE - 259)) | (1L << (REFERENCING - 259)) | (1L << (REJECT - 259)) | (1L << (RELIES_ON - 259)) | (1L << (RENAME - 259)) | (1L << (REPLACE - 259)) | (1L << (RESPECT - 259)) | (1L << (RESTRICT_REFERENCES - 259)) | (1L << (RESULT - 259)) | (1L << (RESULT_CACHE - 259)) | (1L << (RETURN - 259)) | (1L << (RETURNING - 259)) | (1L << (REUSE - 259)) | (1L << (REVERSE - 259)) | (1L << (RIGHT - 259)))) != 0) || ((((_la - 323)) & ~0x3f) == 0 && ((1L << (_la - 323)) & ((1L << (ROLLBACK - 323)) | (1L << (ROLLUP - 323)) | (1L << (ROW - 323)) | (1L << (ROWID - 323)) | (1L << (ROWS - 323)) | (1L << (RULES - 323)) | (1L << (SAMPLE - 323)) | (1L << (SAVE - 323)) | (1L << (SAVEPOINT - 323)) | (1L << (SCHEMA - 323)) | (1L << (SCHEMACHECK - 323)) | (1L << (SCN - 323)) | (1L << (SECOND - 323)) | (1L << (SEED - 323)) | (1L << (SEGMENT - 323)) | (1L << (SELF - 323)) | (1L << (SEQUENTIAL - 323)) | (1L << (SERIALIZABLE - 323)) | (1L << (SERIALLY_REUSABLE - 323)) | (1L << (SERVERERROR - 323)) | (1L << (SESSIONTIMEZONE - 323)) | (1L << (SET - 323)) | (1L << (SETS - 323)) | (1L << (SETTINGS - 323)) | (1L << (SHOW - 323)) | (1L << (SHUTDOWN - 323)) | (1L << (SIBLINGS - 323)) | (1L << (SIGNTYPE - 323)) | (1L << (SIMPLE_INTEGER - 323)) | (1L << (SINGLE - 323)) | (1L << (SKIP_ - 323)) | (1L << (SMALLINT - 323)) | (1L << (SNAPSHOT - 323)) | (1L << (SOME - 323)) | (1L << (SPECIFICATION - 323)) | (1L << (SQLDATA - 323)) | (1L << (SQLERROR - 323)) | (1L << (STANDALONE - 323)) | (1L << (STARTUP - 323)) | (1L << (STATEMENT - 323)) | (1L << (STATEMENT_ID - 323)) | (1L << (STATIC - 323)) | (1L << (STATISTICS - 323)) | (1L << (STRING - 323)) | (1L << (SUBMULTISET - 323)) | (1L << (SUBPARTITION - 323)) | (1L << (SUBSTITUTABLE - 323)) | (1L << (SUBTYPE - 323)) | (1L << (SUCCESS - 323)) | (1L << (SUSPEND - 323)) | (1L << (TIME - 323)) | (1L << (TIMESTAMP - 323)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_UNCONSTRAINED - 323)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TIMEZONE_ABBR - 387)) | (1L << (TIMEZONE_HOUR - 387)) | (1L << (TIMEZONE_MINUTE - 387)) | (1L << (TIMEZONE_REGION - 387)) | (1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (YMINTERVAL_UNCONSTRAINED - 451)) | (1L << (ZONE - 451)) | (1L << (PREDICTION - 451)) | (1L << (PREDICTION_BOUNDS - 451)) | (1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (COVAR_ - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (REGR_ - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (TRIM - 451)) | (1L << (SUM - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (VARIANCE - 451)) | (1L << (NATIONAL_CHAR_STRING_LIT - 451)) | (1L << (CHAR_STRING - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 3076; column_alias();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Pivot_in_clause_elementsContext : ParserRuleContext {
		public Expression_listContext expression_list() {
			return GetRuleContext<Expression_listContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Pivot_in_clause_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pivot_in_clause_elements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterPivot_in_clause_elements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitPivot_in_clause_elements(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPivot_in_clause_elements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Pivot_in_clause_elementsContext pivot_in_clause_elements() {
		Pivot_in_clause_elementsContext _localctx = new Pivot_in_clause_elementsContext(_ctx, State);
		EnterRule(_localctx, 360, RULE_pivot_in_clause_elements);
		try {
			State = 3081;
			switch ( Interpreter.AdaptivePredict(_input,345,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3079; expression();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3080; expression_list();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Unpivot_clauseContext : ParserRuleContext {
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public IReadOnlyList<Column_nameContext> column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public Unpivot_in_clauseContext unpivot_in_clause() {
			return GetRuleContext<Unpivot_in_clauseContext>(0);
		}
		public Pivot_for_clauseContext pivot_for_clause() {
			return GetRuleContext<Pivot_for_clauseContext>(0);
		}
		public ITerminalNode EXCLUDE() { return GetToken(plsqlParser.EXCLUDE, 0); }
		public ITerminalNode NULLS() { return GetToken(plsqlParser.NULLS, 0); }
		public ITerminalNode UNPIVOT() { return GetToken(plsqlParser.UNPIVOT, 0); }
		public ITerminalNode INCLUDE() { return GetToken(plsqlParser.INCLUDE, 0); }
		public Unpivot_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unpivot_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterUnpivot_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitUnpivot_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnpivot_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Unpivot_clauseContext unpivot_clause() {
		Unpivot_clauseContext _localctx = new Unpivot_clauseContext(_ctx, State);
		EnterRule(_localctx, 362, RULE_unpivot_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3083; Match(UNPIVOT);
			State = 3086;
			_la = _input.La(1);
			if (_la==EXCLUDE || _la==INCLUDE) {
				{
				State = 3084;
				_la = _input.La(1);
				if ( !(_la==EXCLUDE || _la==INCLUDE) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				State = 3085; Match(NULLS);
				}
			}

			State = 3088; Match(LEFT_PAREN);
			State = 3101;
			switch (_input.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROW_NUMBER:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 3089; column_name();
				}
				break;
			case LEFT_PAREN:
				{
				State = 3090; Match(LEFT_PAREN);
				State = 3091; column_name();
				State = 3096;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 3092; Match(COMMA);
					State = 3093; column_name();
					}
					}
					State = 3098;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 3099; Match(RIGHT_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3103; pivot_for_clause();
			State = 3104; unpivot_in_clause();
			State = 3105; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Unpivot_in_clauseContext : ParserRuleContext {
		public IReadOnlyList<Unpivot_in_elementsContext> unpivot_in_elements() {
			return GetRuleContexts<Unpivot_in_elementsContext>();
		}
		public Unpivot_in_elementsContext unpivot_in_elements(int i) {
			return GetRuleContext<Unpivot_in_elementsContext>(i);
		}
		public ITerminalNode IN() { return GetToken(plsqlParser.IN, 0); }
		public Unpivot_in_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unpivot_in_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterUnpivot_in_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitUnpivot_in_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnpivot_in_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Unpivot_in_clauseContext unpivot_in_clause() {
		Unpivot_in_clauseContext _localctx = new Unpivot_in_clauseContext(_ctx, State);
		EnterRule(_localctx, 364, RULE_unpivot_in_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3107; Match(IN);
			State = 3108; Match(LEFT_PAREN);
			State = 3109; unpivot_in_elements();
			State = 3114;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 3110; Match(COMMA);
				State = 3111; unpivot_in_elements();
				}
				}
				State = 3116;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 3117; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Unpivot_in_elementsContext : ParserRuleContext {
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public IReadOnlyList<Column_nameContext> column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public IReadOnlyList<ConstantContext> constant() {
			return GetRuleContexts<ConstantContext>();
		}
		public ConstantContext constant(int i) {
			return GetRuleContext<ConstantContext>(i);
		}
		public ITerminalNode AS() { return GetToken(plsqlParser.AS, 0); }
		public Unpivot_in_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unpivot_in_elements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterUnpivot_in_elements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitUnpivot_in_elements(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnpivot_in_elements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Unpivot_in_elementsContext unpivot_in_elements() {
		Unpivot_in_elementsContext _localctx = new Unpivot_in_elementsContext(_ctx, State);
		EnterRule(_localctx, 366, RULE_unpivot_in_elements);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3131;
			switch (_input.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROW_NUMBER:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 3119; column_name();
				}
				break;
			case LEFT_PAREN:
				{
				State = 3120; Match(LEFT_PAREN);
				State = 3121; column_name();
				State = 3126;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 3122; Match(COMMA);
					State = 3123; column_name();
					}
					}
					State = 3128;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 3129; Match(RIGHT_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3148;
			_la = _input.La(1);
			if (_la==AS) {
				{
				State = 3133; Match(AS);
				State = 3146;
				switch (_input.La(1)) {
				case DATE:
				case DBTIMEZONE:
				case DEFAULT:
				case FALSE:
				case INTERVAL:
				case MAXVALUE:
				case MINVALUE:
				case NULL:
				case SESSIONTIMEZONE:
				case TIMESTAMP:
				case TRUE:
				case NATIONAL_CHAR_STRING_LIT:
				case UNSIGNED_INTEGER:
				case APPROXIMATE_NUM_LIT:
				case CHAR_STRING:
					{
					State = 3134; constant();
					}
					break;
				case LEFT_PAREN:
					{
					State = 3135; Match(LEFT_PAREN);
					State = 3136; constant();
					State = 3141;
					_errHandler.Sync(this);
					_la = _input.La(1);
					while (_la==COMMA) {
						{
						{
						State = 3137; Match(COMMA);
						State = 3138; constant();
						}
						}
						State = 3143;
						_errHandler.Sync(this);
						_la = _input.La(1);
					}
					State = 3144; Match(RIGHT_PAREN);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Hierarchical_query_clauseContext : ParserRuleContext {
		public ITerminalNode NOCYCLE() { return GetToken(plsqlParser.NOCYCLE, 0); }
		public ITerminalNode CONNECT() { return GetToken(plsqlParser.CONNECT, 0); }
		public ITerminalNode BY() { return GetToken(plsqlParser.BY, 0); }
		public Start_partContext start_part() {
			return GetRuleContext<Start_partContext>(0);
		}
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public Hierarchical_query_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_hierarchical_query_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterHierarchical_query_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitHierarchical_query_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHierarchical_query_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Hierarchical_query_clauseContext hierarchical_query_clause() {
		Hierarchical_query_clauseContext _localctx = new Hierarchical_query_clauseContext(_ctx, State);
		EnterRule(_localctx, 368, RULE_hierarchical_query_clause);
		try {
			State = 3167;
			switch (_input.La(1)) {
			case CONNECT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3150; Match(CONNECT);
				State = 3151; Match(BY);
				State = 3153;
				switch ( Interpreter.AdaptivePredict(_input,355,_ctx) ) {
				case 1:
					{
					State = 3152; Match(NOCYCLE);
					}
					break;
				}
				State = 3155; condition();
				State = 3157;
				switch ( Interpreter.AdaptivePredict(_input,356,_ctx) ) {
				case 1:
					{
					State = 3156; start_part();
					}
					break;
				}
				}
				break;
			case START:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3159; start_part();
				State = 3160; Match(CONNECT);
				State = 3161; Match(BY);
				State = 3163;
				switch ( Interpreter.AdaptivePredict(_input,357,_ctx) ) {
				case 1:
					{
					State = 3162; Match(NOCYCLE);
					}
					break;
				}
				State = 3165; condition();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Start_partContext : ParserRuleContext {
		public ITerminalNode WITH() { return GetToken(plsqlParser.WITH, 0); }
		public ITerminalNode START() { return GetToken(plsqlParser.START, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public Start_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_start_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterStart_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitStart_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStart_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Start_partContext start_part() {
		Start_partContext _localctx = new Start_partContext(_ctx, State);
		EnterRule(_localctx, 370, RULE_start_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3169; Match(START);
			State = 3170; Match(WITH);
			State = 3171; condition();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Group_by_clauseContext : ParserRuleContext {
		public IReadOnlyList<Group_by_elementsContext> group_by_elements() {
			return GetRuleContexts<Group_by_elementsContext>();
		}
		public Group_by_elementsContext group_by_elements(int i) {
			return GetRuleContext<Group_by_elementsContext>(i);
		}
		public ITerminalNode GROUP() { return GetToken(plsqlParser.GROUP, 0); }
		public Having_clauseContext having_clause() {
			return GetRuleContext<Having_clauseContext>(0);
		}
		public ITerminalNode BY() { return GetToken(plsqlParser.BY, 0); }
		public Group_by_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_group_by_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterGroup_by_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitGroup_by_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGroup_by_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Group_by_clauseContext group_by_clause() {
		Group_by_clauseContext _localctx = new Group_by_clauseContext(_ctx, State);
		EnterRule(_localctx, 372, RULE_group_by_clause);
		try {
			int _alt;
			State = 3199;
			switch (_input.La(1)) {
			case GROUP:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3173; Match(GROUP);
				State = 3174; Match(BY);
				State = 3175; group_by_elements();
				State = 3180;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,359,_ctx);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
					if ( _alt==1 ) {
						{
						{
						State = 3176; Match(COMMA);
						State = 3177; group_by_elements();
						}
						} 
					}
					State = 3182;
					_errHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(_input,359,_ctx);
				}
				State = 3184;
				switch ( Interpreter.AdaptivePredict(_input,360,_ctx) ) {
				case 1:
					{
					State = 3183; having_clause();
					}
					break;
				}
				}
				break;
			case HAVING:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3186; having_clause();
				State = 3197;
				switch ( Interpreter.AdaptivePredict(_input,362,_ctx) ) {
				case 1:
					{
					State = 3187; Match(GROUP);
					State = 3188; Match(BY);
					State = 3189; group_by_elements();
					State = 3194;
					_errHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(_input,361,_ctx);
					while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
						if ( _alt==1 ) {
							{
							{
							State = 3190; Match(COMMA);
							State = 3191; group_by_elements();
							}
							} 
						}
						State = 3196;
						_errHandler.Sync(this);
						_alt = Interpreter.AdaptivePredict(_input,361,_ctx);
					}
					}
					break;
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Group_by_elementsContext : ParserRuleContext {
		public Grouping_sets_clauseContext grouping_sets_clause() {
			return GetRuleContext<Grouping_sets_clauseContext>(0);
		}
		public Rollup_cube_clauseContext rollup_cube_clause() {
			return GetRuleContext<Rollup_cube_clauseContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Group_by_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_group_by_elements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterGroup_by_elements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitGroup_by_elements(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGroup_by_elements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Group_by_elementsContext group_by_elements() {
		Group_by_elementsContext _localctx = new Group_by_elementsContext(_ctx, State);
		EnterRule(_localctx, 374, RULE_group_by_elements);
		try {
			State = 3204;
			switch ( Interpreter.AdaptivePredict(_input,364,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3201; grouping_sets_clause();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3202; rollup_cube_clause();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3203; expression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Rollup_cube_clauseContext : ParserRuleContext {
		public ITerminalNode ROLLUP() { return GetToken(plsqlParser.ROLLUP, 0); }
		public ITerminalNode CUBE() { return GetToken(plsqlParser.CUBE, 0); }
		public Grouping_sets_elementsContext grouping_sets_elements(int i) {
			return GetRuleContext<Grouping_sets_elementsContext>(i);
		}
		public IReadOnlyList<Grouping_sets_elementsContext> grouping_sets_elements() {
			return GetRuleContexts<Grouping_sets_elementsContext>();
		}
		public Rollup_cube_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rollup_cube_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterRollup_cube_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitRollup_cube_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRollup_cube_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Rollup_cube_clauseContext rollup_cube_clause() {
		Rollup_cube_clauseContext _localctx = new Rollup_cube_clauseContext(_ctx, State);
		EnterRule(_localctx, 376, RULE_rollup_cube_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3206;
			_la = _input.La(1);
			if ( !(_la==CUBE || _la==ROLLUP) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			State = 3207; Match(LEFT_PAREN);
			State = 3208; grouping_sets_elements();
			State = 3213;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 3209; Match(COMMA);
				State = 3210; grouping_sets_elements();
				}
				}
				State = 3215;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 3216; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Grouping_sets_clauseContext : ParserRuleContext {
		public ITerminalNode SETS() { return GetToken(plsqlParser.SETS, 0); }
		public ITerminalNode GROUPING() { return GetToken(plsqlParser.GROUPING, 0); }
		public Grouping_sets_elementsContext grouping_sets_elements(int i) {
			return GetRuleContext<Grouping_sets_elementsContext>(i);
		}
		public IReadOnlyList<Grouping_sets_elementsContext> grouping_sets_elements() {
			return GetRuleContexts<Grouping_sets_elementsContext>();
		}
		public Grouping_sets_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_grouping_sets_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterGrouping_sets_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitGrouping_sets_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGrouping_sets_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Grouping_sets_clauseContext grouping_sets_clause() {
		Grouping_sets_clauseContext _localctx = new Grouping_sets_clauseContext(_ctx, State);
		EnterRule(_localctx, 378, RULE_grouping_sets_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3218; Match(GROUPING);
			State = 3219; Match(SETS);
			State = 3220; Match(LEFT_PAREN);
			State = 3221; grouping_sets_elements();
			State = 3226;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 3222; Match(COMMA);
				State = 3223; grouping_sets_elements();
				}
				}
				State = 3228;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 3229; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Grouping_sets_elementsContext : ParserRuleContext {
		public Rollup_cube_clauseContext rollup_cube_clause() {
			return GetRuleContext<Rollup_cube_clauseContext>(0);
		}
		public Expression_listContext expression_list() {
			return GetRuleContext<Expression_listContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Grouping_sets_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_grouping_sets_elements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterGrouping_sets_elements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitGrouping_sets_elements(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGrouping_sets_elements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Grouping_sets_elementsContext grouping_sets_elements() {
		Grouping_sets_elementsContext _localctx = new Grouping_sets_elementsContext(_ctx, State);
		EnterRule(_localctx, 380, RULE_grouping_sets_elements);
		try {
			State = 3234;
			switch ( Interpreter.AdaptivePredict(_input,367,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3231; rollup_cube_clause();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3232; expression_list();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3233; expression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Having_clauseContext : ParserRuleContext {
		public ITerminalNode HAVING() { return GetToken(plsqlParser.HAVING, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public Having_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_having_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterHaving_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitHaving_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHaving_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Having_clauseContext having_clause() {
		Having_clauseContext _localctx = new Having_clauseContext(_ctx, State);
		EnterRule(_localctx, 382, RULE_having_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3236; Match(HAVING);
			State = 3237; condition();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Model_clauseContext : ParserRuleContext {
		public IReadOnlyList<Cell_reference_optionsContext> cell_reference_options() {
			return GetRuleContexts<Cell_reference_optionsContext>();
		}
		public Cell_reference_optionsContext cell_reference_options(int i) {
			return GetRuleContext<Cell_reference_optionsContext>(i);
		}
		public Reference_modelContext reference_model(int i) {
			return GetRuleContext<Reference_modelContext>(i);
		}
		public IReadOnlyList<Reference_modelContext> reference_model() {
			return GetRuleContexts<Reference_modelContext>();
		}
		public ITerminalNode MODEL() { return GetToken(plsqlParser.MODEL, 0); }
		public Return_rows_clauseContext return_rows_clause() {
			return GetRuleContext<Return_rows_clauseContext>(0);
		}
		public Main_modelContext main_model() {
			return GetRuleContext<Main_modelContext>(0);
		}
		public Model_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_model_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterModel_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitModel_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModel_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Model_clauseContext model_clause() {
		Model_clauseContext _localctx = new Model_clauseContext(_ctx, State);
		EnterRule(_localctx, 384, RULE_model_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3239; Match(MODEL);
			State = 3243;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==IGNORE || _la==KEEP || _la==UNIQUE) {
				{
				{
				State = 3240; cell_reference_options();
				}
				}
				State = 3245;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 3247;
			_la = _input.La(1);
			if (_la==RETURN) {
				{
				State = 3246; return_rows_clause();
				}
			}

			State = 3252;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==REFERENCE) {
				{
				{
				State = 3249; reference_model();
				}
				}
				State = 3254;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 3255; main_model();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cell_reference_optionsContext : ParserRuleContext {
		public ITerminalNode UNIQUE() { return GetToken(plsqlParser.UNIQUE, 0); }
		public ITerminalNode IGNORE() { return GetToken(plsqlParser.IGNORE, 0); }
		public ITerminalNode REFERENCE() { return GetToken(plsqlParser.REFERENCE, 0); }
		public ITerminalNode DIMENSION() { return GetToken(plsqlParser.DIMENSION, 0); }
		public ITerminalNode KEEP() { return GetToken(plsqlParser.KEEP, 0); }
		public ITerminalNode NAV() { return GetToken(plsqlParser.NAV, 0); }
		public ITerminalNode SINGLE() { return GetToken(plsqlParser.SINGLE, 0); }
		public Cell_reference_optionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cell_reference_options; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCell_reference_options(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCell_reference_options(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCell_reference_options(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Cell_reference_optionsContext cell_reference_options() {
		Cell_reference_optionsContext _localctx = new Cell_reference_optionsContext(_ctx, State);
		EnterRule(_localctx, 386, RULE_cell_reference_options);
		int _la;
		try {
			State = 3265;
			switch (_input.La(1)) {
			case IGNORE:
			case KEEP:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3257;
				_la = _input.La(1);
				if ( !(_la==IGNORE || _la==KEEP) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				State = 3258; Match(NAV);
				}
				break;
			case UNIQUE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3259; Match(UNIQUE);
				State = 3263;
				switch (_input.La(1)) {
				case DIMENSION:
					{
					State = 3260; Match(DIMENSION);
					}
					break;
				case SINGLE:
					{
					State = 3261; Match(SINGLE);
					State = 3262; Match(REFERENCE);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Return_rows_clauseContext : ParserRuleContext {
		public ITerminalNode RETURN() { return GetToken(plsqlParser.RETURN, 0); }
		public ITerminalNode UPDATED() { return GetToken(plsqlParser.UPDATED, 0); }
		public ITerminalNode ROWS() { return GetToken(plsqlParser.ROWS, 0); }
		public ITerminalNode ALL() { return GetToken(plsqlParser.ALL, 0); }
		public Return_rows_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_return_rows_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterReturn_rows_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitReturn_rows_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReturn_rows_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Return_rows_clauseContext return_rows_clause() {
		Return_rows_clauseContext _localctx = new Return_rows_clauseContext(_ctx, State);
		EnterRule(_localctx, 388, RULE_return_rows_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3267; Match(RETURN);
			State = 3268;
			_la = _input.La(1);
			if ( !(_la==ALL || _la==UPDATED) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			State = 3269; Match(ROWS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Reference_modelContext : ParserRuleContext {
		public ITerminalNode REFERENCE() { return GetToken(plsqlParser.REFERENCE, 0); }
		public ITerminalNode ON() { return GetToken(plsqlParser.ON, 0); }
		public IReadOnlyList<Cell_reference_optionsContext> cell_reference_options() {
			return GetRuleContexts<Cell_reference_optionsContext>();
		}
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public Cell_reference_optionsContext cell_reference_options(int i) {
			return GetRuleContext<Cell_reference_optionsContext>(i);
		}
		public Reference_model_nameContext reference_model_name() {
			return GetRuleContext<Reference_model_nameContext>(0);
		}
		public Model_column_clausesContext model_column_clauses() {
			return GetRuleContext<Model_column_clausesContext>(0);
		}
		public Reference_modelContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reference_model; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterReference_model(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitReference_model(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReference_model(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Reference_modelContext reference_model() {
		Reference_modelContext _localctx = new Reference_modelContext(_ctx, State);
		EnterRule(_localctx, 390, RULE_reference_model);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3271; Match(REFERENCE);
			State = 3272; reference_model_name();
			State = 3273; Match(ON);
			State = 3274; Match(LEFT_PAREN);
			State = 3275; subquery();
			State = 3276; Match(RIGHT_PAREN);
			State = 3277; model_column_clauses();
			State = 3281;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==IGNORE || _la==KEEP || _la==UNIQUE) {
				{
				{
				State = 3278; cell_reference_options();
				}
				}
				State = 3283;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Main_modelContext : ParserRuleContext {
		public IReadOnlyList<Cell_reference_optionsContext> cell_reference_options() {
			return GetRuleContexts<Cell_reference_optionsContext>();
		}
		public Cell_reference_optionsContext cell_reference_options(int i) {
			return GetRuleContext<Cell_reference_optionsContext>(i);
		}
		public Main_model_nameContext main_model_name() {
			return GetRuleContext<Main_model_nameContext>(0);
		}
		public Model_column_clausesContext model_column_clauses() {
			return GetRuleContext<Model_column_clausesContext>(0);
		}
		public Model_rules_clauseContext model_rules_clause() {
			return GetRuleContext<Model_rules_clauseContext>(0);
		}
		public ITerminalNode MAIN() { return GetToken(plsqlParser.MAIN, 0); }
		public Main_modelContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_main_model; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterMain_model(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitMain_model(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMain_model(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Main_modelContext main_model() {
		Main_modelContext _localctx = new Main_modelContext(_ctx, State);
		EnterRule(_localctx, 392, RULE_main_model);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3286;
			_la = _input.La(1);
			if (_la==MAIN) {
				{
				State = 3284; Match(MAIN);
				State = 3285; main_model_name();
				}
			}

			State = 3288; model_column_clauses();
			State = 3292;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==IGNORE || _la==KEEP || _la==UNIQUE) {
				{
				{
				State = 3289; cell_reference_options();
				}
				}
				State = 3294;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 3295; model_rules_clause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Model_column_clausesContext : ParserRuleContext {
		public ITerminalNode MEASURES() { return GetToken(plsqlParser.MEASURES, 0); }
		public ITerminalNode DIMENSION() { return GetToken(plsqlParser.DIMENSION, 0); }
		public Model_column_listContext model_column_list(int i) {
			return GetRuleContext<Model_column_listContext>(i);
		}
		public IReadOnlyList<Model_column_listContext> model_column_list() {
			return GetRuleContexts<Model_column_listContext>();
		}
		public Model_column_partition_partContext model_column_partition_part() {
			return GetRuleContext<Model_column_partition_partContext>(0);
		}
		public ITerminalNode BY() { return GetToken(plsqlParser.BY, 0); }
		public Model_column_clausesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_model_column_clauses; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterModel_column_clauses(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitModel_column_clauses(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModel_column_clauses(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Model_column_clausesContext model_column_clauses() {
		Model_column_clausesContext _localctx = new Model_column_clausesContext(_ctx, State);
		EnterRule(_localctx, 394, RULE_model_column_clauses);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3298;
			_la = _input.La(1);
			if (_la==PARTITION) {
				{
				State = 3297; model_column_partition_part();
				}
			}

			State = 3300; Match(DIMENSION);
			State = 3301; Match(BY);
			State = 3302; model_column_list();
			State = 3303; Match(MEASURES);
			State = 3304; model_column_list();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Model_column_partition_partContext : ParserRuleContext {
		public ITerminalNode PARTITION() { return GetToken(plsqlParser.PARTITION, 0); }
		public Model_column_listContext model_column_list() {
			return GetRuleContext<Model_column_listContext>(0);
		}
		public ITerminalNode BY() { return GetToken(plsqlParser.BY, 0); }
		public Model_column_partition_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_model_column_partition_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterModel_column_partition_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitModel_column_partition_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModel_column_partition_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Model_column_partition_partContext model_column_partition_part() {
		Model_column_partition_partContext _localctx = new Model_column_partition_partContext(_ctx, State);
		EnterRule(_localctx, 396, RULE_model_column_partition_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3306; Match(PARTITION);
			State = 3307; Match(BY);
			State = 3308; model_column_list();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Model_column_listContext : ParserRuleContext {
		public Model_columnContext model_column(int i) {
			return GetRuleContext<Model_columnContext>(i);
		}
		public IReadOnlyList<Model_columnContext> model_column() {
			return GetRuleContexts<Model_columnContext>();
		}
		public Model_column_listContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_model_column_list; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterModel_column_list(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitModel_column_list(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModel_column_list(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Model_column_listContext model_column_list() {
		Model_column_listContext _localctx = new Model_column_listContext(_ctx, State);
		EnterRule(_localctx, 398, RULE_model_column_list);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3310; Match(LEFT_PAREN);
			State = 3311; model_column();
			State = 3316;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 3312; Match(COMMA);
				State = 3313; model_column();
				}
				}
				State = 3318;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 3319; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Model_columnContext : ParserRuleContext {
		public Query_blockContext query_block() {
			return GetRuleContext<Query_blockContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Column_aliasContext column_alias() {
			return GetRuleContext<Column_aliasContext>(0);
		}
		public Model_columnContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_model_column; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterModel_column(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitModel_column(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModel_column(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Model_columnContext model_column() {
		Model_columnContext _localctx = new Model_columnContext(_ctx, State);
		EnterRule(_localctx, 400, RULE_model_column);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3323;
			switch (_input.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALL:
			case ANALYZE:
			case ANY:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CASE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COALESCE:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DISTINCT:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FALSE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NOT:
			case NULL:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIOR:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUE:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case DECODE:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case NVL:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROUND:
			case ROW_NUMBER:
			case SUBSTR:
			case TO_CHAR:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case NATIONAL_CHAR_STRING_LIT:
			case UNSIGNED_INTEGER:
			case APPROXIMATE_NUM_LIT:
			case CHAR_STRING:
			case DELIMITED_ID:
			case LEFT_PAREN:
			case PLUS_SIGN:
			case MINUS_SIGN:
			case BINDVAR:
			case COLON:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 3321; expression();
				}
				break;
			case SELECT:
				{
				State = 3322; query_block();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3326;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << AS) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (CONSTANT - 66)) | (1L << (CONSTRAINT - 66)) | (1L << (CONSTRAINTS - 66)) | (1L << (CONSTRUCTOR - 66)) | (1L << (CONTENT - 66)) | (1L << (CONTEXT - 66)) | (1L << (CONTINUE - 66)) | (1L << (CONVERT - 66)) | (1L << (CORRUPT_XID - 66)) | (1L << (CORRUPT_XID_ALL - 66)) | (1L << (COST - 66)) | (1L << (COUNT - 66)) | (1L << (CROSS - 66)) | (1L << (CUBE - 66)) | (1L << (CURRENT_USER - 66)) | (1L << (CURSOR - 66)) | (1L << (CUSTOMDATUM - 66)) | (1L << (CYCLE - 66)) | (1L << (DATA - 66)) | (1L << (DATABASE - 66)) | (1L << (DAY - 66)) | (1L << (DB_ROLE_CHANGE - 66)) | (1L << (DBTIMEZONE - 66)) | (1L << (DDL - 66)) | (1L << (DEBUG - 66)) | (1L << (DEC - 66)) | (1L << (DECIMAL - 66)) | (1L << (DECOMPOSE - 66)) | (1L << (DECREMENT - 66)) | (1L << (DEFAULTS - 66)) | (1L << (DEFERRED - 66)) | (1L << (DEFINER - 66)) | (1L << (DETERMINISTIC - 66)) | (1L << (DIMENSION - 66)) | (1L << (DISABLE - 66)) | (1L << (DISASSOCIATE - 66)) | (1L << (DOCUMENT - 66)) | (1L << (DOUBLE - 66)) | (1L << (DSINTERVAL_UNCONSTRAINED - 66)) | (1L << (EACH - 66)) | (1L << (ELEMENT - 66)) | (1L << (EMPTY - 66)) | (1L << (ENABLE - 66)) | (1L << (ENCODING - 66)) | (1L << (ENTITYESCAPING - 66)) | (1L << (ERR - 66)) | (1L << (ERRORS - 66)) | (1L << (ESCAPE - 66)) | (1L << (EVALNAME - 66)) | (1L << (EXCEPTION - 66)) | (1L << (EXCEPTION_INIT - 66)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)) | (1L << (EXIT - 130)) | (1L << (EXPLAIN - 130)) | (1L << (EXTERNAL - 130)) | (1L << (EXTRACT - 130)) | (1L << (FAILURE - 130)) | (1L << (FINAL - 130)) | (1L << (FIRST - 130)) | (1L << (FIRST_VALUE - 130)) | (1L << (FLOAT - 130)) | (1L << (FOLLOWING - 130)) | (1L << (FOLLOWS - 130)) | (1L << (FORALL - 130)) | (1L << (FORCE - 130)) | (1L << (FULL - 130)) | (1L << (FUNCTION - 130)) | (1L << (GROUPING - 130)) | (1L << (HASH - 130)) | (1L << (HIDE - 130)) | (1L << (HOUR - 130)) | (1L << (IGNORE - 130)) | (1L << (IMMEDIATE - 130)) | (1L << (INCLUDE - 130)) | (1L << (INCLUDING - 130)) | (1L << (INCREMENT - 130)) | (1L << (INDENT - 130)) | (1L << (INDEXED - 130)) | (1L << (INDICATOR - 130)) | (1L << (INDICES - 130)) | (1L << (INFINITE - 130)) | (1L << (INLINE - 130)) | (1L << (INNER - 130)) | (1L << (INOUT - 130)) | (1L << (INSTANTIABLE - 130)) | (1L << (INSTEAD - 130)) | (1L << (INT - 130)) | (1L << (INTEGER - 130)) | (1L << (INTERVAL - 130)) | (1L << (INVALIDATE - 130)) | (1L << (ISOLATION - 130)) | (1L << (ITERATE - 130)) | (1L << (JAVA - 130)) | (1L << (JOIN - 130)) | (1L << (KEEP - 130)) | (1L << (LANGUAGE - 130)))) != 0) || ((((_la - 194)) & ~0x3f) == 0 && ((1L << (_la - 194)) & ((1L << (LAST - 194)) | (1L << (LAST_VALUE - 194)) | (1L << (LEADING - 194)) | (1L << (LEFT - 194)) | (1L << (LEVEL - 194)) | (1L << (LIBRARY - 194)) | (1L << (LIKE2 - 194)) | (1L << (LIKE4 - 194)) | (1L << (LIKEC - 194)) | (1L << (LIMIT - 194)) | (1L << (LOCAL - 194)) | (1L << (LOCKED - 194)) | (1L << (LOG - 194)) | (1L << (LOGOFF - 194)) | (1L << (LOGON - 194)) | (1L << (LONG - 194)) | (1L << (LOOP - 194)) | (1L << (MAIN - 194)) | (1L << (MAP - 194)) | (1L << (MATCHED - 194)) | (1L << (MAXVALUE - 194)) | (1L << (MEASURES - 194)) | (1L << (MEMBER - 194)) | (1L << (MERGE - 194)) | (1L << (MINUTE - 194)) | (1L << (MINVALUE - 194)) | (1L << (MLSLABEL - 194)) | (1L << (MODEL - 194)) | (1L << (MODIFY - 194)) | (1L << (MONTH - 194)) | (1L << (MULTISET - 194)) | (1L << (NAME - 194)) | (1L << (NAN - 194)) | (1L << (NATURAL - 194)) | (1L << (NATURALN - 194)) | (1L << (NAV - 194)) | (1L << (NCHAR - 194)) | (1L << (NCHAR_CS - 194)) | (1L << (NCLOB - 194)) | (1L << (NESTED - 194)) | (1L << (NEW - 194)) | (1L << (NO - 194)) | (1L << (NOAUDIT - 194)) | (1L << (NOCOPY - 194)) | (1L << (NOCYCLE - 194)) | (1L << (NOENTITYESCAPING - 194)) | (1L << (NONE - 194)) | (1L << (NOSCHEMACHECK - 194)) | (1L << (NULLS - 194)) | (1L << (NUMBER - 194)) | (1L << (NUMERIC - 194)) | (1L << (NVARCHAR2 - 194)) | (1L << (OBJECT - 194)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (OFF - 259)) | (1L << (OID - 259)) | (1L << (OLD - 259)) | (1L << (ONLY - 259)) | (1L << (OPEN - 259)) | (1L << (ORADATA - 259)) | (1L << (ORDINALITY - 259)) | (1L << (OSERROR - 259)) | (1L << (OUT - 259)) | (1L << (OUTER - 259)) | (1L << (OVER - 259)) | (1L << (OVERRIDING - 259)) | (1L << (PACKAGE - 259)) | (1L << (PARALLEL_ENABLE - 259)) | (1L << (PARAMETERS - 259)) | (1L << (PARENT - 259)) | (1L << (PARTITION - 259)) | (1L << (PASSING - 259)) | (1L << (PATH - 259)) | (1L << (PIPELINED - 259)) | (1L << (PLAN - 259)) | (1L << (PLS_INTEGER - 259)) | (1L << (POSITIVE - 259)) | (1L << (POSITIVEN - 259)) | (1L << (PRAGMA - 259)) | (1L << (PRECEDING - 259)) | (1L << (PRECISION - 259)) | (1L << (PRESENT - 259)) | (1L << (RAISE - 259)) | (1L << (RANGE - 259)) | (1L << (RAW - 259)) | (1L << (READ - 259)) | (1L << (REAL - 259)) | (1L << (RECORD - 259)) | (1L << (REF - 259)) | (1L << (REFERENCE - 259)) | (1L << (REFERENCING - 259)) | (1L << (REJECT - 259)) | (1L << (RELIES_ON - 259)) | (1L << (RENAME - 259)) | (1L << (REPLACE - 259)) | (1L << (RESPECT - 259)) | (1L << (RESTRICT_REFERENCES - 259)) | (1L << (RESULT - 259)) | (1L << (RESULT_CACHE - 259)) | (1L << (RETURN - 259)) | (1L << (RETURNING - 259)) | (1L << (REUSE - 259)) | (1L << (REVERSE - 259)) | (1L << (RIGHT - 259)))) != 0) || ((((_la - 323)) & ~0x3f) == 0 && ((1L << (_la - 323)) & ((1L << (ROLLBACK - 323)) | (1L << (ROLLUP - 323)) | (1L << (ROW - 323)) | (1L << (ROWID - 323)) | (1L << (ROWS - 323)) | (1L << (RULES - 323)) | (1L << (SAMPLE - 323)) | (1L << (SAVE - 323)) | (1L << (SAVEPOINT - 323)) | (1L << (SCHEMA - 323)) | (1L << (SCHEMACHECK - 323)) | (1L << (SCN - 323)) | (1L << (SECOND - 323)) | (1L << (SEED - 323)) | (1L << (SEGMENT - 323)) | (1L << (SELF - 323)) | (1L << (SEQUENTIAL - 323)) | (1L << (SERIALIZABLE - 323)) | (1L << (SERIALLY_REUSABLE - 323)) | (1L << (SERVERERROR - 323)) | (1L << (SESSIONTIMEZONE - 323)) | (1L << (SET - 323)) | (1L << (SETS - 323)) | (1L << (SETTINGS - 323)) | (1L << (SHOW - 323)) | (1L << (SHUTDOWN - 323)) | (1L << (SIBLINGS - 323)) | (1L << (SIGNTYPE - 323)) | (1L << (SIMPLE_INTEGER - 323)) | (1L << (SINGLE - 323)) | (1L << (SKIP_ - 323)) | (1L << (SMALLINT - 323)) | (1L << (SNAPSHOT - 323)) | (1L << (SOME - 323)) | (1L << (SPECIFICATION - 323)) | (1L << (SQLDATA - 323)) | (1L << (SQLERROR - 323)) | (1L << (STANDALONE - 323)) | (1L << (STARTUP - 323)) | (1L << (STATEMENT - 323)) | (1L << (STATEMENT_ID - 323)) | (1L << (STATIC - 323)) | (1L << (STATISTICS - 323)) | (1L << (STRING - 323)) | (1L << (SUBMULTISET - 323)) | (1L << (SUBPARTITION - 323)) | (1L << (SUBSTITUTABLE - 323)) | (1L << (SUBTYPE - 323)) | (1L << (SUCCESS - 323)) | (1L << (SUSPEND - 323)) | (1L << (TIME - 323)) | (1L << (TIMESTAMP - 323)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_UNCONSTRAINED - 323)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TIMEZONE_ABBR - 387)) | (1L << (TIMEZONE_HOUR - 387)) | (1L << (TIMEZONE_MINUTE - 387)) | (1L << (TIMEZONE_REGION - 387)) | (1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (YMINTERVAL_UNCONSTRAINED - 451)) | (1L << (ZONE - 451)) | (1L << (PREDICTION - 451)) | (1L << (PREDICTION_BOUNDS - 451)) | (1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (COVAR_ - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (REGR_ - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (TRIM - 451)) | (1L << (SUM - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (VARIANCE - 451)) | (1L << (NATIONAL_CHAR_STRING_LIT - 451)) | (1L << (CHAR_STRING - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 3325; column_alias();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Model_rules_clauseContext : ParserRuleContext {
		public Model_rules_elementContext model_rules_element(int i) {
			return GetRuleContext<Model_rules_elementContext>(i);
		}
		public IReadOnlyList<Model_rules_elementContext> model_rules_element() {
			return GetRuleContexts<Model_rules_elementContext>();
		}
		public Model_rules_partContext model_rules_part() {
			return GetRuleContext<Model_rules_partContext>(0);
		}
		public Model_rules_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_model_rules_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterModel_rules_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitModel_rules_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModel_rules_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Model_rules_clauseContext model_rules_clause() {
		Model_rules_clauseContext _localctx = new Model_rules_clauseContext(_ctx, State);
		EnterRule(_localctx, 402, RULE_model_rules_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3329;
			_la = _input.La(1);
			if (_la==RULES) {
				{
				State = 3328; model_rules_part();
				}
			}

			State = 3331; Match(LEFT_PAREN);
			State = 3340;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALL) | (1L << ANALYZE) | (1L << ANY) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COALESCE) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & ((1L << (CONNECT_BY_ROOT - 65)) | (1L << (CONSTANT - 65)) | (1L << (CONSTRAINT - 65)) | (1L << (CONSTRAINTS - 65)) | (1L << (CONSTRUCTOR - 65)) | (1L << (CONTENT - 65)) | (1L << (CONTEXT - 65)) | (1L << (CONTINUE - 65)) | (1L << (CONVERT - 65)) | (1L << (CORRUPT_XID - 65)) | (1L << (CORRUPT_XID_ALL - 65)) | (1L << (COST - 65)) | (1L << (COUNT - 65)) | (1L << (CROSS - 65)) | (1L << (CUBE - 65)) | (1L << (CURRENT_USER - 65)) | (1L << (CURSOR - 65)) | (1L << (CUSTOMDATUM - 65)) | (1L << (CYCLE - 65)) | (1L << (DATA - 65)) | (1L << (DATABASE - 65)) | (1L << (DATE - 65)) | (1L << (DAY - 65)) | (1L << (DB_ROLE_CHANGE - 65)) | (1L << (DBTIMEZONE - 65)) | (1L << (DDL - 65)) | (1L << (DEBUG - 65)) | (1L << (DEC - 65)) | (1L << (DECIMAL - 65)) | (1L << (DECOMPOSE - 65)) | (1L << (DECREMENT - 65)) | (1L << (DEFAULT - 65)) | (1L << (DEFAULTS - 65)) | (1L << (DEFERRED - 65)) | (1L << (DEFINER - 65)) | (1L << (DETERMINISTIC - 65)) | (1L << (DIMENSION - 65)) | (1L << (DISABLE - 65)) | (1L << (DISASSOCIATE - 65)) | (1L << (DISTINCT - 65)) | (1L << (DOCUMENT - 65)) | (1L << (DOUBLE - 65)) | (1L << (DSINTERVAL_UNCONSTRAINED - 65)) | (1L << (EACH - 65)) | (1L << (ELEMENT - 65)) | (1L << (EMPTY - 65)) | (1L << (ENABLE - 65)) | (1L << (ENCODING - 65)) | (1L << (ENTITYESCAPING - 65)) | (1L << (ERR - 65)) | (1L << (ERRORS - 65)) | (1L << (ESCAPE - 65)) | (1L << (EVALNAME - 65)) | (1L << (EXCEPTION - 65)))) != 0) || ((((_la - 129)) & ~0x3f) == 0 && ((1L << (_la - 129)) & ((1L << (EXCEPTION_INIT - 129)) | (1L << (EXCEPTIONS - 129)) | (1L << (EXCLUDE - 129)) | (1L << (EXECUTE - 129)) | (1L << (EXISTS - 129)) | (1L << (EXIT - 129)) | (1L << (EXPLAIN - 129)) | (1L << (EXTERNAL - 129)) | (1L << (EXTRACT - 129)) | (1L << (FAILURE - 129)) | (1L << (FALSE - 129)) | (1L << (FINAL - 129)) | (1L << (FIRST - 129)) | (1L << (FIRST_VALUE - 129)) | (1L << (FLOAT - 129)) | (1L << (FOLLOWING - 129)) | (1L << (FOLLOWS - 129)) | (1L << (FORALL - 129)) | (1L << (FORCE - 129)) | (1L << (FULL - 129)) | (1L << (FUNCTION - 129)) | (1L << (GROUPING - 129)) | (1L << (HASH - 129)) | (1L << (HIDE - 129)) | (1L << (HOUR - 129)) | (1L << (IGNORE - 129)) | (1L << (IMMEDIATE - 129)) | (1L << (INCLUDE - 129)) | (1L << (INCLUDING - 129)) | (1L << (INCREMENT - 129)) | (1L << (INDENT - 129)) | (1L << (INDEXED - 129)) | (1L << (INDICATOR - 129)) | (1L << (INDICES - 129)) | (1L << (INFINITE - 129)) | (1L << (INLINE - 129)) | (1L << (INNER - 129)) | (1L << (INOUT - 129)) | (1L << (INSTANTIABLE - 129)) | (1L << (INSTEAD - 129)) | (1L << (INT - 129)) | (1L << (INTEGER - 129)) | (1L << (INTERVAL - 129)) | (1L << (INVALIDATE - 129)) | (1L << (ISOLATION - 129)) | (1L << (ITERATE - 129)) | (1L << (JAVA - 129)) | (1L << (JOIN - 129)) | (1L << (KEEP - 129)))) != 0) || ((((_la - 193)) & ~0x3f) == 0 && ((1L << (_la - 193)) & ((1L << (LANGUAGE - 193)) | (1L << (LAST - 193)) | (1L << (LAST_VALUE - 193)) | (1L << (LEADING - 193)) | (1L << (LEFT - 193)) | (1L << (LEVEL - 193)) | (1L << (LIBRARY - 193)) | (1L << (LIKE2 - 193)) | (1L << (LIKE4 - 193)) | (1L << (LIKEC - 193)) | (1L << (LIMIT - 193)) | (1L << (LOCAL - 193)) | (1L << (LOCKED - 193)) | (1L << (LOG - 193)) | (1L << (LOGOFF - 193)) | (1L << (LOGON - 193)) | (1L << (LONG - 193)) | (1L << (LOOP - 193)) | (1L << (MAIN - 193)) | (1L << (MAP - 193)) | (1L << (MATCHED - 193)) | (1L << (MAXVALUE - 193)) | (1L << (MEASURES - 193)) | (1L << (MEMBER - 193)) | (1L << (MERGE - 193)) | (1L << (MINUTE - 193)) | (1L << (MINVALUE - 193)) | (1L << (MLSLABEL - 193)) | (1L << (MODEL - 193)) | (1L << (MODIFY - 193)) | (1L << (MONTH - 193)) | (1L << (MULTISET - 193)) | (1L << (NAME - 193)) | (1L << (NAN - 193)) | (1L << (NATURAL - 193)) | (1L << (NATURALN - 193)) | (1L << (NAV - 193)) | (1L << (NCHAR - 193)) | (1L << (NCHAR_CS - 193)) | (1L << (NCLOB - 193)) | (1L << (NESTED - 193)) | (1L << (NEW - 193)) | (1L << (NO - 193)) | (1L << (NOAUDIT - 193)) | (1L << (NOCOPY - 193)) | (1L << (NOCYCLE - 193)) | (1L << (NOENTITYESCAPING - 193)) | (1L << (NONE - 193)) | (1L << (NOSCHEMACHECK - 193)) | (1L << (NULL - 193)) | (1L << (NULLS - 193)) | (1L << (NUMBER - 193)) | (1L << (NUMERIC - 193)) | (1L << (NVARCHAR2 - 193)))) != 0) || ((((_la - 257)) & ~0x3f) == 0 && ((1L << (_la - 257)) & ((1L << (OBJECT - 257)) | (1L << (OFF - 257)) | (1L << (OID - 257)) | (1L << (OLD - 257)) | (1L << (ONLY - 257)) | (1L << (OPEN - 257)) | (1L << (ORADATA - 257)) | (1L << (ORDINALITY - 257)) | (1L << (OSERROR - 257)) | (1L << (OUT - 257)) | (1L << (OUTER - 257)) | (1L << (OVER - 257)) | (1L << (OVERRIDING - 257)) | (1L << (PACKAGE - 257)) | (1L << (PARALLEL_ENABLE - 257)) | (1L << (PARAMETERS - 257)) | (1L << (PARENT - 257)) | (1L << (PARTITION - 257)) | (1L << (PASSING - 257)) | (1L << (PATH - 257)) | (1L << (PIPELINED - 257)) | (1L << (PLAN - 257)) | (1L << (PLS_INTEGER - 257)) | (1L << (POSITIVE - 257)) | (1L << (POSITIVEN - 257)) | (1L << (PRAGMA - 257)) | (1L << (PRECEDING - 257)) | (1L << (PRECISION - 257)) | (1L << (PRESENT - 257)) | (1L << (PRIOR - 257)) | (1L << (RAISE - 257)) | (1L << (RANGE - 257)) | (1L << (RAW - 257)) | (1L << (READ - 257)) | (1L << (REAL - 257)) | (1L << (RECORD - 257)) | (1L << (REF - 257)) | (1L << (REFERENCE - 257)) | (1L << (REFERENCING - 257)) | (1L << (REJECT - 257)) | (1L << (RELIES_ON - 257)) | (1L << (RENAME - 257)) | (1L << (REPLACE - 257)) | (1L << (RESPECT - 257)) | (1L << (RESTRICT_REFERENCES - 257)) | (1L << (RESULT - 257)) | (1L << (RESULT_CACHE - 257)) | (1L << (RETURN - 257)) | (1L << (RETURNING - 257)) | (1L << (REUSE - 257)) | (1L << (REVERSE - 257)))) != 0) || ((((_la - 322)) & ~0x3f) == 0 && ((1L << (_la - 322)) & ((1L << (RIGHT - 322)) | (1L << (ROLLBACK - 322)) | (1L << (ROLLUP - 322)) | (1L << (ROW - 322)) | (1L << (ROWID - 322)) | (1L << (ROWS - 322)) | (1L << (RULES - 322)) | (1L << (SAMPLE - 322)) | (1L << (SAVE - 322)) | (1L << (SAVEPOINT - 322)) | (1L << (SCHEMA - 322)) | (1L << (SCHEMACHECK - 322)) | (1L << (SCN - 322)) | (1L << (SECOND - 322)) | (1L << (SEED - 322)) | (1L << (SEGMENT - 322)) | (1L << (SELF - 322)) | (1L << (SEQUENTIAL - 322)) | (1L << (SERIALIZABLE - 322)) | (1L << (SERIALLY_REUSABLE - 322)) | (1L << (SERVERERROR - 322)) | (1L << (SESSIONTIMEZONE - 322)) | (1L << (SET - 322)) | (1L << (SETS - 322)) | (1L << (SETTINGS - 322)) | (1L << (SHOW - 322)) | (1L << (SHUTDOWN - 322)) | (1L << (SIBLINGS - 322)) | (1L << (SIGNTYPE - 322)) | (1L << (SIMPLE_INTEGER - 322)) | (1L << (SINGLE - 322)) | (1L << (SKIP_ - 322)) | (1L << (SMALLINT - 322)) | (1L << (SNAPSHOT - 322)) | (1L << (SOME - 322)) | (1L << (SPECIFICATION - 322)) | (1L << (SQLDATA - 322)) | (1L << (SQLERROR - 322)) | (1L << (STANDALONE - 322)) | (1L << (STARTUP - 322)) | (1L << (STATEMENT - 322)) | (1L << (STATEMENT_ID - 322)) | (1L << (STATIC - 322)) | (1L << (STATISTICS - 322)) | (1L << (STRING - 322)) | (1L << (SUBMULTISET - 322)) | (1L << (SUBPARTITION - 322)) | (1L << (SUBSTITUTABLE - 322)) | (1L << (SUBTYPE - 322)) | (1L << (SUCCESS - 322)) | (1L << (SUSPEND - 322)) | (1L << (TIME - 322)) | (1L << (TIMESTAMP - 322)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 322)))) != 0) || ((((_la - 386)) & ~0x3f) == 0 && ((1L << (_la - 386)) & ((1L << (TIMESTAMP_UNCONSTRAINED - 386)) | (1L << (TIMEZONE_ABBR - 386)) | (1L << (TIMEZONE_HOUR - 386)) | (1L << (TIMEZONE_MINUTE - 386)) | (1L << (TIMEZONE_REGION - 386)) | (1L << (TRAILING - 386)) | (1L << (TRANSACTION - 386)) | (1L << (TRANSLATE - 386)) | (1L << (TREAT - 386)) | (1L << (TRIGGER - 386)) | (1L << (TRUE - 386)) | (1L << (TRUNCATE - 386)) | (1L << (TYPE - 386)) | (1L << (UNBOUNDED - 386)) | (1L << (UNDER - 386)) | (1L << (UNLIMITED - 386)) | (1L << (UNTIL - 386)) | (1L << (UPDATE - 386)) | (1L << (UPDATED - 386)) | (1L << (UPSERT - 386)) | (1L << (UROWID - 386)) | (1L << (USE - 386)) | (1L << (VALIDATE - 386)) | (1L << (VALUE - 386)) | (1L << (VARCHAR - 386)) | (1L << (VARCHAR2 - 386)) | (1L << (VARIABLE - 386)) | (1L << (VARRAY - 386)) | (1L << (VARYING - 386)) | (1L << (VERSION - 386)) | (1L << (VERSIONS - 386)) | (1L << (WAIT - 386)) | (1L << (WARNING - 386)) | (1L << (WELLFORMED - 386)) | (1L << (WHENEVER - 386)) | (1L << (WHILE - 386)) | (1L << (WITHIN - 386)) | (1L << (WORK - 386)) | (1L << (WRITE - 386)) | (1L << (XML - 386)) | (1L << (XMLAGG - 386)) | (1L << (XMLATTRIBUTES - 386)) | (1L << (XMLCAST - 386)) | (1L << (XMLCOLATTVAL - 386)) | (1L << (XMLELEMENT - 386)) | (1L << (XMLEXISTS - 386)) | (1L << (XMLFOREST - 386)) | (1L << (XMLNAMESPACES - 386)) | (1L << (XMLPARSE - 386)) | (1L << (XMLPI - 386)) | (1L << (XMLQUERY - 386)) | (1L << (XMLROOT - 386)) | (1L << (XMLSERIALIZE - 386)) | (1L << (XMLTABLE - 386)) | (1L << (YEAR - 386)))) != 0) || ((((_la - 450)) & ~0x3f) == 0 && ((1L << (_la - 450)) & ((1L << (YES - 450)) | (1L << (YMINTERVAL_UNCONSTRAINED - 450)) | (1L << (ZONE - 450)) | (1L << (PREDICTION - 450)) | (1L << (PREDICTION_BOUNDS - 450)) | (1L << (PREDICTION_COST - 450)) | (1L << (PREDICTION_DETAILS - 450)) | (1L << (PREDICTION_PROBABILITY - 450)) | (1L << (PREDICTION_SET - 450)) | (1L << (CUME_DIST - 450)) | (1L << (DENSE_RANK - 450)) | (1L << (LISTAGG - 450)) | (1L << (PERCENT_RANK - 450)) | (1L << (PERCENTILE_CONT - 450)) | (1L << (PERCENTILE_DISC - 450)) | (1L << (RANK - 450)) | (1L << (AVG - 450)) | (1L << (CORR - 450)) | (1L << (COVAR_ - 450)) | (1L << (DECODE - 450)) | (1L << (LAG - 450)) | (1L << (LEAD - 450)) | (1L << (MAX - 450)) | (1L << (MEDIAN - 450)) | (1L << (MIN - 450)) | (1L << (NTILE - 450)) | (1L << (NVL - 450)) | (1L << (RATIO_TO_REPORT - 450)) | (1L << (REGR_ - 450)) | (1L << (ROUND - 450)) | (1L << (ROW_NUMBER - 450)) | (1L << (SUBSTR - 450)) | (1L << (TO_CHAR - 450)) | (1L << (TRIM - 450)) | (1L << (SUM - 450)) | (1L << (STDDEV - 450)) | (1L << (VAR_ - 450)) | (1L << (VARIANCE - 450)) | (1L << (NATIONAL_CHAR_STRING_LIT - 450)) | (1L << (UNSIGNED_INTEGER - 450)) | (1L << (APPROXIMATE_NUM_LIT - 450)) | (1L << (CHAR_STRING - 450)) | (1L << (DELIMITED_ID - 450)) | (1L << (LEFT_PAREN - 450)) | (1L << (PLUS_SIGN - 450)) | (1L << (MINUS_SIGN - 450)) | (1L << (BINDVAR - 450)) | (1L << (COLON - 450)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 3332; model_rules_element();
				State = 3337;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 3333; Match(COMMA);
					State = 3334; model_rules_element();
					}
					}
					State = 3339;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
			}

			State = 3342; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Model_rules_partContext : ParserRuleContext {
		public ITerminalNode RULES() { return GetToken(plsqlParser.RULES, 0); }
		public ITerminalNode UPDATE() { return GetToken(plsqlParser.UPDATE, 0); }
		public ITerminalNode SEQUENTIAL() { return GetToken(plsqlParser.SEQUENTIAL, 0); }
		public ITerminalNode ORDER() { return GetToken(plsqlParser.ORDER, 0); }
		public Model_iterate_clauseContext model_iterate_clause() {
			return GetRuleContext<Model_iterate_clauseContext>(0);
		}
		public ITerminalNode AUTOMATIC() { return GetToken(plsqlParser.AUTOMATIC, 0); }
		public ITerminalNode UPSERT() { return GetToken(plsqlParser.UPSERT, 0); }
		public ITerminalNode ALL() { return GetToken(plsqlParser.ALL, 0); }
		public Model_rules_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_model_rules_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterModel_rules_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitModel_rules_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModel_rules_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Model_rules_partContext model_rules_part() {
		Model_rules_partContext _localctx = new Model_rules_partContext(_ctx, State);
		EnterRule(_localctx, 404, RULE_model_rules_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3344; Match(RULES);
			State = 3350;
			switch (_input.La(1)) {
			case UPDATE:
				{
				State = 3345; Match(UPDATE);
				}
				break;
			case UPSERT:
				{
				State = 3346; Match(UPSERT);
				State = 3348;
				_la = _input.La(1);
				if (_la==ALL) {
					{
					State = 3347; Match(ALL);
					}
				}

				}
				break;
			case AUTOMATIC:
			case ITERATE:
			case SEQUENTIAL:
			case LEFT_PAREN:
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3354;
			_la = _input.La(1);
			if (_la==AUTOMATIC || _la==SEQUENTIAL) {
				{
				State = 3352;
				_la = _input.La(1);
				if ( !(_la==AUTOMATIC || _la==SEQUENTIAL) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				State = 3353; Match(ORDER);
				}
			}

			State = 3357;
			_la = _input.La(1);
			if (_la==ITERATE) {
				{
				State = 3356; model_iterate_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Model_rules_elementContext : ParserRuleContext {
		public ITerminalNode UPDATE() { return GetToken(plsqlParser.UPDATE, 0); }
		public Order_by_clauseContext order_by_clause() {
			return GetRuleContext<Order_by_clauseContext>(0);
		}
		public Cell_assignmentContext cell_assignment() {
			return GetRuleContext<Cell_assignmentContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode UPSERT() { return GetToken(plsqlParser.UPSERT, 0); }
		public ITerminalNode ALL() { return GetToken(plsqlParser.ALL, 0); }
		public Model_rules_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_model_rules_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterModel_rules_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitModel_rules_element(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModel_rules_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Model_rules_elementContext model_rules_element() {
		Model_rules_elementContext _localctx = new Model_rules_elementContext(_ctx, State);
		EnterRule(_localctx, 406, RULE_model_rules_element);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3364;
			switch ( Interpreter.AdaptivePredict(_input,388,_ctx) ) {
			case 1:
				{
				State = 3359; Match(UPDATE);
				}
				break;

			case 2:
				{
				State = 3360; Match(UPSERT);
				State = 3362;
				switch ( Interpreter.AdaptivePredict(_input,387,_ctx) ) {
				case 1:
					{
					State = 3361; Match(ALL);
					}
					break;
				}
				}
				break;
			}
			State = 3366; cell_assignment();
			State = 3368;
			_la = _input.La(1);
			if (_la==ORDER) {
				{
				State = 3367; order_by_clause();
				}
			}

			State = 3370; Match(EQUALS_OP);
			State = 3371; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cell_assignmentContext : ParserRuleContext {
		public Model_expressionContext model_expression() {
			return GetRuleContext<Model_expressionContext>(0);
		}
		public Cell_assignmentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cell_assignment; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCell_assignment(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCell_assignment(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCell_assignment(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Cell_assignmentContext cell_assignment() {
		Cell_assignmentContext _localctx = new Cell_assignmentContext(_ctx, State);
		EnterRule(_localctx, 408, RULE_cell_assignment);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3373; model_expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Model_iterate_clauseContext : ParserRuleContext {
		public ITerminalNode ITERATE() { return GetToken(plsqlParser.ITERATE, 0); }
		public Until_partContext until_part() {
			return GetRuleContext<Until_partContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Model_iterate_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_model_iterate_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterModel_iterate_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitModel_iterate_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModel_iterate_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Model_iterate_clauseContext model_iterate_clause() {
		Model_iterate_clauseContext _localctx = new Model_iterate_clauseContext(_ctx, State);
		EnterRule(_localctx, 410, RULE_model_iterate_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3375; Match(ITERATE);
			State = 3376; Match(LEFT_PAREN);
			State = 3377; expression();
			State = 3378; Match(RIGHT_PAREN);
			State = 3380;
			_la = _input.La(1);
			if (_la==UNTIL) {
				{
				State = 3379; until_part();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Until_partContext : ParserRuleContext {
		public ITerminalNode UNTIL() { return GetToken(plsqlParser.UNTIL, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public Until_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_until_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterUntil_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitUntil_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUntil_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Until_partContext until_part() {
		Until_partContext _localctx = new Until_partContext(_ctx, State);
		EnterRule(_localctx, 412, RULE_until_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3382; Match(UNTIL);
			State = 3383; Match(LEFT_PAREN);
			State = 3384; condition();
			State = 3385; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Order_by_clauseContext : ParserRuleContext {
		public ITerminalNode ORDER() { return GetToken(plsqlParser.ORDER, 0); }
		public IReadOnlyList<Order_by_elementsContext> order_by_elements() {
			return GetRuleContexts<Order_by_elementsContext>();
		}
		public ITerminalNode SIBLINGS() { return GetToken(plsqlParser.SIBLINGS, 0); }
		public ITerminalNode BY() { return GetToken(plsqlParser.BY, 0); }
		public Order_by_elementsContext order_by_elements(int i) {
			return GetRuleContext<Order_by_elementsContext>(i);
		}
		public Order_by_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_order_by_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterOrder_by_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitOrder_by_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOrder_by_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Order_by_clauseContext order_by_clause() {
		Order_by_clauseContext _localctx = new Order_by_clauseContext(_ctx, State);
		EnterRule(_localctx, 414, RULE_order_by_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3387; Match(ORDER);
			State = 3389;
			_la = _input.La(1);
			if (_la==SIBLINGS) {
				{
				State = 3388; Match(SIBLINGS);
				}
			}

			State = 3391; Match(BY);
			State = 3392; order_by_elements();
			State = 3397;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 3393; Match(COMMA);
				State = 3394; order_by_elements();
				}
				}
				State = 3399;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Order_by_elementsContext : ParserRuleContext {
		public ITerminalNode ASC() { return GetToken(plsqlParser.ASC, 0); }
		public ITerminalNode DESC() { return GetToken(plsqlParser.DESC, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode NULLS() { return GetToken(plsqlParser.NULLS, 0); }
		public ITerminalNode FIRST() { return GetToken(plsqlParser.FIRST, 0); }
		public ITerminalNode LAST() { return GetToken(plsqlParser.LAST, 0); }
		public Order_by_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_order_by_elements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterOrder_by_elements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitOrder_by_elements(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOrder_by_elements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Order_by_elementsContext order_by_elements() {
		Order_by_elementsContext _localctx = new Order_by_elementsContext(_ctx, State);
		EnterRule(_localctx, 416, RULE_order_by_elements);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3400; expression();
			State = 3402;
			_la = _input.La(1);
			if (_la==ASC || _la==DESC) {
				{
				State = 3401;
				_la = _input.La(1);
				if ( !(_la==ASC || _la==DESC) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				}
			}

			State = 3406;
			_la = _input.La(1);
			if (_la==NULLS) {
				{
				State = 3404; Match(NULLS);
				State = 3405;
				_la = _input.La(1);
				if ( !(_la==FIRST || _la==LAST) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class For_update_clauseContext : ParserRuleContext {
		public ITerminalNode UPDATE() { return GetToken(plsqlParser.UPDATE, 0); }
		public ITerminalNode FOR() { return GetToken(plsqlParser.FOR, 0); }
		public For_update_optionsContext for_update_options() {
			return GetRuleContext<For_update_optionsContext>(0);
		}
		public For_update_of_partContext for_update_of_part() {
			return GetRuleContext<For_update_of_partContext>(0);
		}
		public For_update_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_for_update_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterFor_update_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitFor_update_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFor_update_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public For_update_clauseContext for_update_clause() {
		For_update_clauseContext _localctx = new For_update_clauseContext(_ctx, State);
		EnterRule(_localctx, 418, RULE_for_update_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3408; Match(FOR);
			State = 3409; Match(UPDATE);
			State = 3411;
			_la = _input.La(1);
			if (_la==OF) {
				{
				State = 3410; for_update_of_part();
				}
			}

			State = 3414;
			_la = _input.La(1);
			if (_la==NOWAIT || _la==SKIP_ || _la==WAIT) {
				{
				State = 3413; for_update_options();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class For_update_of_partContext : ParserRuleContext {
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public IReadOnlyList<Column_nameContext> column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public ITerminalNode OF() { return GetToken(plsqlParser.OF, 0); }
		public For_update_of_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_for_update_of_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterFor_update_of_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitFor_update_of_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFor_update_of_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public For_update_of_partContext for_update_of_part() {
		For_update_of_partContext _localctx = new For_update_of_partContext(_ctx, State);
		EnterRule(_localctx, 420, RULE_for_update_of_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3416; Match(OF);
			State = 3417; column_name();
			State = 3422;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 3418; Match(COMMA);
				State = 3419; column_name();
				}
				}
				State = 3424;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class For_update_optionsContext : ParserRuleContext {
		public ITerminalNode SKIP_() { return GetToken(plsqlParser.SKIP_, 0); }
		public ITerminalNode LOCKED() { return GetToken(plsqlParser.LOCKED, 0); }
		public ITerminalNode NOWAIT() { return GetToken(plsqlParser.NOWAIT, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode WAIT() { return GetToken(plsqlParser.WAIT, 0); }
		public For_update_optionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_for_update_options; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterFor_update_options(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitFor_update_options(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFor_update_options(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public For_update_optionsContext for_update_options() {
		For_update_optionsContext _localctx = new For_update_optionsContext(_ctx, State);
		EnterRule(_localctx, 422, RULE_for_update_options);
		try {
			State = 3430;
			switch (_input.La(1)) {
			case SKIP_:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3425; Match(SKIP_);
				State = 3426; Match(LOCKED);
				}
				break;
			case NOWAIT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3427; Match(NOWAIT);
				}
				break;
			case WAIT:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3428; Match(WAIT);
				State = 3429; expression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Update_statementContext : ParserRuleContext {
		public General_table_refContext general_table_ref() {
			return GetRuleContext<General_table_refContext>(0);
		}
		public Static_returning_clauseContext static_returning_clause() {
			return GetRuleContext<Static_returning_clauseContext>(0);
		}
		public ITerminalNode UPDATE() { return GetToken(plsqlParser.UPDATE, 0); }
		public Where_clauseContext where_clause() {
			return GetRuleContext<Where_clauseContext>(0);
		}
		public Update_set_clauseContext update_set_clause() {
			return GetRuleContext<Update_set_clauseContext>(0);
		}
		public Error_logging_clauseContext error_logging_clause() {
			return GetRuleContext<Error_logging_clauseContext>(0);
		}
		public Update_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_update_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterUpdate_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitUpdate_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUpdate_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Update_statementContext update_statement() {
		Update_statementContext _localctx = new Update_statementContext(_ctx, State);
		EnterRule(_localctx, 424, RULE_update_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3432; Match(UPDATE);
			State = 3433; general_table_ref();
			State = 3434; update_set_clause();
			State = 3436;
			_la = _input.La(1);
			if (_la==WHERE) {
				{
				State = 3435; where_clause();
				}
			}

			State = 3439;
			_la = _input.La(1);
			if (_la==RETURN || _la==RETURNING) {
				{
				State = 3438; static_returning_clause();
				}
			}

			State = 3442;
			_la = _input.La(1);
			if (_la==LOG) {
				{
				State = 3441; error_logging_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Update_set_clauseContext : ParserRuleContext {
		public Column_based_update_set_clauseContext column_based_update_set_clause(int i) {
			return GetRuleContext<Column_based_update_set_clauseContext>(i);
		}
		public IReadOnlyList<Column_based_update_set_clauseContext> column_based_update_set_clause() {
			return GetRuleContexts<Column_based_update_set_clauseContext>();
		}
		public ITerminalNode VALUE() { return GetToken(plsqlParser.VALUE, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode SET() { return GetToken(plsqlParser.SET, 0); }
		public Update_set_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_update_set_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterUpdate_set_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitUpdate_set_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUpdate_set_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Update_set_clauseContext update_set_clause() {
		Update_set_clauseContext _localctx = new Update_set_clauseContext(_ctx, State);
		EnterRule(_localctx, 426, RULE_update_set_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3444; Match(SET);
			State = 3460;
			switch ( Interpreter.AdaptivePredict(_input,403,_ctx) ) {
			case 1:
				{
				State = 3445; column_based_update_set_clause();
				State = 3450;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 3446; Match(COMMA);
					State = 3447; column_based_update_set_clause();
					}
					}
					State = 3452;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
				break;

			case 2:
				{
				State = 3453; Match(VALUE);
				State = 3454; Match(LEFT_PAREN);
				State = 3455; identifier();
				State = 3456; Match(RIGHT_PAREN);
				State = 3457; Match(EQUALS_OP);
				State = 3458; expression();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Column_based_update_set_clauseContext : ParserRuleContext {
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public IReadOnlyList<Column_nameContext> column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Column_based_update_set_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_column_based_update_set_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterColumn_based_update_set_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitColumn_based_update_set_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitColumn_based_update_set_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Column_based_update_set_clauseContext column_based_update_set_clause() {
		Column_based_update_set_clauseContext _localctx = new Column_based_update_set_clauseContext(_ctx, State);
		EnterRule(_localctx, 428, RULE_column_based_update_set_clause);
		int _la;
		try {
			State = 3479;
			switch (_input.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROW_NUMBER:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3462; column_name();
				State = 3463; Match(EQUALS_OP);
				State = 3464; expression();
				}
				break;
			case LEFT_PAREN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3466; Match(LEFT_PAREN);
				State = 3467; column_name();
				State = 3472;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 3468; Match(COMMA);
					State = 3469; column_name();
					}
					}
					State = 3474;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 3475; Match(RIGHT_PAREN);
				State = 3476; Match(EQUALS_OP);
				State = 3477; subquery();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Delete_statementContext : ParserRuleContext {
		public General_table_refContext general_table_ref() {
			return GetRuleContext<General_table_refContext>(0);
		}
		public Static_returning_clauseContext static_returning_clause() {
			return GetRuleContext<Static_returning_clauseContext>(0);
		}
		public ITerminalNode DELETE() { return GetToken(plsqlParser.DELETE, 0); }
		public Where_clauseContext where_clause() {
			return GetRuleContext<Where_clauseContext>(0);
		}
		public ITerminalNode FROM() { return GetToken(plsqlParser.FROM, 0); }
		public Error_logging_clauseContext error_logging_clause() {
			return GetRuleContext<Error_logging_clauseContext>(0);
		}
		public Delete_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_delete_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterDelete_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitDelete_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDelete_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Delete_statementContext delete_statement() {
		Delete_statementContext _localctx = new Delete_statementContext(_ctx, State);
		EnterRule(_localctx, 430, RULE_delete_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3481; Match(DELETE);
			State = 3483;
			_la = _input.La(1);
			if (_la==FROM) {
				{
				State = 3482; Match(FROM);
				}
			}

			State = 3485; general_table_ref();
			State = 3487;
			_la = _input.La(1);
			if (_la==WHERE) {
				{
				State = 3486; where_clause();
				}
			}

			State = 3490;
			_la = _input.La(1);
			if (_la==RETURN || _la==RETURNING) {
				{
				State = 3489; static_returning_clause();
				}
			}

			State = 3493;
			_la = _input.La(1);
			if (_la==LOG) {
				{
				State = 3492; error_logging_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Insert_statementContext : ParserRuleContext {
		public Multi_table_insertContext multi_table_insert() {
			return GetRuleContext<Multi_table_insertContext>(0);
		}
		public ITerminalNode INSERT() { return GetToken(plsqlParser.INSERT, 0); }
		public Single_table_insertContext single_table_insert() {
			return GetRuleContext<Single_table_insertContext>(0);
		}
		public Insert_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_insert_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterInsert_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitInsert_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInsert_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Insert_statementContext insert_statement() {
		Insert_statementContext _localctx = new Insert_statementContext(_ctx, State);
		EnterRule(_localctx, 432, RULE_insert_statement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3495; Match(INSERT);
			State = 3498;
			switch (_input.La(1)) {
			case INTO:
				{
				State = 3496; single_table_insert();
				}
				break;
			case ALL:
			case FIRST:
			case WHEN:
				{
				State = 3497; multi_table_insert();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Single_table_insertContext : ParserRuleContext {
		public Static_returning_clauseContext static_returning_clause() {
			return GetRuleContext<Static_returning_clauseContext>(0);
		}
		public Select_statementContext select_statement() {
			return GetRuleContext<Select_statementContext>(0);
		}
		public Values_clauseContext values_clause() {
			return GetRuleContext<Values_clauseContext>(0);
		}
		public Insert_into_clauseContext insert_into_clause() {
			return GetRuleContext<Insert_into_clauseContext>(0);
		}
		public Error_logging_clauseContext error_logging_clause() {
			return GetRuleContext<Error_logging_clauseContext>(0);
		}
		public Single_table_insertContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_single_table_insert; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSingle_table_insert(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSingle_table_insert(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSingle_table_insert(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Single_table_insertContext single_table_insert() {
		Single_table_insertContext _localctx = new Single_table_insertContext(_ctx, State);
		EnterRule(_localctx, 434, RULE_single_table_insert);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3500; insert_into_clause();
			State = 3506;
			switch (_input.La(1)) {
			case VALUES:
				{
				State = 3501; values_clause();
				State = 3503;
				_la = _input.La(1);
				if (_la==RETURN || _la==RETURNING) {
					{
					State = 3502; static_returning_clause();
					}
				}

				}
				break;
			case SELECT:
			case WITH:
			case LEFT_PAREN:
				{
				State = 3505; select_statement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3509;
			_la = _input.La(1);
			if (_la==LOG) {
				{
				State = 3508; error_logging_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Multi_table_insertContext : ParserRuleContext {
		public Select_statementContext select_statement() {
			return GetRuleContext<Select_statementContext>(0);
		}
		public Conditional_insert_clauseContext conditional_insert_clause() {
			return GetRuleContext<Conditional_insert_clauseContext>(0);
		}
		public IReadOnlyList<Multi_table_elementContext> multi_table_element() {
			return GetRuleContexts<Multi_table_elementContext>();
		}
		public Multi_table_elementContext multi_table_element(int i) {
			return GetRuleContext<Multi_table_elementContext>(i);
		}
		public ITerminalNode ALL() { return GetToken(plsqlParser.ALL, 0); }
		public Multi_table_insertContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multi_table_insert; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterMulti_table_insert(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitMulti_table_insert(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMulti_table_insert(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Multi_table_insertContext multi_table_insert() {
		Multi_table_insertContext _localctx = new Multi_table_insertContext(_ctx, State);
		EnterRule(_localctx, 436, RULE_multi_table_insert);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3518;
			switch ( Interpreter.AdaptivePredict(_input,415,_ctx) ) {
			case 1:
				{
				State = 3511; Match(ALL);
				State = 3513;
				_errHandler.Sync(this);
				_la = _input.La(1);
				do {
					{
					{
					State = 3512; multi_table_element();
					}
					}
					State = 3515;
					_errHandler.Sync(this);
					_la = _input.La(1);
				} while ( _la==INTO );
				}
				break;

			case 2:
				{
				State = 3517; conditional_insert_clause();
				}
				break;
			}
			State = 3520; select_statement();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Multi_table_elementContext : ParserRuleContext {
		public Values_clauseContext values_clause() {
			return GetRuleContext<Values_clauseContext>(0);
		}
		public Insert_into_clauseContext insert_into_clause() {
			return GetRuleContext<Insert_into_clauseContext>(0);
		}
		public Error_logging_clauseContext error_logging_clause() {
			return GetRuleContext<Error_logging_clauseContext>(0);
		}
		public Multi_table_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multi_table_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterMulti_table_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitMulti_table_element(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMulti_table_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Multi_table_elementContext multi_table_element() {
		Multi_table_elementContext _localctx = new Multi_table_elementContext(_ctx, State);
		EnterRule(_localctx, 438, RULE_multi_table_element);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3522; insert_into_clause();
			State = 3524;
			_la = _input.La(1);
			if (_la==VALUES) {
				{
				State = 3523; values_clause();
				}
			}

			State = 3527;
			_la = _input.La(1);
			if (_la==LOG) {
				{
				State = 3526; error_logging_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Conditional_insert_clauseContext : ParserRuleContext {
		public IReadOnlyList<Conditional_insert_when_partContext> conditional_insert_when_part() {
			return GetRuleContexts<Conditional_insert_when_partContext>();
		}
		public Conditional_insert_when_partContext conditional_insert_when_part(int i) {
			return GetRuleContext<Conditional_insert_when_partContext>(i);
		}
		public ITerminalNode FIRST() { return GetToken(plsqlParser.FIRST, 0); }
		public Conditional_insert_else_partContext conditional_insert_else_part() {
			return GetRuleContext<Conditional_insert_else_partContext>(0);
		}
		public ITerminalNode ALL() { return GetToken(plsqlParser.ALL, 0); }
		public Conditional_insert_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_conditional_insert_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterConditional_insert_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitConditional_insert_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConditional_insert_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Conditional_insert_clauseContext conditional_insert_clause() {
		Conditional_insert_clauseContext _localctx = new Conditional_insert_clauseContext(_ctx, State);
		EnterRule(_localctx, 440, RULE_conditional_insert_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3530;
			_la = _input.La(1);
			if (_la==ALL || _la==FIRST) {
				{
				State = 3529;
				_la = _input.La(1);
				if ( !(_la==ALL || _la==FIRST) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				}
			}

			State = 3533;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 3532; conditional_insert_when_part();
				}
				}
				State = 3535;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==WHEN );
			State = 3538;
			_la = _input.La(1);
			if (_la==ELSE) {
				{
				State = 3537; conditional_insert_else_part();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Conditional_insert_when_partContext : ParserRuleContext {
		public ITerminalNode THEN() { return GetToken(plsqlParser.THEN, 0); }
		public IReadOnlyList<Multi_table_elementContext> multi_table_element() {
			return GetRuleContexts<Multi_table_elementContext>();
		}
		public Multi_table_elementContext multi_table_element(int i) {
			return GetRuleContext<Multi_table_elementContext>(i);
		}
		public ITerminalNode WHEN() { return GetToken(plsqlParser.WHEN, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public Conditional_insert_when_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_conditional_insert_when_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterConditional_insert_when_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitConditional_insert_when_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConditional_insert_when_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Conditional_insert_when_partContext conditional_insert_when_part() {
		Conditional_insert_when_partContext _localctx = new Conditional_insert_when_partContext(_ctx, State);
		EnterRule(_localctx, 442, RULE_conditional_insert_when_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3540; Match(WHEN);
			State = 3541; condition();
			State = 3542; Match(THEN);
			State = 3544;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 3543; multi_table_element();
				}
				}
				State = 3546;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==INTO );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Conditional_insert_else_partContext : ParserRuleContext {
		public ITerminalNode ELSE() { return GetToken(plsqlParser.ELSE, 0); }
		public IReadOnlyList<Multi_table_elementContext> multi_table_element() {
			return GetRuleContexts<Multi_table_elementContext>();
		}
		public Multi_table_elementContext multi_table_element(int i) {
			return GetRuleContext<Multi_table_elementContext>(i);
		}
		public Conditional_insert_else_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_conditional_insert_else_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterConditional_insert_else_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitConditional_insert_else_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConditional_insert_else_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Conditional_insert_else_partContext conditional_insert_else_part() {
		Conditional_insert_else_partContext _localctx = new Conditional_insert_else_partContext(_ctx, State);
		EnterRule(_localctx, 444, RULE_conditional_insert_else_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3548; Match(ELSE);
			State = 3550;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 3549; multi_table_element();
				}
				}
				State = 3552;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==INTO );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Insert_into_clauseContext : ParserRuleContext {
		public General_table_refContext general_table_ref() {
			return GetRuleContext<General_table_refContext>(0);
		}
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public IReadOnlyList<Column_nameContext> column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public ITerminalNode INTO() { return GetToken(plsqlParser.INTO, 0); }
		public Insert_into_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_insert_into_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterInsert_into_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitInsert_into_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInsert_into_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Insert_into_clauseContext insert_into_clause() {
		Insert_into_clauseContext _localctx = new Insert_into_clauseContext(_ctx, State);
		EnterRule(_localctx, 446, RULE_insert_into_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3554; Match(INTO);
			State = 3555; general_table_ref();
			State = 3567;
			switch ( Interpreter.AdaptivePredict(_input,424,_ctx) ) {
			case 1:
				{
				State = 3556; Match(LEFT_PAREN);
				State = 3557; column_name();
				State = 3562;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 3558; Match(COMMA);
					State = 3559; column_name();
					}
					}
					State = 3564;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 3565; Match(RIGHT_PAREN);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Values_clauseContext : ParserRuleContext {
		public Expression_listContext expression_list() {
			return GetRuleContext<Expression_listContext>(0);
		}
		public ITerminalNode VALUES() { return GetToken(plsqlParser.VALUES, 0); }
		public Values_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_values_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterValues_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitValues_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitValues_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Values_clauseContext values_clause() {
		Values_clauseContext _localctx = new Values_clauseContext(_ctx, State);
		EnterRule(_localctx, 448, RULE_values_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3569; Match(VALUES);
			State = 3570; expression_list();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Merge_statementContext : ParserRuleContext {
		public ITerminalNode ON() { return GetToken(plsqlParser.ON, 0); }
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public ITerminalNode MERGE() { return GetToken(plsqlParser.MERGE, 0); }
		public Merge_insert_clauseContext merge_insert_clause() {
			return GetRuleContext<Merge_insert_clauseContext>(0);
		}
		public ITerminalNode USING() { return GetToken(plsqlParser.USING, 0); }
		public Table_aliasContext table_alias() {
			return GetRuleContext<Table_aliasContext>(0);
		}
		public Merge_update_clauseContext merge_update_clause() {
			return GetRuleContext<Merge_update_clauseContext>(0);
		}
		public ITerminalNode INTO() { return GetToken(plsqlParser.INTO, 0); }
		public Selected_tableviewContext selected_tableview() {
			return GetRuleContext<Selected_tableviewContext>(0);
		}
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public Error_logging_clauseContext error_logging_clause() {
			return GetRuleContext<Error_logging_clauseContext>(0);
		}
		public Merge_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_merge_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterMerge_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitMerge_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMerge_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Merge_statementContext merge_statement() {
		Merge_statementContext _localctx = new Merge_statementContext(_ctx, State);
		EnterRule(_localctx, 450, RULE_merge_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3572; Match(MERGE);
			State = 3573; Match(INTO);
			State = 3574; tableview_name();
			State = 3576;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (CONSTANT - 66)) | (1L << (CONSTRAINT - 66)) | (1L << (CONSTRAINTS - 66)) | (1L << (CONSTRUCTOR - 66)) | (1L << (CONTENT - 66)) | (1L << (CONTEXT - 66)) | (1L << (CONTINUE - 66)) | (1L << (CONVERT - 66)) | (1L << (CORRUPT_XID - 66)) | (1L << (CORRUPT_XID_ALL - 66)) | (1L << (COST - 66)) | (1L << (COUNT - 66)) | (1L << (CROSS - 66)) | (1L << (CUBE - 66)) | (1L << (CURRENT_USER - 66)) | (1L << (CURSOR - 66)) | (1L << (CUSTOMDATUM - 66)) | (1L << (CYCLE - 66)) | (1L << (DATA - 66)) | (1L << (DATABASE - 66)) | (1L << (DAY - 66)) | (1L << (DB_ROLE_CHANGE - 66)) | (1L << (DBTIMEZONE - 66)) | (1L << (DDL - 66)) | (1L << (DEBUG - 66)) | (1L << (DEC - 66)) | (1L << (DECIMAL - 66)) | (1L << (DECOMPOSE - 66)) | (1L << (DECREMENT - 66)) | (1L << (DEFAULTS - 66)) | (1L << (DEFERRED - 66)) | (1L << (DEFINER - 66)) | (1L << (DETERMINISTIC - 66)) | (1L << (DIMENSION - 66)) | (1L << (DISABLE - 66)) | (1L << (DISASSOCIATE - 66)) | (1L << (DOCUMENT - 66)) | (1L << (DOUBLE - 66)) | (1L << (DSINTERVAL_UNCONSTRAINED - 66)) | (1L << (EACH - 66)) | (1L << (ELEMENT - 66)) | (1L << (EMPTY - 66)) | (1L << (ENABLE - 66)) | (1L << (ENCODING - 66)) | (1L << (ENTITYESCAPING - 66)) | (1L << (ERR - 66)) | (1L << (ERRORS - 66)) | (1L << (ESCAPE - 66)) | (1L << (EVALNAME - 66)) | (1L << (EXCEPTION - 66)) | (1L << (EXCEPTION_INIT - 66)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)) | (1L << (EXIT - 130)) | (1L << (EXPLAIN - 130)) | (1L << (EXTERNAL - 130)) | (1L << (EXTRACT - 130)) | (1L << (FAILURE - 130)) | (1L << (FINAL - 130)) | (1L << (FIRST - 130)) | (1L << (FIRST_VALUE - 130)) | (1L << (FLOAT - 130)) | (1L << (FOLLOWING - 130)) | (1L << (FOLLOWS - 130)) | (1L << (FORALL - 130)) | (1L << (FORCE - 130)) | (1L << (FULL - 130)) | (1L << (FUNCTION - 130)) | (1L << (GROUPING - 130)) | (1L << (HASH - 130)) | (1L << (HIDE - 130)) | (1L << (HOUR - 130)) | (1L << (IGNORE - 130)) | (1L << (IMMEDIATE - 130)) | (1L << (INCLUDE - 130)) | (1L << (INCLUDING - 130)) | (1L << (INCREMENT - 130)) | (1L << (INDENT - 130)) | (1L << (INDEXED - 130)) | (1L << (INDICATOR - 130)) | (1L << (INDICES - 130)) | (1L << (INFINITE - 130)) | (1L << (INLINE - 130)) | (1L << (INNER - 130)) | (1L << (INOUT - 130)) | (1L << (INSTANTIABLE - 130)) | (1L << (INSTEAD - 130)) | (1L << (INT - 130)) | (1L << (INTEGER - 130)) | (1L << (INTERVAL - 130)) | (1L << (INVALIDATE - 130)) | (1L << (ISOLATION - 130)) | (1L << (ITERATE - 130)) | (1L << (JAVA - 130)) | (1L << (JOIN - 130)) | (1L << (KEEP - 130)) | (1L << (LANGUAGE - 130)))) != 0) || ((((_la - 194)) & ~0x3f) == 0 && ((1L << (_la - 194)) & ((1L << (LAST - 194)) | (1L << (LAST_VALUE - 194)) | (1L << (LEADING - 194)) | (1L << (LEFT - 194)) | (1L << (LEVEL - 194)) | (1L << (LIBRARY - 194)) | (1L << (LIKE2 - 194)) | (1L << (LIKE4 - 194)) | (1L << (LIKEC - 194)) | (1L << (LIMIT - 194)) | (1L << (LOCAL - 194)) | (1L << (LOCKED - 194)) | (1L << (LOG - 194)) | (1L << (LOGOFF - 194)) | (1L << (LOGON - 194)) | (1L << (LONG - 194)) | (1L << (LOOP - 194)) | (1L << (MAIN - 194)) | (1L << (MAP - 194)) | (1L << (MATCHED - 194)) | (1L << (MAXVALUE - 194)) | (1L << (MEASURES - 194)) | (1L << (MEMBER - 194)) | (1L << (MERGE - 194)) | (1L << (MINUTE - 194)) | (1L << (MINVALUE - 194)) | (1L << (MLSLABEL - 194)) | (1L << (MODEL - 194)) | (1L << (MODIFY - 194)) | (1L << (MONTH - 194)) | (1L << (MULTISET - 194)) | (1L << (NAME - 194)) | (1L << (NAN - 194)) | (1L << (NATURAL - 194)) | (1L << (NATURALN - 194)) | (1L << (NAV - 194)) | (1L << (NCHAR - 194)) | (1L << (NCHAR_CS - 194)) | (1L << (NCLOB - 194)) | (1L << (NESTED - 194)) | (1L << (NEW - 194)) | (1L << (NO - 194)) | (1L << (NOAUDIT - 194)) | (1L << (NOCOPY - 194)) | (1L << (NOCYCLE - 194)) | (1L << (NOENTITYESCAPING - 194)) | (1L << (NONE - 194)) | (1L << (NOSCHEMACHECK - 194)) | (1L << (NULLS - 194)) | (1L << (NUMBER - 194)) | (1L << (NUMERIC - 194)) | (1L << (NVARCHAR2 - 194)) | (1L << (OBJECT - 194)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (OFF - 259)) | (1L << (OID - 259)) | (1L << (OLD - 259)) | (1L << (ONLY - 259)) | (1L << (OPEN - 259)) | (1L << (ORADATA - 259)) | (1L << (ORDINALITY - 259)) | (1L << (OSERROR - 259)) | (1L << (OUT - 259)) | (1L << (OUTER - 259)) | (1L << (OVER - 259)) | (1L << (OVERRIDING - 259)) | (1L << (PACKAGE - 259)) | (1L << (PARALLEL_ENABLE - 259)) | (1L << (PARAMETERS - 259)) | (1L << (PARENT - 259)) | (1L << (PARTITION - 259)) | (1L << (PASSING - 259)) | (1L << (PATH - 259)) | (1L << (PIPELINED - 259)) | (1L << (PLAN - 259)) | (1L << (PLS_INTEGER - 259)) | (1L << (POSITIVE - 259)) | (1L << (POSITIVEN - 259)) | (1L << (PRAGMA - 259)) | (1L << (PRECEDING - 259)) | (1L << (PRECISION - 259)) | (1L << (PRESENT - 259)) | (1L << (RAISE - 259)) | (1L << (RANGE - 259)) | (1L << (RAW - 259)) | (1L << (READ - 259)) | (1L << (REAL - 259)) | (1L << (RECORD - 259)) | (1L << (REF - 259)) | (1L << (REFERENCE - 259)) | (1L << (REFERENCING - 259)) | (1L << (REJECT - 259)) | (1L << (RELIES_ON - 259)) | (1L << (RENAME - 259)) | (1L << (REPLACE - 259)) | (1L << (RESPECT - 259)) | (1L << (RESTRICT_REFERENCES - 259)) | (1L << (RESULT - 259)) | (1L << (RESULT_CACHE - 259)) | (1L << (RETURN - 259)) | (1L << (RETURNING - 259)) | (1L << (REUSE - 259)) | (1L << (REVERSE - 259)) | (1L << (RIGHT - 259)))) != 0) || ((((_la - 323)) & ~0x3f) == 0 && ((1L << (_la - 323)) & ((1L << (ROLLBACK - 323)) | (1L << (ROLLUP - 323)) | (1L << (ROW - 323)) | (1L << (ROWID - 323)) | (1L << (ROWS - 323)) | (1L << (RULES - 323)) | (1L << (SAMPLE - 323)) | (1L << (SAVE - 323)) | (1L << (SAVEPOINT - 323)) | (1L << (SCHEMA - 323)) | (1L << (SCHEMACHECK - 323)) | (1L << (SCN - 323)) | (1L << (SECOND - 323)) | (1L << (SEED - 323)) | (1L << (SEGMENT - 323)) | (1L << (SELF - 323)) | (1L << (SEQUENTIAL - 323)) | (1L << (SERIALIZABLE - 323)) | (1L << (SERIALLY_REUSABLE - 323)) | (1L << (SERVERERROR - 323)) | (1L << (SESSIONTIMEZONE - 323)) | (1L << (SET - 323)) | (1L << (SETS - 323)) | (1L << (SETTINGS - 323)) | (1L << (SHOW - 323)) | (1L << (SHUTDOWN - 323)) | (1L << (SIBLINGS - 323)) | (1L << (SIGNTYPE - 323)) | (1L << (SIMPLE_INTEGER - 323)) | (1L << (SINGLE - 323)) | (1L << (SKIP_ - 323)) | (1L << (SMALLINT - 323)) | (1L << (SNAPSHOT - 323)) | (1L << (SOME - 323)) | (1L << (SPECIFICATION - 323)) | (1L << (SQLDATA - 323)) | (1L << (SQLERROR - 323)) | (1L << (STANDALONE - 323)) | (1L << (STARTUP - 323)) | (1L << (STATEMENT - 323)) | (1L << (STATEMENT_ID - 323)) | (1L << (STATIC - 323)) | (1L << (STATISTICS - 323)) | (1L << (STRING - 323)) | (1L << (SUBMULTISET - 323)) | (1L << (SUBPARTITION - 323)) | (1L << (SUBSTITUTABLE - 323)) | (1L << (SUBTYPE - 323)) | (1L << (SUCCESS - 323)) | (1L << (SUSPEND - 323)) | (1L << (TIME - 323)) | (1L << (TIMESTAMP - 323)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_UNCONSTRAINED - 323)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TIMEZONE_ABBR - 387)) | (1L << (TIMEZONE_HOUR - 387)) | (1L << (TIMEZONE_MINUTE - 387)) | (1L << (TIMEZONE_REGION - 387)) | (1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (YMINTERVAL_UNCONSTRAINED - 451)) | (1L << (ZONE - 451)) | (1L << (PREDICTION - 451)) | (1L << (PREDICTION_BOUNDS - 451)) | (1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (COVAR_ - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (REGR_ - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (TRIM - 451)) | (1L << (SUM - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (VARIANCE - 451)) | (1L << (NATIONAL_CHAR_STRING_LIT - 451)) | (1L << (CHAR_STRING - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 3575; table_alias();
				}
			}

			State = 3578; Match(USING);
			State = 3579; selected_tableview();
			State = 3580; Match(ON);
			State = 3581; Match(LEFT_PAREN);
			State = 3582; condition();
			State = 3583; Match(RIGHT_PAREN);
			State = 3592;
			switch ( Interpreter.AdaptivePredict(_input,428,_ctx) ) {
			case 1:
				{
				State = 3584; merge_update_clause();
				State = 3586;
				_la = _input.La(1);
				if (_la==WHEN) {
					{
					State = 3585; merge_insert_clause();
					}
				}

				}
				break;

			case 2:
				{
				State = 3588; merge_insert_clause();
				State = 3590;
				_la = _input.La(1);
				if (_la==WHEN) {
					{
					State = 3589; merge_update_clause();
					}
				}

				}
				break;
			}
			State = 3595;
			_la = _input.La(1);
			if (_la==LOG) {
				{
				State = 3594; error_logging_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Merge_update_clauseContext : ParserRuleContext {
		public ITerminalNode MATCHED() { return GetToken(plsqlParser.MATCHED, 0); }
		public ITerminalNode UPDATE() { return GetToken(plsqlParser.UPDATE, 0); }
		public ITerminalNode THEN() { return GetToken(plsqlParser.THEN, 0); }
		public ITerminalNode WHEN() { return GetToken(plsqlParser.WHEN, 0); }
		public IReadOnlyList<Merge_elementContext> merge_element() {
			return GetRuleContexts<Merge_elementContext>();
		}
		public Where_clauseContext where_clause() {
			return GetRuleContext<Where_clauseContext>(0);
		}
		public Merge_elementContext merge_element(int i) {
			return GetRuleContext<Merge_elementContext>(i);
		}
		public ITerminalNode SET() { return GetToken(plsqlParser.SET, 0); }
		public Merge_update_delete_partContext merge_update_delete_part() {
			return GetRuleContext<Merge_update_delete_partContext>(0);
		}
		public Merge_update_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_merge_update_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterMerge_update_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitMerge_update_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMerge_update_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Merge_update_clauseContext merge_update_clause() {
		Merge_update_clauseContext _localctx = new Merge_update_clauseContext(_ctx, State);
		EnterRule(_localctx, 452, RULE_merge_update_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3597; Match(WHEN);
			State = 3598; Match(MATCHED);
			State = 3599; Match(THEN);
			State = 3600; Match(UPDATE);
			State = 3601; Match(SET);
			State = 3602; merge_element();
			State = 3607;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 3603; Match(COMMA);
				State = 3604; merge_element();
				}
				}
				State = 3609;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 3611;
			_la = _input.La(1);
			if (_la==WHERE) {
				{
				State = 3610; where_clause();
				}
			}

			State = 3614;
			switch ( Interpreter.AdaptivePredict(_input,432,_ctx) ) {
			case 1:
				{
				State = 3613; merge_update_delete_part();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Merge_elementContext : ParserRuleContext {
		public Column_nameContext column_name() {
			return GetRuleContext<Column_nameContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Merge_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_merge_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterMerge_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitMerge_element(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMerge_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Merge_elementContext merge_element() {
		Merge_elementContext _localctx = new Merge_elementContext(_ctx, State);
		EnterRule(_localctx, 454, RULE_merge_element);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3616; column_name();
			State = 3617; Match(EQUALS_OP);
			State = 3618; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Merge_update_delete_partContext : ParserRuleContext {
		public ITerminalNode DELETE() { return GetToken(plsqlParser.DELETE, 0); }
		public Where_clauseContext where_clause() {
			return GetRuleContext<Where_clauseContext>(0);
		}
		public Merge_update_delete_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_merge_update_delete_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterMerge_update_delete_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitMerge_update_delete_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMerge_update_delete_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Merge_update_delete_partContext merge_update_delete_part() {
		Merge_update_delete_partContext _localctx = new Merge_update_delete_partContext(_ctx, State);
		EnterRule(_localctx, 456, RULE_merge_update_delete_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3620; Match(DELETE);
			State = 3621; where_clause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Merge_insert_clauseContext : ParserRuleContext {
		public ITerminalNode NOT() { return GetToken(plsqlParser.NOT, 0); }
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public Expression_listContext expression_list() {
			return GetRuleContext<Expression_listContext>(0);
		}
		public ITerminalNode MATCHED() { return GetToken(plsqlParser.MATCHED, 0); }
		public IReadOnlyList<Column_nameContext> column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public ITerminalNode VALUES() { return GetToken(plsqlParser.VALUES, 0); }
		public ITerminalNode THEN() { return GetToken(plsqlParser.THEN, 0); }
		public ITerminalNode WHEN() { return GetToken(plsqlParser.WHEN, 0); }
		public Where_clauseContext where_clause() {
			return GetRuleContext<Where_clauseContext>(0);
		}
		public ITerminalNode INSERT() { return GetToken(plsqlParser.INSERT, 0); }
		public Merge_insert_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_merge_insert_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterMerge_insert_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitMerge_insert_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMerge_insert_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Merge_insert_clauseContext merge_insert_clause() {
		Merge_insert_clauseContext _localctx = new Merge_insert_clauseContext(_ctx, State);
		EnterRule(_localctx, 458, RULE_merge_insert_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3623; Match(WHEN);
			State = 3624; Match(NOT);
			State = 3625; Match(MATCHED);
			State = 3626; Match(THEN);
			State = 3627; Match(INSERT);
			State = 3639;
			_la = _input.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 3628; Match(LEFT_PAREN);
				State = 3629; column_name();
				State = 3634;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 3630; Match(COMMA);
					State = 3631; column_name();
					}
					}
					State = 3636;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 3637; Match(RIGHT_PAREN);
				}
			}

			State = 3641; Match(VALUES);
			State = 3642; expression_list();
			State = 3644;
			_la = _input.La(1);
			if (_la==WHERE) {
				{
				State = 3643; where_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Selected_tableviewContext : ParserRuleContext {
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public Select_statementContext select_statement() {
			return GetRuleContext<Select_statementContext>(0);
		}
		public Table_aliasContext table_alias() {
			return GetRuleContext<Table_aliasContext>(0);
		}
		public Selected_tableviewContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selected_tableview; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSelected_tableview(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSelected_tableview(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelected_tableview(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Selected_tableviewContext selected_tableview() {
		Selected_tableviewContext _localctx = new Selected_tableviewContext(_ctx, State);
		EnterRule(_localctx, 460, RULE_selected_tableview);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3651;
			switch (_input.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROW_NUMBER:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 3646; tableview_name();
				}
				break;
			case LEFT_PAREN:
				{
				State = 3647; Match(LEFT_PAREN);
				State = 3648; select_statement();
				State = 3649; Match(RIGHT_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3654;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (CONSTANT - 66)) | (1L << (CONSTRAINT - 66)) | (1L << (CONSTRAINTS - 66)) | (1L << (CONSTRUCTOR - 66)) | (1L << (CONTENT - 66)) | (1L << (CONTEXT - 66)) | (1L << (CONTINUE - 66)) | (1L << (CONVERT - 66)) | (1L << (CORRUPT_XID - 66)) | (1L << (CORRUPT_XID_ALL - 66)) | (1L << (COST - 66)) | (1L << (COUNT - 66)) | (1L << (CROSS - 66)) | (1L << (CUBE - 66)) | (1L << (CURRENT_USER - 66)) | (1L << (CURSOR - 66)) | (1L << (CUSTOMDATUM - 66)) | (1L << (CYCLE - 66)) | (1L << (DATA - 66)) | (1L << (DATABASE - 66)) | (1L << (DAY - 66)) | (1L << (DB_ROLE_CHANGE - 66)) | (1L << (DBTIMEZONE - 66)) | (1L << (DDL - 66)) | (1L << (DEBUG - 66)) | (1L << (DEC - 66)) | (1L << (DECIMAL - 66)) | (1L << (DECOMPOSE - 66)) | (1L << (DECREMENT - 66)) | (1L << (DEFAULTS - 66)) | (1L << (DEFERRED - 66)) | (1L << (DEFINER - 66)) | (1L << (DETERMINISTIC - 66)) | (1L << (DIMENSION - 66)) | (1L << (DISABLE - 66)) | (1L << (DISASSOCIATE - 66)) | (1L << (DOCUMENT - 66)) | (1L << (DOUBLE - 66)) | (1L << (DSINTERVAL_UNCONSTRAINED - 66)) | (1L << (EACH - 66)) | (1L << (ELEMENT - 66)) | (1L << (EMPTY - 66)) | (1L << (ENABLE - 66)) | (1L << (ENCODING - 66)) | (1L << (ENTITYESCAPING - 66)) | (1L << (ERR - 66)) | (1L << (ERRORS - 66)) | (1L << (ESCAPE - 66)) | (1L << (EVALNAME - 66)) | (1L << (EXCEPTION - 66)) | (1L << (EXCEPTION_INIT - 66)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)) | (1L << (EXIT - 130)) | (1L << (EXPLAIN - 130)) | (1L << (EXTERNAL - 130)) | (1L << (EXTRACT - 130)) | (1L << (FAILURE - 130)) | (1L << (FINAL - 130)) | (1L << (FIRST - 130)) | (1L << (FIRST_VALUE - 130)) | (1L << (FLOAT - 130)) | (1L << (FOLLOWING - 130)) | (1L << (FOLLOWS - 130)) | (1L << (FORALL - 130)) | (1L << (FORCE - 130)) | (1L << (FULL - 130)) | (1L << (FUNCTION - 130)) | (1L << (GROUPING - 130)) | (1L << (HASH - 130)) | (1L << (HIDE - 130)) | (1L << (HOUR - 130)) | (1L << (IGNORE - 130)) | (1L << (IMMEDIATE - 130)) | (1L << (INCLUDE - 130)) | (1L << (INCLUDING - 130)) | (1L << (INCREMENT - 130)) | (1L << (INDENT - 130)) | (1L << (INDEXED - 130)) | (1L << (INDICATOR - 130)) | (1L << (INDICES - 130)) | (1L << (INFINITE - 130)) | (1L << (INLINE - 130)) | (1L << (INNER - 130)) | (1L << (INOUT - 130)) | (1L << (INSTANTIABLE - 130)) | (1L << (INSTEAD - 130)) | (1L << (INT - 130)) | (1L << (INTEGER - 130)) | (1L << (INTERVAL - 130)) | (1L << (INVALIDATE - 130)) | (1L << (ISOLATION - 130)) | (1L << (ITERATE - 130)) | (1L << (JAVA - 130)) | (1L << (JOIN - 130)) | (1L << (KEEP - 130)) | (1L << (LANGUAGE - 130)))) != 0) || ((((_la - 194)) & ~0x3f) == 0 && ((1L << (_la - 194)) & ((1L << (LAST - 194)) | (1L << (LAST_VALUE - 194)) | (1L << (LEADING - 194)) | (1L << (LEFT - 194)) | (1L << (LEVEL - 194)) | (1L << (LIBRARY - 194)) | (1L << (LIKE2 - 194)) | (1L << (LIKE4 - 194)) | (1L << (LIKEC - 194)) | (1L << (LIMIT - 194)) | (1L << (LOCAL - 194)) | (1L << (LOCKED - 194)) | (1L << (LOG - 194)) | (1L << (LOGOFF - 194)) | (1L << (LOGON - 194)) | (1L << (LONG - 194)) | (1L << (LOOP - 194)) | (1L << (MAIN - 194)) | (1L << (MAP - 194)) | (1L << (MATCHED - 194)) | (1L << (MAXVALUE - 194)) | (1L << (MEASURES - 194)) | (1L << (MEMBER - 194)) | (1L << (MERGE - 194)) | (1L << (MINUTE - 194)) | (1L << (MINVALUE - 194)) | (1L << (MLSLABEL - 194)) | (1L << (MODEL - 194)) | (1L << (MODIFY - 194)) | (1L << (MONTH - 194)) | (1L << (MULTISET - 194)) | (1L << (NAME - 194)) | (1L << (NAN - 194)) | (1L << (NATURAL - 194)) | (1L << (NATURALN - 194)) | (1L << (NAV - 194)) | (1L << (NCHAR - 194)) | (1L << (NCHAR_CS - 194)) | (1L << (NCLOB - 194)) | (1L << (NESTED - 194)) | (1L << (NEW - 194)) | (1L << (NO - 194)) | (1L << (NOAUDIT - 194)) | (1L << (NOCOPY - 194)) | (1L << (NOCYCLE - 194)) | (1L << (NOENTITYESCAPING - 194)) | (1L << (NONE - 194)) | (1L << (NOSCHEMACHECK - 194)) | (1L << (NULLS - 194)) | (1L << (NUMBER - 194)) | (1L << (NUMERIC - 194)) | (1L << (NVARCHAR2 - 194)) | (1L << (OBJECT - 194)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (OFF - 259)) | (1L << (OID - 259)) | (1L << (OLD - 259)) | (1L << (ONLY - 259)) | (1L << (OPEN - 259)) | (1L << (ORADATA - 259)) | (1L << (ORDINALITY - 259)) | (1L << (OSERROR - 259)) | (1L << (OUT - 259)) | (1L << (OUTER - 259)) | (1L << (OVER - 259)) | (1L << (OVERRIDING - 259)) | (1L << (PACKAGE - 259)) | (1L << (PARALLEL_ENABLE - 259)) | (1L << (PARAMETERS - 259)) | (1L << (PARENT - 259)) | (1L << (PARTITION - 259)) | (1L << (PASSING - 259)) | (1L << (PATH - 259)) | (1L << (PIPELINED - 259)) | (1L << (PLAN - 259)) | (1L << (PLS_INTEGER - 259)) | (1L << (POSITIVE - 259)) | (1L << (POSITIVEN - 259)) | (1L << (PRAGMA - 259)) | (1L << (PRECEDING - 259)) | (1L << (PRECISION - 259)) | (1L << (PRESENT - 259)) | (1L << (RAISE - 259)) | (1L << (RANGE - 259)) | (1L << (RAW - 259)) | (1L << (READ - 259)) | (1L << (REAL - 259)) | (1L << (RECORD - 259)) | (1L << (REF - 259)) | (1L << (REFERENCE - 259)) | (1L << (REFERENCING - 259)) | (1L << (REJECT - 259)) | (1L << (RELIES_ON - 259)) | (1L << (RENAME - 259)) | (1L << (REPLACE - 259)) | (1L << (RESPECT - 259)) | (1L << (RESTRICT_REFERENCES - 259)) | (1L << (RESULT - 259)) | (1L << (RESULT_CACHE - 259)) | (1L << (RETURN - 259)) | (1L << (RETURNING - 259)) | (1L << (REUSE - 259)) | (1L << (REVERSE - 259)) | (1L << (RIGHT - 259)))) != 0) || ((((_la - 323)) & ~0x3f) == 0 && ((1L << (_la - 323)) & ((1L << (ROLLBACK - 323)) | (1L << (ROLLUP - 323)) | (1L << (ROW - 323)) | (1L << (ROWID - 323)) | (1L << (ROWS - 323)) | (1L << (RULES - 323)) | (1L << (SAMPLE - 323)) | (1L << (SAVE - 323)) | (1L << (SAVEPOINT - 323)) | (1L << (SCHEMA - 323)) | (1L << (SCHEMACHECK - 323)) | (1L << (SCN - 323)) | (1L << (SECOND - 323)) | (1L << (SEED - 323)) | (1L << (SEGMENT - 323)) | (1L << (SELF - 323)) | (1L << (SEQUENTIAL - 323)) | (1L << (SERIALIZABLE - 323)) | (1L << (SERIALLY_REUSABLE - 323)) | (1L << (SERVERERROR - 323)) | (1L << (SESSIONTIMEZONE - 323)) | (1L << (SET - 323)) | (1L << (SETS - 323)) | (1L << (SETTINGS - 323)) | (1L << (SHOW - 323)) | (1L << (SHUTDOWN - 323)) | (1L << (SIBLINGS - 323)) | (1L << (SIGNTYPE - 323)) | (1L << (SIMPLE_INTEGER - 323)) | (1L << (SINGLE - 323)) | (1L << (SKIP_ - 323)) | (1L << (SMALLINT - 323)) | (1L << (SNAPSHOT - 323)) | (1L << (SOME - 323)) | (1L << (SPECIFICATION - 323)) | (1L << (SQLDATA - 323)) | (1L << (SQLERROR - 323)) | (1L << (STANDALONE - 323)) | (1L << (STARTUP - 323)) | (1L << (STATEMENT - 323)) | (1L << (STATEMENT_ID - 323)) | (1L << (STATIC - 323)) | (1L << (STATISTICS - 323)) | (1L << (STRING - 323)) | (1L << (SUBMULTISET - 323)) | (1L << (SUBPARTITION - 323)) | (1L << (SUBSTITUTABLE - 323)) | (1L << (SUBTYPE - 323)) | (1L << (SUCCESS - 323)) | (1L << (SUSPEND - 323)) | (1L << (TIME - 323)) | (1L << (TIMESTAMP - 323)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_UNCONSTRAINED - 323)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TIMEZONE_ABBR - 387)) | (1L << (TIMEZONE_HOUR - 387)) | (1L << (TIMEZONE_MINUTE - 387)) | (1L << (TIMEZONE_REGION - 387)) | (1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (YMINTERVAL_UNCONSTRAINED - 451)) | (1L << (ZONE - 451)) | (1L << (PREDICTION - 451)) | (1L << (PREDICTION_BOUNDS - 451)) | (1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (COVAR_ - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (REGR_ - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (TRIM - 451)) | (1L << (SUM - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (VARIANCE - 451)) | (1L << (NATIONAL_CHAR_STRING_LIT - 451)) | (1L << (CHAR_STRING - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 3653; table_alias();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Lock_table_statementContext : ParserRuleContext {
		public Wait_nowait_partContext wait_nowait_part() {
			return GetRuleContext<Wait_nowait_partContext>(0);
		}
		public Lock_table_elementContext lock_table_element(int i) {
			return GetRuleContext<Lock_table_elementContext>(i);
		}
		public ITerminalNode LOCK() { return GetToken(plsqlParser.LOCK, 0); }
		public IReadOnlyList<Lock_table_elementContext> lock_table_element() {
			return GetRuleContexts<Lock_table_elementContext>();
		}
		public ITerminalNode MODE() { return GetToken(plsqlParser.MODE, 0); }
		public ITerminalNode TABLE() { return GetToken(plsqlParser.TABLE, 0); }
		public Lock_modeContext lock_mode() {
			return GetRuleContext<Lock_modeContext>(0);
		}
		public ITerminalNode IN() { return GetToken(plsqlParser.IN, 0); }
		public Lock_table_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lock_table_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterLock_table_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitLock_table_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLock_table_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Lock_table_statementContext lock_table_statement() {
		Lock_table_statementContext _localctx = new Lock_table_statementContext(_ctx, State);
		EnterRule(_localctx, 462, RULE_lock_table_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3656; Match(LOCK);
			State = 3657; Match(TABLE);
			State = 3658; lock_table_element();
			State = 3663;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 3659; Match(COMMA);
				State = 3660; lock_table_element();
				}
				}
				State = 3665;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 3666; Match(IN);
			State = 3667; lock_mode();
			State = 3668; Match(MODE);
			State = 3670;
			_la = _input.La(1);
			if (_la==NOWAIT || _la==WAIT) {
				{
				State = 3669; wait_nowait_part();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Wait_nowait_partContext : ParserRuleContext {
		public ITerminalNode NOWAIT() { return GetToken(plsqlParser.NOWAIT, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode WAIT() { return GetToken(plsqlParser.WAIT, 0); }
		public Wait_nowait_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_wait_nowait_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterWait_nowait_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitWait_nowait_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWait_nowait_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Wait_nowait_partContext wait_nowait_part() {
		Wait_nowait_partContext _localctx = new Wait_nowait_partContext(_ctx, State);
		EnterRule(_localctx, 464, RULE_wait_nowait_part);
		try {
			State = 3675;
			switch (_input.La(1)) {
			case WAIT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3672; Match(WAIT);
				State = 3673; expression();
				}
				break;
			case NOWAIT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3674; Match(NOWAIT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Lock_table_elementContext : ParserRuleContext {
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public Partition_extension_clauseContext partition_extension_clause() {
			return GetRuleContext<Partition_extension_clauseContext>(0);
		}
		public Lock_table_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lock_table_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterLock_table_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitLock_table_element(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLock_table_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Lock_table_elementContext lock_table_element() {
		Lock_table_elementContext _localctx = new Lock_table_elementContext(_ctx, State);
		EnterRule(_localctx, 466, RULE_lock_table_element);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3677; tableview_name();
			State = 3679;
			_la = _input.La(1);
			if (_la==PARTITION || _la==SUBPARTITION) {
				{
				State = 3678; partition_extension_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Lock_modeContext : ParserRuleContext {
		public ITerminalNode ROW() { return GetToken(plsqlParser.ROW, 0); }
		public ITerminalNode EXCLUSIVE() { return GetToken(plsqlParser.EXCLUSIVE, 0); }
		public ITerminalNode SHARE() { return GetToken(plsqlParser.SHARE, 0); }
		public ITerminalNode UPDATE() { return GetToken(plsqlParser.UPDATE, 0); }
		public Lock_modeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lock_mode; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterLock_mode(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitLock_mode(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLock_mode(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Lock_modeContext lock_mode() {
		Lock_modeContext _localctx = new Lock_modeContext(_ctx, State);
		EnterRule(_localctx, 468, RULE_lock_mode);
		int _la;
		try {
			State = 3693;
			switch ( Interpreter.AdaptivePredict(_input,443,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3681; Match(ROW);
				State = 3682; Match(SHARE);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3683; Match(ROW);
				State = 3684; Match(EXCLUSIVE);
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3685; Match(SHARE);
				State = 3687;
				_la = _input.La(1);
				if (_la==UPDATE) {
					{
					State = 3686; Match(UPDATE);
					}
				}

				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 3689; Match(SHARE);
				State = 3690; Match(ROW);
				State = 3691; Match(EXCLUSIVE);
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 3692; Match(EXCLUSIVE);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class General_table_refContext : ParserRuleContext {
		public Dml_table_expression_clauseContext dml_table_expression_clause() {
			return GetRuleContext<Dml_table_expression_clauseContext>(0);
		}
		public ITerminalNode ONLY() { return GetToken(plsqlParser.ONLY, 0); }
		public Table_aliasContext table_alias() {
			return GetRuleContext<Table_aliasContext>(0);
		}
		public General_table_refContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_general_table_ref; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterGeneral_table_ref(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitGeneral_table_ref(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGeneral_table_ref(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public General_table_refContext general_table_ref() {
		General_table_refContext _localctx = new General_table_refContext(_ctx, State);
		EnterRule(_localctx, 470, RULE_general_table_ref);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3701;
			switch ( Interpreter.AdaptivePredict(_input,444,_ctx) ) {
			case 1:
				{
				State = 3695; dml_table_expression_clause();
				}
				break;

			case 2:
				{
				State = 3696; Match(ONLY);
				State = 3697; Match(LEFT_PAREN);
				State = 3698; dml_table_expression_clause();
				State = 3699; Match(RIGHT_PAREN);
				}
				break;
			}
			State = 3704;
			switch ( Interpreter.AdaptivePredict(_input,445,_ctx) ) {
			case 1:
				{
				State = 3703; table_alias();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Static_returning_clauseContext : ParserRuleContext {
		public ITerminalNode RETURN() { return GetToken(plsqlParser.RETURN, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public Into_clauseContext into_clause() {
			return GetRuleContext<Into_clauseContext>(0);
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode RETURNING() { return GetToken(plsqlParser.RETURNING, 0); }
		public Static_returning_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_static_returning_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterStatic_returning_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitStatic_returning_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatic_returning_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Static_returning_clauseContext static_returning_clause() {
		Static_returning_clauseContext _localctx = new Static_returning_clauseContext(_ctx, State);
		EnterRule(_localctx, 472, RULE_static_returning_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3706;
			_la = _input.La(1);
			if ( !(_la==RETURN || _la==RETURNING) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			State = 3707; expression();
			State = 3712;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 3708; Match(COMMA);
				State = 3709; expression();
				}
				}
				State = 3714;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 3715; into_clause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Error_logging_clauseContext : ParserRuleContext {
		public ITerminalNode LOG() { return GetToken(plsqlParser.LOG, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Error_logging_into_partContext error_logging_into_part() {
			return GetRuleContext<Error_logging_into_partContext>(0);
		}
		public Error_logging_reject_partContext error_logging_reject_part() {
			return GetRuleContext<Error_logging_reject_partContext>(0);
		}
		public ITerminalNode ERRORS() { return GetToken(plsqlParser.ERRORS, 0); }
		public Error_logging_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_error_logging_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterError_logging_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitError_logging_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitError_logging_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Error_logging_clauseContext error_logging_clause() {
		Error_logging_clauseContext _localctx = new Error_logging_clauseContext(_ctx, State);
		EnterRule(_localctx, 474, RULE_error_logging_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3717; Match(LOG);
			State = 3718; Match(ERRORS);
			State = 3720;
			switch ( Interpreter.AdaptivePredict(_input,447,_ctx) ) {
			case 1:
				{
				State = 3719; error_logging_into_part();
				}
				break;
			}
			State = 3723;
			switch ( Interpreter.AdaptivePredict(_input,448,_ctx) ) {
			case 1:
				{
				State = 3722; expression();
				}
				break;
			}
			State = 3726;
			_la = _input.La(1);
			if (_la==REJECT) {
				{
				State = 3725; error_logging_reject_part();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Error_logging_into_partContext : ParserRuleContext {
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public ITerminalNode INTO() { return GetToken(plsqlParser.INTO, 0); }
		public Error_logging_into_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_error_logging_into_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterError_logging_into_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitError_logging_into_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitError_logging_into_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Error_logging_into_partContext error_logging_into_part() {
		Error_logging_into_partContext _localctx = new Error_logging_into_partContext(_ctx, State);
		EnterRule(_localctx, 476, RULE_error_logging_into_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3728; Match(INTO);
			State = 3729; tableview_name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Error_logging_reject_partContext : ParserRuleContext {
		public ITerminalNode REJECT() { return GetToken(plsqlParser.REJECT, 0); }
		public ITerminalNode LIMIT() { return GetToken(plsqlParser.LIMIT, 0); }
		public ITerminalNode UNLIMITED() { return GetToken(plsqlParser.UNLIMITED, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Error_logging_reject_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_error_logging_reject_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterError_logging_reject_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitError_logging_reject_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitError_logging_reject_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Error_logging_reject_partContext error_logging_reject_part() {
		Error_logging_reject_partContext _localctx = new Error_logging_reject_partContext(_ctx, State);
		EnterRule(_localctx, 478, RULE_error_logging_reject_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3731; Match(REJECT);
			State = 3732; Match(LIMIT);
			State = 3735;
			switch ( Interpreter.AdaptivePredict(_input,450,_ctx) ) {
			case 1:
				{
				State = 3733; Match(UNLIMITED);
				}
				break;

			case 2:
				{
				State = 3734; expression();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Dml_table_expression_clauseContext : ParserRuleContext {
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public Select_statementContext select_statement() {
			return GetRuleContext<Select_statementContext>(0);
		}
		public Sample_clauseContext sample_clause() {
			return GetRuleContext<Sample_clauseContext>(0);
		}
		public Subquery_restriction_clauseContext subquery_restriction_clause() {
			return GetRuleContext<Subquery_restriction_clauseContext>(0);
		}
		public Table_collection_expressionContext table_collection_expression() {
			return GetRuleContext<Table_collection_expressionContext>(0);
		}
		public Dml_table_expression_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dml_table_expression_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterDml_table_expression_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitDml_table_expression_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDml_table_expression_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Dml_table_expression_clauseContext dml_table_expression_clause() {
		Dml_table_expression_clauseContext _localctx = new Dml_table_expression_clauseContext(_ctx, State);
		EnterRule(_localctx, 480, RULE_dml_table_expression_clause);
		int _la;
		try {
			State = 3749;
			switch (_input.La(1)) {
			case TABLE:
			case THE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3737; table_collection_expression();
				}
				break;
			case LEFT_PAREN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3738; Match(LEFT_PAREN);
				State = 3739; select_statement();
				State = 3741;
				_la = _input.La(1);
				if (_la==WITH) {
					{
					State = 3740; subquery_restriction_clause();
					}
				}

				State = 3743; Match(RIGHT_PAREN);
				}
				break;
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROW_NUMBER:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3745; tableview_name();
				State = 3747;
				switch ( Interpreter.AdaptivePredict(_input,452,_ctx) ) {
				case 1:
					{
					State = 3746; sample_clause();
					}
					break;
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_collection_expressionContext : ParserRuleContext {
		public ITerminalNode THE() { return GetToken(plsqlParser.THE, 0); }
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode TABLE() { return GetToken(plsqlParser.TABLE, 0); }
		public Table_collection_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_collection_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterTable_collection_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitTable_collection_expression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTable_collection_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Table_collection_expressionContext table_collection_expression() {
		Table_collection_expressionContext _localctx = new Table_collection_expressionContext(_ctx, State);
		EnterRule(_localctx, 482, RULE_table_collection_expression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3751;
			_la = _input.La(1);
			if ( !(_la==TABLE || _la==THE) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			State = 3764;
			switch ( Interpreter.AdaptivePredict(_input,455,_ctx) ) {
			case 1:
				{
				State = 3752; Match(LEFT_PAREN);
				State = 3753; subquery();
				State = 3754; Match(RIGHT_PAREN);
				}
				break;

			case 2:
				{
				State = 3756; Match(LEFT_PAREN);
				State = 3757; expression();
				State = 3758; Match(RIGHT_PAREN);
				State = 3762;
				switch ( Interpreter.AdaptivePredict(_input,454,_ctx) ) {
				case 1:
					{
					State = 3759; Match(LEFT_PAREN);
					State = 3760; Match(PLUS_SIGN);
					State = 3761; Match(RIGHT_PAREN);
					}
					break;
				}
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Subquery_restriction_clauseContext : ParserRuleContext {
		public ITerminalNode CHECK() { return GetToken(plsqlParser.CHECK, 0); }
		public ITerminalNode WITH() { return GetToken(plsqlParser.WITH, 0); }
		public ITerminalNode OPTION() { return GetToken(plsqlParser.OPTION, 0); }
		public ITerminalNode CONSTRAINT() { return GetToken(plsqlParser.CONSTRAINT, 0); }
		public ITerminalNode READ() { return GetToken(plsqlParser.READ, 0); }
		public ITerminalNode ONLY() { return GetToken(plsqlParser.ONLY, 0); }
		public Constraint_nameContext constraint_name() {
			return GetRuleContext<Constraint_nameContext>(0);
		}
		public Subquery_restriction_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subquery_restriction_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSubquery_restriction_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSubquery_restriction_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubquery_restriction_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Subquery_restriction_clauseContext subquery_restriction_clause() {
		Subquery_restriction_clauseContext _localctx = new Subquery_restriction_clauseContext(_ctx, State);
		EnterRule(_localctx, 484, RULE_subquery_restriction_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3766; Match(WITH);
			State = 3775;
			switch (_input.La(1)) {
			case READ:
				{
				State = 3767; Match(READ);
				State = 3768; Match(ONLY);
				}
				break;
			case CHECK:
				{
				State = 3769; Match(CHECK);
				State = 3770; Match(OPTION);
				State = 3773;
				_la = _input.La(1);
				if (_la==CONSTRAINT) {
					{
					State = 3771; Match(CONSTRAINT);
					State = 3772; constraint_name();
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Sample_clauseContext : ParserRuleContext {
		public Seed_partContext seed_part() {
			return GetRuleContext<Seed_partContext>(0);
		}
		public ITerminalNode SAMPLE() { return GetToken(plsqlParser.SAMPLE, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode BLOCK() { return GetToken(plsqlParser.BLOCK, 0); }
		public Sample_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sample_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSample_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSample_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSample_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Sample_clauseContext sample_clause() {
		Sample_clauseContext _localctx = new Sample_clauseContext(_ctx, State);
		EnterRule(_localctx, 486, RULE_sample_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3777; Match(SAMPLE);
			State = 3779;
			_la = _input.La(1);
			if (_la==BLOCK) {
				{
				State = 3778; Match(BLOCK);
				}
			}

			State = 3781; Match(LEFT_PAREN);
			State = 3782; expression();
			State = 3785;
			_la = _input.La(1);
			if (_la==COMMA) {
				{
				State = 3783; Match(COMMA);
				State = 3784; expression();
				}
			}

			State = 3787; Match(RIGHT_PAREN);
			State = 3789;
			switch ( Interpreter.AdaptivePredict(_input,460,_ctx) ) {
			case 1:
				{
				State = 3788; seed_part();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Seed_partContext : ParserRuleContext {
		public ITerminalNode SEED() { return GetToken(plsqlParser.SEED, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Seed_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_seed_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSeed_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSeed_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSeed_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Seed_partContext seed_part() {
		Seed_partContext _localctx = new Seed_partContext(_ctx, State);
		EnterRule(_localctx, 488, RULE_seed_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3791; Match(SEED);
			State = 3792; Match(LEFT_PAREN);
			State = 3793; expression();
			State = 3794; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cursor_expressionContext : ParserRuleContext {
		public ITerminalNode CURSOR() { return GetToken(plsqlParser.CURSOR, 0); }
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public Cursor_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cursor_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCursor_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCursor_expression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCursor_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Cursor_expressionContext cursor_expression() {
		Cursor_expressionContext _localctx = new Cursor_expressionContext(_ctx, State);
		EnterRule(_localctx, 490, RULE_cursor_expression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3796; Match(CURSOR);
			State = 3797; Match(LEFT_PAREN);
			State = 3798; subquery();
			State = 3799; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Expression_listContext : ParserRuleContext {
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public Expression_listContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression_list; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterExpression_list(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitExpression_list(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpression_list(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Expression_listContext expression_list() {
		Expression_listContext _localctx = new Expression_listContext(_ctx, State);
		EnterRule(_localctx, 492, RULE_expression_list);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3801; Match(LEFT_PAREN);
			State = 3803;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALL) | (1L << ANALYZE) | (1L << ANY) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COALESCE) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & ((1L << (CONNECT_BY_ROOT - 65)) | (1L << (CONSTANT - 65)) | (1L << (CONSTRAINT - 65)) | (1L << (CONSTRAINTS - 65)) | (1L << (CONSTRUCTOR - 65)) | (1L << (CONTENT - 65)) | (1L << (CONTEXT - 65)) | (1L << (CONTINUE - 65)) | (1L << (CONVERT - 65)) | (1L << (CORRUPT_XID - 65)) | (1L << (CORRUPT_XID_ALL - 65)) | (1L << (COST - 65)) | (1L << (COUNT - 65)) | (1L << (CROSS - 65)) | (1L << (CUBE - 65)) | (1L << (CURRENT_USER - 65)) | (1L << (CURSOR - 65)) | (1L << (CUSTOMDATUM - 65)) | (1L << (CYCLE - 65)) | (1L << (DATA - 65)) | (1L << (DATABASE - 65)) | (1L << (DATE - 65)) | (1L << (DAY - 65)) | (1L << (DB_ROLE_CHANGE - 65)) | (1L << (DBTIMEZONE - 65)) | (1L << (DDL - 65)) | (1L << (DEBUG - 65)) | (1L << (DEC - 65)) | (1L << (DECIMAL - 65)) | (1L << (DECOMPOSE - 65)) | (1L << (DECREMENT - 65)) | (1L << (DEFAULT - 65)) | (1L << (DEFAULTS - 65)) | (1L << (DEFERRED - 65)) | (1L << (DEFINER - 65)) | (1L << (DETERMINISTIC - 65)) | (1L << (DIMENSION - 65)) | (1L << (DISABLE - 65)) | (1L << (DISASSOCIATE - 65)) | (1L << (DISTINCT - 65)) | (1L << (DOCUMENT - 65)) | (1L << (DOUBLE - 65)) | (1L << (DSINTERVAL_UNCONSTRAINED - 65)) | (1L << (EACH - 65)) | (1L << (ELEMENT - 65)) | (1L << (EMPTY - 65)) | (1L << (ENABLE - 65)) | (1L << (ENCODING - 65)) | (1L << (ENTITYESCAPING - 65)) | (1L << (ERR - 65)) | (1L << (ERRORS - 65)) | (1L << (ESCAPE - 65)) | (1L << (EVALNAME - 65)) | (1L << (EXCEPTION - 65)))) != 0) || ((((_la - 129)) & ~0x3f) == 0 && ((1L << (_la - 129)) & ((1L << (EXCEPTION_INIT - 129)) | (1L << (EXCEPTIONS - 129)) | (1L << (EXCLUDE - 129)) | (1L << (EXECUTE - 129)) | (1L << (EXISTS - 129)) | (1L << (EXIT - 129)) | (1L << (EXPLAIN - 129)) | (1L << (EXTERNAL - 129)) | (1L << (EXTRACT - 129)) | (1L << (FAILURE - 129)) | (1L << (FALSE - 129)) | (1L << (FINAL - 129)) | (1L << (FIRST - 129)) | (1L << (FIRST_VALUE - 129)) | (1L << (FLOAT - 129)) | (1L << (FOLLOWING - 129)) | (1L << (FOLLOWS - 129)) | (1L << (FORALL - 129)) | (1L << (FORCE - 129)) | (1L << (FULL - 129)) | (1L << (FUNCTION - 129)) | (1L << (GROUPING - 129)) | (1L << (HASH - 129)) | (1L << (HIDE - 129)) | (1L << (HOUR - 129)) | (1L << (IGNORE - 129)) | (1L << (IMMEDIATE - 129)) | (1L << (INCLUDE - 129)) | (1L << (INCLUDING - 129)) | (1L << (INCREMENT - 129)) | (1L << (INDENT - 129)) | (1L << (INDEXED - 129)) | (1L << (INDICATOR - 129)) | (1L << (INDICES - 129)) | (1L << (INFINITE - 129)) | (1L << (INLINE - 129)) | (1L << (INNER - 129)) | (1L << (INOUT - 129)) | (1L << (INSTANTIABLE - 129)) | (1L << (INSTEAD - 129)) | (1L << (INT - 129)) | (1L << (INTEGER - 129)) | (1L << (INTERVAL - 129)) | (1L << (INVALIDATE - 129)) | (1L << (ISOLATION - 129)) | (1L << (ITERATE - 129)) | (1L << (JAVA - 129)) | (1L << (JOIN - 129)) | (1L << (KEEP - 129)))) != 0) || ((((_la - 193)) & ~0x3f) == 0 && ((1L << (_la - 193)) & ((1L << (LANGUAGE - 193)) | (1L << (LAST - 193)) | (1L << (LAST_VALUE - 193)) | (1L << (LEADING - 193)) | (1L << (LEFT - 193)) | (1L << (LEVEL - 193)) | (1L << (LIBRARY - 193)) | (1L << (LIKE2 - 193)) | (1L << (LIKE4 - 193)) | (1L << (LIKEC - 193)) | (1L << (LIMIT - 193)) | (1L << (LOCAL - 193)) | (1L << (LOCKED - 193)) | (1L << (LOG - 193)) | (1L << (LOGOFF - 193)) | (1L << (LOGON - 193)) | (1L << (LONG - 193)) | (1L << (LOOP - 193)) | (1L << (MAIN - 193)) | (1L << (MAP - 193)) | (1L << (MATCHED - 193)) | (1L << (MAXVALUE - 193)) | (1L << (MEASURES - 193)) | (1L << (MEMBER - 193)) | (1L << (MERGE - 193)) | (1L << (MINUTE - 193)) | (1L << (MINVALUE - 193)) | (1L << (MLSLABEL - 193)) | (1L << (MODEL - 193)) | (1L << (MODIFY - 193)) | (1L << (MONTH - 193)) | (1L << (MULTISET - 193)) | (1L << (NAME - 193)) | (1L << (NAN - 193)) | (1L << (NATURAL - 193)) | (1L << (NATURALN - 193)) | (1L << (NAV - 193)) | (1L << (NCHAR - 193)) | (1L << (NCHAR_CS - 193)) | (1L << (NCLOB - 193)) | (1L << (NESTED - 193)) | (1L << (NEW - 193)) | (1L << (NO - 193)) | (1L << (NOAUDIT - 193)) | (1L << (NOCOPY - 193)) | (1L << (NOCYCLE - 193)) | (1L << (NOENTITYESCAPING - 193)) | (1L << (NONE - 193)) | (1L << (NOSCHEMACHECK - 193)) | (1L << (NOT - 193)) | (1L << (NULL - 193)) | (1L << (NULLS - 193)) | (1L << (NUMBER - 193)) | (1L << (NUMERIC - 193)) | (1L << (NVARCHAR2 - 193)))) != 0) || ((((_la - 257)) & ~0x3f) == 0 && ((1L << (_la - 257)) & ((1L << (OBJECT - 257)) | (1L << (OFF - 257)) | (1L << (OID - 257)) | (1L << (OLD - 257)) | (1L << (ONLY - 257)) | (1L << (OPEN - 257)) | (1L << (ORADATA - 257)) | (1L << (ORDINALITY - 257)) | (1L << (OSERROR - 257)) | (1L << (OUT - 257)) | (1L << (OUTER - 257)) | (1L << (OVER - 257)) | (1L << (OVERRIDING - 257)) | (1L << (PACKAGE - 257)) | (1L << (PARALLEL_ENABLE - 257)) | (1L << (PARAMETERS - 257)) | (1L << (PARENT - 257)) | (1L << (PARTITION - 257)) | (1L << (PASSING - 257)) | (1L << (PATH - 257)) | (1L << (PIPELINED - 257)) | (1L << (PLAN - 257)) | (1L << (PLS_INTEGER - 257)) | (1L << (POSITIVE - 257)) | (1L << (POSITIVEN - 257)) | (1L << (PRAGMA - 257)) | (1L << (PRECEDING - 257)) | (1L << (PRECISION - 257)) | (1L << (PRESENT - 257)) | (1L << (PRIOR - 257)) | (1L << (RAISE - 257)) | (1L << (RANGE - 257)) | (1L << (RAW - 257)) | (1L << (READ - 257)) | (1L << (REAL - 257)) | (1L << (RECORD - 257)) | (1L << (REF - 257)) | (1L << (REFERENCE - 257)) | (1L << (REFERENCING - 257)) | (1L << (REJECT - 257)) | (1L << (RELIES_ON - 257)) | (1L << (RENAME - 257)) | (1L << (REPLACE - 257)) | (1L << (RESPECT - 257)) | (1L << (RESTRICT_REFERENCES - 257)) | (1L << (RESULT - 257)) | (1L << (RESULT_CACHE - 257)) | (1L << (RETURN - 257)) | (1L << (RETURNING - 257)) | (1L << (REUSE - 257)) | (1L << (REVERSE - 257)))) != 0) || ((((_la - 322)) & ~0x3f) == 0 && ((1L << (_la - 322)) & ((1L << (RIGHT - 322)) | (1L << (ROLLBACK - 322)) | (1L << (ROLLUP - 322)) | (1L << (ROW - 322)) | (1L << (ROWID - 322)) | (1L << (ROWS - 322)) | (1L << (RULES - 322)) | (1L << (SAMPLE - 322)) | (1L << (SAVE - 322)) | (1L << (SAVEPOINT - 322)) | (1L << (SCHEMA - 322)) | (1L << (SCHEMACHECK - 322)) | (1L << (SCN - 322)) | (1L << (SECOND - 322)) | (1L << (SEED - 322)) | (1L << (SEGMENT - 322)) | (1L << (SELF - 322)) | (1L << (SEQUENTIAL - 322)) | (1L << (SERIALIZABLE - 322)) | (1L << (SERIALLY_REUSABLE - 322)) | (1L << (SERVERERROR - 322)) | (1L << (SESSIONTIMEZONE - 322)) | (1L << (SET - 322)) | (1L << (SETS - 322)) | (1L << (SETTINGS - 322)) | (1L << (SHOW - 322)) | (1L << (SHUTDOWN - 322)) | (1L << (SIBLINGS - 322)) | (1L << (SIGNTYPE - 322)) | (1L << (SIMPLE_INTEGER - 322)) | (1L << (SINGLE - 322)) | (1L << (SKIP_ - 322)) | (1L << (SMALLINT - 322)) | (1L << (SNAPSHOT - 322)) | (1L << (SOME - 322)) | (1L << (SPECIFICATION - 322)) | (1L << (SQLDATA - 322)) | (1L << (SQLERROR - 322)) | (1L << (STANDALONE - 322)) | (1L << (STARTUP - 322)) | (1L << (STATEMENT - 322)) | (1L << (STATEMENT_ID - 322)) | (1L << (STATIC - 322)) | (1L << (STATISTICS - 322)) | (1L << (STRING - 322)) | (1L << (SUBMULTISET - 322)) | (1L << (SUBPARTITION - 322)) | (1L << (SUBSTITUTABLE - 322)) | (1L << (SUBTYPE - 322)) | (1L << (SUCCESS - 322)) | (1L << (SUSPEND - 322)) | (1L << (TIME - 322)) | (1L << (TIMESTAMP - 322)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 322)))) != 0) || ((((_la - 386)) & ~0x3f) == 0 && ((1L << (_la - 386)) & ((1L << (TIMESTAMP_UNCONSTRAINED - 386)) | (1L << (TIMEZONE_ABBR - 386)) | (1L << (TIMEZONE_HOUR - 386)) | (1L << (TIMEZONE_MINUTE - 386)) | (1L << (TIMEZONE_REGION - 386)) | (1L << (TRAILING - 386)) | (1L << (TRANSACTION - 386)) | (1L << (TRANSLATE - 386)) | (1L << (TREAT - 386)) | (1L << (TRIGGER - 386)) | (1L << (TRUE - 386)) | (1L << (TRUNCATE - 386)) | (1L << (TYPE - 386)) | (1L << (UNBOUNDED - 386)) | (1L << (UNDER - 386)) | (1L << (UNLIMITED - 386)) | (1L << (UNTIL - 386)) | (1L << (UPDATED - 386)) | (1L << (UPSERT - 386)) | (1L << (UROWID - 386)) | (1L << (USE - 386)) | (1L << (VALIDATE - 386)) | (1L << (VALUE - 386)) | (1L << (VARCHAR - 386)) | (1L << (VARCHAR2 - 386)) | (1L << (VARIABLE - 386)) | (1L << (VARRAY - 386)) | (1L << (VARYING - 386)) | (1L << (VERSION - 386)) | (1L << (VERSIONS - 386)) | (1L << (WAIT - 386)) | (1L << (WARNING - 386)) | (1L << (WELLFORMED - 386)) | (1L << (WHENEVER - 386)) | (1L << (WHILE - 386)) | (1L << (WITHIN - 386)) | (1L << (WORK - 386)) | (1L << (WRITE - 386)) | (1L << (XML - 386)) | (1L << (XMLAGG - 386)) | (1L << (XMLATTRIBUTES - 386)) | (1L << (XMLCAST - 386)) | (1L << (XMLCOLATTVAL - 386)) | (1L << (XMLELEMENT - 386)) | (1L << (XMLEXISTS - 386)) | (1L << (XMLFOREST - 386)) | (1L << (XMLNAMESPACES - 386)) | (1L << (XMLPARSE - 386)) | (1L << (XMLPI - 386)) | (1L << (XMLQUERY - 386)) | (1L << (XMLROOT - 386)) | (1L << (XMLSERIALIZE - 386)) | (1L << (XMLTABLE - 386)) | (1L << (YEAR - 386)))) != 0) || ((((_la - 450)) & ~0x3f) == 0 && ((1L << (_la - 450)) & ((1L << (YES - 450)) | (1L << (YMINTERVAL_UNCONSTRAINED - 450)) | (1L << (ZONE - 450)) | (1L << (PREDICTION - 450)) | (1L << (PREDICTION_BOUNDS - 450)) | (1L << (PREDICTION_COST - 450)) | (1L << (PREDICTION_DETAILS - 450)) | (1L << (PREDICTION_PROBABILITY - 450)) | (1L << (PREDICTION_SET - 450)) | (1L << (CUME_DIST - 450)) | (1L << (DENSE_RANK - 450)) | (1L << (LISTAGG - 450)) | (1L << (PERCENT_RANK - 450)) | (1L << (PERCENTILE_CONT - 450)) | (1L << (PERCENTILE_DISC - 450)) | (1L << (RANK - 450)) | (1L << (AVG - 450)) | (1L << (CORR - 450)) | (1L << (COVAR_ - 450)) | (1L << (DECODE - 450)) | (1L << (LAG - 450)) | (1L << (LEAD - 450)) | (1L << (MAX - 450)) | (1L << (MEDIAN - 450)) | (1L << (MIN - 450)) | (1L << (NTILE - 450)) | (1L << (NVL - 450)) | (1L << (RATIO_TO_REPORT - 450)) | (1L << (REGR_ - 450)) | (1L << (ROUND - 450)) | (1L << (ROW_NUMBER - 450)) | (1L << (SUBSTR - 450)) | (1L << (TO_CHAR - 450)) | (1L << (TRIM - 450)) | (1L << (SUM - 450)) | (1L << (STDDEV - 450)) | (1L << (VAR_ - 450)) | (1L << (VARIANCE - 450)) | (1L << (NATIONAL_CHAR_STRING_LIT - 450)) | (1L << (UNSIGNED_INTEGER - 450)) | (1L << (APPROXIMATE_NUM_LIT - 450)) | (1L << (CHAR_STRING - 450)) | (1L << (DELIMITED_ID - 450)) | (1L << (LEFT_PAREN - 450)) | (1L << (PLUS_SIGN - 450)) | (1L << (MINUS_SIGN - 450)) | (1L << (BINDVAR - 450)) | (1L << (COLON - 450)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 3802; expression();
				}
			}

			State = 3809;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 3805; Match(COMMA);
				State = 3806; expression();
				}
				}
				State = 3811;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 3812; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConditionContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ConditionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_condition; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCondition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCondition(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCondition(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConditionContext condition() {
		ConditionContext _localctx = new ConditionContext(_ctx, State);
		EnterRule(_localctx, 494, RULE_condition);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3814; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionContext : ParserRuleContext {
		public Cursor_expressionContext cursor_expression() {
			return GetRuleContext<Cursor_expressionContext>(0);
		}
		public Logical_or_expressionContext logical_or_expression() {
			return GetRuleContext<Logical_or_expressionContext>(0);
		}
		public ExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionContext expression() {
		ExpressionContext _localctx = new ExpressionContext(_ctx, State);
		EnterRule(_localctx, 496, RULE_expression);
		try {
			State = 3818;
			switch ( Interpreter.AdaptivePredict(_input,463,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3816; cursor_expression();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3817; logical_or_expression(0);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Logical_or_expressionContext : ParserRuleContext {
		public Logical_or_expressionContext logical_or_expression() {
			return GetRuleContext<Logical_or_expressionContext>(0);
		}
		public ITerminalNode OR() { return GetToken(plsqlParser.OR, 0); }
		public Logical_and_expressionContext logical_and_expression() {
			return GetRuleContext<Logical_and_expressionContext>(0);
		}
		public Logical_or_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_logical_or_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterLogical_or_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitLogical_or_expression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogical_or_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Logical_or_expressionContext logical_or_expression() {
		return logical_or_expression(0);
	}

	private Logical_or_expressionContext logical_or_expression(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		Logical_or_expressionContext _localctx = new Logical_or_expressionContext(_ctx, _parentState);
		Logical_or_expressionContext _prevctx = _localctx;
		int _startState = 498;
		EnterRecursionRule(_localctx, 498, RULE_logical_or_expression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 3821; logical_and_expression(0);
			}
			_ctx.stop = _input.Lt(-1);
			State = 3828;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,464,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new Logical_or_expressionContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_logical_or_expression);
					State = 3823;
					if (!(Precpred(_ctx, 1))) throw new FailedPredicateException(this, "Precpred(_ctx, 1)");
					State = 3824; Match(OR);
					State = 3825; logical_and_expression(0);
					}
					} 
				}
				State = 3830;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,464,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class Logical_and_expressionContext : ParserRuleContext {
		public ITerminalNode AND() { return GetToken(plsqlParser.AND, 0); }
		public Negated_expressionContext negated_expression() {
			return GetRuleContext<Negated_expressionContext>(0);
		}
		public Logical_and_expressionContext logical_and_expression() {
			return GetRuleContext<Logical_and_expressionContext>(0);
		}
		public Logical_and_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_logical_and_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterLogical_and_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitLogical_and_expression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogical_and_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Logical_and_expressionContext logical_and_expression() {
		return logical_and_expression(0);
	}

	private Logical_and_expressionContext logical_and_expression(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		Logical_and_expressionContext _localctx = new Logical_and_expressionContext(_ctx, _parentState);
		Logical_and_expressionContext _prevctx = _localctx;
		int _startState = 500;
		EnterRecursionRule(_localctx, 500, RULE_logical_and_expression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 3832; negated_expression();
			}
			_ctx.stop = _input.Lt(-1);
			State = 3839;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,465,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new Logical_and_expressionContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_logical_and_expression);
					State = 3834;
					if (!(Precpred(_ctx, 1))) throw new FailedPredicateException(this, "Precpred(_ctx, 1)");
					State = 3835; Match(AND);
					State = 3836; negated_expression();
					}
					} 
				}
				State = 3841;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,465,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class Negated_expressionContext : ParserRuleContext {
		public ITerminalNode NOT() { return GetToken(plsqlParser.NOT, 0); }
		public Equality_expressionContext equality_expression() {
			return GetRuleContext<Equality_expressionContext>(0);
		}
		public Negated_expressionContext negated_expression() {
			return GetRuleContext<Negated_expressionContext>(0);
		}
		public Negated_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_negated_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterNegated_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitNegated_expression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNegated_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Negated_expressionContext negated_expression() {
		Negated_expressionContext _localctx = new Negated_expressionContext(_ctx, State);
		EnterRule(_localctx, 502, RULE_negated_expression);
		try {
			State = 3845;
			switch (_input.La(1)) {
			case NOT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3842; Match(NOT);
				State = 3843; negated_expression();
				}
				break;
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALL:
			case ANALYZE:
			case ANY:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CASE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COALESCE:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DISTINCT:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FALSE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NULL:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIOR:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUE:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case DECODE:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case NVL:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROUND:
			case ROW_NUMBER:
			case SUBSTR:
			case TO_CHAR:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case NATIONAL_CHAR_STRING_LIT:
			case UNSIGNED_INTEGER:
			case APPROXIMATE_NUM_LIT:
			case CHAR_STRING:
			case DELIMITED_ID:
			case LEFT_PAREN:
			case PLUS_SIGN:
			case MINUS_SIGN:
			case BINDVAR:
			case COLON:
			case INTRODUCER:
			case REGULAR_ID:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3844; equality_expression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Equality_expressionContext : ParserRuleContext {
		public IReadOnlyList<ITerminalNode> TYPE() { return GetTokens(plsqlParser.TYPE); }
		public IReadOnlyList<ITerminalNode> A_LETTER() { return GetTokens(plsqlParser.A_LETTER); }
		public ITerminalNode A_LETTER(int i) {
			return GetToken(plsqlParser.A_LETTER, i);
		}
		public IReadOnlyList<ITerminalNode> NOT() { return GetTokens(plsqlParser.NOT); }
		public IReadOnlyList<ITerminalNode> NULL() { return GetTokens(plsqlParser.NULL); }
		public IReadOnlyList<ITerminalNode> OF() { return GetTokens(plsqlParser.OF); }
		public IReadOnlyList<Type_specContext> type_spec() {
			return GetRuleContexts<Type_specContext>();
		}
		public IReadOnlyList<ITerminalNode> ONLY() { return GetTokens(plsqlParser.ONLY); }
		public ITerminalNode INFINITE(int i) {
			return GetToken(plsqlParser.INFINITE, i);
		}
		public ITerminalNode ONLY(int i) {
			return GetToken(plsqlParser.ONLY, i);
		}
		public ITerminalNode IS(int i) {
			return GetToken(plsqlParser.IS, i);
		}
		public IReadOnlyList<ITerminalNode> INFINITE() { return GetTokens(plsqlParser.INFINITE); }
		public IReadOnlyList<ITerminalNode> NAN() { return GetTokens(plsqlParser.NAN); }
		public Type_specContext type_spec(int i) {
			return GetRuleContext<Type_specContext>(i);
		}
		public ITerminalNode OF(int i) {
			return GetToken(plsqlParser.OF, i);
		}
		public ITerminalNode TYPE(int i) {
			return GetToken(plsqlParser.TYPE, i);
		}
		public IReadOnlyList<ITerminalNode> PRESENT() { return GetTokens(plsqlParser.PRESENT); }
		public Multiset_expressionContext multiset_expression() {
			return GetRuleContext<Multiset_expressionContext>(0);
		}
		public ITerminalNode NULL(int i) {
			return GetToken(plsqlParser.NULL, i);
		}
		public ITerminalNode PRESENT(int i) {
			return GetToken(plsqlParser.PRESENT, i);
		}
		public ITerminalNode SET(int i) {
			return GetToken(plsqlParser.SET, i);
		}
		public IReadOnlyList<ITerminalNode> IS() { return GetTokens(plsqlParser.IS); }
		public ITerminalNode EMPTY(int i) {
			return GetToken(plsqlParser.EMPTY, i);
		}
		public ITerminalNode NAN(int i) {
			return GetToken(plsqlParser.NAN, i);
		}
		public IReadOnlyList<ITerminalNode> EMPTY() { return GetTokens(plsqlParser.EMPTY); }
		public ITerminalNode NOT(int i) {
			return GetToken(plsqlParser.NOT, i);
		}
		public IReadOnlyList<ITerminalNode> SET() { return GetTokens(plsqlParser.SET); }
		public Equality_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_equality_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterEquality_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitEquality_expression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEquality_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Equality_expressionContext equality_expression() {
		Equality_expressionContext _localctx = new Equality_expressionContext(_ctx, State);
		EnterRule(_localctx, 504, RULE_equality_expression);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 3847; multiset_expression();
			State = 3881;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,472,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 3848; Match(IS);
					State = 3850;
					_la = _input.La(1);
					if (_la==NOT) {
						{
						State = 3849; Match(NOT);
						}
					}

					State = 3877;
					switch (_input.La(1)) {
					case NULL:
						{
						State = 3852; Match(NULL);
						}
						break;
					case NAN:
						{
						State = 3853; Match(NAN);
						}
						break;
					case PRESENT:
						{
						State = 3854; Match(PRESENT);
						}
						break;
					case INFINITE:
						{
						State = 3855; Match(INFINITE);
						}
						break;
					case A_LETTER:
						{
						State = 3856; Match(A_LETTER);
						State = 3857; Match(SET);
						}
						break;
					case EMPTY:
						{
						State = 3858; Match(EMPTY);
						}
						break;
					case OF:
						{
						State = 3859; Match(OF);
						State = 3861;
						_la = _input.La(1);
						if (_la==TYPE) {
							{
							State = 3860; Match(TYPE);
							}
						}

						State = 3863; Match(LEFT_PAREN);
						State = 3865;
						switch ( Interpreter.AdaptivePredict(_input,469,_ctx) ) {
						case 1:
							{
							State = 3864; Match(ONLY);
							}
							break;
						}
						State = 3867; type_spec();
						State = 3872;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==COMMA) {
							{
							{
							State = 3868; Match(COMMA);
							State = 3869; type_spec();
							}
							}
							State = 3874;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 3875; Match(RIGHT_PAREN);
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					} 
				}
				State = 3883;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,472,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Multiset_expressionContext : ParserRuleContext {
		public Relational_expressionContext relational_expression() {
			return GetRuleContext<Relational_expressionContext>(0);
		}
		public ITerminalNode OF() { return GetToken(plsqlParser.OF, 0); }
		public ConcatenationContext concatenation() {
			return GetRuleContext<ConcatenationContext>(0);
		}
		public Multiset_typeContext multiset_type() {
			return GetRuleContext<Multiset_typeContext>(0);
		}
		public Multiset_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multiset_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterMultiset_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitMultiset_expression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultiset_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Multiset_expressionContext multiset_expression() {
		Multiset_expressionContext _localctx = new Multiset_expressionContext(_ctx, State);
		EnterRule(_localctx, 506, RULE_multiset_expression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3884; relational_expression(0);
			State = 3891;
			switch ( Interpreter.AdaptivePredict(_input,474,_ctx) ) {
			case 1:
				{
				State = 3885; multiset_type();
				State = 3887;
				_la = _input.La(1);
				if (_la==OF) {
					{
					State = 3886; Match(OF);
					}
				}

				State = 3889; concatenation();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Multiset_typeContext : ParserRuleContext {
		public ITerminalNode SUBMULTISET() { return GetToken(plsqlParser.SUBMULTISET, 0); }
		public ITerminalNode MEMBER() { return GetToken(plsqlParser.MEMBER, 0); }
		public Multiset_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multiset_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterMultiset_type(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitMultiset_type(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultiset_type(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Multiset_typeContext multiset_type() {
		Multiset_typeContext _localctx = new Multiset_typeContext(_ctx, State);
		EnterRule(_localctx, 508, RULE_multiset_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3893;
			_la = _input.La(1);
			if ( !(_la==MEMBER || _la==SUBMULTISET) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Relational_expressionContext : ParserRuleContext {
		public IReadOnlyList<Relational_expressionContext> relational_expression() {
			return GetRuleContexts<Relational_expressionContext>();
		}
		public Relational_operatorContext relational_operator() {
			return GetRuleContext<Relational_operatorContext>(0);
		}
		public Relational_expressionContext relational_expression(int i) {
			return GetRuleContext<Relational_expressionContext>(i);
		}
		public Compound_expressionContext compound_expression() {
			return GetRuleContext<Compound_expressionContext>(0);
		}
		public Relational_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_relational_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterRelational_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitRelational_expression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRelational_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Relational_expressionContext relational_expression() {
		return relational_expression(0);
	}

	private Relational_expressionContext relational_expression(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		Relational_expressionContext _localctx = new Relational_expressionContext(_ctx, _parentState);
		Relational_expressionContext _prevctx = _localctx;
		int _startState = 510;
		EnterRecursionRule(_localctx, 510, RULE_relational_expression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 3896; compound_expression();
			}
			_ctx.stop = _input.Lt(-1);
			State = 3904;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,475,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new Relational_expressionContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_relational_expression);
					State = 3898;
					if (!(Precpred(_ctx, 2))) throw new FailedPredicateException(this, "Precpred(_ctx, 2)");
					State = 3899; relational_operator();
					State = 3900; relational_expression(3);
					}
					} 
				}
				State = 3906;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,475,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class Compound_expressionContext : ParserRuleContext {
		public ITerminalNode NOT() { return GetToken(plsqlParser.NOT, 0); }
		public ConcatenationContext concatenation(int i) {
			return GetRuleContext<ConcatenationContext>(i);
		}
		public Like_escape_partContext like_escape_part() {
			return GetRuleContext<Like_escape_partContext>(0);
		}
		public ITerminalNode BETWEEN() { return GetToken(plsqlParser.BETWEEN, 0); }
		public In_elementsContext in_elements() {
			return GetRuleContext<In_elementsContext>(0);
		}
		public Between_elementsContext between_elements() {
			return GetRuleContext<Between_elementsContext>(0);
		}
		public IReadOnlyList<ConcatenationContext> concatenation() {
			return GetRuleContexts<ConcatenationContext>();
		}
		public Like_typeContext like_type() {
			return GetRuleContext<Like_typeContext>(0);
		}
		public ITerminalNode IN() { return GetToken(plsqlParser.IN, 0); }
		public Compound_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compound_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCompound_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCompound_expression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompound_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Compound_expressionContext compound_expression() {
		Compound_expressionContext _localctx = new Compound_expressionContext(_ctx, State);
		EnterRule(_localctx, 512, RULE_compound_expression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3907; concatenation();
			State = 3922;
			switch ( Interpreter.AdaptivePredict(_input,479,_ctx) ) {
			case 1:
				{
				State = 3909;
				_la = _input.La(1);
				if (_la==NOT) {
					{
					State = 3908; Match(NOT);
					}
				}

				State = 3920;
				switch (_input.La(1)) {
				case IN:
					{
					State = 3911; Match(IN);
					State = 3912; in_elements();
					}
					break;
				case BETWEEN:
					{
					State = 3913; Match(BETWEEN);
					State = 3914; between_elements();
					}
					break;
				case LIKE:
				case LIKE2:
				case LIKE4:
				case LIKEC:
					{
					State = 3915; like_type();
					State = 3916; concatenation();
					State = 3918;
					switch ( Interpreter.AdaptivePredict(_input,477,_ctx) ) {
					case 1:
						{
						State = 3917; like_escape_part();
						}
						break;
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Relational_operatorContext : ParserRuleContext {
		public Not_equal_opContext not_equal_op() {
			return GetRuleContext<Not_equal_opContext>(0);
		}
		public Greater_than_or_equals_opContext greater_than_or_equals_op() {
			return GetRuleContext<Greater_than_or_equals_opContext>(0);
		}
		public Less_than_or_equals_opContext less_than_or_equals_op() {
			return GetRuleContext<Less_than_or_equals_opContext>(0);
		}
		public Relational_operatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_relational_operator; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterRelational_operator(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitRelational_operator(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRelational_operator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Relational_operatorContext relational_operator() {
		Relational_operatorContext _localctx = new Relational_operatorContext(_ctx, State);
		EnterRule(_localctx, 514, RULE_relational_operator);
		try {
			State = 3930;
			switch ( Interpreter.AdaptivePredict(_input,480,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3924; Match(EQUALS_OP);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3925; not_equal_op();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3926; Match(LESS_THAN_OP);
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 3927; Match(GREATER_THAN_OP);
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 3928; less_than_or_equals_op();
				}
				break;

			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 3929; greater_than_or_equals_op();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Like_typeContext : ParserRuleContext {
		public ITerminalNode LIKE4() { return GetToken(plsqlParser.LIKE4, 0); }
		public ITerminalNode LIKEC() { return GetToken(plsqlParser.LIKEC, 0); }
		public ITerminalNode LIKE2() { return GetToken(plsqlParser.LIKE2, 0); }
		public ITerminalNode LIKE() { return GetToken(plsqlParser.LIKE, 0); }
		public Like_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_like_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterLike_type(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitLike_type(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLike_type(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Like_typeContext like_type() {
		Like_typeContext _localctx = new Like_typeContext(_ctx, State);
		EnterRule(_localctx, 516, RULE_like_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3932;
			_la = _input.La(1);
			if ( !(((((_la - 200)) & ~0x3f) == 0 && ((1L << (_la - 200)) & ((1L << (LIKE - 200)) | (1L << (LIKE2 - 200)) | (1L << (LIKE4 - 200)) | (1L << (LIKEC - 200)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Like_escape_partContext : ParserRuleContext {
		public ITerminalNode ESCAPE() { return GetToken(plsqlParser.ESCAPE, 0); }
		public ConcatenationContext concatenation() {
			return GetRuleContext<ConcatenationContext>(0);
		}
		public Like_escape_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_like_escape_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterLike_escape_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitLike_escape_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLike_escape_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Like_escape_partContext like_escape_part() {
		Like_escape_partContext _localctx = new Like_escape_partContext(_ctx, State);
		EnterRule(_localctx, 518, RULE_like_escape_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3934; Match(ESCAPE);
			State = 3935; concatenation();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class In_elementsContext : ParserRuleContext {
		public ConcatenationContext concatenation(int i) {
			return GetRuleContext<ConcatenationContext>(i);
		}
		public Bind_variableContext bind_variable() {
			return GetRuleContext<Bind_variableContext>(0);
		}
		public ConstantContext constant() {
			return GetRuleContext<ConstantContext>(0);
		}
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public IReadOnlyList<ConcatenationContext> concatenation() {
			return GetRuleContexts<ConcatenationContext>();
		}
		public General_elementContext general_element() {
			return GetRuleContext<General_elementContext>(0);
		}
		public In_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_in_elements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterIn_elements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitIn_elements(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIn_elements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public In_elementsContext in_elements() {
		In_elementsContext _localctx = new In_elementsContext(_ctx, State);
		EnterRule(_localctx, 520, RULE_in_elements);
		int _la;
		try {
			State = 3955;
			switch ( Interpreter.AdaptivePredict(_input,482,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3937; Match(LEFT_PAREN);
				State = 3938; subquery();
				State = 3939; Match(RIGHT_PAREN);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3941; Match(LEFT_PAREN);
				State = 3942; concatenation();
				State = 3947;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 3943; Match(COMMA);
					State = 3944; concatenation();
					}
					}
					State = 3949;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 3950; Match(RIGHT_PAREN);
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3952; constant();
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 3953; bind_variable();
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 3954; general_element();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Between_elementsContext : ParserRuleContext {
		public ConcatenationContext concatenation(int i) {
			return GetRuleContext<ConcatenationContext>(i);
		}
		public IReadOnlyList<ConcatenationContext> concatenation() {
			return GetRuleContexts<ConcatenationContext>();
		}
		public ITerminalNode AND() { return GetToken(plsqlParser.AND, 0); }
		public Between_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_between_elements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterBetween_elements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitBetween_elements(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBetween_elements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Between_elementsContext between_elements() {
		Between_elementsContext _localctx = new Between_elementsContext(_ctx, State);
		EnterRule(_localctx, 522, RULE_between_elements);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3957; concatenation();
			State = 3958; Match(AND);
			State = 3959; concatenation();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConcatenationContext : ParserRuleContext {
		public Additive_expressionContext additive_expression(int i) {
			return GetRuleContext<Additive_expressionContext>(i);
		}
		public IReadOnlyList<Concatenation_opContext> concatenation_op() {
			return GetRuleContexts<Concatenation_opContext>();
		}
		public IReadOnlyList<Additive_expressionContext> additive_expression() {
			return GetRuleContexts<Additive_expressionContext>();
		}
		public Concatenation_opContext concatenation_op(int i) {
			return GetRuleContext<Concatenation_opContext>(i);
		}
		public ConcatenationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_concatenation; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterConcatenation(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitConcatenation(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConcatenation(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConcatenationContext concatenation() {
		ConcatenationContext _localctx = new ConcatenationContext(_ctx, State);
		EnterRule(_localctx, 524, RULE_concatenation);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 3961; additive_expression();
			State = 3967;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,483,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 3962; concatenation_op();
					State = 3963; additive_expression();
					}
					} 
				}
				State = 3969;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,483,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Additive_expressionContext : ParserRuleContext {
		public IToken s503;
		public IList<IToken> _op = new List<IToken>();
		public IToken s504;
		public IToken _tset6984;
		public Multiply_expressionContext multiply_expression(int i) {
			return GetRuleContext<Multiply_expressionContext>(i);
		}
		public IReadOnlyList<Multiply_expressionContext> multiply_expression() {
			return GetRuleContexts<Multiply_expressionContext>();
		}
		public Additive_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_additive_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterAdditive_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitAdditive_expression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAdditive_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Additive_expressionContext additive_expression() {
		Additive_expressionContext _localctx = new Additive_expressionContext(_ctx, State);
		EnterRule(_localctx, 526, RULE_additive_expression);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 3970; multiply_expression();
			State = 3975;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,484,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 3971;
					_localctx._tset6984 = _input.Lt(1);
					_la = _input.La(1);
					if ( !(_la==PLUS_SIGN || _la==MINUS_SIGN) ) {
						_localctx._tset6984 = _errHandler.RecoverInline(this);
					}
					Consume();
					_localctx._op.Add(_localctx._tset6984);
					State = 3972; multiply_expression();
					}
					} 
				}
				State = 3977;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,484,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Multiply_expressionContext : ParserRuleContext {
		public IToken s502;
		public IList<IToken> _op = new List<IToken>();
		public IToken s506;
		public IToken _tset7007;
		public Datetime_expressionContext datetime_expression(int i) {
			return GetRuleContext<Datetime_expressionContext>(i);
		}
		public IReadOnlyList<Datetime_expressionContext> datetime_expression() {
			return GetRuleContexts<Datetime_expressionContext>();
		}
		public Multiply_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multiply_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterMultiply_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitMultiply_expression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultiply_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Multiply_expressionContext multiply_expression() {
		Multiply_expressionContext _localctx = new Multiply_expressionContext(_ctx, State);
		EnterRule(_localctx, 528, RULE_multiply_expression);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 3978; datetime_expression();
			State = 3983;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,485,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 3979;
					_localctx._tset7007 = _input.Lt(1);
					_la = _input.La(1);
					if ( !(_la==ASTERISK || _la==SOLIDUS) ) {
						_localctx._tset7007 = _errHandler.RecoverInline(this);
					}
					Consume();
					_localctx._op.Add(_localctx._tset7007);
					State = 3980; datetime_expression();
					}
					} 
				}
				State = 3985;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,485,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Datetime_expressionContext : ParserRuleContext {
		public ITerminalNode AT() { return GetToken(plsqlParser.AT, 0); }
		public ITerminalNode ZONE() { return GetToken(plsqlParser.ZONE, 0); }
		public Interval_expressionContext interval_expression() {
			return GetRuleContext<Interval_expressionContext>(0);
		}
		public ITerminalNode TIME() { return GetToken(plsqlParser.TIME, 0); }
		public Model_expressionContext model_expression() {
			return GetRuleContext<Model_expressionContext>(0);
		}
		public ConcatenationContext concatenation() {
			return GetRuleContext<ConcatenationContext>(0);
		}
		public ITerminalNode LOCAL() { return GetToken(plsqlParser.LOCAL, 0); }
		public Datetime_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_datetime_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterDatetime_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitDatetime_expression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDatetime_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Datetime_expressionContext datetime_expression() {
		Datetime_expressionContext _localctx = new Datetime_expressionContext(_ctx, State);
		EnterRule(_localctx, 530, RULE_datetime_expression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3986; model_expression();
			State = 3995;
			switch ( Interpreter.AdaptivePredict(_input,487,_ctx) ) {
			case 1:
				{
				State = 3987; Match(AT);
				State = 3992;
				switch (_input.La(1)) {
				case LOCAL:
					{
					State = 3988; Match(LOCAL);
					}
					break;
				case TIME:
					{
					State = 3989; Match(TIME);
					State = 3990; Match(ZONE);
					State = 3991; concatenation();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;

			case 2:
				{
				State = 3994; interval_expression();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Interval_expressionContext : ParserRuleContext {
		public ConcatenationContext concatenation(int i) {
			return GetRuleContext<ConcatenationContext>(i);
		}
		public ITerminalNode SECOND() { return GetToken(plsqlParser.SECOND, 0); }
		public IReadOnlyList<ConcatenationContext> concatenation() {
			return GetRuleContexts<ConcatenationContext>();
		}
		public ITerminalNode TO() { return GetToken(plsqlParser.TO, 0); }
		public ITerminalNode MONTH() { return GetToken(plsqlParser.MONTH, 0); }
		public ITerminalNode DAY() { return GetToken(plsqlParser.DAY, 0); }
		public ITerminalNode YEAR() { return GetToken(plsqlParser.YEAR, 0); }
		public Interval_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_interval_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterInterval_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitInterval_expression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInterval_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Interval_expressionContext interval_expression() {
		Interval_expressionContext _localctx = new Interval_expressionContext(_ctx, State);
		EnterRule(_localctx, 532, RULE_interval_expression);
		int _la;
		try {
			State = 4021;
			switch (_input.La(1)) {
			case DAY:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3997; Match(DAY);
				State = 4002;
				_la = _input.La(1);
				if (_la==LEFT_PAREN) {
					{
					State = 3998; Match(LEFT_PAREN);
					State = 3999; concatenation();
					State = 4000; Match(RIGHT_PAREN);
					}
				}

				State = 4004; Match(TO);
				State = 4005; Match(SECOND);
				State = 4010;
				switch ( Interpreter.AdaptivePredict(_input,489,_ctx) ) {
				case 1:
					{
					State = 4006; Match(LEFT_PAREN);
					State = 4007; concatenation();
					State = 4008; Match(RIGHT_PAREN);
					}
					break;
				}
				}
				break;
			case YEAR:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4012; Match(YEAR);
				State = 4017;
				_la = _input.La(1);
				if (_la==LEFT_PAREN) {
					{
					State = 4013; Match(LEFT_PAREN);
					State = 4014; concatenation();
					State = 4015; Match(RIGHT_PAREN);
					}
				}

				State = 4019; Match(TO);
				State = 4020; Match(MONTH);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Model_expressionContext : ParserRuleContext {
		public Unary_expressionContext unary_expression() {
			return GetRuleContext<Unary_expressionContext>(0);
		}
		public Model_expression_elementContext model_expression_element() {
			return GetRuleContext<Model_expression_elementContext>(0);
		}
		public Model_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_model_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterModel_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitModel_expression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModel_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Model_expressionContext model_expression() {
		Model_expressionContext _localctx = new Model_expressionContext(_ctx, State);
		EnterRule(_localctx, 534, RULE_model_expression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4023; unary_expression();
			State = 4028;
			switch ( Interpreter.AdaptivePredict(_input,492,_ctx) ) {
			case 1:
				{
				State = 4024; Match(LEFT_BRACKET);
				State = 4025; model_expression_element();
				State = 4026; Match(RIGHT_BRACKET);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Model_expression_elementContext : ParserRuleContext {
		public IReadOnlyList<Single_column_for_loopContext> single_column_for_loop() {
			return GetRuleContexts<Single_column_for_loopContext>();
		}
		public ITerminalNode ANY(int i) {
			return GetToken(plsqlParser.ANY, i);
		}
		public Multi_column_for_loopContext multi_column_for_loop() {
			return GetRuleContext<Multi_column_for_loopContext>(0);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public IReadOnlyList<ITerminalNode> ANY() { return GetTokens(plsqlParser.ANY); }
		public Single_column_for_loopContext single_column_for_loop(int i) {
			return GetRuleContext<Single_column_for_loopContext>(i);
		}
		public Model_expression_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_model_expression_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterModel_expression_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitModel_expression_element(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModel_expression_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Model_expression_elementContext model_expression_element() {
		Model_expression_elementContext _localctx = new Model_expression_elementContext(_ctx, State);
		EnterRule(_localctx, 536, RULE_model_expression_element);
		int _la;
		try {
			State = 4053;
			switch ( Interpreter.AdaptivePredict(_input,497,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4032;
				switch ( Interpreter.AdaptivePredict(_input,493,_ctx) ) {
				case 1:
					{
					State = 4030; Match(ANY);
					}
					break;

				case 2:
					{
					State = 4031; expression();
					}
					break;
				}
				State = 4041;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 4034; Match(COMMA);
					State = 4037;
					switch ( Interpreter.AdaptivePredict(_input,494,_ctx) ) {
					case 1:
						{
						State = 4035; Match(ANY);
						}
						break;

					case 2:
						{
						State = 4036; expression();
						}
						break;
					}
					}
					}
					State = 4043;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4044; single_column_for_loop();
				State = 4049;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 4045; Match(COMMA);
					State = 4046; single_column_for_loop();
					}
					}
					State = 4051;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4052; multi_column_for_loop();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Single_column_for_loopContext : ParserRuleContext {
		public ExpressionContext ex1;
		public ExpressionContext ex2;
		public ExpressionContext ex3;
		public Expression_listContext expression_list() {
			return GetRuleContext<Expression_listContext>(0);
		}
		public Column_nameContext column_name() {
			return GetRuleContext<Column_nameContext>(0);
		}
		public For_like_partContext for_like_part() {
			return GetRuleContext<For_like_partContext>(0);
		}
		public ITerminalNode FOR() { return GetToken(plsqlParser.FOR, 0); }
		public For_increment_decrement_typeContext for_increment_decrement_type() {
			return GetRuleContext<For_increment_decrement_typeContext>(0);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode FROM() { return GetToken(plsqlParser.FROM, 0); }
		public ITerminalNode TO() { return GetToken(plsqlParser.TO, 0); }
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode IN() { return GetToken(plsqlParser.IN, 0); }
		public Single_column_for_loopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_single_column_for_loop; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSingle_column_for_loop(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSingle_column_for_loop(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSingle_column_for_loop(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Single_column_for_loopContext single_column_for_loop() {
		Single_column_for_loopContext _localctx = new Single_column_for_loopContext(_ctx, State);
		EnterRule(_localctx, 538, RULE_single_column_for_loop);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4055; Match(FOR);
			State = 4056; column_name();
			State = 4069;
			switch (_input.La(1)) {
			case IN:
				{
				State = 4057; Match(IN);
				State = 4058; expression_list();
				}
				break;
			case FROM:
			case LIKE:
				{
				State = 4060;
				_la = _input.La(1);
				if (_la==LIKE) {
					{
					State = 4059; for_like_part();
					}
				}

				State = 4062; Match(FROM);
				State = 4063; _localctx.ex1 = expression();
				State = 4064; Match(TO);
				State = 4065; _localctx.ex2 = expression();
				State = 4066; for_increment_decrement_type();
				State = 4067; _localctx.ex3 = expression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class For_like_partContext : ParserRuleContext {
		public ITerminalNode LIKE() { return GetToken(plsqlParser.LIKE, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public For_like_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_for_like_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterFor_like_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitFor_like_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFor_like_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public For_like_partContext for_like_part() {
		For_like_partContext _localctx = new For_like_partContext(_ctx, State);
		EnterRule(_localctx, 540, RULE_for_like_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4071; Match(LIKE);
			State = 4072; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class For_increment_decrement_typeContext : ParserRuleContext {
		public ITerminalNode INCREMENT() { return GetToken(plsqlParser.INCREMENT, 0); }
		public ITerminalNode DECREMENT() { return GetToken(plsqlParser.DECREMENT, 0); }
		public For_increment_decrement_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_for_increment_decrement_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterFor_increment_decrement_type(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitFor_increment_decrement_type(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFor_increment_decrement_type(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public For_increment_decrement_typeContext for_increment_decrement_type() {
		For_increment_decrement_typeContext _localctx = new For_increment_decrement_typeContext(_ctx, State);
		EnterRule(_localctx, 542, RULE_for_increment_decrement_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4074;
			_la = _input.La(1);
			if ( !(_la==DECREMENT || _la==INCREMENT) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Multi_column_for_loopContext : ParserRuleContext {
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public IReadOnlyList<Expression_listContext> expression_list() {
			return GetRuleContexts<Expression_listContext>();
		}
		public IReadOnlyList<Column_nameContext> column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public Expression_listContext expression_list(int i) {
			return GetRuleContext<Expression_listContext>(i);
		}
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public ITerminalNode FOR() { return GetToken(plsqlParser.FOR, 0); }
		public ITerminalNode IN() { return GetToken(plsqlParser.IN, 0); }
		public Multi_column_for_loopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multi_column_for_loop; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterMulti_column_for_loop(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitMulti_column_for_loop(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMulti_column_for_loop(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Multi_column_for_loopContext multi_column_for_loop() {
		Multi_column_for_loopContext _localctx = new Multi_column_for_loopContext(_ctx, State);
		EnterRule(_localctx, 544, RULE_multi_column_for_loop);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4076; Match(FOR);
			State = 4077; Match(LEFT_PAREN);
			State = 4078; column_name();
			State = 4083;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 4079; Match(COMMA);
				State = 4080; column_name();
				}
				}
				State = 4085;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 4086; Match(RIGHT_PAREN);
			State = 4087; Match(IN);
			State = 4088; Match(LEFT_PAREN);
			State = 4101;
			switch ( Interpreter.AdaptivePredict(_input,502,_ctx) ) {
			case 1:
				{
				State = 4089; subquery();
				}
				break;

			case 2:
				{
				State = 4090; Match(LEFT_PAREN);
				State = 4091; expression_list();
				State = 4096;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 4092; Match(COMMA);
					State = 4093; expression_list();
					}
					}
					State = 4098;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 4099; Match(RIGHT_PAREN);
				}
				break;
			}
			State = 4103; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Unary_expressionContext : ParserRuleContext {
		public Case_statementContext case_statement() {
			return GetRuleContext<Case_statementContext>(0);
		}
		public Standard_functionContext standard_function() {
			return GetRuleContext<Standard_functionContext>(0);
		}
		public Unary_expressionContext unary_expression() {
			return GetRuleContext<Unary_expressionContext>(0);
		}
		public ITerminalNode CONNECT_BY_ROOT() { return GetToken(plsqlParser.CONNECT_BY_ROOT, 0); }
		public Quantified_expressionContext quantified_expression() {
			return GetRuleContext<Quantified_expressionContext>(0);
		}
		public ITerminalNode DISTINCT() { return GetToken(plsqlParser.DISTINCT, 0); }
		public ITerminalNode NEW() { return GetToken(plsqlParser.NEW, 0); }
		public AtomContext atom() {
			return GetRuleContext<AtomContext>(0);
		}
		public ITerminalNode PRIOR() { return GetToken(plsqlParser.PRIOR, 0); }
		public ITerminalNode ALL() { return GetToken(plsqlParser.ALL, 0); }
		public Unary_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unary_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterUnary_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitUnary_expression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnary_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Unary_expressionContext unary_expression() {
		Unary_expressionContext _localctx = new Unary_expressionContext(_ctx, State);
		EnterRule(_localctx, 546, RULE_unary_expression);
		int _la;
		try {
			State = 4121;
			switch ( Interpreter.AdaptivePredict(_input,503,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4105;
				_la = _input.La(1);
				if ( !(_la==PLUS_SIGN || _la==MINUS_SIGN) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				State = 4106; unary_expression();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4107; Match(PRIOR);
				State = 4108; unary_expression();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4109; Match(CONNECT_BY_ROOT);
				State = 4110; unary_expression();
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 4111; Match(NEW);
				State = 4112; unary_expression();
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 4113; Match(DISTINCT);
				State = 4114; unary_expression();
				}
				break;

			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 4115; Match(ALL);
				State = 4116; unary_expression();
				}
				break;

			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 4117; case_statement();
				}
				break;

			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 4118; quantified_expression();
				}
				break;

			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 4119; standard_function();
				}
				break;

			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 4120; atom();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Case_statementContext : ParserRuleContext {
		public Searched_case_statementContext searched_case_statement() {
			return GetRuleContext<Searched_case_statementContext>(0);
		}
		public Simple_case_statementContext simple_case_statement() {
			return GetRuleContext<Simple_case_statementContext>(0);
		}
		public Case_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_case_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCase_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCase_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCase_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Case_statementContext case_statement() {
		Case_statementContext _localctx = new Case_statementContext(_ctx, State);
		EnterRule(_localctx, 548, RULE_case_statement);
		try {
			State = 4125;
			switch ( Interpreter.AdaptivePredict(_input,504,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4123; searched_case_statement();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4124; simple_case_statement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Simple_case_statementContext : ParserRuleContext {
		public IToken ck1;
		public IReadOnlyList<ITerminalNode> CASE() { return GetTokens(plsqlParser.CASE); }
		public Simple_case_when_partContext simple_case_when_part(int i) {
			return GetRuleContext<Simple_case_when_partContext>(i);
		}
		public IReadOnlyList<Label_nameContext> label_name() {
			return GetRuleContexts<Label_nameContext>();
		}
		public Label_nameContext label_name(int i) {
			return GetRuleContext<Label_nameContext>(i);
		}
		public IReadOnlyList<Simple_case_when_partContext> simple_case_when_part() {
			return GetRuleContexts<Simple_case_when_partContext>();
		}
		public ITerminalNode END() { return GetToken(plsqlParser.END, 0); }
		public Case_else_partContext case_else_part() {
			return GetRuleContext<Case_else_partContext>(0);
		}
		public AtomContext atom() {
			return GetRuleContext<AtomContext>(0);
		}
		public ITerminalNode CASE(int i) {
			return GetToken(plsqlParser.CASE, i);
		}
		public Simple_case_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simple_case_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSimple_case_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSimple_case_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSimple_case_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Simple_case_statementContext simple_case_statement() {
		Simple_case_statementContext _localctx = new Simple_case_statementContext(_ctx, State);
		EnterRule(_localctx, 550, RULE_simple_case_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4128;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (CONSTANT - 66)) | (1L << (CONSTRAINT - 66)) | (1L << (CONSTRAINTS - 66)) | (1L << (CONSTRUCTOR - 66)) | (1L << (CONTENT - 66)) | (1L << (CONTEXT - 66)) | (1L << (CONTINUE - 66)) | (1L << (CONVERT - 66)) | (1L << (CORRUPT_XID - 66)) | (1L << (CORRUPT_XID_ALL - 66)) | (1L << (COST - 66)) | (1L << (COUNT - 66)) | (1L << (CROSS - 66)) | (1L << (CUBE - 66)) | (1L << (CURRENT_USER - 66)) | (1L << (CURSOR - 66)) | (1L << (CUSTOMDATUM - 66)) | (1L << (CYCLE - 66)) | (1L << (DATA - 66)) | (1L << (DATABASE - 66)) | (1L << (DAY - 66)) | (1L << (DB_ROLE_CHANGE - 66)) | (1L << (DBTIMEZONE - 66)) | (1L << (DDL - 66)) | (1L << (DEBUG - 66)) | (1L << (DEC - 66)) | (1L << (DECIMAL - 66)) | (1L << (DECOMPOSE - 66)) | (1L << (DECREMENT - 66)) | (1L << (DEFAULTS - 66)) | (1L << (DEFERRED - 66)) | (1L << (DEFINER - 66)) | (1L << (DETERMINISTIC - 66)) | (1L << (DIMENSION - 66)) | (1L << (DISABLE - 66)) | (1L << (DISASSOCIATE - 66)) | (1L << (DOCUMENT - 66)) | (1L << (DOUBLE - 66)) | (1L << (DSINTERVAL_UNCONSTRAINED - 66)) | (1L << (EACH - 66)) | (1L << (ELEMENT - 66)) | (1L << (EMPTY - 66)) | (1L << (ENABLE - 66)) | (1L << (ENCODING - 66)) | (1L << (ENTITYESCAPING - 66)) | (1L << (ERR - 66)) | (1L << (ERRORS - 66)) | (1L << (ESCAPE - 66)) | (1L << (EVALNAME - 66)) | (1L << (EXCEPTION - 66)) | (1L << (EXCEPTION_INIT - 66)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)) | (1L << (EXIT - 130)) | (1L << (EXPLAIN - 130)) | (1L << (EXTERNAL - 130)) | (1L << (EXTRACT - 130)) | (1L << (FAILURE - 130)) | (1L << (FINAL - 130)) | (1L << (FIRST - 130)) | (1L << (FIRST_VALUE - 130)) | (1L << (FLOAT - 130)) | (1L << (FOLLOWING - 130)) | (1L << (FOLLOWS - 130)) | (1L << (FORALL - 130)) | (1L << (FORCE - 130)) | (1L << (FULL - 130)) | (1L << (FUNCTION - 130)) | (1L << (GROUPING - 130)) | (1L << (HASH - 130)) | (1L << (HIDE - 130)) | (1L << (HOUR - 130)) | (1L << (IGNORE - 130)) | (1L << (IMMEDIATE - 130)) | (1L << (INCLUDE - 130)) | (1L << (INCLUDING - 130)) | (1L << (INCREMENT - 130)) | (1L << (INDENT - 130)) | (1L << (INDEXED - 130)) | (1L << (INDICATOR - 130)) | (1L << (INDICES - 130)) | (1L << (INFINITE - 130)) | (1L << (INLINE - 130)) | (1L << (INNER - 130)) | (1L << (INOUT - 130)) | (1L << (INSTANTIABLE - 130)) | (1L << (INSTEAD - 130)) | (1L << (INT - 130)) | (1L << (INTEGER - 130)) | (1L << (INTERVAL - 130)) | (1L << (INVALIDATE - 130)) | (1L << (ISOLATION - 130)) | (1L << (ITERATE - 130)) | (1L << (JAVA - 130)) | (1L << (JOIN - 130)) | (1L << (KEEP - 130)) | (1L << (LANGUAGE - 130)))) != 0) || ((((_la - 194)) & ~0x3f) == 0 && ((1L << (_la - 194)) & ((1L << (LAST - 194)) | (1L << (LAST_VALUE - 194)) | (1L << (LEADING - 194)) | (1L << (LEFT - 194)) | (1L << (LEVEL - 194)) | (1L << (LIBRARY - 194)) | (1L << (LIKE2 - 194)) | (1L << (LIKE4 - 194)) | (1L << (LIKEC - 194)) | (1L << (LIMIT - 194)) | (1L << (LOCAL - 194)) | (1L << (LOCKED - 194)) | (1L << (LOG - 194)) | (1L << (LOGOFF - 194)) | (1L << (LOGON - 194)) | (1L << (LONG - 194)) | (1L << (LOOP - 194)) | (1L << (MAIN - 194)) | (1L << (MAP - 194)) | (1L << (MATCHED - 194)) | (1L << (MAXVALUE - 194)) | (1L << (MEASURES - 194)) | (1L << (MEMBER - 194)) | (1L << (MERGE - 194)) | (1L << (MINUTE - 194)) | (1L << (MINVALUE - 194)) | (1L << (MLSLABEL - 194)) | (1L << (MODEL - 194)) | (1L << (MODIFY - 194)) | (1L << (MONTH - 194)) | (1L << (MULTISET - 194)) | (1L << (NAME - 194)) | (1L << (NAN - 194)) | (1L << (NATURAL - 194)) | (1L << (NATURALN - 194)) | (1L << (NAV - 194)) | (1L << (NCHAR - 194)) | (1L << (NCHAR_CS - 194)) | (1L << (NCLOB - 194)) | (1L << (NESTED - 194)) | (1L << (NEW - 194)) | (1L << (NO - 194)) | (1L << (NOAUDIT - 194)) | (1L << (NOCOPY - 194)) | (1L << (NOCYCLE - 194)) | (1L << (NOENTITYESCAPING - 194)) | (1L << (NONE - 194)) | (1L << (NOSCHEMACHECK - 194)) | (1L << (NULLS - 194)) | (1L << (NUMBER - 194)) | (1L << (NUMERIC - 194)) | (1L << (NVARCHAR2 - 194)) | (1L << (OBJECT - 194)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (OFF - 259)) | (1L << (OID - 259)) | (1L << (OLD - 259)) | (1L << (ONLY - 259)) | (1L << (OPEN - 259)) | (1L << (ORADATA - 259)) | (1L << (ORDINALITY - 259)) | (1L << (OSERROR - 259)) | (1L << (OUT - 259)) | (1L << (OUTER - 259)) | (1L << (OVER - 259)) | (1L << (OVERRIDING - 259)) | (1L << (PACKAGE - 259)) | (1L << (PARALLEL_ENABLE - 259)) | (1L << (PARAMETERS - 259)) | (1L << (PARENT - 259)) | (1L << (PARTITION - 259)) | (1L << (PASSING - 259)) | (1L << (PATH - 259)) | (1L << (PIPELINED - 259)) | (1L << (PLAN - 259)) | (1L << (PLS_INTEGER - 259)) | (1L << (POSITIVE - 259)) | (1L << (POSITIVEN - 259)) | (1L << (PRAGMA - 259)) | (1L << (PRECEDING - 259)) | (1L << (PRECISION - 259)) | (1L << (PRESENT - 259)) | (1L << (RAISE - 259)) | (1L << (RANGE - 259)) | (1L << (RAW - 259)) | (1L << (READ - 259)) | (1L << (REAL - 259)) | (1L << (RECORD - 259)) | (1L << (REF - 259)) | (1L << (REFERENCE - 259)) | (1L << (REFERENCING - 259)) | (1L << (REJECT - 259)) | (1L << (RELIES_ON - 259)) | (1L << (RENAME - 259)) | (1L << (REPLACE - 259)) | (1L << (RESPECT - 259)) | (1L << (RESTRICT_REFERENCES - 259)) | (1L << (RESULT - 259)) | (1L << (RESULT_CACHE - 259)) | (1L << (RETURN - 259)) | (1L << (RETURNING - 259)) | (1L << (REUSE - 259)) | (1L << (REVERSE - 259)) | (1L << (RIGHT - 259)))) != 0) || ((((_la - 323)) & ~0x3f) == 0 && ((1L << (_la - 323)) & ((1L << (ROLLBACK - 323)) | (1L << (ROLLUP - 323)) | (1L << (ROW - 323)) | (1L << (ROWID - 323)) | (1L << (ROWS - 323)) | (1L << (RULES - 323)) | (1L << (SAMPLE - 323)) | (1L << (SAVE - 323)) | (1L << (SAVEPOINT - 323)) | (1L << (SCHEMA - 323)) | (1L << (SCHEMACHECK - 323)) | (1L << (SCN - 323)) | (1L << (SECOND - 323)) | (1L << (SEED - 323)) | (1L << (SEGMENT - 323)) | (1L << (SELF - 323)) | (1L << (SEQUENTIAL - 323)) | (1L << (SERIALIZABLE - 323)) | (1L << (SERIALLY_REUSABLE - 323)) | (1L << (SERVERERROR - 323)) | (1L << (SESSIONTIMEZONE - 323)) | (1L << (SET - 323)) | (1L << (SETS - 323)) | (1L << (SETTINGS - 323)) | (1L << (SHOW - 323)) | (1L << (SHUTDOWN - 323)) | (1L << (SIBLINGS - 323)) | (1L << (SIGNTYPE - 323)) | (1L << (SIMPLE_INTEGER - 323)) | (1L << (SINGLE - 323)) | (1L << (SKIP_ - 323)) | (1L << (SMALLINT - 323)) | (1L << (SNAPSHOT - 323)) | (1L << (SOME - 323)) | (1L << (SPECIFICATION - 323)) | (1L << (SQLDATA - 323)) | (1L << (SQLERROR - 323)) | (1L << (STANDALONE - 323)) | (1L << (STARTUP - 323)) | (1L << (STATEMENT - 323)) | (1L << (STATEMENT_ID - 323)) | (1L << (STATIC - 323)) | (1L << (STATISTICS - 323)) | (1L << (STRING - 323)) | (1L << (SUBMULTISET - 323)) | (1L << (SUBPARTITION - 323)) | (1L << (SUBSTITUTABLE - 323)) | (1L << (SUBTYPE - 323)) | (1L << (SUCCESS - 323)) | (1L << (SUSPEND - 323)) | (1L << (TIME - 323)) | (1L << (TIMESTAMP - 323)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_UNCONSTRAINED - 323)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TIMEZONE_ABBR - 387)) | (1L << (TIMEZONE_HOUR - 387)) | (1L << (TIMEZONE_MINUTE - 387)) | (1L << (TIMEZONE_REGION - 387)) | (1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (YMINTERVAL_UNCONSTRAINED - 451)) | (1L << (ZONE - 451)) | (1L << (PREDICTION - 451)) | (1L << (PREDICTION_BOUNDS - 451)) | (1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (COVAR_ - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (REGR_ - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (TRIM - 451)) | (1L << (SUM - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (VARIANCE - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==REGULAR_ID) {
				{
				State = 4127; label_name();
				}
			}

			State = 4130; _localctx.ck1 = Match(CASE);
			State = 4131; atom();
			State = 4133;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 4132; simple_case_when_part();
				}
				}
				State = 4135;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==WHEN );
			State = 4138;
			_la = _input.La(1);
			if (_la==ELSE) {
				{
				State = 4137; case_else_part();
				}
			}

			State = 4140; Match(END);
			State = 4142;
			switch ( Interpreter.AdaptivePredict(_input,508,_ctx) ) {
			case 1:
				{
				State = 4141; Match(CASE);
				}
				break;
			}
			State = 4145;
			switch ( Interpreter.AdaptivePredict(_input,509,_ctx) ) {
			case 1:
				{
				State = 4144; label_name();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Simple_case_when_partContext : ParserRuleContext {
		public Seq_of_statementsContext seq_of_statements() {
			return GetRuleContext<Seq_of_statementsContext>(0);
		}
		public ITerminalNode THEN() { return GetToken(plsqlParser.THEN, 0); }
		public ITerminalNode WHEN() { return GetToken(plsqlParser.WHEN, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public Simple_case_when_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simple_case_when_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSimple_case_when_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSimple_case_when_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSimple_case_when_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Simple_case_when_partContext simple_case_when_part() {
		Simple_case_when_partContext _localctx = new Simple_case_when_partContext(_ctx, State);
		EnterRule(_localctx, 552, RULE_simple_case_when_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4147; Match(WHEN);
			State = 4148; expression();
			State = 4149; Match(THEN);
			State = 4152;
			switch ( Interpreter.AdaptivePredict(_input,510,_ctx) ) {
			case 1:
				{
				State = 4150; seq_of_statements();
				}
				break;

			case 2:
				{
				State = 4151; expression();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Searched_case_statementContext : ParserRuleContext {
		public IToken ck1;
		public IReadOnlyList<ITerminalNode> CASE() { return GetTokens(plsqlParser.CASE); }
		public IReadOnlyList<Label_nameContext> label_name() {
			return GetRuleContexts<Label_nameContext>();
		}
		public Label_nameContext label_name(int i) {
			return GetRuleContext<Label_nameContext>(i);
		}
		public ITerminalNode END() { return GetToken(plsqlParser.END, 0); }
		public IReadOnlyList<Searched_case_when_partContext> searched_case_when_part() {
			return GetRuleContexts<Searched_case_when_partContext>();
		}
		public Case_else_partContext case_else_part() {
			return GetRuleContext<Case_else_partContext>(0);
		}
		public ITerminalNode CASE(int i) {
			return GetToken(plsqlParser.CASE, i);
		}
		public Searched_case_when_partContext searched_case_when_part(int i) {
			return GetRuleContext<Searched_case_when_partContext>(i);
		}
		public Searched_case_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_searched_case_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSearched_case_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSearched_case_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSearched_case_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Searched_case_statementContext searched_case_statement() {
		Searched_case_statementContext _localctx = new Searched_case_statementContext(_ctx, State);
		EnterRule(_localctx, 554, RULE_searched_case_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4155;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (CONSTANT - 66)) | (1L << (CONSTRAINT - 66)) | (1L << (CONSTRAINTS - 66)) | (1L << (CONSTRUCTOR - 66)) | (1L << (CONTENT - 66)) | (1L << (CONTEXT - 66)) | (1L << (CONTINUE - 66)) | (1L << (CONVERT - 66)) | (1L << (CORRUPT_XID - 66)) | (1L << (CORRUPT_XID_ALL - 66)) | (1L << (COST - 66)) | (1L << (COUNT - 66)) | (1L << (CROSS - 66)) | (1L << (CUBE - 66)) | (1L << (CURRENT_USER - 66)) | (1L << (CURSOR - 66)) | (1L << (CUSTOMDATUM - 66)) | (1L << (CYCLE - 66)) | (1L << (DATA - 66)) | (1L << (DATABASE - 66)) | (1L << (DAY - 66)) | (1L << (DB_ROLE_CHANGE - 66)) | (1L << (DBTIMEZONE - 66)) | (1L << (DDL - 66)) | (1L << (DEBUG - 66)) | (1L << (DEC - 66)) | (1L << (DECIMAL - 66)) | (1L << (DECOMPOSE - 66)) | (1L << (DECREMENT - 66)) | (1L << (DEFAULTS - 66)) | (1L << (DEFERRED - 66)) | (1L << (DEFINER - 66)) | (1L << (DETERMINISTIC - 66)) | (1L << (DIMENSION - 66)) | (1L << (DISABLE - 66)) | (1L << (DISASSOCIATE - 66)) | (1L << (DOCUMENT - 66)) | (1L << (DOUBLE - 66)) | (1L << (DSINTERVAL_UNCONSTRAINED - 66)) | (1L << (EACH - 66)) | (1L << (ELEMENT - 66)) | (1L << (EMPTY - 66)) | (1L << (ENABLE - 66)) | (1L << (ENCODING - 66)) | (1L << (ENTITYESCAPING - 66)) | (1L << (ERR - 66)) | (1L << (ERRORS - 66)) | (1L << (ESCAPE - 66)) | (1L << (EVALNAME - 66)) | (1L << (EXCEPTION - 66)) | (1L << (EXCEPTION_INIT - 66)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)) | (1L << (EXIT - 130)) | (1L << (EXPLAIN - 130)) | (1L << (EXTERNAL - 130)) | (1L << (EXTRACT - 130)) | (1L << (FAILURE - 130)) | (1L << (FINAL - 130)) | (1L << (FIRST - 130)) | (1L << (FIRST_VALUE - 130)) | (1L << (FLOAT - 130)) | (1L << (FOLLOWING - 130)) | (1L << (FOLLOWS - 130)) | (1L << (FORALL - 130)) | (1L << (FORCE - 130)) | (1L << (FULL - 130)) | (1L << (FUNCTION - 130)) | (1L << (GROUPING - 130)) | (1L << (HASH - 130)) | (1L << (HIDE - 130)) | (1L << (HOUR - 130)) | (1L << (IGNORE - 130)) | (1L << (IMMEDIATE - 130)) | (1L << (INCLUDE - 130)) | (1L << (INCLUDING - 130)) | (1L << (INCREMENT - 130)) | (1L << (INDENT - 130)) | (1L << (INDEXED - 130)) | (1L << (INDICATOR - 130)) | (1L << (INDICES - 130)) | (1L << (INFINITE - 130)) | (1L << (INLINE - 130)) | (1L << (INNER - 130)) | (1L << (INOUT - 130)) | (1L << (INSTANTIABLE - 130)) | (1L << (INSTEAD - 130)) | (1L << (INT - 130)) | (1L << (INTEGER - 130)) | (1L << (INTERVAL - 130)) | (1L << (INVALIDATE - 130)) | (1L << (ISOLATION - 130)) | (1L << (ITERATE - 130)) | (1L << (JAVA - 130)) | (1L << (JOIN - 130)) | (1L << (KEEP - 130)) | (1L << (LANGUAGE - 130)))) != 0) || ((((_la - 194)) & ~0x3f) == 0 && ((1L << (_la - 194)) & ((1L << (LAST - 194)) | (1L << (LAST_VALUE - 194)) | (1L << (LEADING - 194)) | (1L << (LEFT - 194)) | (1L << (LEVEL - 194)) | (1L << (LIBRARY - 194)) | (1L << (LIKE2 - 194)) | (1L << (LIKE4 - 194)) | (1L << (LIKEC - 194)) | (1L << (LIMIT - 194)) | (1L << (LOCAL - 194)) | (1L << (LOCKED - 194)) | (1L << (LOG - 194)) | (1L << (LOGOFF - 194)) | (1L << (LOGON - 194)) | (1L << (LONG - 194)) | (1L << (LOOP - 194)) | (1L << (MAIN - 194)) | (1L << (MAP - 194)) | (1L << (MATCHED - 194)) | (1L << (MAXVALUE - 194)) | (1L << (MEASURES - 194)) | (1L << (MEMBER - 194)) | (1L << (MERGE - 194)) | (1L << (MINUTE - 194)) | (1L << (MINVALUE - 194)) | (1L << (MLSLABEL - 194)) | (1L << (MODEL - 194)) | (1L << (MODIFY - 194)) | (1L << (MONTH - 194)) | (1L << (MULTISET - 194)) | (1L << (NAME - 194)) | (1L << (NAN - 194)) | (1L << (NATURAL - 194)) | (1L << (NATURALN - 194)) | (1L << (NAV - 194)) | (1L << (NCHAR - 194)) | (1L << (NCHAR_CS - 194)) | (1L << (NCLOB - 194)) | (1L << (NESTED - 194)) | (1L << (NEW - 194)) | (1L << (NO - 194)) | (1L << (NOAUDIT - 194)) | (1L << (NOCOPY - 194)) | (1L << (NOCYCLE - 194)) | (1L << (NOENTITYESCAPING - 194)) | (1L << (NONE - 194)) | (1L << (NOSCHEMACHECK - 194)) | (1L << (NULLS - 194)) | (1L << (NUMBER - 194)) | (1L << (NUMERIC - 194)) | (1L << (NVARCHAR2 - 194)) | (1L << (OBJECT - 194)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (OFF - 259)) | (1L << (OID - 259)) | (1L << (OLD - 259)) | (1L << (ONLY - 259)) | (1L << (OPEN - 259)) | (1L << (ORADATA - 259)) | (1L << (ORDINALITY - 259)) | (1L << (OSERROR - 259)) | (1L << (OUT - 259)) | (1L << (OUTER - 259)) | (1L << (OVER - 259)) | (1L << (OVERRIDING - 259)) | (1L << (PACKAGE - 259)) | (1L << (PARALLEL_ENABLE - 259)) | (1L << (PARAMETERS - 259)) | (1L << (PARENT - 259)) | (1L << (PARTITION - 259)) | (1L << (PASSING - 259)) | (1L << (PATH - 259)) | (1L << (PIPELINED - 259)) | (1L << (PLAN - 259)) | (1L << (PLS_INTEGER - 259)) | (1L << (POSITIVE - 259)) | (1L << (POSITIVEN - 259)) | (1L << (PRAGMA - 259)) | (1L << (PRECEDING - 259)) | (1L << (PRECISION - 259)) | (1L << (PRESENT - 259)) | (1L << (RAISE - 259)) | (1L << (RANGE - 259)) | (1L << (RAW - 259)) | (1L << (READ - 259)) | (1L << (REAL - 259)) | (1L << (RECORD - 259)) | (1L << (REF - 259)) | (1L << (REFERENCE - 259)) | (1L << (REFERENCING - 259)) | (1L << (REJECT - 259)) | (1L << (RELIES_ON - 259)) | (1L << (RENAME - 259)) | (1L << (REPLACE - 259)) | (1L << (RESPECT - 259)) | (1L << (RESTRICT_REFERENCES - 259)) | (1L << (RESULT - 259)) | (1L << (RESULT_CACHE - 259)) | (1L << (RETURN - 259)) | (1L << (RETURNING - 259)) | (1L << (REUSE - 259)) | (1L << (REVERSE - 259)) | (1L << (RIGHT - 259)))) != 0) || ((((_la - 323)) & ~0x3f) == 0 && ((1L << (_la - 323)) & ((1L << (ROLLBACK - 323)) | (1L << (ROLLUP - 323)) | (1L << (ROW - 323)) | (1L << (ROWID - 323)) | (1L << (ROWS - 323)) | (1L << (RULES - 323)) | (1L << (SAMPLE - 323)) | (1L << (SAVE - 323)) | (1L << (SAVEPOINT - 323)) | (1L << (SCHEMA - 323)) | (1L << (SCHEMACHECK - 323)) | (1L << (SCN - 323)) | (1L << (SECOND - 323)) | (1L << (SEED - 323)) | (1L << (SEGMENT - 323)) | (1L << (SELF - 323)) | (1L << (SEQUENTIAL - 323)) | (1L << (SERIALIZABLE - 323)) | (1L << (SERIALLY_REUSABLE - 323)) | (1L << (SERVERERROR - 323)) | (1L << (SESSIONTIMEZONE - 323)) | (1L << (SET - 323)) | (1L << (SETS - 323)) | (1L << (SETTINGS - 323)) | (1L << (SHOW - 323)) | (1L << (SHUTDOWN - 323)) | (1L << (SIBLINGS - 323)) | (1L << (SIGNTYPE - 323)) | (1L << (SIMPLE_INTEGER - 323)) | (1L << (SINGLE - 323)) | (1L << (SKIP_ - 323)) | (1L << (SMALLINT - 323)) | (1L << (SNAPSHOT - 323)) | (1L << (SOME - 323)) | (1L << (SPECIFICATION - 323)) | (1L << (SQLDATA - 323)) | (1L << (SQLERROR - 323)) | (1L << (STANDALONE - 323)) | (1L << (STARTUP - 323)) | (1L << (STATEMENT - 323)) | (1L << (STATEMENT_ID - 323)) | (1L << (STATIC - 323)) | (1L << (STATISTICS - 323)) | (1L << (STRING - 323)) | (1L << (SUBMULTISET - 323)) | (1L << (SUBPARTITION - 323)) | (1L << (SUBSTITUTABLE - 323)) | (1L << (SUBTYPE - 323)) | (1L << (SUCCESS - 323)) | (1L << (SUSPEND - 323)) | (1L << (TIME - 323)) | (1L << (TIMESTAMP - 323)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_UNCONSTRAINED - 323)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TIMEZONE_ABBR - 387)) | (1L << (TIMEZONE_HOUR - 387)) | (1L << (TIMEZONE_MINUTE - 387)) | (1L << (TIMEZONE_REGION - 387)) | (1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (YMINTERVAL_UNCONSTRAINED - 451)) | (1L << (ZONE - 451)) | (1L << (PREDICTION - 451)) | (1L << (PREDICTION_BOUNDS - 451)) | (1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (COVAR_ - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (REGR_ - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (TRIM - 451)) | (1L << (SUM - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (VARIANCE - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==REGULAR_ID) {
				{
				State = 4154; label_name();
				}
			}

			State = 4157; _localctx.ck1 = Match(CASE);
			State = 4159;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 4158; searched_case_when_part();
				}
				}
				State = 4161;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==WHEN );
			State = 4164;
			_la = _input.La(1);
			if (_la==ELSE) {
				{
				State = 4163; case_else_part();
				}
			}

			State = 4166; Match(END);
			State = 4168;
			switch ( Interpreter.AdaptivePredict(_input,514,_ctx) ) {
			case 1:
				{
				State = 4167; Match(CASE);
				}
				break;
			}
			State = 4171;
			switch ( Interpreter.AdaptivePredict(_input,515,_ctx) ) {
			case 1:
				{
				State = 4170; label_name();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Searched_case_when_partContext : ParserRuleContext {
		public Seq_of_statementsContext seq_of_statements() {
			return GetRuleContext<Seq_of_statementsContext>(0);
		}
		public ITerminalNode THEN() { return GetToken(plsqlParser.THEN, 0); }
		public ITerminalNode WHEN() { return GetToken(plsqlParser.WHEN, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public Searched_case_when_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_searched_case_when_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSearched_case_when_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSearched_case_when_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSearched_case_when_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Searched_case_when_partContext searched_case_when_part() {
		Searched_case_when_partContext _localctx = new Searched_case_when_partContext(_ctx, State);
		EnterRule(_localctx, 556, RULE_searched_case_when_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4173; Match(WHEN);
			State = 4174; expression();
			State = 4175; Match(THEN);
			State = 4178;
			switch ( Interpreter.AdaptivePredict(_input,516,_ctx) ) {
			case 1:
				{
				State = 4176; seq_of_statements();
				}
				break;

			case 2:
				{
				State = 4177; expression();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Case_else_partContext : ParserRuleContext {
		public Seq_of_statementsContext seq_of_statements() {
			return GetRuleContext<Seq_of_statementsContext>(0);
		}
		public ITerminalNode ELSE() { return GetToken(plsqlParser.ELSE, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Case_else_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_case_else_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCase_else_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCase_else_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCase_else_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Case_else_partContext case_else_part() {
		Case_else_partContext _localctx = new Case_else_partContext(_ctx, State);
		EnterRule(_localctx, 558, RULE_case_else_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4180; Match(ELSE);
			State = 4183;
			switch ( Interpreter.AdaptivePredict(_input,517,_ctx) ) {
			case 1:
				{
				State = 4181; seq_of_statements();
				}
				break;

			case 2:
				{
				State = 4182; expression();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AtomContext : ParserRuleContext {
		public Table_elementContext table_element() {
			return GetRuleContext<Table_elementContext>(0);
		}
		public Subquery_operation_partContext subquery_operation_part(int i) {
			return GetRuleContext<Subquery_operation_partContext>(i);
		}
		public Bind_variableContext bind_variable() {
			return GetRuleContext<Bind_variableContext>(0);
		}
		public ConstantContext constant() {
			return GetRuleContext<ConstantContext>(0);
		}
		public Outer_join_signContext outer_join_sign() {
			return GetRuleContext<Outer_join_signContext>(0);
		}
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public IReadOnlyList<Subquery_operation_partContext> subquery_operation_part() {
			return GetRuleContexts<Subquery_operation_partContext>();
		}
		public General_elementContext general_element() {
			return GetRuleContext<General_elementContext>(0);
		}
		public Expression_or_vectorContext expression_or_vector() {
			return GetRuleContext<Expression_or_vectorContext>(0);
		}
		public AtomContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_atom; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitAtom(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAtom(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AtomContext atom() {
		AtomContext _localctx = new AtomContext(_ctx, State);
		EnterRule(_localctx, 560, RULE_atom);
		try {
			int _alt;
			State = 4205;
			switch ( Interpreter.AdaptivePredict(_input,520,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4185; table_element();
				State = 4186; outer_join_sign();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4188; bind_variable();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4189; constant();
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 4190; general_element();
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 4191; Match(LEFT_PAREN);
				State = 4203;
				switch ( Interpreter.AdaptivePredict(_input,519,_ctx) ) {
				case 1:
					{
					State = 4192; subquery();
					State = 4193; Match(RIGHT_PAREN);
					State = 4197;
					_errHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(_input,518,_ctx);
					while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
						if ( _alt==1 ) {
							{
							{
							State = 4194; subquery_operation_part();
							}
							} 
						}
						State = 4199;
						_errHandler.Sync(this);
						_alt = Interpreter.AdaptivePredict(_input,518,_ctx);
					}
					}
					break;

				case 2:
					{
					State = 4200; expression_or_vector();
					State = 4201; Match(RIGHT_PAREN);
					}
					break;
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Expression_or_vectorContext : ParserRuleContext {
		public Vector_exprContext vector_expr() {
			return GetRuleContext<Vector_exprContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Expression_or_vectorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression_or_vector; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterExpression_or_vector(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitExpression_or_vector(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpression_or_vector(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Expression_or_vectorContext expression_or_vector() {
		Expression_or_vectorContext _localctx = new Expression_or_vectorContext(_ctx, State);
		EnterRule(_localctx, 562, RULE_expression_or_vector);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4207; expression();
			State = 4209;
			_la = _input.La(1);
			if (_la==COMMA) {
				{
				State = 4208; vector_expr();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Vector_exprContext : ParserRuleContext {
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public Vector_exprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_vector_expr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterVector_expr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitVector_expr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVector_expr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Vector_exprContext vector_expr() {
		Vector_exprContext _localctx = new Vector_exprContext(_ctx, State);
		EnterRule(_localctx, 564, RULE_vector_expr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4211; Match(COMMA);
			State = 4212; expression();
			State = 4217;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 4213; Match(COMMA);
				State = 4214; expression();
				}
				}
				State = 4219;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Quantified_expressionContext : ParserRuleContext {
		public ITerminalNode EXISTS() { return GetToken(plsqlParser.EXISTS, 0); }
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode ANY() { return GetToken(plsqlParser.ANY, 0); }
		public ITerminalNode SOME() { return GetToken(plsqlParser.SOME, 0); }
		public ITerminalNode ALL() { return GetToken(plsqlParser.ALL, 0); }
		public Quantified_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_quantified_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterQuantified_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitQuantified_expression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQuantified_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Quantified_expressionContext quantified_expression() {
		Quantified_expressionContext _localctx = new Quantified_expressionContext(_ctx, State);
		EnterRule(_localctx, 566, RULE_quantified_expression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4220;
			_la = _input.La(1);
			if ( !(_la==ALL || _la==ANY || _la==EXISTS || _la==SOME) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			State = 4229;
			switch ( Interpreter.AdaptivePredict(_input,523,_ctx) ) {
			case 1:
				{
				State = 4221; Match(LEFT_PAREN);
				State = 4222; subquery();
				State = 4223; Match(RIGHT_PAREN);
				}
				break;

			case 2:
				{
				State = 4225; Match(LEFT_PAREN);
				State = 4226; expression();
				State = 4227; Match(RIGHT_PAREN);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class String_functionContext : ParserRuleContext {
		public Quoted_stringContext quoted_string() {
			return GetRuleContext<Quoted_stringContext>(0);
		}
		public ConcatenationContext concatenation() {
			return GetRuleContext<ConcatenationContext>(0);
		}
		public ITerminalNode NCHAR_CS() { return GetToken(plsqlParser.NCHAR_CS, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode FROM() { return GetToken(plsqlParser.FROM, 0); }
		public ITerminalNode USING() { return GetToken(plsqlParser.USING, 0); }
		public ITerminalNode NVL() { return GetToken(plsqlParser.NVL, 0); }
		public ITerminalNode SUBSTR() { return GetToken(plsqlParser.SUBSTR, 0); }
		public ITerminalNode COMMA(int i) {
			return GetToken(plsqlParser.COMMA, i);
		}
		public ITerminalNode TRIM() { return GetToken(plsqlParser.TRIM, 0); }
		public Table_elementContext table_element() {
			return GetRuleContext<Table_elementContext>(0);
		}
		public Standard_functionContext standard_function() {
			return GetRuleContext<Standard_functionContext>(0);
		}
		public IReadOnlyList<ITerminalNode> COMMA() { return GetTokens(plsqlParser.COMMA); }
		public ITerminalNode BOTH() { return GetToken(plsqlParser.BOTH, 0); }
		public ITerminalNode TO_CHAR() { return GetToken(plsqlParser.TO_CHAR, 0); }
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode DECODE() { return GetToken(plsqlParser.DECODE, 0); }
		public ITerminalNode LEADING() { return GetToken(plsqlParser.LEADING, 0); }
		public ITerminalNode CHR() { return GetToken(plsqlParser.CHR, 0); }
		public ITerminalNode TRAILING() { return GetToken(plsqlParser.TRAILING, 0); }
		public String_functionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_string_function; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterString_function(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitString_function(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitString_function(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public String_functionContext string_function() {
		String_functionContext _localctx = new String_functionContext(_ctx, State);
		EnterRule(_localctx, 568, RULE_string_function);
		int _la;
		try {
			State = 4294;
			switch (_input.La(1)) {
			case SUBSTR:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4231; Match(SUBSTR);
				State = 4232; Match(LEFT_PAREN);
				State = 4233; expression();
				State = 4234; Match(COMMA);
				State = 4235; expression();
				State = 4238;
				_la = _input.La(1);
				if (_la==COMMA) {
					{
					State = 4236; Match(COMMA);
					State = 4237; expression();
					}
				}

				State = 4240; Match(RIGHT_PAREN);
				}
				break;
			case TO_CHAR:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4242; Match(TO_CHAR);
				State = 4243; Match(LEFT_PAREN);
				State = 4246;
				switch ( Interpreter.AdaptivePredict(_input,525,_ctx) ) {
				case 1:
					{
					State = 4244; table_element();
					}
					break;

				case 2:
					{
					State = 4245; standard_function();
					}
					break;
				}
				State = 4250;
				_la = _input.La(1);
				if (_la==COMMA) {
					{
					State = 4248; Match(COMMA);
					State = 4249; quoted_string();
					}
				}

				State = 4252; Match(RIGHT_PAREN);
				}
				break;
			case DECODE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4254; Match(DECODE);
				State = 4255; Match(LEFT_PAREN);
				State = 4256; expression();
				State = 4261;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 4257; Match(COMMA);
					State = 4258; expression();
					}
					}
					State = 4263;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 4264; Match(RIGHT_PAREN);
				}
				break;
			case CHR:
				EnterOuterAlt(_localctx, 4);
				{
				State = 4266; Match(CHR);
				State = 4267; Match(LEFT_PAREN);
				State = 4268; concatenation();
				State = 4269; Match(USING);
				State = 4270; Match(NCHAR_CS);
				State = 4271; Match(RIGHT_PAREN);
				}
				break;
			case NVL:
				EnterOuterAlt(_localctx, 5);
				{
				State = 4273; Match(NVL);
				State = 4274; Match(LEFT_PAREN);
				State = 4275; expression();
				State = 4276; Match(COMMA);
				State = 4277; expression();
				State = 4278; Match(RIGHT_PAREN);
				}
				break;
			case TRIM:
				EnterOuterAlt(_localctx, 6);
				{
				State = 4280; Match(TRIM);
				State = 4281; Match(LEFT_PAREN);
				State = 4289;
				switch ( Interpreter.AdaptivePredict(_input,530,_ctx) ) {
				case 1:
					{
					State = 4283;
					_la = _input.La(1);
					if (_la==BOTH || _la==LEADING || _la==TRAILING) {
						{
						State = 4282;
						_la = _input.La(1);
						if ( !(_la==BOTH || _la==LEADING || _la==TRAILING) ) {
						_errHandler.RecoverInline(this);
						}
						Consume();
						}
					}

					State = 4286;
					_la = _input.La(1);
					if (_la==NATIONAL_CHAR_STRING_LIT || _la==CHAR_STRING) {
						{
						State = 4285; quoted_string();
						}
					}

					State = 4288; Match(FROM);
					}
					break;
				}
				State = 4291; concatenation();
				State = 4292; Match(RIGHT_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Standard_functionContext : ParserRuleContext {
		public String_functionContext string_function() {
			return GetRuleContext<String_functionContext>(0);
		}
		public Numeric_function_wrapperContext numeric_function_wrapper() {
			return GetRuleContext<Numeric_function_wrapperContext>(0);
		}
		public Other_functionContext other_function() {
			return GetRuleContext<Other_functionContext>(0);
		}
		public Standard_functionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_standard_function; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterStandard_function(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitStandard_function(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStandard_function(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Standard_functionContext standard_function() {
		Standard_functionContext _localctx = new Standard_functionContext(_ctx, State);
		EnterRule(_localctx, 570, RULE_standard_function);
		try {
			State = 4299;
			switch ( Interpreter.AdaptivePredict(_input,532,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4296; string_function();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4297; numeric_function_wrapper();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4298; other_function();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Numeric_function_wrapperContext : ParserRuleContext {
		public Single_column_for_loopContext single_column_for_loop() {
			return GetRuleContext<Single_column_for_loopContext>(0);
		}
		public Numeric_functionContext numeric_function() {
			return GetRuleContext<Numeric_functionContext>(0);
		}
		public Multi_column_for_loopContext multi_column_for_loop() {
			return GetRuleContext<Multi_column_for_loopContext>(0);
		}
		public Numeric_function_wrapperContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_numeric_function_wrapper; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterNumeric_function_wrapper(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitNumeric_function_wrapper(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumeric_function_wrapper(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Numeric_function_wrapperContext numeric_function_wrapper() {
		Numeric_function_wrapperContext _localctx = new Numeric_function_wrapperContext(_ctx, State);
		EnterRule(_localctx, 572, RULE_numeric_function_wrapper);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4301; numeric_function();
			State = 4304;
			switch ( Interpreter.AdaptivePredict(_input,533,_ctx) ) {
			case 1:
				{
				State = 4302; single_column_for_loop();
				}
				break;

			case 2:
				{
				State = 4303; multi_column_for_loop();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Numeric_functionContext : ParserRuleContext {
		public ITerminalNode COUNT() { return GetToken(plsqlParser.COUNT, 0); }
		public ITerminalNode ROUND() { return GetToken(plsqlParser.ROUND, 0); }
		public ConcatenationContext concatenation() {
			return GetRuleContext<ConcatenationContext>(0);
		}
		public ITerminalNode AVG() { return GetToken(plsqlParser.AVG, 0); }
		public ITerminalNode SUM() { return GetToken(plsqlParser.SUM, 0); }
		public ITerminalNode ALL() { return GetToken(plsqlParser.ALL, 0); }
		public ITerminalNode UNIQUE() { return GetToken(plsqlParser.UNIQUE, 0); }
		public ITerminalNode UNSIGNED_INTEGER() { return GetToken(plsqlParser.UNSIGNED_INTEGER, 0); }
		public ITerminalNode MAX() { return GetToken(plsqlParser.MAX, 0); }
		public ITerminalNode COMMA() { return GetToken(plsqlParser.COMMA, 0); }
		public ITerminalNode DISTINCT() { return GetToken(plsqlParser.DISTINCT, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Over_clauseContext over_clause() {
			return GetRuleContext<Over_clauseContext>(0);
		}
		public Numeric_functionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_numeric_function; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterNumeric_function(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitNumeric_function(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumeric_function(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Numeric_functionContext numeric_function() {
		Numeric_functionContext _localctx = new Numeric_functionContext(_ctx, State);
		EnterRule(_localctx, 574, RULE_numeric_function);
		int _la;
		try {
			State = 4354;
			switch (_input.La(1)) {
			case SUM:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4306; Match(SUM);
				State = 4307; Match(LEFT_PAREN);
				State = 4309;
				switch ( Interpreter.AdaptivePredict(_input,534,_ctx) ) {
				case 1:
					{
					State = 4308;
					_la = _input.La(1);
					if ( !(_la==ALL || _la==DISTINCT) ) {
					_errHandler.RecoverInline(this);
					}
					Consume();
					}
					break;
				}
				State = 4311; expression();
				State = 4312; Match(RIGHT_PAREN);
				}
				break;
			case COUNT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4314; Match(COUNT);
				State = 4315; Match(LEFT_PAREN);
				State = 4323;
				switch (_input.La(1)) {
				case ASTERISK:
					{
					State = 4316; Match(ASTERISK);
					}
					break;
				case A_LETTER:
				case ADD:
				case AFTER:
				case AGENT:
				case AGGREGATE:
				case ALL:
				case ANALYZE:
				case ANY:
				case ARRAY:
				case ASSOCIATE:
				case AT:
				case ATTRIBUTE:
				case AUDIT:
				case AUTHID:
				case AUTO:
				case AUTOMATIC:
				case AUTONOMOUS_TRANSACTION:
				case BATCH:
				case BEFORE:
				case BFILE:
				case BINARY_DOUBLE:
				case BINARY_FLOAT:
				case BINARY_INTEGER:
				case BLOB:
				case BLOCK:
				case BODY:
				case BOOLEAN:
				case BOTH:
				case BULK:
				case BYTE:
				case C_LETTER:
				case CALL:
				case CANONICAL:
				case CASCADE:
				case CASE:
				case CAST:
				case CHAR:
				case CHAR_CS:
				case CHARACTER:
				case CHR:
				case CLOB:
				case CLOSE:
				case CLUSTER:
				case COALESCE:
				case COLLECT:
				case COLUMNS:
				case COMMENT:
				case COMMIT:
				case COMMITTED:
				case COMPATIBILITY:
				case COMPILE:
				case COMPOUND:
				case CONNECT_BY_ROOT:
				case CONSTANT:
				case CONSTRAINT:
				case CONSTRAINTS:
				case CONSTRUCTOR:
				case CONTENT:
				case CONTEXT:
				case CONTINUE:
				case CONVERT:
				case CORRUPT_XID:
				case CORRUPT_XID_ALL:
				case COST:
				case COUNT:
				case CROSS:
				case CUBE:
				case CURRENT_USER:
				case CURSOR:
				case CUSTOMDATUM:
				case CYCLE:
				case DATA:
				case DATABASE:
				case DATE:
				case DAY:
				case DB_ROLE_CHANGE:
				case DBTIMEZONE:
				case DDL:
				case DEBUG:
				case DEC:
				case DECIMAL:
				case DECOMPOSE:
				case DECREMENT:
				case DEFAULT:
				case DEFAULTS:
				case DEFERRED:
				case DEFINER:
				case DETERMINISTIC:
				case DIMENSION:
				case DISABLE:
				case DISASSOCIATE:
				case DISTINCT:
				case DOCUMENT:
				case DOUBLE:
				case DSINTERVAL_UNCONSTRAINED:
				case EACH:
				case ELEMENT:
				case EMPTY:
				case ENABLE:
				case ENCODING:
				case ENTITYESCAPING:
				case ERR:
				case ERRORS:
				case ESCAPE:
				case EVALNAME:
				case EXCEPTION:
				case EXCEPTION_INIT:
				case EXCEPTIONS:
				case EXCLUDE:
				case EXECUTE:
				case EXISTS:
				case EXIT:
				case EXPLAIN:
				case EXTERNAL:
				case EXTRACT:
				case FAILURE:
				case FALSE:
				case FINAL:
				case FIRST:
				case FIRST_VALUE:
				case FLOAT:
				case FOLLOWING:
				case FOLLOWS:
				case FORALL:
				case FORCE:
				case FULL:
				case FUNCTION:
				case GROUPING:
				case HASH:
				case HIDE:
				case HOUR:
				case IGNORE:
				case IMMEDIATE:
				case INCLUDE:
				case INCLUDING:
				case INCREMENT:
				case INDENT:
				case INDEXED:
				case INDICATOR:
				case INDICES:
				case INFINITE:
				case INLINE:
				case INNER:
				case INOUT:
				case INSTANTIABLE:
				case INSTEAD:
				case INT:
				case INTEGER:
				case INTERVAL:
				case INVALIDATE:
				case ISOLATION:
				case ITERATE:
				case JAVA:
				case JOIN:
				case KEEP:
				case LANGUAGE:
				case LAST:
				case LAST_VALUE:
				case LEADING:
				case LEFT:
				case LEVEL:
				case LIBRARY:
				case LIKE2:
				case LIKE4:
				case LIKEC:
				case LIMIT:
				case LOCAL:
				case LOCKED:
				case LOG:
				case LOGOFF:
				case LOGON:
				case LONG:
				case LOOP:
				case MAIN:
				case MAP:
				case MATCHED:
				case MAXVALUE:
				case MEASURES:
				case MEMBER:
				case MERGE:
				case MINUTE:
				case MINVALUE:
				case MLSLABEL:
				case MODEL:
				case MODIFY:
				case MONTH:
				case MULTISET:
				case NAME:
				case NAN:
				case NATURAL:
				case NATURALN:
				case NAV:
				case NCHAR:
				case NCHAR_CS:
				case NCLOB:
				case NESTED:
				case NEW:
				case NO:
				case NOAUDIT:
				case NOCOPY:
				case NOCYCLE:
				case NOENTITYESCAPING:
				case NONE:
				case NOSCHEMACHECK:
				case NULL:
				case NULLS:
				case NUMBER:
				case NUMERIC:
				case NVARCHAR2:
				case OBJECT:
				case OFF:
				case OID:
				case OLD:
				case ONLY:
				case OPEN:
				case ORADATA:
				case ORDINALITY:
				case OSERROR:
				case OUT:
				case OUTER:
				case OVER:
				case OVERRIDING:
				case PACKAGE:
				case PARALLEL_ENABLE:
				case PARAMETERS:
				case PARENT:
				case PARTITION:
				case PASSING:
				case PATH:
				case PIPELINED:
				case PLAN:
				case PLS_INTEGER:
				case POSITIVE:
				case POSITIVEN:
				case PRAGMA:
				case PRECEDING:
				case PRECISION:
				case PRESENT:
				case PRIOR:
				case RAISE:
				case RANGE:
				case RAW:
				case READ:
				case REAL:
				case RECORD:
				case REF:
				case REFERENCE:
				case REFERENCING:
				case REJECT:
				case RELIES_ON:
				case RENAME:
				case REPLACE:
				case RESPECT:
				case RESTRICT_REFERENCES:
				case RESULT:
				case RESULT_CACHE:
				case RETURN:
				case RETURNING:
				case REUSE:
				case REVERSE:
				case RIGHT:
				case ROLLBACK:
				case ROLLUP:
				case ROW:
				case ROWID:
				case ROWS:
				case RULES:
				case SAMPLE:
				case SAVE:
				case SAVEPOINT:
				case SCHEMA:
				case SCHEMACHECK:
				case SCN:
				case SECOND:
				case SEED:
				case SEGMENT:
				case SELF:
				case SEQUENTIAL:
				case SERIALIZABLE:
				case SERIALLY_REUSABLE:
				case SERVERERROR:
				case SESSIONTIMEZONE:
				case SET:
				case SETS:
				case SETTINGS:
				case SHOW:
				case SHUTDOWN:
				case SIBLINGS:
				case SIGNTYPE:
				case SIMPLE_INTEGER:
				case SINGLE:
				case SKIP_:
				case SMALLINT:
				case SNAPSHOT:
				case SOME:
				case SPECIFICATION:
				case SQLDATA:
				case SQLERROR:
				case STANDALONE:
				case STARTUP:
				case STATEMENT:
				case STATEMENT_ID:
				case STATIC:
				case STATISTICS:
				case STRING:
				case SUBMULTISET:
				case SUBPARTITION:
				case SUBSTITUTABLE:
				case SUBTYPE:
				case SUCCESS:
				case SUSPEND:
				case TIME:
				case TIMESTAMP:
				case TIMESTAMP_LTZ_UNCONSTRAINED:
				case TIMESTAMP_TZ_UNCONSTRAINED:
				case TIMESTAMP_UNCONSTRAINED:
				case TIMEZONE_ABBR:
				case TIMEZONE_HOUR:
				case TIMEZONE_MINUTE:
				case TIMEZONE_REGION:
				case TRAILING:
				case TRANSACTION:
				case TRANSLATE:
				case TREAT:
				case TRIGGER:
				case TRUE:
				case TRUNCATE:
				case TYPE:
				case UNBOUNDED:
				case UNDER:
				case UNIQUE:
				case UNLIMITED:
				case UNTIL:
				case UPDATED:
				case UPSERT:
				case UROWID:
				case USE:
				case VALIDATE:
				case VALUE:
				case VARCHAR:
				case VARCHAR2:
				case VARIABLE:
				case VARRAY:
				case VARYING:
				case VERSION:
				case VERSIONS:
				case WAIT:
				case WARNING:
				case WELLFORMED:
				case WHENEVER:
				case WHILE:
				case WITHIN:
				case WORK:
				case WRITE:
				case XML:
				case XMLAGG:
				case XMLATTRIBUTES:
				case XMLCAST:
				case XMLCOLATTVAL:
				case XMLELEMENT:
				case XMLEXISTS:
				case XMLFOREST:
				case XMLNAMESPACES:
				case XMLPARSE:
				case XMLPI:
				case XMLQUERY:
				case XMLROOT:
				case XMLSERIALIZE:
				case XMLTABLE:
				case YEAR:
				case YES:
				case YMINTERVAL_UNCONSTRAINED:
				case ZONE:
				case PREDICTION:
				case PREDICTION_BOUNDS:
				case PREDICTION_COST:
				case PREDICTION_DETAILS:
				case PREDICTION_PROBABILITY:
				case PREDICTION_SET:
				case CUME_DIST:
				case DENSE_RANK:
				case LISTAGG:
				case PERCENT_RANK:
				case PERCENTILE_CONT:
				case PERCENTILE_DISC:
				case RANK:
				case AVG:
				case CORR:
				case COVAR_:
				case DECODE:
				case LAG:
				case LEAD:
				case MAX:
				case MEDIAN:
				case MIN:
				case NTILE:
				case NVL:
				case RATIO_TO_REPORT:
				case REGR_:
				case ROUND:
				case ROW_NUMBER:
				case SUBSTR:
				case TO_CHAR:
				case TRIM:
				case SUM:
				case STDDEV:
				case VAR_:
				case VARIANCE:
				case NATIONAL_CHAR_STRING_LIT:
				case UNSIGNED_INTEGER:
				case APPROXIMATE_NUM_LIT:
				case CHAR_STRING:
				case DELIMITED_ID:
				case LEFT_PAREN:
				case RIGHT_PAREN:
				case PLUS_SIGN:
				case MINUS_SIGN:
				case BINDVAR:
				case COLON:
				case INTRODUCER:
				case REGULAR_ID:
					{
					State = 4321;
					_la = _input.La(1);
					if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALL) | (1L << ANALYZE) | (1L << ANY) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COALESCE) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & ((1L << (CONNECT_BY_ROOT - 65)) | (1L << (CONSTANT - 65)) | (1L << (CONSTRAINT - 65)) | (1L << (CONSTRAINTS - 65)) | (1L << (CONSTRUCTOR - 65)) | (1L << (CONTENT - 65)) | (1L << (CONTEXT - 65)) | (1L << (CONTINUE - 65)) | (1L << (CONVERT - 65)) | (1L << (CORRUPT_XID - 65)) | (1L << (CORRUPT_XID_ALL - 65)) | (1L << (COST - 65)) | (1L << (COUNT - 65)) | (1L << (CROSS - 65)) | (1L << (CUBE - 65)) | (1L << (CURRENT_USER - 65)) | (1L << (CURSOR - 65)) | (1L << (CUSTOMDATUM - 65)) | (1L << (CYCLE - 65)) | (1L << (DATA - 65)) | (1L << (DATABASE - 65)) | (1L << (DATE - 65)) | (1L << (DAY - 65)) | (1L << (DB_ROLE_CHANGE - 65)) | (1L << (DBTIMEZONE - 65)) | (1L << (DDL - 65)) | (1L << (DEBUG - 65)) | (1L << (DEC - 65)) | (1L << (DECIMAL - 65)) | (1L << (DECOMPOSE - 65)) | (1L << (DECREMENT - 65)) | (1L << (DEFAULT - 65)) | (1L << (DEFAULTS - 65)) | (1L << (DEFERRED - 65)) | (1L << (DEFINER - 65)) | (1L << (DETERMINISTIC - 65)) | (1L << (DIMENSION - 65)) | (1L << (DISABLE - 65)) | (1L << (DISASSOCIATE - 65)) | (1L << (DISTINCT - 65)) | (1L << (DOCUMENT - 65)) | (1L << (DOUBLE - 65)) | (1L << (DSINTERVAL_UNCONSTRAINED - 65)) | (1L << (EACH - 65)) | (1L << (ELEMENT - 65)) | (1L << (EMPTY - 65)) | (1L << (ENABLE - 65)) | (1L << (ENCODING - 65)) | (1L << (ENTITYESCAPING - 65)) | (1L << (ERR - 65)) | (1L << (ERRORS - 65)) | (1L << (ESCAPE - 65)) | (1L << (EVALNAME - 65)) | (1L << (EXCEPTION - 65)))) != 0) || ((((_la - 129)) & ~0x3f) == 0 && ((1L << (_la - 129)) & ((1L << (EXCEPTION_INIT - 129)) | (1L << (EXCEPTIONS - 129)) | (1L << (EXCLUDE - 129)) | (1L << (EXECUTE - 129)) | (1L << (EXISTS - 129)) | (1L << (EXIT - 129)) | (1L << (EXPLAIN - 129)) | (1L << (EXTERNAL - 129)) | (1L << (EXTRACT - 129)) | (1L << (FAILURE - 129)) | (1L << (FALSE - 129)) | (1L << (FINAL - 129)) | (1L << (FIRST - 129)) | (1L << (FIRST_VALUE - 129)) | (1L << (FLOAT - 129)) | (1L << (FOLLOWING - 129)) | (1L << (FOLLOWS - 129)) | (1L << (FORALL - 129)) | (1L << (FORCE - 129)) | (1L << (FULL - 129)) | (1L << (FUNCTION - 129)) | (1L << (GROUPING - 129)) | (1L << (HASH - 129)) | (1L << (HIDE - 129)) | (1L << (HOUR - 129)) | (1L << (IGNORE - 129)) | (1L << (IMMEDIATE - 129)) | (1L << (INCLUDE - 129)) | (1L << (INCLUDING - 129)) | (1L << (INCREMENT - 129)) | (1L << (INDENT - 129)) | (1L << (INDEXED - 129)) | (1L << (INDICATOR - 129)) | (1L << (INDICES - 129)) | (1L << (INFINITE - 129)) | (1L << (INLINE - 129)) | (1L << (INNER - 129)) | (1L << (INOUT - 129)) | (1L << (INSTANTIABLE - 129)) | (1L << (INSTEAD - 129)) | (1L << (INT - 129)) | (1L << (INTEGER - 129)) | (1L << (INTERVAL - 129)) | (1L << (INVALIDATE - 129)) | (1L << (ISOLATION - 129)) | (1L << (ITERATE - 129)) | (1L << (JAVA - 129)) | (1L << (JOIN - 129)) | (1L << (KEEP - 129)))) != 0) || ((((_la - 193)) & ~0x3f) == 0 && ((1L << (_la - 193)) & ((1L << (LANGUAGE - 193)) | (1L << (LAST - 193)) | (1L << (LAST_VALUE - 193)) | (1L << (LEADING - 193)) | (1L << (LEFT - 193)) | (1L << (LEVEL - 193)) | (1L << (LIBRARY - 193)) | (1L << (LIKE2 - 193)) | (1L << (LIKE4 - 193)) | (1L << (LIKEC - 193)) | (1L << (LIMIT - 193)) | (1L << (LOCAL - 193)) | (1L << (LOCKED - 193)) | (1L << (LOG - 193)) | (1L << (LOGOFF - 193)) | (1L << (LOGON - 193)) | (1L << (LONG - 193)) | (1L << (LOOP - 193)) | (1L << (MAIN - 193)) | (1L << (MAP - 193)) | (1L << (MATCHED - 193)) | (1L << (MAXVALUE - 193)) | (1L << (MEASURES - 193)) | (1L << (MEMBER - 193)) | (1L << (MERGE - 193)) | (1L << (MINUTE - 193)) | (1L << (MINVALUE - 193)) | (1L << (MLSLABEL - 193)) | (1L << (MODEL - 193)) | (1L << (MODIFY - 193)) | (1L << (MONTH - 193)) | (1L << (MULTISET - 193)) | (1L << (NAME - 193)) | (1L << (NAN - 193)) | (1L << (NATURAL - 193)) | (1L << (NATURALN - 193)) | (1L << (NAV - 193)) | (1L << (NCHAR - 193)) | (1L << (NCHAR_CS - 193)) | (1L << (NCLOB - 193)) | (1L << (NESTED - 193)) | (1L << (NEW - 193)) | (1L << (NO - 193)) | (1L << (NOAUDIT - 193)) | (1L << (NOCOPY - 193)) | (1L << (NOCYCLE - 193)) | (1L << (NOENTITYESCAPING - 193)) | (1L << (NONE - 193)) | (1L << (NOSCHEMACHECK - 193)) | (1L << (NULL - 193)) | (1L << (NULLS - 193)) | (1L << (NUMBER - 193)) | (1L << (NUMERIC - 193)) | (1L << (NVARCHAR2 - 193)))) != 0) || ((((_la - 257)) & ~0x3f) == 0 && ((1L << (_la - 257)) & ((1L << (OBJECT - 257)) | (1L << (OFF - 257)) | (1L << (OID - 257)) | (1L << (OLD - 257)) | (1L << (ONLY - 257)) | (1L << (OPEN - 257)) | (1L << (ORADATA - 257)) | (1L << (ORDINALITY - 257)) | (1L << (OSERROR - 257)) | (1L << (OUT - 257)) | (1L << (OUTER - 257)) | (1L << (OVER - 257)) | (1L << (OVERRIDING - 257)) | (1L << (PACKAGE - 257)) | (1L << (PARALLEL_ENABLE - 257)) | (1L << (PARAMETERS - 257)) | (1L << (PARENT - 257)) | (1L << (PARTITION - 257)) | (1L << (PASSING - 257)) | (1L << (PATH - 257)) | (1L << (PIPELINED - 257)) | (1L << (PLAN - 257)) | (1L << (PLS_INTEGER - 257)) | (1L << (POSITIVE - 257)) | (1L << (POSITIVEN - 257)) | (1L << (PRAGMA - 257)) | (1L << (PRECEDING - 257)) | (1L << (PRECISION - 257)) | (1L << (PRESENT - 257)) | (1L << (PRIOR - 257)) | (1L << (RAISE - 257)) | (1L << (RANGE - 257)) | (1L << (RAW - 257)) | (1L << (READ - 257)) | (1L << (REAL - 257)) | (1L << (RECORD - 257)) | (1L << (REF - 257)) | (1L << (REFERENCE - 257)) | (1L << (REFERENCING - 257)) | (1L << (REJECT - 257)) | (1L << (RELIES_ON - 257)) | (1L << (RENAME - 257)) | (1L << (REPLACE - 257)) | (1L << (RESPECT - 257)) | (1L << (RESTRICT_REFERENCES - 257)) | (1L << (RESULT - 257)) | (1L << (RESULT_CACHE - 257)) | (1L << (RETURN - 257)) | (1L << (RETURNING - 257)) | (1L << (REUSE - 257)) | (1L << (REVERSE - 257)))) != 0) || ((((_la - 322)) & ~0x3f) == 0 && ((1L << (_la - 322)) & ((1L << (RIGHT - 322)) | (1L << (ROLLBACK - 322)) | (1L << (ROLLUP - 322)) | (1L << (ROW - 322)) | (1L << (ROWID - 322)) | (1L << (ROWS - 322)) | (1L << (RULES - 322)) | (1L << (SAMPLE - 322)) | (1L << (SAVE - 322)) | (1L << (SAVEPOINT - 322)) | (1L << (SCHEMA - 322)) | (1L << (SCHEMACHECK - 322)) | (1L << (SCN - 322)) | (1L << (SECOND - 322)) | (1L << (SEED - 322)) | (1L << (SEGMENT - 322)) | (1L << (SELF - 322)) | (1L << (SEQUENTIAL - 322)) | (1L << (SERIALIZABLE - 322)) | (1L << (SERIALLY_REUSABLE - 322)) | (1L << (SERVERERROR - 322)) | (1L << (SESSIONTIMEZONE - 322)) | (1L << (SET - 322)) | (1L << (SETS - 322)) | (1L << (SETTINGS - 322)) | (1L << (SHOW - 322)) | (1L << (SHUTDOWN - 322)) | (1L << (SIBLINGS - 322)) | (1L << (SIGNTYPE - 322)) | (1L << (SIMPLE_INTEGER - 322)) | (1L << (SINGLE - 322)) | (1L << (SKIP_ - 322)) | (1L << (SMALLINT - 322)) | (1L << (SNAPSHOT - 322)) | (1L << (SOME - 322)) | (1L << (SPECIFICATION - 322)) | (1L << (SQLDATA - 322)) | (1L << (SQLERROR - 322)) | (1L << (STANDALONE - 322)) | (1L << (STARTUP - 322)) | (1L << (STATEMENT - 322)) | (1L << (STATEMENT_ID - 322)) | (1L << (STATIC - 322)) | (1L << (STATISTICS - 322)) | (1L << (STRING - 322)) | (1L << (SUBMULTISET - 322)) | (1L << (SUBPARTITION - 322)) | (1L << (SUBSTITUTABLE - 322)) | (1L << (SUBTYPE - 322)) | (1L << (SUCCESS - 322)) | (1L << (SUSPEND - 322)) | (1L << (TIME - 322)) | (1L << (TIMESTAMP - 322)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 322)))) != 0) || ((((_la - 386)) & ~0x3f) == 0 && ((1L << (_la - 386)) & ((1L << (TIMESTAMP_UNCONSTRAINED - 386)) | (1L << (TIMEZONE_ABBR - 386)) | (1L << (TIMEZONE_HOUR - 386)) | (1L << (TIMEZONE_MINUTE - 386)) | (1L << (TIMEZONE_REGION - 386)) | (1L << (TRAILING - 386)) | (1L << (TRANSACTION - 386)) | (1L << (TRANSLATE - 386)) | (1L << (TREAT - 386)) | (1L << (TRIGGER - 386)) | (1L << (TRUE - 386)) | (1L << (TRUNCATE - 386)) | (1L << (TYPE - 386)) | (1L << (UNBOUNDED - 386)) | (1L << (UNDER - 386)) | (1L << (UNIQUE - 386)) | (1L << (UNLIMITED - 386)) | (1L << (UNTIL - 386)) | (1L << (UPDATED - 386)) | (1L << (UPSERT - 386)) | (1L << (UROWID - 386)) | (1L << (USE - 386)) | (1L << (VALIDATE - 386)) | (1L << (VALUE - 386)) | (1L << (VARCHAR - 386)) | (1L << (VARCHAR2 - 386)) | (1L << (VARIABLE - 386)) | (1L << (VARRAY - 386)) | (1L << (VARYING - 386)) | (1L << (VERSION - 386)) | (1L << (VERSIONS - 386)) | (1L << (WAIT - 386)) | (1L << (WARNING - 386)) | (1L << (WELLFORMED - 386)) | (1L << (WHENEVER - 386)) | (1L << (WHILE - 386)) | (1L << (WITHIN - 386)) | (1L << (WORK - 386)) | (1L << (WRITE - 386)) | (1L << (XML - 386)) | (1L << (XMLAGG - 386)) | (1L << (XMLATTRIBUTES - 386)) | (1L << (XMLCAST - 386)) | (1L << (XMLCOLATTVAL - 386)) | (1L << (XMLELEMENT - 386)) | (1L << (XMLEXISTS - 386)) | (1L << (XMLFOREST - 386)) | (1L << (XMLNAMESPACES - 386)) | (1L << (XMLPARSE - 386)) | (1L << (XMLPI - 386)) | (1L << (XMLQUERY - 386)) | (1L << (XMLROOT - 386)) | (1L << (XMLSERIALIZE - 386)) | (1L << (XMLTABLE - 386)) | (1L << (YEAR - 386)))) != 0) || ((((_la - 450)) & ~0x3f) == 0 && ((1L << (_la - 450)) & ((1L << (YES - 450)) | (1L << (YMINTERVAL_UNCONSTRAINED - 450)) | (1L << (ZONE - 450)) | (1L << (PREDICTION - 450)) | (1L << (PREDICTION_BOUNDS - 450)) | (1L << (PREDICTION_COST - 450)) | (1L << (PREDICTION_DETAILS - 450)) | (1L << (PREDICTION_PROBABILITY - 450)) | (1L << (PREDICTION_SET - 450)) | (1L << (CUME_DIST - 450)) | (1L << (DENSE_RANK - 450)) | (1L << (LISTAGG - 450)) | (1L << (PERCENT_RANK - 450)) | (1L << (PERCENTILE_CONT - 450)) | (1L << (PERCENTILE_DISC - 450)) | (1L << (RANK - 450)) | (1L << (AVG - 450)) | (1L << (CORR - 450)) | (1L << (COVAR_ - 450)) | (1L << (DECODE - 450)) | (1L << (LAG - 450)) | (1L << (LEAD - 450)) | (1L << (MAX - 450)) | (1L << (MEDIAN - 450)) | (1L << (MIN - 450)) | (1L << (NTILE - 450)) | (1L << (NVL - 450)) | (1L << (RATIO_TO_REPORT - 450)) | (1L << (REGR_ - 450)) | (1L << (ROUND - 450)) | (1L << (ROW_NUMBER - 450)) | (1L << (SUBSTR - 450)) | (1L << (TO_CHAR - 450)) | (1L << (TRIM - 450)) | (1L << (SUM - 450)) | (1L << (STDDEV - 450)) | (1L << (VAR_ - 450)) | (1L << (VARIANCE - 450)) | (1L << (NATIONAL_CHAR_STRING_LIT - 450)) | (1L << (UNSIGNED_INTEGER - 450)) | (1L << (APPROXIMATE_NUM_LIT - 450)) | (1L << (CHAR_STRING - 450)) | (1L << (DELIMITED_ID - 450)) | (1L << (LEFT_PAREN - 450)) | (1L << (PLUS_SIGN - 450)) | (1L << (MINUS_SIGN - 450)) | (1L << (BINDVAR - 450)) | (1L << (COLON - 450)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
						{
						State = 4318;
						switch ( Interpreter.AdaptivePredict(_input,535,_ctx) ) {
						case 1:
							{
							State = 4317;
							_la = _input.La(1);
							if ( !(_la==ALL || _la==DISTINCT || _la==UNIQUE) ) {
							_errHandler.RecoverInline(this);
							}
							Consume();
							}
							break;
						}
						State = 4320; concatenation();
						}
					}

					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 4325; Match(RIGHT_PAREN);
				State = 4327;
				switch ( Interpreter.AdaptivePredict(_input,538,_ctx) ) {
				case 1:
					{
					State = 4326; over_clause();
					}
					break;
				}
				}
				break;
			case ROUND:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4329; Match(ROUND);
				State = 4330; Match(LEFT_PAREN);
				State = 4331; expression();
				State = 4334;
				_la = _input.La(1);
				if (_la==COMMA) {
					{
					State = 4332; Match(COMMA);
					State = 4333; Match(UNSIGNED_INTEGER);
					}
				}

				State = 4336; Match(RIGHT_PAREN);
				}
				break;
			case AVG:
				EnterOuterAlt(_localctx, 4);
				{
				State = 4338; Match(AVG);
				State = 4339; Match(LEFT_PAREN);
				State = 4341;
				switch ( Interpreter.AdaptivePredict(_input,540,_ctx) ) {
				case 1:
					{
					State = 4340;
					_la = _input.La(1);
					if ( !(_la==ALL || _la==DISTINCT) ) {
					_errHandler.RecoverInline(this);
					}
					Consume();
					}
					break;
				}
				State = 4343; expression();
				State = 4344; Match(RIGHT_PAREN);
				}
				break;
			case MAX:
				EnterOuterAlt(_localctx, 5);
				{
				State = 4346; Match(MAX);
				State = 4347; Match(LEFT_PAREN);
				State = 4349;
				switch ( Interpreter.AdaptivePredict(_input,541,_ctx) ) {
				case 1:
					{
					State = 4348;
					_la = _input.La(1);
					if ( !(_la==ALL || _la==DISTINCT) ) {
					_errHandler.RecoverInline(this);
					}
					Consume();
					}
					break;
				}
				State = 4351; expression();
				State = 4352; Match(RIGHT_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Other_functionContext : ParserRuleContext {
		public Xml_table_columnContext xml_table_column(int i) {
			return GetRuleContext<Xml_table_columnContext>(i);
		}
		public ITerminalNode EVALNAME() { return GetToken(plsqlParser.EVALNAME, 0); }
		public ITerminalNode XMLCOLATTVAL() { return GetToken(plsqlParser.XMLCOLATTVAL, 0); }
		public Xmlserialize_param_version_partContext xmlserialize_param_version_part() {
			return GetRuleContext<Xmlserialize_param_version_partContext>(0);
		}
		public ITerminalNode XMLELEMENT() { return GetToken(plsqlParser.XMLELEMENT, 0); }
		public Using_clauseContext using_clause() {
			return GetRuleContext<Using_clauseContext>(0);
		}
		public ITerminalNode PERCENT_FOUND() { return GetToken(plsqlParser.PERCENT_FOUND, 0); }
		public ITerminalNode EXTRACT() { return GetToken(plsqlParser.EXTRACT, 0); }
		public ITerminalNode TRAILING() { return GetToken(plsqlParser.TRAILING, 0); }
		public ITerminalNode WELLFORMED() { return GetToken(plsqlParser.WELLFORMED, 0); }
		public Xmlroot_param_version_partContext xmlroot_param_version_part() {
			return GetRuleContext<Xmlroot_param_version_partContext>(0);
		}
		public General_element_partContext general_element_part() {
			return GetRuleContext<General_element_partContext>(0);
		}
		public Quoted_stringContext quoted_string() {
			return GetRuleContext<Quoted_stringContext>(0);
		}
		public ITerminalNode DOCUMENT() { return GetToken(plsqlParser.DOCUMENT, 0); }
		public ITerminalNode XMLCAST() { return GetToken(plsqlParser.XMLCAST, 0); }
		public ITerminalNode COALESCE() { return GetToken(plsqlParser.COALESCE, 0); }
		public ConcatenationContext concatenation(int i) {
			return GetRuleContext<ConcatenationContext>(i);
		}
		public NumericContext numeric() {
			return GetRuleContext<NumericContext>(0);
		}
		public IReadOnlyList<Xml_multiuse_expression_elementContext> xml_multiuse_expression_element() {
			return GetRuleContexts<Xml_multiuse_expression_elementContext>();
		}
		public ITerminalNode REF() { return GetToken(plsqlParser.REF, 0); }
		public ITerminalNode LEADING() { return GetToken(plsqlParser.LEADING, 0); }
		public ITerminalNode PERCENT_ISOPEN() { return GetToken(plsqlParser.PERCENT_ISOPEN, 0); }
		public Over_clause_keywordContext over_clause_keyword() {
			return GetRuleContext<Over_clause_keywordContext>(0);
		}
		public Xml_attributes_clauseContext xml_attributes_clause() {
			return GetRuleContext<Xml_attributes_clauseContext>(0);
		}
		public ITerminalNode LAST_VALUE() { return GetToken(plsqlParser.LAST_VALUE, 0); }
		public Xmlroot_param_standalone_partContext xmlroot_param_standalone_part() {
			return GetRuleContext<Xmlroot_param_standalone_partContext>(0);
		}
		public Xml_namespaces_clauseContext xml_namespaces_clause() {
			return GetRuleContext<Xml_namespaces_clauseContext>(0);
		}
		public Standard_prediction_function_keywordContext standard_prediction_function_keyword() {
			return GetRuleContext<Standard_prediction_function_keywordContext>(0);
		}
		public ITerminalNode AS() { return GetToken(plsqlParser.AS, 0); }
		public ITerminalNode XMLFOREST() { return GetToken(plsqlParser.XMLFOREST, 0); }
		public Function_argument_modelingContext function_argument_modeling() {
			return GetRuleContext<Function_argument_modelingContext>(0);
		}
		public ITerminalNode COMPATIBILITY() { return GetToken(plsqlParser.COMPATIBILITY, 0); }
		public ITerminalNode PERCENT_ROWCOUNT() { return GetToken(plsqlParser.PERCENT_ROWCOUNT, 0); }
		public ITerminalNode XMLROOT() { return GetToken(plsqlParser.XMLROOT, 0); }
		public ITerminalNode SHOW() { return GetToken(plsqlParser.SHOW, 0); }
		public Function_argument_analyticContext function_argument_analytic() {
			return GetRuleContext<Function_argument_analyticContext>(0);
		}
		public ITerminalNode COLLECT() { return GetToken(plsqlParser.COLLECT, 0); }
		public Function_argumentContext function_argument() {
			return GetRuleContext<Function_argumentContext>(0);
		}
		public IReadOnlyList<Within_or_over_partContext> within_or_over_part() {
			return GetRuleContexts<Within_or_over_partContext>();
		}
		public Within_or_over_clause_keywordContext within_or_over_clause_keyword() {
			return GetRuleContext<Within_or_over_clause_keywordContext>(0);
		}
		public ITerminalNode COLUMNS() { return GetToken(plsqlParser.COLUMNS, 0); }
		public ITerminalNode TRANSLATE() { return GetToken(plsqlParser.TRANSLATE, 0); }
		public ITerminalNode DISTINCT() { return GetToken(plsqlParser.DISTINCT, 0); }
		public ITerminalNode DEFAULTS() { return GetToken(plsqlParser.DEFAULTS, 0); }
		public ITerminalNode EMPTY() { return GetToken(plsqlParser.EMPTY, 0); }
		public ITerminalNode RETURNING() { return GetToken(plsqlParser.RETURNING, 0); }
		public ITerminalNode COUNT() { return GetToken(plsqlParser.COUNT, 0); }
		public Regular_idContext regular_id() {
			return GetRuleContext<Regular_idContext>(0);
		}
		public ITerminalNode MULTISET() { return GetToken(plsqlParser.MULTISET, 0); }
		public ITerminalNode XMLAGG() { return GetToken(plsqlParser.XMLAGG, 0); }
		public Within_or_over_partContext within_or_over_part(int i) {
			return GetRuleContext<Within_or_over_partContext>(i);
		}
		public ITerminalNode NULL() { return GetToken(plsqlParser.NULL, 0); }
		public ITerminalNode NAME() { return GetToken(plsqlParser.NAME, 0); }
		public Cursor_nameContext cursor_name() {
			return GetRuleContext<Cursor_nameContext>(0);
		}
		public ITerminalNode HIDE() { return GetToken(plsqlParser.HIDE, 0); }
		public ITerminalNode CAST() { return GetToken(plsqlParser.CAST, 0); }
		public Xml_multiuse_expression_elementContext xml_multiuse_expression_element(int i) {
			return GetRuleContext<Xml_multiuse_expression_elementContext>(i);
		}
		public Column_aliasContext column_alias(int i) {
			return GetRuleContext<Column_aliasContext>(i);
		}
		public ITerminalNode CHAR_CS() { return GetToken(plsqlParser.CHAR_CS, 0); }
		public ITerminalNode CONTENT() { return GetToken(plsqlParser.CONTENT, 0); }
		public ITerminalNode NCHAR_CS() { return GetToken(plsqlParser.NCHAR_CS, 0); }
		public ITerminalNode USING() { return GetToken(plsqlParser.USING, 0); }
		public ITerminalNode NOENTITYESCAPING() { return GetToken(plsqlParser.NOENTITYESCAPING, 0); }
		public ITerminalNode DECOMPOSE() { return GetToken(plsqlParser.DECOMPOSE, 0); }
		public ITerminalNode BOTH() { return GetToken(plsqlParser.BOTH, 0); }
		public ITerminalNode XMLPARSE() { return GetToken(plsqlParser.XMLPARSE, 0); }
		public Order_by_clauseContext order_by_clause() {
			return GetRuleContext<Order_by_clauseContext>(0);
		}
		public ITerminalNode XMLTABLE() { return GetToken(plsqlParser.XMLTABLE, 0); }
		public ITerminalNode TREAT() { return GetToken(plsqlParser.TREAT, 0); }
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public Xmlserialize_param_enconding_partContext xmlserialize_param_enconding_part() {
			return GetRuleContext<Xmlserialize_param_enconding_partContext>(0);
		}
		public ITerminalNode ENTITYESCAPING() { return GetToken(plsqlParser.ENTITYESCAPING, 0); }
		public ITerminalNode TRIM() { return GetToken(plsqlParser.TRIM, 0); }
		public ITerminalNode ALL() { return GetToken(plsqlParser.ALL, 0); }
		public ITerminalNode XMLSERIALIZE() { return GetToken(plsqlParser.XMLSERIALIZE, 0); }
		public Respect_or_ignore_nullsContext respect_or_ignore_nulls() {
			return GetRuleContext<Respect_or_ignore_nullsContext>(0);
		}
		public ITerminalNode COMMA() { return GetToken(plsqlParser.COMMA, 0); }
		public Xmlserialize_param_ident_partContext xmlserialize_param_ident_part() {
			return GetRuleContext<Xmlserialize_param_ident_partContext>(0);
		}
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode FIRST_VALUE() { return GetToken(plsqlParser.FIRST_VALUE, 0); }
		public ITerminalNode XMLEXISTS() { return GetToken(plsqlParser.XMLEXISTS, 0); }
		public ITerminalNode XMLPI() { return GetToken(plsqlParser.XMLPI, 0); }
		public ITerminalNode CANONICAL() { return GetToken(plsqlParser.CANONICAL, 0); }
		public ITerminalNode ON() { return GetToken(plsqlParser.ON, 0); }
		public IReadOnlyList<ConcatenationContext> concatenation() {
			return GetRuleContexts<ConcatenationContext>();
		}
		public IReadOnlyList<Xml_table_columnContext> xml_table_column() {
			return GetRuleContexts<Xml_table_columnContext>();
		}
		public ITerminalNode FROM() { return GetToken(plsqlParser.FROM, 0); }
		public Xml_passing_clauseContext xml_passing_clause() {
			return GetRuleContext<Xml_passing_clauseContext>(0);
		}
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Collect_order_by_partContext collect_order_by_part() {
			return GetRuleContext<Collect_order_by_partContext>(0);
		}
		public ITerminalNode PERCENT_NOTFOUND() { return GetToken(plsqlParser.PERCENT_NOTFOUND, 0); }
		public IReadOnlyList<Column_aliasContext> column_alias() {
			return GetRuleContexts<Column_aliasContext>();
		}
		public ITerminalNode UNIQUE() { return GetToken(plsqlParser.UNIQUE, 0); }
		public Table_elementContext table_element() {
			return GetRuleContext<Table_elementContext>(0);
		}
		public ITerminalNode XMLQUERY() { return GetToken(plsqlParser.XMLQUERY, 0); }
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public Over_clauseContext over_clause() {
			return GetRuleContext<Over_clauseContext>(0);
		}
		public Cost_matrix_clauseContext cost_matrix_clause() {
			return GetRuleContext<Cost_matrix_clauseContext>(0);
		}
		public Other_functionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_other_function; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterOther_function(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitOther_function(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOther_function(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Other_functionContext other_function() {
		Other_functionContext _localctx = new Other_functionContext(_ctx, State);
		EnterRule(_localctx, 576, RULE_other_function);
		int _la;
		try {
			int _alt;
			State = 4678;
			switch ( Interpreter.AdaptivePredict(_input,597,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4356; over_clause_keyword();
				State = 4357; function_argument_analytic();
				State = 4359;
				switch ( Interpreter.AdaptivePredict(_input,543,_ctx) ) {
				case 1:
					{
					State = 4358; over_clause();
					}
					break;
				}
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4361; regular_id();
				State = 4362; function_argument_modeling();
				State = 4364;
				switch ( Interpreter.AdaptivePredict(_input,544,_ctx) ) {
				case 1:
					{
					State = 4363; using_clause();
					}
					break;
				}
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4366; Match(COUNT);
				State = 4367; Match(LEFT_PAREN);
				State = 4373;
				switch (_input.La(1)) {
				case ASTERISK:
					{
					State = 4368; Match(ASTERISK);
					}
					break;
				case A_LETTER:
				case ADD:
				case AFTER:
				case AGENT:
				case AGGREGATE:
				case ALL:
				case ANALYZE:
				case ANY:
				case ARRAY:
				case ASSOCIATE:
				case AT:
				case ATTRIBUTE:
				case AUDIT:
				case AUTHID:
				case AUTO:
				case AUTOMATIC:
				case AUTONOMOUS_TRANSACTION:
				case BATCH:
				case BEFORE:
				case BFILE:
				case BINARY_DOUBLE:
				case BINARY_FLOAT:
				case BINARY_INTEGER:
				case BLOB:
				case BLOCK:
				case BODY:
				case BOOLEAN:
				case BOTH:
				case BULK:
				case BYTE:
				case C_LETTER:
				case CALL:
				case CANONICAL:
				case CASCADE:
				case CASE:
				case CAST:
				case CHAR:
				case CHAR_CS:
				case CHARACTER:
				case CHR:
				case CLOB:
				case CLOSE:
				case CLUSTER:
				case COALESCE:
				case COLLECT:
				case COLUMNS:
				case COMMENT:
				case COMMIT:
				case COMMITTED:
				case COMPATIBILITY:
				case COMPILE:
				case COMPOUND:
				case CONNECT_BY_ROOT:
				case CONSTANT:
				case CONSTRAINT:
				case CONSTRAINTS:
				case CONSTRUCTOR:
				case CONTENT:
				case CONTEXT:
				case CONTINUE:
				case CONVERT:
				case CORRUPT_XID:
				case CORRUPT_XID_ALL:
				case COST:
				case COUNT:
				case CROSS:
				case CUBE:
				case CURRENT_USER:
				case CURSOR:
				case CUSTOMDATUM:
				case CYCLE:
				case DATA:
				case DATABASE:
				case DATE:
				case DAY:
				case DB_ROLE_CHANGE:
				case DBTIMEZONE:
				case DDL:
				case DEBUG:
				case DEC:
				case DECIMAL:
				case DECOMPOSE:
				case DECREMENT:
				case DEFAULT:
				case DEFAULTS:
				case DEFERRED:
				case DEFINER:
				case DETERMINISTIC:
				case DIMENSION:
				case DISABLE:
				case DISASSOCIATE:
				case DISTINCT:
				case DOCUMENT:
				case DOUBLE:
				case DSINTERVAL_UNCONSTRAINED:
				case EACH:
				case ELEMENT:
				case EMPTY:
				case ENABLE:
				case ENCODING:
				case ENTITYESCAPING:
				case ERR:
				case ERRORS:
				case ESCAPE:
				case EVALNAME:
				case EXCEPTION:
				case EXCEPTION_INIT:
				case EXCEPTIONS:
				case EXCLUDE:
				case EXECUTE:
				case EXISTS:
				case EXIT:
				case EXPLAIN:
				case EXTERNAL:
				case EXTRACT:
				case FAILURE:
				case FALSE:
				case FINAL:
				case FIRST:
				case FIRST_VALUE:
				case FLOAT:
				case FOLLOWING:
				case FOLLOWS:
				case FORALL:
				case FORCE:
				case FULL:
				case FUNCTION:
				case GROUPING:
				case HASH:
				case HIDE:
				case HOUR:
				case IGNORE:
				case IMMEDIATE:
				case INCLUDE:
				case INCLUDING:
				case INCREMENT:
				case INDENT:
				case INDEXED:
				case INDICATOR:
				case INDICES:
				case INFINITE:
				case INLINE:
				case INNER:
				case INOUT:
				case INSTANTIABLE:
				case INSTEAD:
				case INT:
				case INTEGER:
				case INTERVAL:
				case INVALIDATE:
				case ISOLATION:
				case ITERATE:
				case JAVA:
				case JOIN:
				case KEEP:
				case LANGUAGE:
				case LAST:
				case LAST_VALUE:
				case LEADING:
				case LEFT:
				case LEVEL:
				case LIBRARY:
				case LIKE2:
				case LIKE4:
				case LIKEC:
				case LIMIT:
				case LOCAL:
				case LOCKED:
				case LOG:
				case LOGOFF:
				case LOGON:
				case LONG:
				case LOOP:
				case MAIN:
				case MAP:
				case MATCHED:
				case MAXVALUE:
				case MEASURES:
				case MEMBER:
				case MERGE:
				case MINUTE:
				case MINVALUE:
				case MLSLABEL:
				case MODEL:
				case MODIFY:
				case MONTH:
				case MULTISET:
				case NAME:
				case NAN:
				case NATURAL:
				case NATURALN:
				case NAV:
				case NCHAR:
				case NCHAR_CS:
				case NCLOB:
				case NESTED:
				case NEW:
				case NO:
				case NOAUDIT:
				case NOCOPY:
				case NOCYCLE:
				case NOENTITYESCAPING:
				case NONE:
				case NOSCHEMACHECK:
				case NULL:
				case NULLS:
				case NUMBER:
				case NUMERIC:
				case NVARCHAR2:
				case OBJECT:
				case OFF:
				case OID:
				case OLD:
				case ONLY:
				case OPEN:
				case ORADATA:
				case ORDINALITY:
				case OSERROR:
				case OUT:
				case OUTER:
				case OVER:
				case OVERRIDING:
				case PACKAGE:
				case PARALLEL_ENABLE:
				case PARAMETERS:
				case PARENT:
				case PARTITION:
				case PASSING:
				case PATH:
				case PIPELINED:
				case PLAN:
				case PLS_INTEGER:
				case POSITIVE:
				case POSITIVEN:
				case PRAGMA:
				case PRECEDING:
				case PRECISION:
				case PRESENT:
				case PRIOR:
				case RAISE:
				case RANGE:
				case RAW:
				case READ:
				case REAL:
				case RECORD:
				case REF:
				case REFERENCE:
				case REFERENCING:
				case REJECT:
				case RELIES_ON:
				case RENAME:
				case REPLACE:
				case RESPECT:
				case RESTRICT_REFERENCES:
				case RESULT:
				case RESULT_CACHE:
				case RETURN:
				case RETURNING:
				case REUSE:
				case REVERSE:
				case RIGHT:
				case ROLLBACK:
				case ROLLUP:
				case ROW:
				case ROWID:
				case ROWS:
				case RULES:
				case SAMPLE:
				case SAVE:
				case SAVEPOINT:
				case SCHEMA:
				case SCHEMACHECK:
				case SCN:
				case SECOND:
				case SEED:
				case SEGMENT:
				case SELF:
				case SEQUENTIAL:
				case SERIALIZABLE:
				case SERIALLY_REUSABLE:
				case SERVERERROR:
				case SESSIONTIMEZONE:
				case SET:
				case SETS:
				case SETTINGS:
				case SHOW:
				case SHUTDOWN:
				case SIBLINGS:
				case SIGNTYPE:
				case SIMPLE_INTEGER:
				case SINGLE:
				case SKIP_:
				case SMALLINT:
				case SNAPSHOT:
				case SOME:
				case SPECIFICATION:
				case SQLDATA:
				case SQLERROR:
				case STANDALONE:
				case STARTUP:
				case STATEMENT:
				case STATEMENT_ID:
				case STATIC:
				case STATISTICS:
				case STRING:
				case SUBMULTISET:
				case SUBPARTITION:
				case SUBSTITUTABLE:
				case SUBTYPE:
				case SUCCESS:
				case SUSPEND:
				case TIME:
				case TIMESTAMP:
				case TIMESTAMP_LTZ_UNCONSTRAINED:
				case TIMESTAMP_TZ_UNCONSTRAINED:
				case TIMESTAMP_UNCONSTRAINED:
				case TIMEZONE_ABBR:
				case TIMEZONE_HOUR:
				case TIMEZONE_MINUTE:
				case TIMEZONE_REGION:
				case TRAILING:
				case TRANSACTION:
				case TRANSLATE:
				case TREAT:
				case TRIGGER:
				case TRUE:
				case TRUNCATE:
				case TYPE:
				case UNBOUNDED:
				case UNDER:
				case UNIQUE:
				case UNLIMITED:
				case UNTIL:
				case UPDATED:
				case UPSERT:
				case UROWID:
				case USE:
				case VALIDATE:
				case VALUE:
				case VARCHAR:
				case VARCHAR2:
				case VARIABLE:
				case VARRAY:
				case VARYING:
				case VERSION:
				case VERSIONS:
				case WAIT:
				case WARNING:
				case WELLFORMED:
				case WHENEVER:
				case WHILE:
				case WITHIN:
				case WORK:
				case WRITE:
				case XML:
				case XMLAGG:
				case XMLATTRIBUTES:
				case XMLCAST:
				case XMLCOLATTVAL:
				case XMLELEMENT:
				case XMLEXISTS:
				case XMLFOREST:
				case XMLNAMESPACES:
				case XMLPARSE:
				case XMLPI:
				case XMLQUERY:
				case XMLROOT:
				case XMLSERIALIZE:
				case XMLTABLE:
				case YEAR:
				case YES:
				case YMINTERVAL_UNCONSTRAINED:
				case ZONE:
				case PREDICTION:
				case PREDICTION_BOUNDS:
				case PREDICTION_COST:
				case PREDICTION_DETAILS:
				case PREDICTION_PROBABILITY:
				case PREDICTION_SET:
				case CUME_DIST:
				case DENSE_RANK:
				case LISTAGG:
				case PERCENT_RANK:
				case PERCENTILE_CONT:
				case PERCENTILE_DISC:
				case RANK:
				case AVG:
				case CORR:
				case COVAR_:
				case DECODE:
				case LAG:
				case LEAD:
				case MAX:
				case MEDIAN:
				case MIN:
				case NTILE:
				case NVL:
				case RATIO_TO_REPORT:
				case REGR_:
				case ROUND:
				case ROW_NUMBER:
				case SUBSTR:
				case TO_CHAR:
				case TRIM:
				case SUM:
				case STDDEV:
				case VAR_:
				case VARIANCE:
				case NATIONAL_CHAR_STRING_LIT:
				case UNSIGNED_INTEGER:
				case APPROXIMATE_NUM_LIT:
				case CHAR_STRING:
				case DELIMITED_ID:
				case LEFT_PAREN:
				case PLUS_SIGN:
				case MINUS_SIGN:
				case BINDVAR:
				case COLON:
				case INTRODUCER:
				case REGULAR_ID:
					{
					State = 4370;
					switch ( Interpreter.AdaptivePredict(_input,545,_ctx) ) {
					case 1:
						{
						State = 4369;
						_la = _input.La(1);
						if ( !(_la==ALL || _la==DISTINCT || _la==UNIQUE) ) {
						_errHandler.RecoverInline(this);
						}
						Consume();
						}
						break;
					}
					State = 4372; concatenation();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 4375; Match(RIGHT_PAREN);
				State = 4377;
				switch ( Interpreter.AdaptivePredict(_input,547,_ctx) ) {
				case 1:
					{
					State = 4376; over_clause();
					}
					break;
				}
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 4379;
				_la = _input.La(1);
				if ( !(_la==CAST || _la==XMLCAST) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				State = 4380; Match(LEFT_PAREN);
				State = 4387;
				switch ( Interpreter.AdaptivePredict(_input,548,_ctx) ) {
				case 1:
					{
					State = 4381; Match(MULTISET);
					State = 4382; Match(LEFT_PAREN);
					State = 4383; subquery();
					State = 4384; Match(RIGHT_PAREN);
					}
					break;

				case 2:
					{
					State = 4386; concatenation();
					}
					break;
				}
				State = 4389; Match(AS);
				State = 4390; type_spec();
				State = 4391; Match(RIGHT_PAREN);
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 4393; Match(COALESCE);
				State = 4394; Match(LEFT_PAREN);
				State = 4395; table_element();
				State = 4401;
				_la = _input.La(1);
				if (_la==COMMA) {
					{
					State = 4396; Match(COMMA);
					State = 4399;
					switch (_input.La(1)) {
					case UNSIGNED_INTEGER:
					case APPROXIMATE_NUM_LIT:
						{
						State = 4397; numeric();
						}
						break;
					case NATIONAL_CHAR_STRING_LIT:
					case CHAR_STRING:
						{
						State = 4398; quoted_string();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
				}

				State = 4403; Match(RIGHT_PAREN);
				}
				break;

			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 4405; Match(COLLECT);
				State = 4406; Match(LEFT_PAREN);
				State = 4408;
				switch ( Interpreter.AdaptivePredict(_input,551,_ctx) ) {
				case 1:
					{
					State = 4407;
					_la = _input.La(1);
					if ( !(_la==DISTINCT || _la==UNIQUE) ) {
					_errHandler.RecoverInline(this);
					}
					Consume();
					}
					break;
				}
				State = 4410; concatenation();
				State = 4412;
				_la = _input.La(1);
				if (_la==ORDER) {
					{
					State = 4411; collect_order_by_part();
					}
				}

				State = 4414; Match(RIGHT_PAREN);
				}
				break;

			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 4416; within_or_over_clause_keyword();
				State = 4417; function_argument();
				State = 4419;
				_errHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						State = 4418; within_or_over_part();
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 4421;
					_errHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(_input,553,_ctx);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber );
				}
				break;

			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 4423; cursor_name();
				State = 4424;
				_la = _input.La(1);
				if ( !(((((_la - 282)) & ~0x3f) == 0 && ((1L << (_la - 282)) & ((1L << (PERCENT_ISOPEN - 282)) | (1L << (PERCENT_FOUND - 282)) | (1L << (PERCENT_NOTFOUND - 282)) | (1L << (PERCENT_ROWCOUNT - 282)))) != 0)) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				}
				break;

			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 4426; Match(DECOMPOSE);
				State = 4427; Match(LEFT_PAREN);
				State = 4428; concatenation();
				State = 4430;
				_la = _input.La(1);
				if (_la==CANONICAL || _la==COMPATIBILITY) {
					{
					State = 4429;
					_la = _input.La(1);
					if ( !(_la==CANONICAL || _la==COMPATIBILITY) ) {
					_errHandler.RecoverInline(this);
					}
					Consume();
					}
				}

				State = 4432; Match(RIGHT_PAREN);
				}
				break;

			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 4434; Match(EXTRACT);
				State = 4435; Match(LEFT_PAREN);
				State = 4436; regular_id();
				State = 4437; Match(FROM);
				State = 4438; concatenation();
				State = 4439; Match(RIGHT_PAREN);
				}
				break;

			case 11:
				EnterOuterAlt(_localctx, 11);
				{
				State = 4441;
				_la = _input.La(1);
				if ( !(_la==FIRST_VALUE || _la==LAST_VALUE) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				State = 4442; function_argument_analytic();
				State = 4444;
				_la = _input.La(1);
				if (_la==IGNORE || _la==RESPECT) {
					{
					State = 4443; respect_or_ignore_nulls();
					}
				}

				State = 4446; over_clause();
				}
				break;

			case 12:
				EnterOuterAlt(_localctx, 12);
				{
				State = 4448; standard_prediction_function_keyword();
				State = 4449; Match(LEFT_PAREN);
				State = 4450; expression();
				State = 4455;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 4451; Match(COMMA);
					State = 4452; expression();
					}
					}
					State = 4457;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 4459;
				_la = _input.La(1);
				if (_la==COST) {
					{
					State = 4458; cost_matrix_clause();
					}
				}

				State = 4462;
				_la = _input.La(1);
				if (_la==USING) {
					{
					State = 4461; using_clause();
					}
				}

				State = 4464; Match(RIGHT_PAREN);
				}
				break;

			case 13:
				EnterOuterAlt(_localctx, 13);
				{
				State = 4466; Match(TRANSLATE);
				State = 4467; Match(LEFT_PAREN);
				State = 4468; expression();
				State = 4471;
				_la = _input.La(1);
				if (_la==USING) {
					{
					State = 4469; Match(USING);
					State = 4470;
					_la = _input.La(1);
					if ( !(_la==CHAR_CS || _la==NCHAR_CS) ) {
					_errHandler.RecoverInline(this);
					}
					Consume();
					}
				}

				State = 4477;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 4473; Match(COMMA);
					State = 4474; expression();
					}
					}
					State = 4479;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 4480; Match(RIGHT_PAREN);
				}
				break;

			case 14:
				EnterOuterAlt(_localctx, 14);
				{
				State = 4482; Match(TREAT);
				State = 4483; Match(LEFT_PAREN);
				State = 4484; expression();
				State = 4485; Match(AS);
				State = 4487;
				switch ( Interpreter.AdaptivePredict(_input,561,_ctx) ) {
				case 1:
					{
					State = 4486; Match(REF);
					}
					break;
				}
				State = 4489; type_spec();
				State = 4490; Match(RIGHT_PAREN);
				}
				break;

			case 15:
				EnterOuterAlt(_localctx, 15);
				{
				State = 4492; Match(TRIM);
				State = 4493; Match(LEFT_PAREN);
				State = 4501;
				switch ( Interpreter.AdaptivePredict(_input,564,_ctx) ) {
				case 1:
					{
					State = 4495;
					_la = _input.La(1);
					if (_la==BOTH || _la==LEADING || _la==TRAILING) {
						{
						State = 4494;
						_la = _input.La(1);
						if ( !(_la==BOTH || _la==LEADING || _la==TRAILING) ) {
						_errHandler.RecoverInline(this);
						}
						Consume();
						}
					}

					State = 4498;
					_la = _input.La(1);
					if (_la==NATIONAL_CHAR_STRING_LIT || _la==CHAR_STRING) {
						{
						State = 4497; quoted_string();
						}
					}

					State = 4500; Match(FROM);
					}
					break;
				}
				State = 4503; concatenation();
				State = 4504; Match(RIGHT_PAREN);
				}
				break;

			case 16:
				EnterOuterAlt(_localctx, 16);
				{
				State = 4506; Match(XMLAGG);
				State = 4507; Match(LEFT_PAREN);
				State = 4508; expression();
				State = 4510;
				_la = _input.La(1);
				if (_la==ORDER) {
					{
					State = 4509; order_by_clause();
					}
				}

				State = 4512; Match(RIGHT_PAREN);
				State = 4515;
				switch ( Interpreter.AdaptivePredict(_input,566,_ctx) ) {
				case 1:
					{
					State = 4513; Match(PERIOD);
					State = 4514; general_element_part();
					}
					break;
				}
				}
				break;

			case 17:
				EnterOuterAlt(_localctx, 17);
				{
				State = 4517;
				_la = _input.La(1);
				if ( !(_la==XMLCOLATTVAL || _la==XMLFOREST) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				State = 4518; Match(LEFT_PAREN);
				State = 4519; xml_multiuse_expression_element();
				State = 4524;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 4520; Match(COMMA);
					State = 4521; xml_multiuse_expression_element();
					}
					}
					State = 4526;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 4527; Match(RIGHT_PAREN);
				State = 4530;
				switch ( Interpreter.AdaptivePredict(_input,568,_ctx) ) {
				case 1:
					{
					State = 4528; Match(PERIOD);
					State = 4529; general_element_part();
					}
					break;
				}
				}
				break;

			case 18:
				EnterOuterAlt(_localctx, 18);
				{
				State = 4532; Match(XMLELEMENT);
				State = 4533; Match(LEFT_PAREN);
				State = 4535;
				switch ( Interpreter.AdaptivePredict(_input,569,_ctx) ) {
				case 1:
					{
					State = 4534;
					_la = _input.La(1);
					if ( !(_la==ENTITYESCAPING || _la==NOENTITYESCAPING) ) {
					_errHandler.RecoverInline(this);
					}
					Consume();
					}
					break;
				}
				State = 4538;
				switch ( Interpreter.AdaptivePredict(_input,570,_ctx) ) {
				case 1:
					{
					State = 4537;
					_la = _input.La(1);
					if ( !(_la==EVALNAME || _la==NAME) ) {
					_errHandler.RecoverInline(this);
					}
					Consume();
					}
					break;
				}
				State = 4540; expression();
				State = 4543;
				switch ( Interpreter.AdaptivePredict(_input,571,_ctx) ) {
				case 1:
					{
					State = 4541; Match(COMMA);
					State = 4542; xml_attributes_clause();
					}
					break;
				}
				State = 4552;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 4545; Match(COMMA);
					State = 4546; expression();
					State = 4548;
					_la = _input.La(1);
					if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << AS) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (CONSTANT - 66)) | (1L << (CONSTRAINT - 66)) | (1L << (CONSTRAINTS - 66)) | (1L << (CONSTRUCTOR - 66)) | (1L << (CONTENT - 66)) | (1L << (CONTEXT - 66)) | (1L << (CONTINUE - 66)) | (1L << (CONVERT - 66)) | (1L << (CORRUPT_XID - 66)) | (1L << (CORRUPT_XID_ALL - 66)) | (1L << (COST - 66)) | (1L << (COUNT - 66)) | (1L << (CROSS - 66)) | (1L << (CUBE - 66)) | (1L << (CURRENT_USER - 66)) | (1L << (CURSOR - 66)) | (1L << (CUSTOMDATUM - 66)) | (1L << (CYCLE - 66)) | (1L << (DATA - 66)) | (1L << (DATABASE - 66)) | (1L << (DAY - 66)) | (1L << (DB_ROLE_CHANGE - 66)) | (1L << (DBTIMEZONE - 66)) | (1L << (DDL - 66)) | (1L << (DEBUG - 66)) | (1L << (DEC - 66)) | (1L << (DECIMAL - 66)) | (1L << (DECOMPOSE - 66)) | (1L << (DECREMENT - 66)) | (1L << (DEFAULTS - 66)) | (1L << (DEFERRED - 66)) | (1L << (DEFINER - 66)) | (1L << (DETERMINISTIC - 66)) | (1L << (DIMENSION - 66)) | (1L << (DISABLE - 66)) | (1L << (DISASSOCIATE - 66)) | (1L << (DOCUMENT - 66)) | (1L << (DOUBLE - 66)) | (1L << (DSINTERVAL_UNCONSTRAINED - 66)) | (1L << (EACH - 66)) | (1L << (ELEMENT - 66)) | (1L << (EMPTY - 66)) | (1L << (ENABLE - 66)) | (1L << (ENCODING - 66)) | (1L << (ENTITYESCAPING - 66)) | (1L << (ERR - 66)) | (1L << (ERRORS - 66)) | (1L << (ESCAPE - 66)) | (1L << (EVALNAME - 66)) | (1L << (EXCEPTION - 66)) | (1L << (EXCEPTION_INIT - 66)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)) | (1L << (EXIT - 130)) | (1L << (EXPLAIN - 130)) | (1L << (EXTERNAL - 130)) | (1L << (EXTRACT - 130)) | (1L << (FAILURE - 130)) | (1L << (FINAL - 130)) | (1L << (FIRST - 130)) | (1L << (FIRST_VALUE - 130)) | (1L << (FLOAT - 130)) | (1L << (FOLLOWING - 130)) | (1L << (FOLLOWS - 130)) | (1L << (FORALL - 130)) | (1L << (FORCE - 130)) | (1L << (FULL - 130)) | (1L << (FUNCTION - 130)) | (1L << (GROUPING - 130)) | (1L << (HASH - 130)) | (1L << (HIDE - 130)) | (1L << (HOUR - 130)) | (1L << (IGNORE - 130)) | (1L << (IMMEDIATE - 130)) | (1L << (INCLUDE - 130)) | (1L << (INCLUDING - 130)) | (1L << (INCREMENT - 130)) | (1L << (INDENT - 130)) | (1L << (INDEXED - 130)) | (1L << (INDICATOR - 130)) | (1L << (INDICES - 130)) | (1L << (INFINITE - 130)) | (1L << (INLINE - 130)) | (1L << (INNER - 130)) | (1L << (INOUT - 130)) | (1L << (INSTANTIABLE - 130)) | (1L << (INSTEAD - 130)) | (1L << (INT - 130)) | (1L << (INTEGER - 130)) | (1L << (INTERVAL - 130)) | (1L << (INVALIDATE - 130)) | (1L << (ISOLATION - 130)) | (1L << (ITERATE - 130)) | (1L << (JAVA - 130)) | (1L << (JOIN - 130)) | (1L << (KEEP - 130)) | (1L << (LANGUAGE - 130)))) != 0) || ((((_la - 194)) & ~0x3f) == 0 && ((1L << (_la - 194)) & ((1L << (LAST - 194)) | (1L << (LAST_VALUE - 194)) | (1L << (LEADING - 194)) | (1L << (LEFT - 194)) | (1L << (LEVEL - 194)) | (1L << (LIBRARY - 194)) | (1L << (LIKE2 - 194)) | (1L << (LIKE4 - 194)) | (1L << (LIKEC - 194)) | (1L << (LIMIT - 194)) | (1L << (LOCAL - 194)) | (1L << (LOCKED - 194)) | (1L << (LOG - 194)) | (1L << (LOGOFF - 194)) | (1L << (LOGON - 194)) | (1L << (LONG - 194)) | (1L << (LOOP - 194)) | (1L << (MAIN - 194)) | (1L << (MAP - 194)) | (1L << (MATCHED - 194)) | (1L << (MAXVALUE - 194)) | (1L << (MEASURES - 194)) | (1L << (MEMBER - 194)) | (1L << (MERGE - 194)) | (1L << (MINUTE - 194)) | (1L << (MINVALUE - 194)) | (1L << (MLSLABEL - 194)) | (1L << (MODEL - 194)) | (1L << (MODIFY - 194)) | (1L << (MONTH - 194)) | (1L << (MULTISET - 194)) | (1L << (NAME - 194)) | (1L << (NAN - 194)) | (1L << (NATURAL - 194)) | (1L << (NATURALN - 194)) | (1L << (NAV - 194)) | (1L << (NCHAR - 194)) | (1L << (NCHAR_CS - 194)) | (1L << (NCLOB - 194)) | (1L << (NESTED - 194)) | (1L << (NEW - 194)) | (1L << (NO - 194)) | (1L << (NOAUDIT - 194)) | (1L << (NOCOPY - 194)) | (1L << (NOCYCLE - 194)) | (1L << (NOENTITYESCAPING - 194)) | (1L << (NONE - 194)) | (1L << (NOSCHEMACHECK - 194)) | (1L << (NULLS - 194)) | (1L << (NUMBER - 194)) | (1L << (NUMERIC - 194)) | (1L << (NVARCHAR2 - 194)) | (1L << (OBJECT - 194)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (OFF - 259)) | (1L << (OID - 259)) | (1L << (OLD - 259)) | (1L << (ONLY - 259)) | (1L << (OPEN - 259)) | (1L << (ORADATA - 259)) | (1L << (ORDINALITY - 259)) | (1L << (OSERROR - 259)) | (1L << (OUT - 259)) | (1L << (OUTER - 259)) | (1L << (OVER - 259)) | (1L << (OVERRIDING - 259)) | (1L << (PACKAGE - 259)) | (1L << (PARALLEL_ENABLE - 259)) | (1L << (PARAMETERS - 259)) | (1L << (PARENT - 259)) | (1L << (PARTITION - 259)) | (1L << (PASSING - 259)) | (1L << (PATH - 259)) | (1L << (PIPELINED - 259)) | (1L << (PLAN - 259)) | (1L << (PLS_INTEGER - 259)) | (1L << (POSITIVE - 259)) | (1L << (POSITIVEN - 259)) | (1L << (PRAGMA - 259)) | (1L << (PRECEDING - 259)) | (1L << (PRECISION - 259)) | (1L << (PRESENT - 259)) | (1L << (RAISE - 259)) | (1L << (RANGE - 259)) | (1L << (RAW - 259)) | (1L << (READ - 259)) | (1L << (REAL - 259)) | (1L << (RECORD - 259)) | (1L << (REF - 259)) | (1L << (REFERENCE - 259)) | (1L << (REFERENCING - 259)) | (1L << (REJECT - 259)) | (1L << (RELIES_ON - 259)) | (1L << (RENAME - 259)) | (1L << (REPLACE - 259)) | (1L << (RESPECT - 259)) | (1L << (RESTRICT_REFERENCES - 259)) | (1L << (RESULT - 259)) | (1L << (RESULT_CACHE - 259)) | (1L << (RETURN - 259)) | (1L << (RETURNING - 259)) | (1L << (REUSE - 259)) | (1L << (REVERSE - 259)) | (1L << (RIGHT - 259)))) != 0) || ((((_la - 323)) & ~0x3f) == 0 && ((1L << (_la - 323)) & ((1L << (ROLLBACK - 323)) | (1L << (ROLLUP - 323)) | (1L << (ROW - 323)) | (1L << (ROWID - 323)) | (1L << (ROWS - 323)) | (1L << (RULES - 323)) | (1L << (SAMPLE - 323)) | (1L << (SAVE - 323)) | (1L << (SAVEPOINT - 323)) | (1L << (SCHEMA - 323)) | (1L << (SCHEMACHECK - 323)) | (1L << (SCN - 323)) | (1L << (SECOND - 323)) | (1L << (SEED - 323)) | (1L << (SEGMENT - 323)) | (1L << (SELF - 323)) | (1L << (SEQUENTIAL - 323)) | (1L << (SERIALIZABLE - 323)) | (1L << (SERIALLY_REUSABLE - 323)) | (1L << (SERVERERROR - 323)) | (1L << (SESSIONTIMEZONE - 323)) | (1L << (SET - 323)) | (1L << (SETS - 323)) | (1L << (SETTINGS - 323)) | (1L << (SHOW - 323)) | (1L << (SHUTDOWN - 323)) | (1L << (SIBLINGS - 323)) | (1L << (SIGNTYPE - 323)) | (1L << (SIMPLE_INTEGER - 323)) | (1L << (SINGLE - 323)) | (1L << (SKIP_ - 323)) | (1L << (SMALLINT - 323)) | (1L << (SNAPSHOT - 323)) | (1L << (SOME - 323)) | (1L << (SPECIFICATION - 323)) | (1L << (SQLDATA - 323)) | (1L << (SQLERROR - 323)) | (1L << (STANDALONE - 323)) | (1L << (STARTUP - 323)) | (1L << (STATEMENT - 323)) | (1L << (STATEMENT_ID - 323)) | (1L << (STATIC - 323)) | (1L << (STATISTICS - 323)) | (1L << (STRING - 323)) | (1L << (SUBMULTISET - 323)) | (1L << (SUBPARTITION - 323)) | (1L << (SUBSTITUTABLE - 323)) | (1L << (SUBTYPE - 323)) | (1L << (SUCCESS - 323)) | (1L << (SUSPEND - 323)) | (1L << (TIME - 323)) | (1L << (TIMESTAMP - 323)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_UNCONSTRAINED - 323)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TIMEZONE_ABBR - 387)) | (1L << (TIMEZONE_HOUR - 387)) | (1L << (TIMEZONE_MINUTE - 387)) | (1L << (TIMEZONE_REGION - 387)) | (1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (YMINTERVAL_UNCONSTRAINED - 451)) | (1L << (ZONE - 451)) | (1L << (PREDICTION - 451)) | (1L << (PREDICTION_BOUNDS - 451)) | (1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (COVAR_ - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (REGR_ - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (TRIM - 451)) | (1L << (SUM - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (VARIANCE - 451)) | (1L << (NATIONAL_CHAR_STRING_LIT - 451)) | (1L << (CHAR_STRING - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
						{
						State = 4547; column_alias();
						}
					}

					}
					}
					State = 4554;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 4555; Match(RIGHT_PAREN);
				State = 4558;
				switch ( Interpreter.AdaptivePredict(_input,574,_ctx) ) {
				case 1:
					{
					State = 4556; Match(PERIOD);
					State = 4557; general_element_part();
					}
					break;
				}
				}
				break;

			case 19:
				EnterOuterAlt(_localctx, 19);
				{
				State = 4560; Match(XMLEXISTS);
				State = 4561; Match(LEFT_PAREN);
				State = 4562; expression();
				State = 4564;
				_la = _input.La(1);
				if (_la==PASSING) {
					{
					State = 4563; xml_passing_clause();
					}
				}

				State = 4566; Match(RIGHT_PAREN);
				}
				break;

			case 20:
				EnterOuterAlt(_localctx, 20);
				{
				State = 4568; Match(XMLPARSE);
				State = 4569; Match(LEFT_PAREN);
				State = 4570;
				_la = _input.La(1);
				if ( !(_la==CONTENT || _la==DOCUMENT) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				State = 4571; concatenation();
				State = 4573;
				_la = _input.La(1);
				if (_la==WELLFORMED) {
					{
					State = 4572; Match(WELLFORMED);
					}
				}

				State = 4575; Match(RIGHT_PAREN);
				State = 4578;
				switch ( Interpreter.AdaptivePredict(_input,577,_ctx) ) {
				case 1:
					{
					State = 4576; Match(PERIOD);
					State = 4577; general_element_part();
					}
					break;
				}
				}
				break;

			case 21:
				EnterOuterAlt(_localctx, 21);
				{
				State = 4580; Match(XMLPI);
				State = 4581; Match(LEFT_PAREN);
				State = 4586;
				switch (_input.La(1)) {
				case NAME:
					{
					State = 4582; Match(NAME);
					State = 4583; identifier();
					}
					break;
				case EVALNAME:
					{
					State = 4584; Match(EVALNAME);
					State = 4585; concatenation();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 4590;
				_la = _input.La(1);
				if (_la==COMMA) {
					{
					State = 4588; Match(COMMA);
					State = 4589; concatenation();
					}
				}

				State = 4592; Match(RIGHT_PAREN);
				State = 4595;
				switch ( Interpreter.AdaptivePredict(_input,580,_ctx) ) {
				case 1:
					{
					State = 4593; Match(PERIOD);
					State = 4594; general_element_part();
					}
					break;
				}
				}
				break;

			case 22:
				EnterOuterAlt(_localctx, 22);
				{
				State = 4597; Match(XMLQUERY);
				State = 4598; Match(LEFT_PAREN);
				State = 4599; concatenation();
				State = 4601;
				_la = _input.La(1);
				if (_la==PASSING) {
					{
					State = 4600; xml_passing_clause();
					}
				}

				State = 4603; Match(RETURNING);
				State = 4604; Match(CONTENT);
				State = 4608;
				_la = _input.La(1);
				if (_la==NULL) {
					{
					State = 4605; Match(NULL);
					State = 4606; Match(ON);
					State = 4607; Match(EMPTY);
					}
				}

				State = 4610; Match(RIGHT_PAREN);
				State = 4613;
				switch ( Interpreter.AdaptivePredict(_input,583,_ctx) ) {
				case 1:
					{
					State = 4611; Match(PERIOD);
					State = 4612; general_element_part();
					}
					break;
				}
				}
				break;

			case 23:
				EnterOuterAlt(_localctx, 23);
				{
				State = 4615; Match(XMLROOT);
				State = 4616; Match(LEFT_PAREN);
				State = 4617; concatenation();
				State = 4620;
				switch ( Interpreter.AdaptivePredict(_input,584,_ctx) ) {
				case 1:
					{
					State = 4618; Match(COMMA);
					State = 4619; xmlroot_param_version_part();
					}
					break;
				}
				State = 4624;
				_la = _input.La(1);
				if (_la==COMMA) {
					{
					State = 4622; Match(COMMA);
					State = 4623; xmlroot_param_standalone_part();
					}
				}

				State = 4626; Match(RIGHT_PAREN);
				State = 4629;
				switch ( Interpreter.AdaptivePredict(_input,586,_ctx) ) {
				case 1:
					{
					State = 4627; Match(PERIOD);
					State = 4628; general_element_part();
					}
					break;
				}
				}
				break;

			case 24:
				EnterOuterAlt(_localctx, 24);
				{
				State = 4631; Match(XMLSERIALIZE);
				State = 4632; Match(LEFT_PAREN);
				State = 4633;
				_la = _input.La(1);
				if ( !(_la==CONTENT || _la==DOCUMENT) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				State = 4634; concatenation();
				State = 4637;
				_la = _input.La(1);
				if (_la==AS) {
					{
					State = 4635; Match(AS);
					State = 4636; type_spec();
					}
				}

				State = 4640;
				_la = _input.La(1);
				if (_la==ENCODING) {
					{
					State = 4639; xmlserialize_param_enconding_part();
					}
				}

				State = 4643;
				_la = _input.La(1);
				if (_la==VERSION) {
					{
					State = 4642; xmlserialize_param_version_part();
					}
				}

				State = 4646;
				_la = _input.La(1);
				if (_la==INDENT || _la==NO) {
					{
					State = 4645; xmlserialize_param_ident_part();
					}
				}

				State = 4650;
				_la = _input.La(1);
				if (_la==HIDE || _la==SHOW) {
					{
					State = 4648;
					_la = _input.La(1);
					if ( !(_la==HIDE || _la==SHOW) ) {
					_errHandler.RecoverInline(this);
					}
					Consume();
					State = 4649; Match(DEFAULTS);
					}
				}

				State = 4652; Match(RIGHT_PAREN);
				State = 4655;
				switch ( Interpreter.AdaptivePredict(_input,592,_ctx) ) {
				case 1:
					{
					State = 4653; Match(PERIOD);
					State = 4654; general_element_part();
					}
					break;
				}
				}
				break;

			case 25:
				EnterOuterAlt(_localctx, 25);
				{
				State = 4657; Match(XMLTABLE);
				State = 4658; Match(LEFT_PAREN);
				State = 4660;
				switch ( Interpreter.AdaptivePredict(_input,593,_ctx) ) {
				case 1:
					{
					State = 4659; xml_namespaces_clause();
					}
					break;
				}
				State = 4662; concatenation();
				State = 4664;
				_la = _input.La(1);
				if (_la==PASSING) {
					{
					State = 4663; xml_passing_clause();
					}
				}

				State = 4671;
				_la = _input.La(1);
				if (_la==COLUMNS) {
					{
					State = 4666; Match(COLUMNS);
					State = 4667; xml_table_column();
					{
					State = 4668; Match(COMMA);
					State = 4669; xml_table_column();
					}
					}
				}

				State = 4673; Match(RIGHT_PAREN);
				State = 4676;
				switch ( Interpreter.AdaptivePredict(_input,596,_ctx) ) {
				case 1:
					{
					State = 4674; Match(PERIOD);
					State = 4675; general_element_part();
					}
					break;
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Over_clause_keywordContext : ParserRuleContext {
		public ITerminalNode MIN() { return GetToken(plsqlParser.MIN, 0); }
		public ITerminalNode VARIANCE() { return GetToken(plsqlParser.VARIANCE, 0); }
		public ITerminalNode LAG() { return GetToken(plsqlParser.LAG, 0); }
		public ITerminalNode REGR_() { return GetToken(plsqlParser.REGR_, 0); }
		public ITerminalNode MEDIAN() { return GetToken(plsqlParser.MEDIAN, 0); }
		public ITerminalNode NTILE() { return GetToken(plsqlParser.NTILE, 0); }
		public ITerminalNode RATIO_TO_REPORT() { return GetToken(plsqlParser.RATIO_TO_REPORT, 0); }
		public ITerminalNode AVG() { return GetToken(plsqlParser.AVG, 0); }
		public ITerminalNode CORR() { return GetToken(plsqlParser.CORR, 0); }
		public ITerminalNode SUM() { return GetToken(plsqlParser.SUM, 0); }
		public ITerminalNode LEAD() { return GetToken(plsqlParser.LEAD, 0); }
		public ITerminalNode ROW_NUMBER() { return GetToken(plsqlParser.ROW_NUMBER, 0); }
		public ITerminalNode STDDEV() { return GetToken(plsqlParser.STDDEV, 0); }
		public ITerminalNode MAX() { return GetToken(plsqlParser.MAX, 0); }
		public ITerminalNode COVAR_() { return GetToken(plsqlParser.COVAR_, 0); }
		public ITerminalNode VAR_() { return GetToken(plsqlParser.VAR_, 0); }
		public Over_clause_keywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_over_clause_keyword; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterOver_clause_keyword(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitOver_clause_keyword(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOver_clause_keyword(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Over_clause_keywordContext over_clause_keyword() {
		Over_clause_keywordContext _localctx = new Over_clause_keywordContext(_ctx, State);
		EnterRule(_localctx, 578, RULE_over_clause_keyword);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4680;
			_la = _input.La(1);
			if ( !(((((_la - 466)) & ~0x3f) == 0 && ((1L << (_la - 466)) & ((1L << (AVG - 466)) | (1L << (CORR - 466)) | (1L << (COVAR_ - 466)) | (1L << (LAG - 466)) | (1L << (LEAD - 466)) | (1L << (MAX - 466)) | (1L << (MEDIAN - 466)) | (1L << (MIN - 466)) | (1L << (NTILE - 466)) | (1L << (RATIO_TO_REPORT - 466)) | (1L << (REGR_ - 466)) | (1L << (ROW_NUMBER - 466)) | (1L << (SUM - 466)) | (1L << (STDDEV - 466)) | (1L << (VAR_ - 466)) | (1L << (VARIANCE - 466)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Within_or_over_clause_keywordContext : ParserRuleContext {
		public ITerminalNode CUME_DIST() { return GetToken(plsqlParser.CUME_DIST, 0); }
		public ITerminalNode RANK() { return GetToken(plsqlParser.RANK, 0); }
		public ITerminalNode PERCENTILE_CONT() { return GetToken(plsqlParser.PERCENTILE_CONT, 0); }
		public ITerminalNode PERCENTILE_DISC() { return GetToken(plsqlParser.PERCENTILE_DISC, 0); }
		public ITerminalNode PERCENT_RANK() { return GetToken(plsqlParser.PERCENT_RANK, 0); }
		public ITerminalNode DENSE_RANK() { return GetToken(plsqlParser.DENSE_RANK, 0); }
		public ITerminalNode LISTAGG() { return GetToken(plsqlParser.LISTAGG, 0); }
		public Within_or_over_clause_keywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_within_or_over_clause_keyword; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterWithin_or_over_clause_keyword(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitWithin_or_over_clause_keyword(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWithin_or_over_clause_keyword(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Within_or_over_clause_keywordContext within_or_over_clause_keyword() {
		Within_or_over_clause_keywordContext _localctx = new Within_or_over_clause_keywordContext(_ctx, State);
		EnterRule(_localctx, 580, RULE_within_or_over_clause_keyword);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4682;
			_la = _input.La(1);
			if ( !(((((_la - 459)) & ~0x3f) == 0 && ((1L << (_la - 459)) & ((1L << (CUME_DIST - 459)) | (1L << (DENSE_RANK - 459)) | (1L << (LISTAGG - 459)) | (1L << (PERCENT_RANK - 459)) | (1L << (PERCENTILE_CONT - 459)) | (1L << (PERCENTILE_DISC - 459)) | (1L << (RANK - 459)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Standard_prediction_function_keywordContext : ParserRuleContext {
		public ITerminalNode PREDICTION_PROBABILITY() { return GetToken(plsqlParser.PREDICTION_PROBABILITY, 0); }
		public ITerminalNode PREDICTION_DETAILS() { return GetToken(plsqlParser.PREDICTION_DETAILS, 0); }
		public ITerminalNode PREDICTION_BOUNDS() { return GetToken(plsqlParser.PREDICTION_BOUNDS, 0); }
		public ITerminalNode PREDICTION() { return GetToken(plsqlParser.PREDICTION, 0); }
		public ITerminalNode PREDICTION_COST() { return GetToken(plsqlParser.PREDICTION_COST, 0); }
		public ITerminalNode PREDICTION_SET() { return GetToken(plsqlParser.PREDICTION_SET, 0); }
		public Standard_prediction_function_keywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_standard_prediction_function_keyword; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterStandard_prediction_function_keyword(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitStandard_prediction_function_keyword(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStandard_prediction_function_keyword(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Standard_prediction_function_keywordContext standard_prediction_function_keyword() {
		Standard_prediction_function_keywordContext _localctx = new Standard_prediction_function_keywordContext(_ctx, State);
		EnterRule(_localctx, 582, RULE_standard_prediction_function_keyword);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4684;
			_la = _input.La(1);
			if ( !(((((_la - 453)) & ~0x3f) == 0 && ((1L << (_la - 453)) & ((1L << (PREDICTION - 453)) | (1L << (PREDICTION_BOUNDS - 453)) | (1L << (PREDICTION_COST - 453)) | (1L << (PREDICTION_DETAILS - 453)) | (1L << (PREDICTION_PROBABILITY - 453)) | (1L << (PREDICTION_SET - 453)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Over_clauseContext : ParserRuleContext {
		public ITerminalNode OVER() { return GetToken(plsqlParser.OVER, 0); }
		public Order_by_clauseContext order_by_clause() {
			return GetRuleContext<Order_by_clauseContext>(0);
		}
		public Query_partition_clauseContext query_partition_clause() {
			return GetRuleContext<Query_partition_clauseContext>(0);
		}
		public Windowing_clauseContext windowing_clause() {
			return GetRuleContext<Windowing_clauseContext>(0);
		}
		public Over_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_over_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterOver_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitOver_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOver_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Over_clauseContext over_clause() {
		Over_clauseContext _localctx = new Over_clauseContext(_ctx, State);
		EnterRule(_localctx, 584, RULE_over_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4686; Match(OVER);
			State = 4687; Match(LEFT_PAREN);
			State = 4689;
			_la = _input.La(1);
			if (_la==PARTITION) {
				{
				State = 4688; query_partition_clause();
				}
			}

			State = 4695;
			_la = _input.La(1);
			if (_la==ORDER) {
				{
				State = 4691; order_by_clause();
				State = 4693;
				_la = _input.La(1);
				if (_la==RANGE || _la==ROWS) {
					{
					State = 4692; windowing_clause();
					}
				}

				}
			}

			State = 4697; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Windowing_clauseContext : ParserRuleContext {
		public Windowing_elementsContext windowing_elements(int i) {
			return GetRuleContext<Windowing_elementsContext>(i);
		}
		public ITerminalNode BETWEEN() { return GetToken(plsqlParser.BETWEEN, 0); }
		public IReadOnlyList<Windowing_elementsContext> windowing_elements() {
			return GetRuleContexts<Windowing_elementsContext>();
		}
		public ITerminalNode AND() { return GetToken(plsqlParser.AND, 0); }
		public Windowing_typeContext windowing_type() {
			return GetRuleContext<Windowing_typeContext>(0);
		}
		public Windowing_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_windowing_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterWindowing_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitWindowing_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWindowing_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Windowing_clauseContext windowing_clause() {
		Windowing_clauseContext _localctx = new Windowing_clauseContext(_ctx, State);
		EnterRule(_localctx, 586, RULE_windowing_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4699; windowing_type();
			State = 4706;
			switch (_input.La(1)) {
			case BETWEEN:
				{
				State = 4700; Match(BETWEEN);
				State = 4701; windowing_elements();
				State = 4702; Match(AND);
				State = 4703; windowing_elements();
				}
				break;
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALL:
			case ANALYZE:
			case ANY:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CASE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COALESCE:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DISTINCT:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FALSE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NULL:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIOR:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUE:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case DECODE:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case NVL:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROUND:
			case ROW_NUMBER:
			case SUBSTR:
			case TO_CHAR:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case NATIONAL_CHAR_STRING_LIT:
			case UNSIGNED_INTEGER:
			case APPROXIMATE_NUM_LIT:
			case CHAR_STRING:
			case DELIMITED_ID:
			case LEFT_PAREN:
			case PLUS_SIGN:
			case MINUS_SIGN:
			case BINDVAR:
			case COLON:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 4705; windowing_elements();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Windowing_typeContext : ParserRuleContext {
		public ITerminalNode RANGE() { return GetToken(plsqlParser.RANGE, 0); }
		public ITerminalNode ROWS() { return GetToken(plsqlParser.ROWS, 0); }
		public Windowing_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_windowing_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterWindowing_type(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitWindowing_type(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWindowing_type(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Windowing_typeContext windowing_type() {
		Windowing_typeContext _localctx = new Windowing_typeContext(_ctx, State);
		EnterRule(_localctx, 588, RULE_windowing_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4708;
			_la = _input.La(1);
			if ( !(_la==RANGE || _la==ROWS) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Windowing_elementsContext : ParserRuleContext {
		public ITerminalNode ROW() { return GetToken(plsqlParser.ROW, 0); }
		public ITerminalNode PRECEDING() { return GetToken(plsqlParser.PRECEDING, 0); }
		public ITerminalNode UNBOUNDED() { return GetToken(plsqlParser.UNBOUNDED, 0); }
		public ITerminalNode CURRENT() { return GetToken(plsqlParser.CURRENT, 0); }
		public ConcatenationContext concatenation() {
			return GetRuleContext<ConcatenationContext>(0);
		}
		public ITerminalNode FOLLOWING() { return GetToken(plsqlParser.FOLLOWING, 0); }
		public Windowing_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_windowing_elements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterWindowing_elements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitWindowing_elements(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWindowing_elements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Windowing_elementsContext windowing_elements() {
		Windowing_elementsContext _localctx = new Windowing_elementsContext(_ctx, State);
		EnterRule(_localctx, 590, RULE_windowing_elements);
		int _la;
		try {
			State = 4717;
			switch ( Interpreter.AdaptivePredict(_input,602,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4710; Match(UNBOUNDED);
				State = 4711; Match(PRECEDING);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4712; Match(CURRENT);
				State = 4713; Match(ROW);
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4714; concatenation();
				State = 4715;
				_la = _input.La(1);
				if ( !(_la==FOLLOWING || _la==PRECEDING) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Using_clauseContext : ParserRuleContext {
		public IReadOnlyList<Using_elementContext> using_element() {
			return GetRuleContexts<Using_elementContext>();
		}
		public ITerminalNode USING() { return GetToken(plsqlParser.USING, 0); }
		public Using_elementContext using_element(int i) {
			return GetRuleContext<Using_elementContext>(i);
		}
		public Using_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_using_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterUsing_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitUsing_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUsing_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Using_clauseContext using_clause() {
		Using_clauseContext _localctx = new Using_clauseContext(_ctx, State);
		EnterRule(_localctx, 592, RULE_using_clause);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 4719; Match(USING);
			State = 4729;
			switch (_input.La(1)) {
			case ASTERISK:
				{
				State = 4720; Match(ASTERISK);
				}
				break;
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALL:
			case ANALYZE:
			case ANY:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CASE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COALESCE:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DISTINCT:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FALSE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case IN:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NOT:
			case NULL:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIOR:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUE:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case DECODE:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case NVL:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROUND:
			case ROW_NUMBER:
			case SUBSTR:
			case TO_CHAR:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case NATIONAL_CHAR_STRING_LIT:
			case UNSIGNED_INTEGER:
			case APPROXIMATE_NUM_LIT:
			case CHAR_STRING:
			case DELIMITED_ID:
			case LEFT_PAREN:
			case PLUS_SIGN:
			case MINUS_SIGN:
			case BINDVAR:
			case COLON:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 4721; using_element();
				State = 4726;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,603,_ctx);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
					if ( _alt==1 ) {
						{
						{
						State = 4722; Match(COMMA);
						State = 4723; using_element();
						}
						} 
					}
					State = 4728;
					_errHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(_input,603,_ctx);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Using_elementContext : ParserRuleContext {
		public Select_list_elementsContext select_list_elements() {
			return GetRuleContext<Select_list_elementsContext>(0);
		}
		public ITerminalNode IN() { return GetToken(plsqlParser.IN, 0); }
		public Column_aliasContext column_alias() {
			return GetRuleContext<Column_aliasContext>(0);
		}
		public ITerminalNode OUT() { return GetToken(plsqlParser.OUT, 0); }
		public Using_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_using_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterUsing_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitUsing_element(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUsing_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Using_elementContext using_element() {
		Using_elementContext _localctx = new Using_elementContext(_ctx, State);
		EnterRule(_localctx, 594, RULE_using_element);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4736;
			switch ( Interpreter.AdaptivePredict(_input,606,_ctx) ) {
			case 1:
				{
				State = 4731; Match(IN);
				State = 4733;
				switch ( Interpreter.AdaptivePredict(_input,605,_ctx) ) {
				case 1:
					{
					State = 4732; Match(OUT);
					}
					break;
				}
				}
				break;

			case 2:
				{
				State = 4735; Match(OUT);
				}
				break;
			}
			State = 4738; select_list_elements();
			State = 4740;
			switch ( Interpreter.AdaptivePredict(_input,607,_ctx) ) {
			case 1:
				{
				State = 4739; column_alias();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Collect_order_by_partContext : ParserRuleContext {
		public ITerminalNode ORDER() { return GetToken(plsqlParser.ORDER, 0); }
		public ConcatenationContext concatenation() {
			return GetRuleContext<ConcatenationContext>(0);
		}
		public ITerminalNode BY() { return GetToken(plsqlParser.BY, 0); }
		public Collect_order_by_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_collect_order_by_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCollect_order_by_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCollect_order_by_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCollect_order_by_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Collect_order_by_partContext collect_order_by_part() {
		Collect_order_by_partContext _localctx = new Collect_order_by_partContext(_ctx, State);
		EnterRule(_localctx, 596, RULE_collect_order_by_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4742; Match(ORDER);
			State = 4743; Match(BY);
			State = 4744; concatenation();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Within_or_over_partContext : ParserRuleContext {
		public Order_by_clauseContext order_by_clause() {
			return GetRuleContext<Order_by_clauseContext>(0);
		}
		public ITerminalNode GROUP() { return GetToken(plsqlParser.GROUP, 0); }
		public Over_clauseContext over_clause() {
			return GetRuleContext<Over_clauseContext>(0);
		}
		public ITerminalNode WITHIN() { return GetToken(plsqlParser.WITHIN, 0); }
		public Within_or_over_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_within_or_over_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterWithin_or_over_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitWithin_or_over_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWithin_or_over_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Within_or_over_partContext within_or_over_part() {
		Within_or_over_partContext _localctx = new Within_or_over_partContext(_ctx, State);
		EnterRule(_localctx, 598, RULE_within_or_over_part);
		try {
			State = 4753;
			switch (_input.La(1)) {
			case WITHIN:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4746; Match(WITHIN);
				State = 4747; Match(GROUP);
				State = 4748; Match(LEFT_PAREN);
				State = 4749; order_by_clause();
				State = 4750; Match(RIGHT_PAREN);
				}
				break;
			case OVER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4752; over_clause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cost_matrix_clauseContext : ParserRuleContext {
		public Expression_listContext expression_list() {
			return GetRuleContext<Expression_listContext>(0);
		}
		public ITerminalNode COST() { return GetToken(plsqlParser.COST, 0); }
		public Cost_class_nameContext cost_class_name(int i) {
			return GetRuleContext<Cost_class_nameContext>(i);
		}
		public ITerminalNode VALUES() { return GetToken(plsqlParser.VALUES, 0); }
		public ITerminalNode AUTO() { return GetToken(plsqlParser.AUTO, 0); }
		public IReadOnlyList<Cost_class_nameContext> cost_class_name() {
			return GetRuleContexts<Cost_class_nameContext>();
		}
		public ITerminalNode MODEL() { return GetToken(plsqlParser.MODEL, 0); }
		public Cost_matrix_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cost_matrix_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCost_matrix_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCost_matrix_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCost_matrix_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Cost_matrix_clauseContext cost_matrix_clause() {
		Cost_matrix_clauseContext _localctx = new Cost_matrix_clauseContext(_ctx, State);
		EnterRule(_localctx, 600, RULE_cost_matrix_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4755; Match(COST);
			State = 4773;
			switch (_input.La(1)) {
			case MODEL:
				{
				State = 4756; Match(MODEL);
				State = 4758;
				_la = _input.La(1);
				if (_la==AUTO) {
					{
					State = 4757; Match(AUTO);
					}
				}

				}
				break;
			case LEFT_PAREN:
				{
				State = 4760; Match(LEFT_PAREN);
				State = 4761; cost_class_name();
				State = 4766;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 4762; Match(COMMA);
					State = 4763; cost_class_name();
					}
					}
					State = 4768;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 4769; Match(RIGHT_PAREN);
				State = 4770; Match(VALUES);
				State = 4771; expression_list();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xml_passing_clauseContext : ParserRuleContext {
		public ITerminalNode PASSING() { return GetToken(plsqlParser.PASSING, 0); }
		public Column_aliasContext column_alias(int i) {
			return GetRuleContext<Column_aliasContext>(i);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode VALUE() { return GetToken(plsqlParser.VALUE, 0); }
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode BY() { return GetToken(plsqlParser.BY, 0); }
		public IReadOnlyList<Column_aliasContext> column_alias() {
			return GetRuleContexts<Column_aliasContext>();
		}
		public Xml_passing_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xml_passing_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterXml_passing_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitXml_passing_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXml_passing_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xml_passing_clauseContext xml_passing_clause() {
		Xml_passing_clauseContext _localctx = new Xml_passing_clauseContext(_ctx, State);
		EnterRule(_localctx, 602, RULE_xml_passing_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4775; Match(PASSING);
			State = 4778;
			_la = _input.La(1);
			if (_la==BY) {
				{
				State = 4776; Match(BY);
				State = 4777; Match(VALUE);
				}
			}

			State = 4780; expression();
			State = 4782;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << AS) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (CONSTANT - 66)) | (1L << (CONSTRAINT - 66)) | (1L << (CONSTRAINTS - 66)) | (1L << (CONSTRUCTOR - 66)) | (1L << (CONTENT - 66)) | (1L << (CONTEXT - 66)) | (1L << (CONTINUE - 66)) | (1L << (CONVERT - 66)) | (1L << (CORRUPT_XID - 66)) | (1L << (CORRUPT_XID_ALL - 66)) | (1L << (COST - 66)) | (1L << (COUNT - 66)) | (1L << (CROSS - 66)) | (1L << (CUBE - 66)) | (1L << (CURRENT_USER - 66)) | (1L << (CURSOR - 66)) | (1L << (CUSTOMDATUM - 66)) | (1L << (CYCLE - 66)) | (1L << (DATA - 66)) | (1L << (DATABASE - 66)) | (1L << (DAY - 66)) | (1L << (DB_ROLE_CHANGE - 66)) | (1L << (DBTIMEZONE - 66)) | (1L << (DDL - 66)) | (1L << (DEBUG - 66)) | (1L << (DEC - 66)) | (1L << (DECIMAL - 66)) | (1L << (DECOMPOSE - 66)) | (1L << (DECREMENT - 66)) | (1L << (DEFAULTS - 66)) | (1L << (DEFERRED - 66)) | (1L << (DEFINER - 66)) | (1L << (DETERMINISTIC - 66)) | (1L << (DIMENSION - 66)) | (1L << (DISABLE - 66)) | (1L << (DISASSOCIATE - 66)) | (1L << (DOCUMENT - 66)) | (1L << (DOUBLE - 66)) | (1L << (DSINTERVAL_UNCONSTRAINED - 66)) | (1L << (EACH - 66)) | (1L << (ELEMENT - 66)) | (1L << (EMPTY - 66)) | (1L << (ENABLE - 66)) | (1L << (ENCODING - 66)) | (1L << (ENTITYESCAPING - 66)) | (1L << (ERR - 66)) | (1L << (ERRORS - 66)) | (1L << (ESCAPE - 66)) | (1L << (EVALNAME - 66)) | (1L << (EXCEPTION - 66)) | (1L << (EXCEPTION_INIT - 66)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)) | (1L << (EXIT - 130)) | (1L << (EXPLAIN - 130)) | (1L << (EXTERNAL - 130)) | (1L << (EXTRACT - 130)) | (1L << (FAILURE - 130)) | (1L << (FINAL - 130)) | (1L << (FIRST - 130)) | (1L << (FIRST_VALUE - 130)) | (1L << (FLOAT - 130)) | (1L << (FOLLOWING - 130)) | (1L << (FOLLOWS - 130)) | (1L << (FORALL - 130)) | (1L << (FORCE - 130)) | (1L << (FULL - 130)) | (1L << (FUNCTION - 130)) | (1L << (GROUPING - 130)) | (1L << (HASH - 130)) | (1L << (HIDE - 130)) | (1L << (HOUR - 130)) | (1L << (IGNORE - 130)) | (1L << (IMMEDIATE - 130)) | (1L << (INCLUDE - 130)) | (1L << (INCLUDING - 130)) | (1L << (INCREMENT - 130)) | (1L << (INDENT - 130)) | (1L << (INDEXED - 130)) | (1L << (INDICATOR - 130)) | (1L << (INDICES - 130)) | (1L << (INFINITE - 130)) | (1L << (INLINE - 130)) | (1L << (INNER - 130)) | (1L << (INOUT - 130)) | (1L << (INSTANTIABLE - 130)) | (1L << (INSTEAD - 130)) | (1L << (INT - 130)) | (1L << (INTEGER - 130)) | (1L << (INTERVAL - 130)) | (1L << (INVALIDATE - 130)) | (1L << (ISOLATION - 130)) | (1L << (ITERATE - 130)) | (1L << (JAVA - 130)) | (1L << (JOIN - 130)) | (1L << (KEEP - 130)) | (1L << (LANGUAGE - 130)))) != 0) || ((((_la - 194)) & ~0x3f) == 0 && ((1L << (_la - 194)) & ((1L << (LAST - 194)) | (1L << (LAST_VALUE - 194)) | (1L << (LEADING - 194)) | (1L << (LEFT - 194)) | (1L << (LEVEL - 194)) | (1L << (LIBRARY - 194)) | (1L << (LIKE2 - 194)) | (1L << (LIKE4 - 194)) | (1L << (LIKEC - 194)) | (1L << (LIMIT - 194)) | (1L << (LOCAL - 194)) | (1L << (LOCKED - 194)) | (1L << (LOG - 194)) | (1L << (LOGOFF - 194)) | (1L << (LOGON - 194)) | (1L << (LONG - 194)) | (1L << (LOOP - 194)) | (1L << (MAIN - 194)) | (1L << (MAP - 194)) | (1L << (MATCHED - 194)) | (1L << (MAXVALUE - 194)) | (1L << (MEASURES - 194)) | (1L << (MEMBER - 194)) | (1L << (MERGE - 194)) | (1L << (MINUTE - 194)) | (1L << (MINVALUE - 194)) | (1L << (MLSLABEL - 194)) | (1L << (MODEL - 194)) | (1L << (MODIFY - 194)) | (1L << (MONTH - 194)) | (1L << (MULTISET - 194)) | (1L << (NAME - 194)) | (1L << (NAN - 194)) | (1L << (NATURAL - 194)) | (1L << (NATURALN - 194)) | (1L << (NAV - 194)) | (1L << (NCHAR - 194)) | (1L << (NCHAR_CS - 194)) | (1L << (NCLOB - 194)) | (1L << (NESTED - 194)) | (1L << (NEW - 194)) | (1L << (NO - 194)) | (1L << (NOAUDIT - 194)) | (1L << (NOCOPY - 194)) | (1L << (NOCYCLE - 194)) | (1L << (NOENTITYESCAPING - 194)) | (1L << (NONE - 194)) | (1L << (NOSCHEMACHECK - 194)) | (1L << (NULLS - 194)) | (1L << (NUMBER - 194)) | (1L << (NUMERIC - 194)) | (1L << (NVARCHAR2 - 194)) | (1L << (OBJECT - 194)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (OFF - 259)) | (1L << (OID - 259)) | (1L << (OLD - 259)) | (1L << (ONLY - 259)) | (1L << (OPEN - 259)) | (1L << (ORADATA - 259)) | (1L << (ORDINALITY - 259)) | (1L << (OSERROR - 259)) | (1L << (OUT - 259)) | (1L << (OUTER - 259)) | (1L << (OVER - 259)) | (1L << (OVERRIDING - 259)) | (1L << (PACKAGE - 259)) | (1L << (PARALLEL_ENABLE - 259)) | (1L << (PARAMETERS - 259)) | (1L << (PARENT - 259)) | (1L << (PARTITION - 259)) | (1L << (PASSING - 259)) | (1L << (PATH - 259)) | (1L << (PIPELINED - 259)) | (1L << (PLAN - 259)) | (1L << (PLS_INTEGER - 259)) | (1L << (POSITIVE - 259)) | (1L << (POSITIVEN - 259)) | (1L << (PRAGMA - 259)) | (1L << (PRECEDING - 259)) | (1L << (PRECISION - 259)) | (1L << (PRESENT - 259)) | (1L << (RAISE - 259)) | (1L << (RANGE - 259)) | (1L << (RAW - 259)) | (1L << (READ - 259)) | (1L << (REAL - 259)) | (1L << (RECORD - 259)) | (1L << (REF - 259)) | (1L << (REFERENCE - 259)) | (1L << (REFERENCING - 259)) | (1L << (REJECT - 259)) | (1L << (RELIES_ON - 259)) | (1L << (RENAME - 259)) | (1L << (REPLACE - 259)) | (1L << (RESPECT - 259)) | (1L << (RESTRICT_REFERENCES - 259)) | (1L << (RESULT - 259)) | (1L << (RESULT_CACHE - 259)) | (1L << (RETURN - 259)) | (1L << (RETURNING - 259)) | (1L << (REUSE - 259)) | (1L << (REVERSE - 259)) | (1L << (RIGHT - 259)))) != 0) || ((((_la - 323)) & ~0x3f) == 0 && ((1L << (_la - 323)) & ((1L << (ROLLBACK - 323)) | (1L << (ROLLUP - 323)) | (1L << (ROW - 323)) | (1L << (ROWID - 323)) | (1L << (ROWS - 323)) | (1L << (RULES - 323)) | (1L << (SAMPLE - 323)) | (1L << (SAVE - 323)) | (1L << (SAVEPOINT - 323)) | (1L << (SCHEMA - 323)) | (1L << (SCHEMACHECK - 323)) | (1L << (SCN - 323)) | (1L << (SECOND - 323)) | (1L << (SEED - 323)) | (1L << (SEGMENT - 323)) | (1L << (SELF - 323)) | (1L << (SEQUENTIAL - 323)) | (1L << (SERIALIZABLE - 323)) | (1L << (SERIALLY_REUSABLE - 323)) | (1L << (SERVERERROR - 323)) | (1L << (SESSIONTIMEZONE - 323)) | (1L << (SET - 323)) | (1L << (SETS - 323)) | (1L << (SETTINGS - 323)) | (1L << (SHOW - 323)) | (1L << (SHUTDOWN - 323)) | (1L << (SIBLINGS - 323)) | (1L << (SIGNTYPE - 323)) | (1L << (SIMPLE_INTEGER - 323)) | (1L << (SINGLE - 323)) | (1L << (SKIP_ - 323)) | (1L << (SMALLINT - 323)) | (1L << (SNAPSHOT - 323)) | (1L << (SOME - 323)) | (1L << (SPECIFICATION - 323)) | (1L << (SQLDATA - 323)) | (1L << (SQLERROR - 323)) | (1L << (STANDALONE - 323)) | (1L << (STARTUP - 323)) | (1L << (STATEMENT - 323)) | (1L << (STATEMENT_ID - 323)) | (1L << (STATIC - 323)) | (1L << (STATISTICS - 323)) | (1L << (STRING - 323)) | (1L << (SUBMULTISET - 323)) | (1L << (SUBPARTITION - 323)) | (1L << (SUBSTITUTABLE - 323)) | (1L << (SUBTYPE - 323)) | (1L << (SUCCESS - 323)) | (1L << (SUSPEND - 323)) | (1L << (TIME - 323)) | (1L << (TIMESTAMP - 323)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_UNCONSTRAINED - 323)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TIMEZONE_ABBR - 387)) | (1L << (TIMEZONE_HOUR - 387)) | (1L << (TIMEZONE_MINUTE - 387)) | (1L << (TIMEZONE_REGION - 387)) | (1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (YMINTERVAL_UNCONSTRAINED - 451)) | (1L << (ZONE - 451)) | (1L << (PREDICTION - 451)) | (1L << (PREDICTION_BOUNDS - 451)) | (1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (COVAR_ - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (REGR_ - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (TRIM - 451)) | (1L << (SUM - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (VARIANCE - 451)) | (1L << (NATIONAL_CHAR_STRING_LIT - 451)) | (1L << (CHAR_STRING - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 4781; column_alias();
				}
			}

			{
			State = 4784; Match(COMMA);
			State = 4785; expression();
			State = 4787;
			switch ( Interpreter.AdaptivePredict(_input,614,_ctx) ) {
			case 1:
				{
				State = 4786; column_alias();
				}
				break;
			}
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xml_attributes_clauseContext : ParserRuleContext {
		public ITerminalNode XMLATTRIBUTES() { return GetToken(plsqlParser.XMLATTRIBUTES, 0); }
		public ITerminalNode NOSCHEMACHECK() { return GetToken(plsqlParser.NOSCHEMACHECK, 0); }
		public IReadOnlyList<Xml_multiuse_expression_elementContext> xml_multiuse_expression_element() {
			return GetRuleContexts<Xml_multiuse_expression_elementContext>();
		}
		public ITerminalNode SCHEMACHECK() { return GetToken(plsqlParser.SCHEMACHECK, 0); }
		public Xml_multiuse_expression_elementContext xml_multiuse_expression_element(int i) {
			return GetRuleContext<Xml_multiuse_expression_elementContext>(i);
		}
		public ITerminalNode ENTITYESCAPING() { return GetToken(plsqlParser.ENTITYESCAPING, 0); }
		public ITerminalNode NOENTITYESCAPING() { return GetToken(plsqlParser.NOENTITYESCAPING, 0); }
		public Xml_attributes_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xml_attributes_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterXml_attributes_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitXml_attributes_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXml_attributes_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xml_attributes_clauseContext xml_attributes_clause() {
		Xml_attributes_clauseContext _localctx = new Xml_attributes_clauseContext(_ctx, State);
		EnterRule(_localctx, 604, RULE_xml_attributes_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4789; Match(XMLATTRIBUTES);
			State = 4790; Match(LEFT_PAREN);
			State = 4792;
			switch ( Interpreter.AdaptivePredict(_input,615,_ctx) ) {
			case 1:
				{
				State = 4791;
				_la = _input.La(1);
				if ( !(_la==ENTITYESCAPING || _la==NOENTITYESCAPING) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				}
				break;
			}
			State = 4795;
			switch ( Interpreter.AdaptivePredict(_input,616,_ctx) ) {
			case 1:
				{
				State = 4794;
				_la = _input.La(1);
				if ( !(_la==NOSCHEMACHECK || _la==SCHEMACHECK) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				}
				break;
			}
			State = 4797; xml_multiuse_expression_element();
			State = 4802;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 4798; Match(COMMA);
				State = 4799; xml_multiuse_expression_element();
				}
				}
				State = 4804;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 4805; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xml_namespaces_clauseContext : ParserRuleContext {
		public ConcatenationContext concatenation(int i) {
			return GetRuleContext<ConcatenationContext>(i);
		}
		public Column_aliasContext column_alias(int i) {
			return GetRuleContext<Column_aliasContext>(i);
		}
		public IReadOnlyList<ConcatenationContext> concatenation() {
			return GetRuleContexts<ConcatenationContext>();
		}
		public Xml_general_default_partContext xml_general_default_part() {
			return GetRuleContext<Xml_general_default_partContext>(0);
		}
		public IReadOnlyList<Column_aliasContext> column_alias() {
			return GetRuleContexts<Column_aliasContext>();
		}
		public ITerminalNode XMLNAMESPACES() { return GetToken(plsqlParser.XMLNAMESPACES, 0); }
		public Xml_namespaces_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xml_namespaces_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterXml_namespaces_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitXml_namespaces_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXml_namespaces_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xml_namespaces_clauseContext xml_namespaces_clause() {
		Xml_namespaces_clauseContext _localctx = new Xml_namespaces_clauseContext(_ctx, State);
		EnterRule(_localctx, 606, RULE_xml_namespaces_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4807; Match(XMLNAMESPACES);
			State = 4808; Match(LEFT_PAREN);
			State = 4812;
			switch ( Interpreter.AdaptivePredict(_input,618,_ctx) ) {
			case 1:
				{
				State = 4809; concatenation();
				State = 4810; column_alias();
				}
				break;
			}
			State = 4820;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 4814; Match(COMMA);
				State = 4815; concatenation();
				State = 4816; column_alias();
				}
				}
				State = 4822;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 4824;
			_la = _input.La(1);
			if (_la==DEFAULT) {
				{
				State = 4823; xml_general_default_part();
				}
			}

			State = 4826; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xml_table_columnContext : ParserRuleContext {
		public ITerminalNode PATH() { return GetToken(plsqlParser.PATH, 0); }
		public ITerminalNode ORDINALITY() { return GetToken(plsqlParser.ORDINALITY, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ConcatenationContext concatenation() {
			return GetRuleContext<ConcatenationContext>(0);
		}
		public ITerminalNode FOR() { return GetToken(plsqlParser.FOR, 0); }
		public Xml_column_nameContext xml_column_name() {
			return GetRuleContext<Xml_column_nameContext>(0);
		}
		public Xml_general_default_partContext xml_general_default_part() {
			return GetRuleContext<Xml_general_default_partContext>(0);
		}
		public Xml_table_columnContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xml_table_column; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterXml_table_column(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitXml_table_column(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXml_table_column(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xml_table_columnContext xml_table_column() {
		Xml_table_columnContext _localctx = new Xml_table_columnContext(_ctx, State);
		EnterRule(_localctx, 608, RULE_xml_table_column);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4828; xml_column_name();
			State = 4839;
			switch (_input.La(1)) {
			case FOR:
				{
				State = 4829; Match(FOR);
				State = 4830; Match(ORDINALITY);
				}
				break;
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROW_NUMBER:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case DELIMITED_ID:
			case REGULAR_ID:
				{
				State = 4831; type_spec();
				State = 4834;
				_la = _input.La(1);
				if (_la==PATH) {
					{
					State = 4832; Match(PATH);
					State = 4833; concatenation();
					}
				}

				State = 4837;
				_la = _input.La(1);
				if (_la==DEFAULT) {
					{
					State = 4836; xml_general_default_part();
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xml_general_default_partContext : ParserRuleContext {
		public ConcatenationContext concatenation() {
			return GetRuleContext<ConcatenationContext>(0);
		}
		public ITerminalNode DEFAULT() { return GetToken(plsqlParser.DEFAULT, 0); }
		public Xml_general_default_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xml_general_default_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterXml_general_default_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitXml_general_default_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXml_general_default_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xml_general_default_partContext xml_general_default_part() {
		Xml_general_default_partContext _localctx = new Xml_general_default_partContext(_ctx, State);
		EnterRule(_localctx, 610, RULE_xml_general_default_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4841; Match(DEFAULT);
			State = 4842; concatenation();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xml_multiuse_expression_elementContext : ParserRuleContext {
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public ITerminalNode EVALNAME() { return GetToken(plsqlParser.EVALNAME, 0); }
		public ConcatenationContext concatenation() {
			return GetRuleContext<ConcatenationContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode AS() { return GetToken(plsqlParser.AS, 0); }
		public Xml_multiuse_expression_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xml_multiuse_expression_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterXml_multiuse_expression_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitXml_multiuse_expression_element(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXml_multiuse_expression_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xml_multiuse_expression_elementContext xml_multiuse_expression_element() {
		Xml_multiuse_expression_elementContext _localctx = new Xml_multiuse_expression_elementContext(_ctx, State);
		EnterRule(_localctx, 612, RULE_xml_multiuse_expression_element);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4844; expression();
			State = 4851;
			_la = _input.La(1);
			if (_la==AS) {
				{
				State = 4845; Match(AS);
				State = 4849;
				switch ( Interpreter.AdaptivePredict(_input,624,_ctx) ) {
				case 1:
					{
					State = 4846; id_expression();
					}
					break;

				case 2:
					{
					State = 4847; Match(EVALNAME);
					State = 4848; concatenation();
					}
					break;
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xmlroot_param_version_partContext : ParserRuleContext {
		public ITerminalNode VERSION() { return GetToken(plsqlParser.VERSION, 0); }
		public ITerminalNode NO() { return GetToken(plsqlParser.NO, 0); }
		public ITerminalNode VALUE() { return GetToken(plsqlParser.VALUE, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Xmlroot_param_version_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlroot_param_version_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterXmlroot_param_version_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitXmlroot_param_version_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXmlroot_param_version_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xmlroot_param_version_partContext xmlroot_param_version_part() {
		Xmlroot_param_version_partContext _localctx = new Xmlroot_param_version_partContext(_ctx, State);
		EnterRule(_localctx, 614, RULE_xmlroot_param_version_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4853; Match(VERSION);
			State = 4857;
			switch ( Interpreter.AdaptivePredict(_input,626,_ctx) ) {
			case 1:
				{
				State = 4854; Match(NO);
				State = 4855; Match(VALUE);
				}
				break;

			case 2:
				{
				State = 4856; expression();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xmlroot_param_standalone_partContext : ParserRuleContext {
		public ITerminalNode YES() { return GetToken(plsqlParser.YES, 0); }
		public ITerminalNode NO() { return GetToken(plsqlParser.NO, 0); }
		public ITerminalNode STANDALONE() { return GetToken(plsqlParser.STANDALONE, 0); }
		public ITerminalNode VALUE() { return GetToken(plsqlParser.VALUE, 0); }
		public Xmlroot_param_standalone_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlroot_param_standalone_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterXmlroot_param_standalone_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitXmlroot_param_standalone_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXmlroot_param_standalone_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xmlroot_param_standalone_partContext xmlroot_param_standalone_part() {
		Xmlroot_param_standalone_partContext _localctx = new Xmlroot_param_standalone_partContext(_ctx, State);
		EnterRule(_localctx, 616, RULE_xmlroot_param_standalone_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4859; Match(STANDALONE);
			State = 4865;
			switch (_input.La(1)) {
			case YES:
				{
				State = 4860; Match(YES);
				}
				break;
			case NO:
				{
				State = 4861; Match(NO);
				State = 4863;
				_la = _input.La(1);
				if (_la==VALUE) {
					{
					State = 4862; Match(VALUE);
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xmlserialize_param_enconding_partContext : ParserRuleContext {
		public ITerminalNode ENCODING() { return GetToken(plsqlParser.ENCODING, 0); }
		public ConcatenationContext concatenation() {
			return GetRuleContext<ConcatenationContext>(0);
		}
		public Xmlserialize_param_enconding_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlserialize_param_enconding_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterXmlserialize_param_enconding_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitXmlserialize_param_enconding_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXmlserialize_param_enconding_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xmlserialize_param_enconding_partContext xmlserialize_param_enconding_part() {
		Xmlserialize_param_enconding_partContext _localctx = new Xmlserialize_param_enconding_partContext(_ctx, State);
		EnterRule(_localctx, 618, RULE_xmlserialize_param_enconding_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4867; Match(ENCODING);
			State = 4868; concatenation();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xmlserialize_param_version_partContext : ParserRuleContext {
		public ITerminalNode VERSION() { return GetToken(plsqlParser.VERSION, 0); }
		public ConcatenationContext concatenation() {
			return GetRuleContext<ConcatenationContext>(0);
		}
		public Xmlserialize_param_version_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlserialize_param_version_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterXmlserialize_param_version_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitXmlserialize_param_version_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXmlserialize_param_version_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xmlserialize_param_version_partContext xmlserialize_param_version_part() {
		Xmlserialize_param_version_partContext _localctx = new Xmlserialize_param_version_partContext(_ctx, State);
		EnterRule(_localctx, 620, RULE_xmlserialize_param_version_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4870; Match(VERSION);
			State = 4871; concatenation();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xmlserialize_param_ident_partContext : ParserRuleContext {
		public ITerminalNode NO() { return GetToken(plsqlParser.NO, 0); }
		public ITerminalNode INDENT() { return GetToken(plsqlParser.INDENT, 0); }
		public ConcatenationContext concatenation() {
			return GetRuleContext<ConcatenationContext>(0);
		}
		public ITerminalNode SIZE() { return GetToken(plsqlParser.SIZE, 0); }
		public Xmlserialize_param_ident_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlserialize_param_ident_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterXmlserialize_param_ident_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitXmlserialize_param_ident_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXmlserialize_param_ident_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xmlserialize_param_ident_partContext xmlserialize_param_ident_part() {
		Xmlserialize_param_ident_partContext _localctx = new Xmlserialize_param_ident_partContext(_ctx, State);
		EnterRule(_localctx, 622, RULE_xmlserialize_param_ident_part);
		int _la;
		try {
			State = 4881;
			switch (_input.La(1)) {
			case NO:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4873; Match(NO);
				State = 4874; Match(INDENT);
				}
				break;
			case INDENT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4875; Match(INDENT);
				State = 4879;
				_la = _input.La(1);
				if (_la==SIZE) {
					{
					State = 4876; Match(SIZE);
					State = 4877; Match(EQUALS_OP);
					State = 4878; concatenation();
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Sql_plus_commandContext : ParserRuleContext {
		public Show_errors_commandContext show_errors_command() {
			return GetRuleContext<Show_errors_commandContext>(0);
		}
		public Whenever_commandContext whenever_command() {
			return GetRuleContext<Whenever_commandContext>(0);
		}
		public Set_commandContext set_command() {
			return GetRuleContext<Set_commandContext>(0);
		}
		public Exit_commandContext exit_command() {
			return GetRuleContext<Exit_commandContext>(0);
		}
		public Prompt_commandContext prompt_command() {
			return GetRuleContext<Prompt_commandContext>(0);
		}
		public Sql_plus_commandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sql_plus_command; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSql_plus_command(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSql_plus_command(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSql_plus_command(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Sql_plus_commandContext sql_plus_command() {
		Sql_plus_commandContext _localctx = new Sql_plus_commandContext(_ctx, State);
		EnterRule(_localctx, 624, RULE_sql_plus_command);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4889;
			switch (_input.La(1)) {
			case SOLIDUS:
				{
				State = 4883; Match(SOLIDUS);
				}
				break;
			case WHENEVER:
				{
				State = 4884; whenever_command();
				}
				break;
			case EXIT:
				{
				State = 4885; exit_command();
				}
				break;
			case PROMPT:
				{
				State = 4886; prompt_command();
				}
				break;
			case SET:
				{
				State = 4887; set_command();
				}
				break;
			case SHOW:
				{
				State = 4888; show_errors_command();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 4892;
			_la = _input.La(1);
			if (_la==SEMICOLON) {
				{
				State = 4891; Match(SEMICOLON);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Whenever_commandContext : ParserRuleContext {
		public ITerminalNode OSERROR() { return GetToken(plsqlParser.OSERROR, 0); }
		public ITerminalNode SQLERROR() { return GetToken(plsqlParser.SQLERROR, 0); }
		public ITerminalNode CONTINUE() { return GetToken(plsqlParser.CONTINUE, 0); }
		public ITerminalNode WARNING() { return GetToken(plsqlParser.WARNING, 0); }
		public ITerminalNode SUCCESS() { return GetToken(plsqlParser.SUCCESS, 0); }
		public ITerminalNode NONE() { return GetToken(plsqlParser.NONE, 0); }
		public ITerminalNode FAILURE() { return GetToken(plsqlParser.FAILURE, 0); }
		public ITerminalNode EXIT() { return GetToken(plsqlParser.EXIT, 0); }
		public ITerminalNode WHENEVER() { return GetToken(plsqlParser.WHENEVER, 0); }
		public ITerminalNode COMMIT() { return GetToken(plsqlParser.COMMIT, 0); }
		public ITerminalNode ROLLBACK() { return GetToken(plsqlParser.ROLLBACK, 0); }
		public Whenever_commandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_whenever_command; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterWhenever_command(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitWhenever_command(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWhenever_command(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Whenever_commandContext whenever_command() {
		Whenever_commandContext _localctx = new Whenever_commandContext(_ctx, State);
		EnterRule(_localctx, 626, RULE_whenever_command);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4894; Match(WHENEVER);
			State = 4895;
			_la = _input.La(1);
			if ( !(_la==OSERROR || _la==SQLERROR) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			State = 4901;
			switch (_input.La(1)) {
			case EXIT:
				{
				State = 4896; Match(EXIT);
				State = 4897;
				_la = _input.La(1);
				if ( !(_la==FAILURE || _la==SUCCESS || _la==WARNING) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				State = 4898;
				_la = _input.La(1);
				if ( !(_la==COMMIT || _la==ROLLBACK) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				}
				break;
			case CONTINUE:
				{
				State = 4899; Match(CONTINUE);
				State = 4900;
				_la = _input.La(1);
				if ( !(_la==COMMIT || _la==NONE || _la==ROLLBACK) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Set_commandContext : ParserRuleContext {
		public NumericContext numeric() {
			return GetRuleContext<NumericContext>(0);
		}
		public ITerminalNode ON() { return GetToken(plsqlParser.ON, 0); }
		public ITerminalNode OFF() { return GetToken(plsqlParser.OFF, 0); }
		public IReadOnlyList<Regular_idContext> regular_id() {
			return GetRuleContexts<Regular_idContext>();
		}
		public ITerminalNode CHAR_STRING() { return GetToken(plsqlParser.CHAR_STRING, 0); }
		public ITerminalNode SET() { return GetToken(plsqlParser.SET, 0); }
		public Regular_idContext regular_id(int i) {
			return GetRuleContext<Regular_idContext>(i);
		}
		public Set_commandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_set_command; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSet_command(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSet_command(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSet_command(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Set_commandContext set_command() {
		Set_commandContext _localctx = new Set_commandContext(_ctx, State);
		EnterRule(_localctx, 628, RULE_set_command);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4903; Match(SET);
			State = 4904; regular_id();
			State = 4910;
			switch ( Interpreter.AdaptivePredict(_input,634,_ctx) ) {
			case 1:
				{
				State = 4905; Match(CHAR_STRING);
				}
				break;

			case 2:
				{
				State = 4906; Match(ON);
				}
				break;

			case 3:
				{
				State = 4907; Match(OFF);
				}
				break;

			case 4:
				{
				State = 4908; numeric();
				}
				break;

			case 5:
				{
				State = 4909; regular_id();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Exit_commandContext : ParserRuleContext {
		public ITerminalNode EXIT() { return GetToken(plsqlParser.EXIT, 0); }
		public Exit_commandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exit_command; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterExit_command(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitExit_command(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExit_command(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Exit_commandContext exit_command() {
		Exit_commandContext _localctx = new Exit_commandContext(_ctx, State);
		EnterRule(_localctx, 630, RULE_exit_command);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4912; Match(EXIT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Prompt_commandContext : ParserRuleContext {
		public ITerminalNode PROMPT() { return GetToken(plsqlParser.PROMPT, 0); }
		public Prompt_commandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_prompt_command; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterPrompt_command(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitPrompt_command(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrompt_command(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Prompt_commandContext prompt_command() {
		Prompt_commandContext _localctx = new Prompt_commandContext(_ctx, State);
		EnterRule(_localctx, 632, RULE_prompt_command);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4914; Match(PROMPT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Show_errors_commandContext : ParserRuleContext {
		public ITerminalNode SHOW() { return GetToken(plsqlParser.SHOW, 0); }
		public ITerminalNode ERR() { return GetToken(plsqlParser.ERR, 0); }
		public ITerminalNode ERRORS() { return GetToken(plsqlParser.ERRORS, 0); }
		public Show_errors_commandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_show_errors_command; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterShow_errors_command(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitShow_errors_command(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShow_errors_command(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Show_errors_commandContext show_errors_command() {
		Show_errors_commandContext _localctx = new Show_errors_commandContext(_ctx, State);
		EnterRule(_localctx, 634, RULE_show_errors_command);
		try {
			State = 4920;
			switch ( Interpreter.AdaptivePredict(_input,635,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4916; Match(SHOW);
				State = 4917; Match(ERR);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4918; Match(SHOW);
				State = 4919; Match(ERRORS);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Partition_extension_clauseContext : ParserRuleContext {
		public Expression_listContext expression_list() {
			return GetRuleContext<Expression_listContext>(0);
		}
		public ITerminalNode SUBPARTITION() { return GetToken(plsqlParser.SUBPARTITION, 0); }
		public ITerminalNode PARTITION() { return GetToken(plsqlParser.PARTITION, 0); }
		public ITerminalNode FOR() { return GetToken(plsqlParser.FOR, 0); }
		public Partition_extension_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partition_extension_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterPartition_extension_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitPartition_extension_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPartition_extension_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Partition_extension_clauseContext partition_extension_clause() {
		Partition_extension_clauseContext _localctx = new Partition_extension_clauseContext(_ctx, State);
		EnterRule(_localctx, 636, RULE_partition_extension_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4922;
			_la = _input.La(1);
			if ( !(_la==PARTITION || _la==SUBPARTITION) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			State = 4924;
			_la = _input.La(1);
			if (_la==FOR) {
				{
				State = 4923; Match(FOR);
				}
			}

			State = 4926; expression_list();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Column_aliasContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Alias_quoted_stringContext alias_quoted_string() {
			return GetRuleContext<Alias_quoted_stringContext>(0);
		}
		public ITerminalNode AS() { return GetToken(plsqlParser.AS, 0); }
		public Column_aliasContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_column_alias; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterColumn_alias(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitColumn_alias(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitColumn_alias(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Column_aliasContext column_alias() {
		Column_aliasContext _localctx = new Column_aliasContext(_ctx, State);
		EnterRule(_localctx, 638, RULE_column_alias);
		int _la;
		try {
			State = 4936;
			switch ( Interpreter.AdaptivePredict(_input,639,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4929;
				_la = _input.La(1);
				if (_la==AS) {
					{
					State = 4928; Match(AS);
					}
				}

				State = 4933;
				switch (_input.La(1)) {
				case A_LETTER:
				case ADD:
				case AFTER:
				case AGENT:
				case AGGREGATE:
				case ANALYZE:
				case ARRAY:
				case ASSOCIATE:
				case AT:
				case ATTRIBUTE:
				case AUDIT:
				case AUTHID:
				case AUTO:
				case AUTOMATIC:
				case AUTONOMOUS_TRANSACTION:
				case BATCH:
				case BEFORE:
				case BFILE:
				case BINARY_DOUBLE:
				case BINARY_FLOAT:
				case BINARY_INTEGER:
				case BLOB:
				case BLOCK:
				case BODY:
				case BOOLEAN:
				case BOTH:
				case BULK:
				case BYTE:
				case C_LETTER:
				case CALL:
				case CANONICAL:
				case CASCADE:
				case CAST:
				case CHAR:
				case CHAR_CS:
				case CHARACTER:
				case CHR:
				case CLOB:
				case CLOSE:
				case CLUSTER:
				case COLLECT:
				case COLUMNS:
				case COMMENT:
				case COMMIT:
				case COMMITTED:
				case COMPATIBILITY:
				case COMPILE:
				case COMPOUND:
				case CONSTANT:
				case CONSTRAINT:
				case CONSTRAINTS:
				case CONSTRUCTOR:
				case CONTENT:
				case CONTEXT:
				case CONTINUE:
				case CONVERT:
				case CORRUPT_XID:
				case CORRUPT_XID_ALL:
				case COST:
				case COUNT:
				case CROSS:
				case CUBE:
				case CURRENT_USER:
				case CURSOR:
				case CUSTOMDATUM:
				case CYCLE:
				case DATA:
				case DATABASE:
				case DAY:
				case DB_ROLE_CHANGE:
				case DBTIMEZONE:
				case DDL:
				case DEBUG:
				case DEC:
				case DECIMAL:
				case DECOMPOSE:
				case DECREMENT:
				case DEFAULTS:
				case DEFERRED:
				case DEFINER:
				case DETERMINISTIC:
				case DIMENSION:
				case DISABLE:
				case DISASSOCIATE:
				case DOCUMENT:
				case DOUBLE:
				case DSINTERVAL_UNCONSTRAINED:
				case EACH:
				case ELEMENT:
				case EMPTY:
				case ENABLE:
				case ENCODING:
				case ENTITYESCAPING:
				case ERR:
				case ERRORS:
				case ESCAPE:
				case EVALNAME:
				case EXCEPTION:
				case EXCEPTION_INIT:
				case EXCEPTIONS:
				case EXCLUDE:
				case EXECUTE:
				case EXIT:
				case EXPLAIN:
				case EXTERNAL:
				case EXTRACT:
				case FAILURE:
				case FINAL:
				case FIRST:
				case FIRST_VALUE:
				case FLOAT:
				case FOLLOWING:
				case FOLLOWS:
				case FORALL:
				case FORCE:
				case FULL:
				case FUNCTION:
				case GROUPING:
				case HASH:
				case HIDE:
				case HOUR:
				case IGNORE:
				case IMMEDIATE:
				case INCLUDE:
				case INCLUDING:
				case INCREMENT:
				case INDENT:
				case INDEXED:
				case INDICATOR:
				case INDICES:
				case INFINITE:
				case INLINE:
				case INNER:
				case INOUT:
				case INSTANTIABLE:
				case INSTEAD:
				case INT:
				case INTEGER:
				case INTERVAL:
				case INVALIDATE:
				case ISOLATION:
				case ITERATE:
				case JAVA:
				case JOIN:
				case KEEP:
				case LANGUAGE:
				case LAST:
				case LAST_VALUE:
				case LEADING:
				case LEFT:
				case LEVEL:
				case LIBRARY:
				case LIKE2:
				case LIKE4:
				case LIKEC:
				case LIMIT:
				case LOCAL:
				case LOCKED:
				case LOG:
				case LOGOFF:
				case LOGON:
				case LONG:
				case LOOP:
				case MAIN:
				case MAP:
				case MATCHED:
				case MAXVALUE:
				case MEASURES:
				case MEMBER:
				case MERGE:
				case MINUTE:
				case MINVALUE:
				case MLSLABEL:
				case MODEL:
				case MODIFY:
				case MONTH:
				case MULTISET:
				case NAME:
				case NAN:
				case NATURAL:
				case NATURALN:
				case NAV:
				case NCHAR:
				case NCHAR_CS:
				case NCLOB:
				case NESTED:
				case NEW:
				case NO:
				case NOAUDIT:
				case NOCOPY:
				case NOCYCLE:
				case NOENTITYESCAPING:
				case NONE:
				case NOSCHEMACHECK:
				case NULLS:
				case NUMBER:
				case NUMERIC:
				case NVARCHAR2:
				case OBJECT:
				case OFF:
				case OID:
				case OLD:
				case ONLY:
				case OPEN:
				case ORADATA:
				case ORDINALITY:
				case OSERROR:
				case OUT:
				case OUTER:
				case OVER:
				case OVERRIDING:
				case PACKAGE:
				case PARALLEL_ENABLE:
				case PARAMETERS:
				case PARENT:
				case PARTITION:
				case PASSING:
				case PATH:
				case PIPELINED:
				case PLAN:
				case PLS_INTEGER:
				case POSITIVE:
				case POSITIVEN:
				case PRAGMA:
				case PRECEDING:
				case PRECISION:
				case PRESENT:
				case RAISE:
				case RANGE:
				case RAW:
				case READ:
				case REAL:
				case RECORD:
				case REF:
				case REFERENCE:
				case REFERENCING:
				case REJECT:
				case RELIES_ON:
				case RENAME:
				case REPLACE:
				case RESPECT:
				case RESTRICT_REFERENCES:
				case RESULT:
				case RESULT_CACHE:
				case RETURN:
				case RETURNING:
				case REUSE:
				case REVERSE:
				case RIGHT:
				case ROLLBACK:
				case ROLLUP:
				case ROW:
				case ROWID:
				case ROWS:
				case RULES:
				case SAMPLE:
				case SAVE:
				case SAVEPOINT:
				case SCHEMA:
				case SCHEMACHECK:
				case SCN:
				case SECOND:
				case SEED:
				case SEGMENT:
				case SELF:
				case SEQUENTIAL:
				case SERIALIZABLE:
				case SERIALLY_REUSABLE:
				case SERVERERROR:
				case SESSIONTIMEZONE:
				case SET:
				case SETS:
				case SETTINGS:
				case SHOW:
				case SHUTDOWN:
				case SIBLINGS:
				case SIGNTYPE:
				case SIMPLE_INTEGER:
				case SINGLE:
				case SKIP_:
				case SMALLINT:
				case SNAPSHOT:
				case SOME:
				case SPECIFICATION:
				case SQLDATA:
				case SQLERROR:
				case STANDALONE:
				case STARTUP:
				case STATEMENT:
				case STATEMENT_ID:
				case STATIC:
				case STATISTICS:
				case STRING:
				case SUBMULTISET:
				case SUBPARTITION:
				case SUBSTITUTABLE:
				case SUBTYPE:
				case SUCCESS:
				case SUSPEND:
				case TIME:
				case TIMESTAMP:
				case TIMESTAMP_LTZ_UNCONSTRAINED:
				case TIMESTAMP_TZ_UNCONSTRAINED:
				case TIMESTAMP_UNCONSTRAINED:
				case TIMEZONE_ABBR:
				case TIMEZONE_HOUR:
				case TIMEZONE_MINUTE:
				case TIMEZONE_REGION:
				case TRAILING:
				case TRANSACTION:
				case TRANSLATE:
				case TREAT:
				case TRIGGER:
				case TRUNCATE:
				case TYPE:
				case UNBOUNDED:
				case UNDER:
				case UNLIMITED:
				case UNTIL:
				case UPDATED:
				case UPSERT:
				case UROWID:
				case USE:
				case VALIDATE:
				case VALUE:
				case VARCHAR:
				case VARCHAR2:
				case VARIABLE:
				case VARRAY:
				case VARYING:
				case VERSION:
				case VERSIONS:
				case WAIT:
				case WARNING:
				case WELLFORMED:
				case WHENEVER:
				case WHILE:
				case WITHIN:
				case WORK:
				case WRITE:
				case XML:
				case XMLAGG:
				case XMLATTRIBUTES:
				case XMLCAST:
				case XMLCOLATTVAL:
				case XMLELEMENT:
				case XMLEXISTS:
				case XMLFOREST:
				case XMLNAMESPACES:
				case XMLPARSE:
				case XMLPI:
				case XMLQUERY:
				case XMLROOT:
				case XMLSERIALIZE:
				case XMLTABLE:
				case YEAR:
				case YES:
				case YMINTERVAL_UNCONSTRAINED:
				case ZONE:
				case PREDICTION:
				case PREDICTION_BOUNDS:
				case PREDICTION_COST:
				case PREDICTION_DETAILS:
				case PREDICTION_PROBABILITY:
				case PREDICTION_SET:
				case CUME_DIST:
				case DENSE_RANK:
				case LISTAGG:
				case PERCENT_RANK:
				case PERCENTILE_CONT:
				case PERCENTILE_DISC:
				case RANK:
				case AVG:
				case CORR:
				case COVAR_:
				case LAG:
				case LEAD:
				case MAX:
				case MEDIAN:
				case MIN:
				case NTILE:
				case RATIO_TO_REPORT:
				case REGR_:
				case ROW_NUMBER:
				case TRIM:
				case SUM:
				case STDDEV:
				case VAR_:
				case VARIANCE:
				case DELIMITED_ID:
				case INTRODUCER:
				case REGULAR_ID:
					{
					State = 4931; identifier();
					}
					break;
				case NATIONAL_CHAR_STRING_LIT:
				case CHAR_STRING:
					{
					State = 4932; alias_quoted_string();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4935; Match(AS);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_aliasContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Alias_quoted_stringContext alias_quoted_string() {
			return GetRuleContext<Alias_quoted_stringContext>(0);
		}
		public Table_aliasContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_alias; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterTable_alias(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitTable_alias(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTable_alias(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Table_aliasContext table_alias() {
		Table_aliasContext _localctx = new Table_aliasContext(_ctx, State);
		EnterRule(_localctx, 640, RULE_table_alias);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4940;
			switch (_input.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROW_NUMBER:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 4938; identifier();
				}
				break;
			case NATIONAL_CHAR_STRING_LIT:
			case CHAR_STRING:
				{
				State = 4939; alias_quoted_string();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alias_quoted_stringContext : ParserRuleContext {
		public Quoted_stringContext quoted_string() {
			return GetRuleContext<Quoted_stringContext>(0);
		}
		public Alias_quoted_stringContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alias_quoted_string; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterAlias_quoted_string(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitAlias_quoted_string(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlias_quoted_string(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Alias_quoted_stringContext alias_quoted_string() {
		Alias_quoted_stringContext _localctx = new Alias_quoted_stringContext(_ctx, State);
		EnterRule(_localctx, 642, RULE_alias_quoted_string);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4942; quoted_string();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Where_clauseContext : ParserRuleContext {
		public Current_of_clauseContext current_of_clause() {
			return GetRuleContext<Current_of_clauseContext>(0);
		}
		public ITerminalNode WHERE() { return GetToken(plsqlParser.WHERE, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Where_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_where_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterWhere_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitWhere_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWhere_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Where_clauseContext where_clause() {
		Where_clauseContext _localctx = new Where_clauseContext(_ctx, State);
		EnterRule(_localctx, 644, RULE_where_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4944; Match(WHERE);
			State = 4947;
			switch (_input.La(1)) {
			case CURRENT:
				{
				State = 4945; current_of_clause();
				}
				break;
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALL:
			case ANALYZE:
			case ANY:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CASE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COALESCE:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DISTINCT:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FALSE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NOT:
			case NULL:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIOR:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUE:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case DECODE:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case NVL:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROUND:
			case ROW_NUMBER:
			case SUBSTR:
			case TO_CHAR:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case NATIONAL_CHAR_STRING_LIT:
			case UNSIGNED_INTEGER:
			case APPROXIMATE_NUM_LIT:
			case CHAR_STRING:
			case DELIMITED_ID:
			case LEFT_PAREN:
			case PLUS_SIGN:
			case MINUS_SIGN:
			case BINDVAR:
			case COLON:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 4946; expression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Current_of_clauseContext : ParserRuleContext {
		public Cursor_nameContext cursor_name() {
			return GetRuleContext<Cursor_nameContext>(0);
		}
		public ITerminalNode OF() { return GetToken(plsqlParser.OF, 0); }
		public ITerminalNode CURRENT() { return GetToken(plsqlParser.CURRENT, 0); }
		public Current_of_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_current_of_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCurrent_of_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCurrent_of_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCurrent_of_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Current_of_clauseContext current_of_clause() {
		Current_of_clauseContext _localctx = new Current_of_clauseContext(_ctx, State);
		EnterRule(_localctx, 646, RULE_current_of_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4949; Match(CURRENT);
			State = 4950; Match(OF);
			State = 4951; cursor_name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Into_clauseContext : ParserRuleContext {
		public ITerminalNode BULK() { return GetToken(plsqlParser.BULK, 0); }
		public Variable_nameContext variable_name(int i) {
			return GetRuleContext<Variable_nameContext>(i);
		}
		public ITerminalNode COLLECT() { return GetToken(plsqlParser.COLLECT, 0); }
		public IReadOnlyList<Variable_nameContext> variable_name() {
			return GetRuleContexts<Variable_nameContext>();
		}
		public ITerminalNode INTO() { return GetToken(plsqlParser.INTO, 0); }
		public Into_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_into_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterInto_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitInto_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInto_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Into_clauseContext into_clause() {
		Into_clauseContext _localctx = new Into_clauseContext(_ctx, State);
		EnterRule(_localctx, 648, RULE_into_clause);
		int _la;
		try {
			State = 4973;
			switch (_input.La(1)) {
			case INTO:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4953; Match(INTO);
				State = 4954; variable_name();
				State = 4959;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 4955; Match(COMMA);
					State = 4956; variable_name();
					}
					}
					State = 4961;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
				break;
			case BULK:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4962; Match(BULK);
				State = 4963; Match(COLLECT);
				State = 4964; Match(INTO);
				State = 4965; variable_name();
				State = 4970;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 4966; Match(COMMA);
					State = 4967; variable_name();
					}
					}
					State = 4972;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xml_column_nameContext : ParserRuleContext {
		public Quoted_stringContext quoted_string() {
			return GetRuleContext<Quoted_stringContext>(0);
		}
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Xml_column_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xml_column_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterXml_column_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitXml_column_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXml_column_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xml_column_nameContext xml_column_name() {
		Xml_column_nameContext _localctx = new Xml_column_nameContext(_ctx, State);
		EnterRule(_localctx, 650, RULE_xml_column_name);
		try {
			State = 4977;
			switch (_input.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROW_NUMBER:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4975; identifier();
				}
				break;
			case NATIONAL_CHAR_STRING_LIT:
			case CHAR_STRING:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4976; quoted_string();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cost_class_nameContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Cost_class_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cost_class_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCost_class_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCost_class_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCost_class_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Cost_class_nameContext cost_class_name() {
		Cost_class_nameContext _localctx = new Cost_class_nameContext(_ctx, State);
		EnterRule(_localctx, 652, RULE_cost_class_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4979; identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Attribute_nameContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Attribute_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_attribute_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterAttribute_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitAttribute_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAttribute_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Attribute_nameContext attribute_name() {
		Attribute_nameContext _localctx = new Attribute_nameContext(_ctx, State);
		EnterRule(_localctx, 654, RULE_attribute_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4981; identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Savepoint_nameContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Savepoint_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_savepoint_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSavepoint_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSavepoint_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSavepoint_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Savepoint_nameContext savepoint_name() {
		Savepoint_nameContext _localctx = new Savepoint_nameContext(_ctx, State);
		EnterRule(_localctx, 656, RULE_savepoint_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4983; identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Rollback_segment_nameContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Rollback_segment_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rollback_segment_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterRollback_segment_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitRollback_segment_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRollback_segment_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Rollback_segment_nameContext rollback_segment_name() {
		Rollback_segment_nameContext _localctx = new Rollback_segment_nameContext(_ctx, State);
		EnterRule(_localctx, 658, RULE_rollback_segment_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4985; identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_var_nameContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Table_var_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_var_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterTable_var_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitTable_var_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTable_var_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Table_var_nameContext table_var_name() {
		Table_var_nameContext _localctx = new Table_var_nameContext(_ctx, State);
		EnterRule(_localctx, 660, RULE_table_var_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4987; identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Schema_nameContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Schema_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_schema_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSchema_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSchema_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSchema_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Schema_nameContext schema_name() {
		Schema_nameContext _localctx = new Schema_nameContext(_ctx, State);
		EnterRule(_localctx, 662, RULE_schema_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4989; identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Routine_nameContext : ParserRuleContext {
		public Link_nameContext link_name() {
			return GetRuleContext<Link_nameContext>(0);
		}
		public IReadOnlyList<Id_expressionContext> id_expression() {
			return GetRuleContexts<Id_expressionContext>();
		}
		public Id_expressionContext id_expression(int i) {
			return GetRuleContext<Id_expressionContext>(i);
		}
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Routine_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_routine_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterRoutine_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitRoutine_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRoutine_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Routine_nameContext routine_name() {
		Routine_nameContext _localctx = new Routine_nameContext(_ctx, State);
		EnterRule(_localctx, 664, RULE_routine_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4991; identifier();
			State = 4996;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==PERIOD) {
				{
				{
				State = 4992; Match(PERIOD);
				State = 4993; id_expression();
				}
				}
				State = 4998;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 5001;
			_la = _input.La(1);
			if (_la==AT_SIGN) {
				{
				State = 4999; Match(AT_SIGN);
				State = 5000; link_name();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Package_nameContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Package_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_package_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterPackage_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitPackage_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPackage_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Package_nameContext package_name() {
		Package_nameContext _localctx = new Package_nameContext(_ctx, State);
		EnterRule(_localctx, 666, RULE_package_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5003; identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Implementation_type_nameContext : ParserRuleContext {
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Implementation_type_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_implementation_type_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterImplementation_type_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitImplementation_type_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitImplementation_type_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Implementation_type_nameContext implementation_type_name() {
		Implementation_type_nameContext _localctx = new Implementation_type_nameContext(_ctx, State);
		EnterRule(_localctx, 668, RULE_implementation_type_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5005; identifier();
			State = 5008;
			_la = _input.La(1);
			if (_la==PERIOD) {
				{
				State = 5006; Match(PERIOD);
				State = 5007; id_expression();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Parameter_nameContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Parameter_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameter_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterParameter_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitParameter_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameter_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Parameter_nameContext parameter_name() {
		Parameter_nameContext _localctx = new Parameter_nameContext(_ctx, State);
		EnterRule(_localctx, 670, RULE_parameter_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5010; identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Reference_model_nameContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Reference_model_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reference_model_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterReference_model_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitReference_model_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReference_model_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Reference_model_nameContext reference_model_name() {
		Reference_model_nameContext _localctx = new Reference_model_nameContext(_ctx, State);
		EnterRule(_localctx, 672, RULE_reference_model_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5012; identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Main_model_nameContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Main_model_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_main_model_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterMain_model_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitMain_model_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMain_model_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Main_model_nameContext main_model_name() {
		Main_model_nameContext _localctx = new Main_model_nameContext(_ctx, State);
		EnterRule(_localctx, 674, RULE_main_model_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5014; identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Aggregate_function_nameContext : ParserRuleContext {
		public IReadOnlyList<Id_expressionContext> id_expression() {
			return GetRuleContexts<Id_expressionContext>();
		}
		public Id_expressionContext id_expression(int i) {
			return GetRuleContext<Id_expressionContext>(i);
		}
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Aggregate_function_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_aggregate_function_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterAggregate_function_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitAggregate_function_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAggregate_function_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Aggregate_function_nameContext aggregate_function_name() {
		Aggregate_function_nameContext _localctx = new Aggregate_function_nameContext(_ctx, State);
		EnterRule(_localctx, 676, RULE_aggregate_function_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5016; identifier();
			State = 5021;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==PERIOD) {
				{
				{
				State = 5017; Match(PERIOD);
				State = 5018; id_expression();
				}
				}
				State = 5023;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Query_nameContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Query_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_query_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterQuery_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitQuery_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQuery_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Query_nameContext query_name() {
		Query_nameContext _localctx = new Query_nameContext(_ctx, State);
		EnterRule(_localctx, 678, RULE_query_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5024; identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Constraint_nameContext : ParserRuleContext {
		public Link_nameContext link_name() {
			return GetRuleContext<Link_nameContext>(0);
		}
		public IReadOnlyList<Id_expressionContext> id_expression() {
			return GetRuleContexts<Id_expressionContext>();
		}
		public Id_expressionContext id_expression(int i) {
			return GetRuleContext<Id_expressionContext>(i);
		}
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Constraint_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constraint_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterConstraint_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitConstraint_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstraint_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Constraint_nameContext constraint_name() {
		Constraint_nameContext _localctx = new Constraint_nameContext(_ctx, State);
		EnterRule(_localctx, 680, RULE_constraint_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5026; identifier();
			State = 5031;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==PERIOD) {
				{
				{
				State = 5027; Match(PERIOD);
				State = 5028; id_expression();
				}
				}
				State = 5033;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 5036;
			_la = _input.La(1);
			if (_la==AT_SIGN) {
				{
				State = 5034; Match(AT_SIGN);
				State = 5035; link_name();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Label_nameContext : ParserRuleContext {
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public Label_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_label_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterLabel_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitLabel_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLabel_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Label_nameContext label_name() {
		Label_nameContext _localctx = new Label_nameContext(_ctx, State);
		EnterRule(_localctx, 682, RULE_label_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5038; id_expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Type_nameContext : ParserRuleContext {
		public IReadOnlyList<Id_expressionContext> id_expression() {
			return GetRuleContexts<Id_expressionContext>();
		}
		public Id_expressionContext id_expression(int i) {
			return GetRuleContext<Id_expressionContext>(i);
		}
		public Type_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterType_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitType_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Type_nameContext type_name() {
		Type_nameContext _localctx = new Type_nameContext(_ctx, State);
		EnterRule(_localctx, 684, RULE_type_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5040; id_expression();
			State = 5045;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==PERIOD) {
				{
				{
				State = 5041; Match(PERIOD);
				State = 5042; id_expression();
				}
				}
				State = 5047;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Sequence_nameContext : ParserRuleContext {
		public IReadOnlyList<Id_expressionContext> id_expression() {
			return GetRuleContexts<Id_expressionContext>();
		}
		public Id_expressionContext id_expression(int i) {
			return GetRuleContext<Id_expressionContext>(i);
		}
		public Sequence_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sequence_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSequence_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSequence_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSequence_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Sequence_nameContext sequence_name() {
		Sequence_nameContext _localctx = new Sequence_nameContext(_ctx, State);
		EnterRule(_localctx, 686, RULE_sequence_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5048; id_expression();
			State = 5053;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==PERIOD) {
				{
				{
				State = 5049; Match(PERIOD);
				State = 5050; id_expression();
				}
				}
				State = 5055;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Exception_nameContext : ParserRuleContext {
		public IReadOnlyList<Id_expressionContext> id_expression() {
			return GetRuleContexts<Id_expressionContext>();
		}
		public Id_expressionContext id_expression(int i) {
			return GetRuleContext<Id_expressionContext>(i);
		}
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Exception_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exception_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterException_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitException_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitException_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Exception_nameContext exception_name() {
		Exception_nameContext _localctx = new Exception_nameContext(_ctx, State);
		EnterRule(_localctx, 688, RULE_exception_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5056; identifier();
			State = 5061;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==PERIOD) {
				{
				{
				State = 5057; Match(PERIOD);
				State = 5058; id_expression();
				}
				}
				State = 5063;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Function_nameContext : ParserRuleContext {
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Function_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterFunction_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitFunction_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Function_nameContext function_name() {
		Function_nameContext _localctx = new Function_nameContext(_ctx, State);
		EnterRule(_localctx, 690, RULE_function_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5064; identifier();
			State = 5067;
			_la = _input.La(1);
			if (_la==PERIOD) {
				{
				State = 5065; Match(PERIOD);
				State = 5066; id_expression();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Procedure_nameContext : ParserRuleContext {
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Procedure_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_procedure_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterProcedure_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitProcedure_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProcedure_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Procedure_nameContext procedure_name() {
		Procedure_nameContext _localctx = new Procedure_nameContext(_ctx, State);
		EnterRule(_localctx, 692, RULE_procedure_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5069; identifier();
			State = 5072;
			_la = _input.La(1);
			if (_la==PERIOD) {
				{
				State = 5070; Match(PERIOD);
				State = 5071; id_expression();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Trigger_nameContext : ParserRuleContext {
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Trigger_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_trigger_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterTrigger_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitTrigger_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTrigger_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Trigger_nameContext trigger_name() {
		Trigger_nameContext _localctx = new Trigger_nameContext(_ctx, State);
		EnterRule(_localctx, 694, RULE_trigger_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5074; identifier();
			State = 5077;
			_la = _input.La(1);
			if (_la==PERIOD) {
				{
				State = 5075; Match(PERIOD);
				State = 5076; id_expression();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Variable_nameContext : ParserRuleContext {
		public IReadOnlyList<Id_expressionContext> id_expression() {
			return GetRuleContexts<Id_expressionContext>();
		}
		public Id_expressionContext id_expression(int i) {
			return GetRuleContext<Id_expressionContext>(i);
		}
		public Bind_variableContext bind_variable() {
			return GetRuleContext<Bind_variableContext>(0);
		}
		public Char_set_nameContext char_set_name() {
			return GetRuleContext<Char_set_nameContext>(0);
		}
		public ITerminalNode INTRODUCER() { return GetToken(plsqlParser.INTRODUCER, 0); }
		public Variable_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_variable_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterVariable_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitVariable_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVariable_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Variable_nameContext variable_name() {
		Variable_nameContext _localctx = new Variable_nameContext(_ctx, State);
		EnterRule(_localctx, 696, RULE_variable_name);
		int _la;
		try {
			State = 5089;
			switch (_input.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROW_NUMBER:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5081;
				_la = _input.La(1);
				if (_la==INTRODUCER) {
					{
					State = 5079; Match(INTRODUCER);
					State = 5080; char_set_name();
					}
				}

				State = 5083; id_expression();
				State = 5086;
				_la = _input.La(1);
				if (_la==PERIOD) {
					{
					State = 5084; Match(PERIOD);
					State = 5085; id_expression();
					}
				}

				}
				break;
			case BINDVAR:
			case COLON:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5088; bind_variable();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Index_nameContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Index_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_index_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterIndex_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitIndex_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndex_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Index_nameContext index_name() {
		Index_nameContext _localctx = new Index_nameContext(_ctx, State);
		EnterRule(_localctx, 698, RULE_index_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5091; identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cursor_nameContext : ParserRuleContext {
		public Bind_variableContext bind_variable() {
			return GetRuleContext<Bind_variableContext>(0);
		}
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Cursor_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cursor_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCursor_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCursor_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCursor_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Cursor_nameContext cursor_name() {
		Cursor_nameContext _localctx = new Cursor_nameContext(_ctx, State);
		EnterRule(_localctx, 700, RULE_cursor_name);
		try {
			State = 5095;
			switch (_input.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROW_NUMBER:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5093; identifier();
				}
				break;
			case BINDVAR:
			case COLON:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5094; bind_variable();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Record_nameContext : ParserRuleContext {
		public Bind_variableContext bind_variable() {
			return GetRuleContext<Bind_variableContext>(0);
		}
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Record_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_record_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterRecord_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitRecord_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRecord_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Record_nameContext record_name() {
		Record_nameContext _localctx = new Record_nameContext(_ctx, State);
		EnterRule(_localctx, 702, RULE_record_name);
		try {
			State = 5099;
			switch (_input.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROW_NUMBER:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5097; identifier();
				}
				break;
			case BINDVAR:
			case COLON:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5098; bind_variable();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Collection_nameContext : ParserRuleContext {
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Collection_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_collection_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCollection_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCollection_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCollection_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Collection_nameContext collection_name() {
		Collection_nameContext _localctx = new Collection_nameContext(_ctx, State);
		EnterRule(_localctx, 704, RULE_collection_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5101; identifier();
			State = 5104;
			_la = _input.La(1);
			if (_la==PERIOD) {
				{
				State = 5102; Match(PERIOD);
				State = 5103; id_expression();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Link_nameContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Link_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_link_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterLink_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitLink_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLink_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Link_nameContext link_name() {
		Link_nameContext _localctx = new Link_nameContext(_ctx, State);
		EnterRule(_localctx, 706, RULE_link_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5106; identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Column_nameContext : ParserRuleContext {
		public IReadOnlyList<Id_expressionContext> id_expression() {
			return GetRuleContexts<Id_expressionContext>();
		}
		public Id_expressionContext id_expression(int i) {
			return GetRuleContext<Id_expressionContext>(i);
		}
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Column_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_column_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterColumn_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitColumn_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitColumn_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Column_nameContext column_name() {
		Column_nameContext _localctx = new Column_nameContext(_ctx, State);
		EnterRule(_localctx, 708, RULE_column_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5108; identifier();
			State = 5113;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==PERIOD) {
				{
				{
				State = 5109; Match(PERIOD);
				State = 5110; id_expression();
				}
				}
				State = 5115;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Tableview_nameContext : ParserRuleContext {
		public Link_nameContext link_name() {
			return GetRuleContext<Link_nameContext>(0);
		}
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Partition_extension_clauseContext partition_extension_clause() {
			return GetRuleContext<Partition_extension_clauseContext>(0);
		}
		public Tableview_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tableview_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterTableview_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitTableview_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTableview_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Tableview_nameContext tableview_name() {
		Tableview_nameContext _localctx = new Tableview_nameContext(_ctx, State);
		EnterRule(_localctx, 710, RULE_tableview_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5116; identifier();
			State = 5119;
			switch ( Interpreter.AdaptivePredict(_input,665,_ctx) ) {
			case 1:
				{
				State = 5117; Match(PERIOD);
				State = 5118; id_expression();
				}
				break;
			}
			State = 5124;
			switch ( Interpreter.AdaptivePredict(_input,666,_ctx) ) {
			case 1:
				{
				State = 5121; Match(AT_SIGN);
				State = 5122; link_name();
				}
				break;

			case 2:
				{
				State = 5123; partition_extension_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Char_set_nameContext : ParserRuleContext {
		public IReadOnlyList<Id_expressionContext> id_expression() {
			return GetRuleContexts<Id_expressionContext>();
		}
		public Id_expressionContext id_expression(int i) {
			return GetRuleContext<Id_expressionContext>(i);
		}
		public Char_set_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_char_set_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterChar_set_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitChar_set_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitChar_set_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Char_set_nameContext char_set_name() {
		Char_set_nameContext _localctx = new Char_set_nameContext(_ctx, State);
		EnterRule(_localctx, 712, RULE_char_set_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5126; id_expression();
			State = 5131;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==PERIOD) {
				{
				{
				State = 5127; Match(PERIOD);
				State = 5128; id_expression();
				}
				}
				State = 5133;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Keep_clauseContext : ParserRuleContext {
		public ITerminalNode KEEP() { return GetToken(plsqlParser.KEEP, 0); }
		public Order_by_clauseContext order_by_clause() {
			return GetRuleContext<Order_by_clauseContext>(0);
		}
		public ITerminalNode FIRST() { return GetToken(plsqlParser.FIRST, 0); }
		public ITerminalNode DENSE_RANK() { return GetToken(plsqlParser.DENSE_RANK, 0); }
		public ITerminalNode LAST() { return GetToken(plsqlParser.LAST, 0); }
		public Over_clauseContext over_clause() {
			return GetRuleContext<Over_clauseContext>(0);
		}
		public Keep_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_keep_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterKeep_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitKeep_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitKeep_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Keep_clauseContext keep_clause() {
		Keep_clauseContext _localctx = new Keep_clauseContext(_ctx, State);
		EnterRule(_localctx, 714, RULE_keep_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5134; Match(KEEP);
			State = 5135; Match(LEFT_PAREN);
			State = 5136; Match(DENSE_RANK);
			State = 5137;
			_la = _input.La(1);
			if ( !(_la==FIRST || _la==LAST) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			State = 5138; order_by_clause();
			State = 5139; Match(RIGHT_PAREN);
			State = 5141;
			switch ( Interpreter.AdaptivePredict(_input,668,_ctx) ) {
			case 1:
				{
				State = 5140; over_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Function_argumentContext : ParserRuleContext {
		public Keep_clauseContext keep_clause() {
			return GetRuleContext<Keep_clauseContext>(0);
		}
		public IReadOnlyList<ArgumentContext> argument() {
			return GetRuleContexts<ArgumentContext>();
		}
		public ArgumentContext argument(int i) {
			return GetRuleContext<ArgumentContext>(i);
		}
		public Function_argumentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function_argument; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterFunction_argument(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitFunction_argument(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction_argument(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Function_argumentContext function_argument() {
		Function_argumentContext _localctx = new Function_argumentContext(_ctx, State);
		EnterRule(_localctx, 716, RULE_function_argument);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5143; Match(LEFT_PAREN);
			State = 5145;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALL) | (1L << ANALYZE) | (1L << ANY) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COALESCE) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & ((1L << (CONNECT_BY_ROOT - 65)) | (1L << (CONSTANT - 65)) | (1L << (CONSTRAINT - 65)) | (1L << (CONSTRAINTS - 65)) | (1L << (CONSTRUCTOR - 65)) | (1L << (CONTENT - 65)) | (1L << (CONTEXT - 65)) | (1L << (CONTINUE - 65)) | (1L << (CONVERT - 65)) | (1L << (CORRUPT_XID - 65)) | (1L << (CORRUPT_XID_ALL - 65)) | (1L << (COST - 65)) | (1L << (COUNT - 65)) | (1L << (CROSS - 65)) | (1L << (CUBE - 65)) | (1L << (CURRENT_USER - 65)) | (1L << (CURSOR - 65)) | (1L << (CUSTOMDATUM - 65)) | (1L << (CYCLE - 65)) | (1L << (DATA - 65)) | (1L << (DATABASE - 65)) | (1L << (DATE - 65)) | (1L << (DAY - 65)) | (1L << (DB_ROLE_CHANGE - 65)) | (1L << (DBTIMEZONE - 65)) | (1L << (DDL - 65)) | (1L << (DEBUG - 65)) | (1L << (DEC - 65)) | (1L << (DECIMAL - 65)) | (1L << (DECOMPOSE - 65)) | (1L << (DECREMENT - 65)) | (1L << (DEFAULT - 65)) | (1L << (DEFAULTS - 65)) | (1L << (DEFERRED - 65)) | (1L << (DEFINER - 65)) | (1L << (DETERMINISTIC - 65)) | (1L << (DIMENSION - 65)) | (1L << (DISABLE - 65)) | (1L << (DISASSOCIATE - 65)) | (1L << (DISTINCT - 65)) | (1L << (DOCUMENT - 65)) | (1L << (DOUBLE - 65)) | (1L << (DSINTERVAL_UNCONSTRAINED - 65)) | (1L << (EACH - 65)) | (1L << (ELEMENT - 65)) | (1L << (EMPTY - 65)) | (1L << (ENABLE - 65)) | (1L << (ENCODING - 65)) | (1L << (ENTITYESCAPING - 65)) | (1L << (ERR - 65)) | (1L << (ERRORS - 65)) | (1L << (ESCAPE - 65)) | (1L << (EVALNAME - 65)) | (1L << (EXCEPTION - 65)))) != 0) || ((((_la - 129)) & ~0x3f) == 0 && ((1L << (_la - 129)) & ((1L << (EXCEPTION_INIT - 129)) | (1L << (EXCEPTIONS - 129)) | (1L << (EXCLUDE - 129)) | (1L << (EXECUTE - 129)) | (1L << (EXISTS - 129)) | (1L << (EXIT - 129)) | (1L << (EXPLAIN - 129)) | (1L << (EXTERNAL - 129)) | (1L << (EXTRACT - 129)) | (1L << (FAILURE - 129)) | (1L << (FALSE - 129)) | (1L << (FINAL - 129)) | (1L << (FIRST - 129)) | (1L << (FIRST_VALUE - 129)) | (1L << (FLOAT - 129)) | (1L << (FOLLOWING - 129)) | (1L << (FOLLOWS - 129)) | (1L << (FORALL - 129)) | (1L << (FORCE - 129)) | (1L << (FULL - 129)) | (1L << (FUNCTION - 129)) | (1L << (GROUPING - 129)) | (1L << (HASH - 129)) | (1L << (HIDE - 129)) | (1L << (HOUR - 129)) | (1L << (IGNORE - 129)) | (1L << (IMMEDIATE - 129)) | (1L << (INCLUDE - 129)) | (1L << (INCLUDING - 129)) | (1L << (INCREMENT - 129)) | (1L << (INDENT - 129)) | (1L << (INDEXED - 129)) | (1L << (INDICATOR - 129)) | (1L << (INDICES - 129)) | (1L << (INFINITE - 129)) | (1L << (INLINE - 129)) | (1L << (INNER - 129)) | (1L << (INOUT - 129)) | (1L << (INSTANTIABLE - 129)) | (1L << (INSTEAD - 129)) | (1L << (INT - 129)) | (1L << (INTEGER - 129)) | (1L << (INTERVAL - 129)) | (1L << (INVALIDATE - 129)) | (1L << (ISOLATION - 129)) | (1L << (ITERATE - 129)) | (1L << (JAVA - 129)) | (1L << (JOIN - 129)) | (1L << (KEEP - 129)))) != 0) || ((((_la - 193)) & ~0x3f) == 0 && ((1L << (_la - 193)) & ((1L << (LANGUAGE - 193)) | (1L << (LAST - 193)) | (1L << (LAST_VALUE - 193)) | (1L << (LEADING - 193)) | (1L << (LEFT - 193)) | (1L << (LEVEL - 193)) | (1L << (LIBRARY - 193)) | (1L << (LIKE2 - 193)) | (1L << (LIKE4 - 193)) | (1L << (LIKEC - 193)) | (1L << (LIMIT - 193)) | (1L << (LOCAL - 193)) | (1L << (LOCKED - 193)) | (1L << (LOG - 193)) | (1L << (LOGOFF - 193)) | (1L << (LOGON - 193)) | (1L << (LONG - 193)) | (1L << (LOOP - 193)) | (1L << (MAIN - 193)) | (1L << (MAP - 193)) | (1L << (MATCHED - 193)) | (1L << (MAXVALUE - 193)) | (1L << (MEASURES - 193)) | (1L << (MEMBER - 193)) | (1L << (MERGE - 193)) | (1L << (MINUTE - 193)) | (1L << (MINVALUE - 193)) | (1L << (MLSLABEL - 193)) | (1L << (MODEL - 193)) | (1L << (MODIFY - 193)) | (1L << (MONTH - 193)) | (1L << (MULTISET - 193)) | (1L << (NAME - 193)) | (1L << (NAN - 193)) | (1L << (NATURAL - 193)) | (1L << (NATURALN - 193)) | (1L << (NAV - 193)) | (1L << (NCHAR - 193)) | (1L << (NCHAR_CS - 193)) | (1L << (NCLOB - 193)) | (1L << (NESTED - 193)) | (1L << (NEW - 193)) | (1L << (NO - 193)) | (1L << (NOAUDIT - 193)) | (1L << (NOCOPY - 193)) | (1L << (NOCYCLE - 193)) | (1L << (NOENTITYESCAPING - 193)) | (1L << (NONE - 193)) | (1L << (NOSCHEMACHECK - 193)) | (1L << (NOT - 193)) | (1L << (NULL - 193)) | (1L << (NULLS - 193)) | (1L << (NUMBER - 193)) | (1L << (NUMERIC - 193)) | (1L << (NVARCHAR2 - 193)))) != 0) || ((((_la - 257)) & ~0x3f) == 0 && ((1L << (_la - 257)) & ((1L << (OBJECT - 257)) | (1L << (OFF - 257)) | (1L << (OID - 257)) | (1L << (OLD - 257)) | (1L << (ONLY - 257)) | (1L << (OPEN - 257)) | (1L << (ORADATA - 257)) | (1L << (ORDINALITY - 257)) | (1L << (OSERROR - 257)) | (1L << (OUT - 257)) | (1L << (OUTER - 257)) | (1L << (OVER - 257)) | (1L << (OVERRIDING - 257)) | (1L << (PACKAGE - 257)) | (1L << (PARALLEL_ENABLE - 257)) | (1L << (PARAMETERS - 257)) | (1L << (PARENT - 257)) | (1L << (PARTITION - 257)) | (1L << (PASSING - 257)) | (1L << (PATH - 257)) | (1L << (PIPELINED - 257)) | (1L << (PLAN - 257)) | (1L << (PLS_INTEGER - 257)) | (1L << (POSITIVE - 257)) | (1L << (POSITIVEN - 257)) | (1L << (PRAGMA - 257)) | (1L << (PRECEDING - 257)) | (1L << (PRECISION - 257)) | (1L << (PRESENT - 257)) | (1L << (PRIOR - 257)) | (1L << (RAISE - 257)) | (1L << (RANGE - 257)) | (1L << (RAW - 257)) | (1L << (READ - 257)) | (1L << (REAL - 257)) | (1L << (RECORD - 257)) | (1L << (REF - 257)) | (1L << (REFERENCE - 257)) | (1L << (REFERENCING - 257)) | (1L << (REJECT - 257)) | (1L << (RELIES_ON - 257)) | (1L << (RENAME - 257)) | (1L << (REPLACE - 257)) | (1L << (RESPECT - 257)) | (1L << (RESTRICT_REFERENCES - 257)) | (1L << (RESULT - 257)) | (1L << (RESULT_CACHE - 257)) | (1L << (RETURN - 257)) | (1L << (RETURNING - 257)) | (1L << (REUSE - 257)) | (1L << (REVERSE - 257)))) != 0) || ((((_la - 322)) & ~0x3f) == 0 && ((1L << (_la - 322)) & ((1L << (RIGHT - 322)) | (1L << (ROLLBACK - 322)) | (1L << (ROLLUP - 322)) | (1L << (ROW - 322)) | (1L << (ROWID - 322)) | (1L << (ROWS - 322)) | (1L << (RULES - 322)) | (1L << (SAMPLE - 322)) | (1L << (SAVE - 322)) | (1L << (SAVEPOINT - 322)) | (1L << (SCHEMA - 322)) | (1L << (SCHEMACHECK - 322)) | (1L << (SCN - 322)) | (1L << (SECOND - 322)) | (1L << (SEED - 322)) | (1L << (SEGMENT - 322)) | (1L << (SELF - 322)) | (1L << (SEQUENTIAL - 322)) | (1L << (SERIALIZABLE - 322)) | (1L << (SERIALLY_REUSABLE - 322)) | (1L << (SERVERERROR - 322)) | (1L << (SESSIONTIMEZONE - 322)) | (1L << (SET - 322)) | (1L << (SETS - 322)) | (1L << (SETTINGS - 322)) | (1L << (SHOW - 322)) | (1L << (SHUTDOWN - 322)) | (1L << (SIBLINGS - 322)) | (1L << (SIGNTYPE - 322)) | (1L << (SIMPLE_INTEGER - 322)) | (1L << (SINGLE - 322)) | (1L << (SKIP_ - 322)) | (1L << (SMALLINT - 322)) | (1L << (SNAPSHOT - 322)) | (1L << (SOME - 322)) | (1L << (SPECIFICATION - 322)) | (1L << (SQLDATA - 322)) | (1L << (SQLERROR - 322)) | (1L << (STANDALONE - 322)) | (1L << (STARTUP - 322)) | (1L << (STATEMENT - 322)) | (1L << (STATEMENT_ID - 322)) | (1L << (STATIC - 322)) | (1L << (STATISTICS - 322)) | (1L << (STRING - 322)) | (1L << (SUBMULTISET - 322)) | (1L << (SUBPARTITION - 322)) | (1L << (SUBSTITUTABLE - 322)) | (1L << (SUBTYPE - 322)) | (1L << (SUCCESS - 322)) | (1L << (SUSPEND - 322)) | (1L << (TIME - 322)) | (1L << (TIMESTAMP - 322)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 322)))) != 0) || ((((_la - 386)) & ~0x3f) == 0 && ((1L << (_la - 386)) & ((1L << (TIMESTAMP_UNCONSTRAINED - 386)) | (1L << (TIMEZONE_ABBR - 386)) | (1L << (TIMEZONE_HOUR - 386)) | (1L << (TIMEZONE_MINUTE - 386)) | (1L << (TIMEZONE_REGION - 386)) | (1L << (TRAILING - 386)) | (1L << (TRANSACTION - 386)) | (1L << (TRANSLATE - 386)) | (1L << (TREAT - 386)) | (1L << (TRIGGER - 386)) | (1L << (TRUE - 386)) | (1L << (TRUNCATE - 386)) | (1L << (TYPE - 386)) | (1L << (UNBOUNDED - 386)) | (1L << (UNDER - 386)) | (1L << (UNLIMITED - 386)) | (1L << (UNTIL - 386)) | (1L << (UPDATED - 386)) | (1L << (UPSERT - 386)) | (1L << (UROWID - 386)) | (1L << (USE - 386)) | (1L << (VALIDATE - 386)) | (1L << (VALUE - 386)) | (1L << (VARCHAR - 386)) | (1L << (VARCHAR2 - 386)) | (1L << (VARIABLE - 386)) | (1L << (VARRAY - 386)) | (1L << (VARYING - 386)) | (1L << (VERSION - 386)) | (1L << (VERSIONS - 386)) | (1L << (WAIT - 386)) | (1L << (WARNING - 386)) | (1L << (WELLFORMED - 386)) | (1L << (WHENEVER - 386)) | (1L << (WHILE - 386)) | (1L << (WITHIN - 386)) | (1L << (WORK - 386)) | (1L << (WRITE - 386)) | (1L << (XML - 386)) | (1L << (XMLAGG - 386)) | (1L << (XMLATTRIBUTES - 386)) | (1L << (XMLCAST - 386)) | (1L << (XMLCOLATTVAL - 386)) | (1L << (XMLELEMENT - 386)) | (1L << (XMLEXISTS - 386)) | (1L << (XMLFOREST - 386)) | (1L << (XMLNAMESPACES - 386)) | (1L << (XMLPARSE - 386)) | (1L << (XMLPI - 386)) | (1L << (XMLQUERY - 386)) | (1L << (XMLROOT - 386)) | (1L << (XMLSERIALIZE - 386)) | (1L << (XMLTABLE - 386)) | (1L << (YEAR - 386)))) != 0) || ((((_la - 450)) & ~0x3f) == 0 && ((1L << (_la - 450)) & ((1L << (YES - 450)) | (1L << (YMINTERVAL_UNCONSTRAINED - 450)) | (1L << (ZONE - 450)) | (1L << (PREDICTION - 450)) | (1L << (PREDICTION_BOUNDS - 450)) | (1L << (PREDICTION_COST - 450)) | (1L << (PREDICTION_DETAILS - 450)) | (1L << (PREDICTION_PROBABILITY - 450)) | (1L << (PREDICTION_SET - 450)) | (1L << (CUME_DIST - 450)) | (1L << (DENSE_RANK - 450)) | (1L << (LISTAGG - 450)) | (1L << (PERCENT_RANK - 450)) | (1L << (PERCENTILE_CONT - 450)) | (1L << (PERCENTILE_DISC - 450)) | (1L << (RANK - 450)) | (1L << (AVG - 450)) | (1L << (CORR - 450)) | (1L << (COVAR_ - 450)) | (1L << (DECODE - 450)) | (1L << (LAG - 450)) | (1L << (LEAD - 450)) | (1L << (MAX - 450)) | (1L << (MEDIAN - 450)) | (1L << (MIN - 450)) | (1L << (NTILE - 450)) | (1L << (NVL - 450)) | (1L << (RATIO_TO_REPORT - 450)) | (1L << (REGR_ - 450)) | (1L << (ROUND - 450)) | (1L << (ROW_NUMBER - 450)) | (1L << (SUBSTR - 450)) | (1L << (TO_CHAR - 450)) | (1L << (TRIM - 450)) | (1L << (SUM - 450)) | (1L << (STDDEV - 450)) | (1L << (VAR_ - 450)) | (1L << (VARIANCE - 450)) | (1L << (NATIONAL_CHAR_STRING_LIT - 450)) | (1L << (UNSIGNED_INTEGER - 450)) | (1L << (APPROXIMATE_NUM_LIT - 450)) | (1L << (CHAR_STRING - 450)) | (1L << (DELIMITED_ID - 450)) | (1L << (LEFT_PAREN - 450)) | (1L << (PLUS_SIGN - 450)) | (1L << (MINUS_SIGN - 450)) | (1L << (BINDVAR - 450)) | (1L << (COLON - 450)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 5144; argument();
				}
			}

			State = 5151;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 5147; Match(COMMA);
				State = 5148; argument();
				}
				}
				State = 5153;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 5154; Match(RIGHT_PAREN);
			State = 5156;
			switch ( Interpreter.AdaptivePredict(_input,671,_ctx) ) {
			case 1:
				{
				State = 5155; keep_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Function_argument_analyticContext : ParserRuleContext {
		public IReadOnlyList<Respect_or_ignore_nullsContext> respect_or_ignore_nulls() {
			return GetRuleContexts<Respect_or_ignore_nullsContext>();
		}
		public Keep_clauseContext keep_clause() {
			return GetRuleContext<Keep_clauseContext>(0);
		}
		public IReadOnlyList<ArgumentContext> argument() {
			return GetRuleContexts<ArgumentContext>();
		}
		public ArgumentContext argument(int i) {
			return GetRuleContext<ArgumentContext>(i);
		}
		public Respect_or_ignore_nullsContext respect_or_ignore_nulls(int i) {
			return GetRuleContext<Respect_or_ignore_nullsContext>(i);
		}
		public Function_argument_analyticContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function_argument_analytic; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterFunction_argument_analytic(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitFunction_argument_analytic(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction_argument_analytic(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Function_argument_analyticContext function_argument_analytic() {
		Function_argument_analyticContext _localctx = new Function_argument_analyticContext(_ctx, State);
		EnterRule(_localctx, 718, RULE_function_argument_analytic);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5158; Match(LEFT_PAREN);
			State = 5163;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALL) | (1L << ANALYZE) | (1L << ANY) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COALESCE) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & ((1L << (CONNECT_BY_ROOT - 65)) | (1L << (CONSTANT - 65)) | (1L << (CONSTRAINT - 65)) | (1L << (CONSTRAINTS - 65)) | (1L << (CONSTRUCTOR - 65)) | (1L << (CONTENT - 65)) | (1L << (CONTEXT - 65)) | (1L << (CONTINUE - 65)) | (1L << (CONVERT - 65)) | (1L << (CORRUPT_XID - 65)) | (1L << (CORRUPT_XID_ALL - 65)) | (1L << (COST - 65)) | (1L << (COUNT - 65)) | (1L << (CROSS - 65)) | (1L << (CUBE - 65)) | (1L << (CURRENT_USER - 65)) | (1L << (CURSOR - 65)) | (1L << (CUSTOMDATUM - 65)) | (1L << (CYCLE - 65)) | (1L << (DATA - 65)) | (1L << (DATABASE - 65)) | (1L << (DATE - 65)) | (1L << (DAY - 65)) | (1L << (DB_ROLE_CHANGE - 65)) | (1L << (DBTIMEZONE - 65)) | (1L << (DDL - 65)) | (1L << (DEBUG - 65)) | (1L << (DEC - 65)) | (1L << (DECIMAL - 65)) | (1L << (DECOMPOSE - 65)) | (1L << (DECREMENT - 65)) | (1L << (DEFAULT - 65)) | (1L << (DEFAULTS - 65)) | (1L << (DEFERRED - 65)) | (1L << (DEFINER - 65)) | (1L << (DETERMINISTIC - 65)) | (1L << (DIMENSION - 65)) | (1L << (DISABLE - 65)) | (1L << (DISASSOCIATE - 65)) | (1L << (DISTINCT - 65)) | (1L << (DOCUMENT - 65)) | (1L << (DOUBLE - 65)) | (1L << (DSINTERVAL_UNCONSTRAINED - 65)) | (1L << (EACH - 65)) | (1L << (ELEMENT - 65)) | (1L << (EMPTY - 65)) | (1L << (ENABLE - 65)) | (1L << (ENCODING - 65)) | (1L << (ENTITYESCAPING - 65)) | (1L << (ERR - 65)) | (1L << (ERRORS - 65)) | (1L << (ESCAPE - 65)) | (1L << (EVALNAME - 65)) | (1L << (EXCEPTION - 65)))) != 0) || ((((_la - 129)) & ~0x3f) == 0 && ((1L << (_la - 129)) & ((1L << (EXCEPTION_INIT - 129)) | (1L << (EXCEPTIONS - 129)) | (1L << (EXCLUDE - 129)) | (1L << (EXECUTE - 129)) | (1L << (EXISTS - 129)) | (1L << (EXIT - 129)) | (1L << (EXPLAIN - 129)) | (1L << (EXTERNAL - 129)) | (1L << (EXTRACT - 129)) | (1L << (FAILURE - 129)) | (1L << (FALSE - 129)) | (1L << (FINAL - 129)) | (1L << (FIRST - 129)) | (1L << (FIRST_VALUE - 129)) | (1L << (FLOAT - 129)) | (1L << (FOLLOWING - 129)) | (1L << (FOLLOWS - 129)) | (1L << (FORALL - 129)) | (1L << (FORCE - 129)) | (1L << (FULL - 129)) | (1L << (FUNCTION - 129)) | (1L << (GROUPING - 129)) | (1L << (HASH - 129)) | (1L << (HIDE - 129)) | (1L << (HOUR - 129)) | (1L << (IGNORE - 129)) | (1L << (IMMEDIATE - 129)) | (1L << (INCLUDE - 129)) | (1L << (INCLUDING - 129)) | (1L << (INCREMENT - 129)) | (1L << (INDENT - 129)) | (1L << (INDEXED - 129)) | (1L << (INDICATOR - 129)) | (1L << (INDICES - 129)) | (1L << (INFINITE - 129)) | (1L << (INLINE - 129)) | (1L << (INNER - 129)) | (1L << (INOUT - 129)) | (1L << (INSTANTIABLE - 129)) | (1L << (INSTEAD - 129)) | (1L << (INT - 129)) | (1L << (INTEGER - 129)) | (1L << (INTERVAL - 129)) | (1L << (INVALIDATE - 129)) | (1L << (ISOLATION - 129)) | (1L << (ITERATE - 129)) | (1L << (JAVA - 129)) | (1L << (JOIN - 129)) | (1L << (KEEP - 129)))) != 0) || ((((_la - 193)) & ~0x3f) == 0 && ((1L << (_la - 193)) & ((1L << (LANGUAGE - 193)) | (1L << (LAST - 193)) | (1L << (LAST_VALUE - 193)) | (1L << (LEADING - 193)) | (1L << (LEFT - 193)) | (1L << (LEVEL - 193)) | (1L << (LIBRARY - 193)) | (1L << (LIKE2 - 193)) | (1L << (LIKE4 - 193)) | (1L << (LIKEC - 193)) | (1L << (LIMIT - 193)) | (1L << (LOCAL - 193)) | (1L << (LOCKED - 193)) | (1L << (LOG - 193)) | (1L << (LOGOFF - 193)) | (1L << (LOGON - 193)) | (1L << (LONG - 193)) | (1L << (LOOP - 193)) | (1L << (MAIN - 193)) | (1L << (MAP - 193)) | (1L << (MATCHED - 193)) | (1L << (MAXVALUE - 193)) | (1L << (MEASURES - 193)) | (1L << (MEMBER - 193)) | (1L << (MERGE - 193)) | (1L << (MINUTE - 193)) | (1L << (MINVALUE - 193)) | (1L << (MLSLABEL - 193)) | (1L << (MODEL - 193)) | (1L << (MODIFY - 193)) | (1L << (MONTH - 193)) | (1L << (MULTISET - 193)) | (1L << (NAME - 193)) | (1L << (NAN - 193)) | (1L << (NATURAL - 193)) | (1L << (NATURALN - 193)) | (1L << (NAV - 193)) | (1L << (NCHAR - 193)) | (1L << (NCHAR_CS - 193)) | (1L << (NCLOB - 193)) | (1L << (NESTED - 193)) | (1L << (NEW - 193)) | (1L << (NO - 193)) | (1L << (NOAUDIT - 193)) | (1L << (NOCOPY - 193)) | (1L << (NOCYCLE - 193)) | (1L << (NOENTITYESCAPING - 193)) | (1L << (NONE - 193)) | (1L << (NOSCHEMACHECK - 193)) | (1L << (NOT - 193)) | (1L << (NULL - 193)) | (1L << (NULLS - 193)) | (1L << (NUMBER - 193)) | (1L << (NUMERIC - 193)) | (1L << (NVARCHAR2 - 193)))) != 0) || ((((_la - 257)) & ~0x3f) == 0 && ((1L << (_la - 257)) & ((1L << (OBJECT - 257)) | (1L << (OFF - 257)) | (1L << (OID - 257)) | (1L << (OLD - 257)) | (1L << (ONLY - 257)) | (1L << (OPEN - 257)) | (1L << (ORADATA - 257)) | (1L << (ORDINALITY - 257)) | (1L << (OSERROR - 257)) | (1L << (OUT - 257)) | (1L << (OUTER - 257)) | (1L << (OVER - 257)) | (1L << (OVERRIDING - 257)) | (1L << (PACKAGE - 257)) | (1L << (PARALLEL_ENABLE - 257)) | (1L << (PARAMETERS - 257)) | (1L << (PARENT - 257)) | (1L << (PARTITION - 257)) | (1L << (PASSING - 257)) | (1L << (PATH - 257)) | (1L << (PIPELINED - 257)) | (1L << (PLAN - 257)) | (1L << (PLS_INTEGER - 257)) | (1L << (POSITIVE - 257)) | (1L << (POSITIVEN - 257)) | (1L << (PRAGMA - 257)) | (1L << (PRECEDING - 257)) | (1L << (PRECISION - 257)) | (1L << (PRESENT - 257)) | (1L << (PRIOR - 257)) | (1L << (RAISE - 257)) | (1L << (RANGE - 257)) | (1L << (RAW - 257)) | (1L << (READ - 257)) | (1L << (REAL - 257)) | (1L << (RECORD - 257)) | (1L << (REF - 257)) | (1L << (REFERENCE - 257)) | (1L << (REFERENCING - 257)) | (1L << (REJECT - 257)) | (1L << (RELIES_ON - 257)) | (1L << (RENAME - 257)) | (1L << (REPLACE - 257)) | (1L << (RESPECT - 257)) | (1L << (RESTRICT_REFERENCES - 257)) | (1L << (RESULT - 257)) | (1L << (RESULT_CACHE - 257)) | (1L << (RETURN - 257)) | (1L << (RETURNING - 257)) | (1L << (REUSE - 257)) | (1L << (REVERSE - 257)))) != 0) || ((((_la - 322)) & ~0x3f) == 0 && ((1L << (_la - 322)) & ((1L << (RIGHT - 322)) | (1L << (ROLLBACK - 322)) | (1L << (ROLLUP - 322)) | (1L << (ROW - 322)) | (1L << (ROWID - 322)) | (1L << (ROWS - 322)) | (1L << (RULES - 322)) | (1L << (SAMPLE - 322)) | (1L << (SAVE - 322)) | (1L << (SAVEPOINT - 322)) | (1L << (SCHEMA - 322)) | (1L << (SCHEMACHECK - 322)) | (1L << (SCN - 322)) | (1L << (SECOND - 322)) | (1L << (SEED - 322)) | (1L << (SEGMENT - 322)) | (1L << (SELF - 322)) | (1L << (SEQUENTIAL - 322)) | (1L << (SERIALIZABLE - 322)) | (1L << (SERIALLY_REUSABLE - 322)) | (1L << (SERVERERROR - 322)) | (1L << (SESSIONTIMEZONE - 322)) | (1L << (SET - 322)) | (1L << (SETS - 322)) | (1L << (SETTINGS - 322)) | (1L << (SHOW - 322)) | (1L << (SHUTDOWN - 322)) | (1L << (SIBLINGS - 322)) | (1L << (SIGNTYPE - 322)) | (1L << (SIMPLE_INTEGER - 322)) | (1L << (SINGLE - 322)) | (1L << (SKIP_ - 322)) | (1L << (SMALLINT - 322)) | (1L << (SNAPSHOT - 322)) | (1L << (SOME - 322)) | (1L << (SPECIFICATION - 322)) | (1L << (SQLDATA - 322)) | (1L << (SQLERROR - 322)) | (1L << (STANDALONE - 322)) | (1L << (STARTUP - 322)) | (1L << (STATEMENT - 322)) | (1L << (STATEMENT_ID - 322)) | (1L << (STATIC - 322)) | (1L << (STATISTICS - 322)) | (1L << (STRING - 322)) | (1L << (SUBMULTISET - 322)) | (1L << (SUBPARTITION - 322)) | (1L << (SUBSTITUTABLE - 322)) | (1L << (SUBTYPE - 322)) | (1L << (SUCCESS - 322)) | (1L << (SUSPEND - 322)) | (1L << (TIME - 322)) | (1L << (TIMESTAMP - 322)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 322)))) != 0) || ((((_la - 386)) & ~0x3f) == 0 && ((1L << (_la - 386)) & ((1L << (TIMESTAMP_UNCONSTRAINED - 386)) | (1L << (TIMEZONE_ABBR - 386)) | (1L << (TIMEZONE_HOUR - 386)) | (1L << (TIMEZONE_MINUTE - 386)) | (1L << (TIMEZONE_REGION - 386)) | (1L << (TRAILING - 386)) | (1L << (TRANSACTION - 386)) | (1L << (TRANSLATE - 386)) | (1L << (TREAT - 386)) | (1L << (TRIGGER - 386)) | (1L << (TRUE - 386)) | (1L << (TRUNCATE - 386)) | (1L << (TYPE - 386)) | (1L << (UNBOUNDED - 386)) | (1L << (UNDER - 386)) | (1L << (UNLIMITED - 386)) | (1L << (UNTIL - 386)) | (1L << (UPDATED - 386)) | (1L << (UPSERT - 386)) | (1L << (UROWID - 386)) | (1L << (USE - 386)) | (1L << (VALIDATE - 386)) | (1L << (VALUE - 386)) | (1L << (VARCHAR - 386)) | (1L << (VARCHAR2 - 386)) | (1L << (VARIABLE - 386)) | (1L << (VARRAY - 386)) | (1L << (VARYING - 386)) | (1L << (VERSION - 386)) | (1L << (VERSIONS - 386)) | (1L << (WAIT - 386)) | (1L << (WARNING - 386)) | (1L << (WELLFORMED - 386)) | (1L << (WHENEVER - 386)) | (1L << (WHILE - 386)) | (1L << (WITHIN - 386)) | (1L << (WORK - 386)) | (1L << (WRITE - 386)) | (1L << (XML - 386)) | (1L << (XMLAGG - 386)) | (1L << (XMLATTRIBUTES - 386)) | (1L << (XMLCAST - 386)) | (1L << (XMLCOLATTVAL - 386)) | (1L << (XMLELEMENT - 386)) | (1L << (XMLEXISTS - 386)) | (1L << (XMLFOREST - 386)) | (1L << (XMLNAMESPACES - 386)) | (1L << (XMLPARSE - 386)) | (1L << (XMLPI - 386)) | (1L << (XMLQUERY - 386)) | (1L << (XMLROOT - 386)) | (1L << (XMLSERIALIZE - 386)) | (1L << (XMLTABLE - 386)) | (1L << (YEAR - 386)))) != 0) || ((((_la - 450)) & ~0x3f) == 0 && ((1L << (_la - 450)) & ((1L << (YES - 450)) | (1L << (YMINTERVAL_UNCONSTRAINED - 450)) | (1L << (ZONE - 450)) | (1L << (PREDICTION - 450)) | (1L << (PREDICTION_BOUNDS - 450)) | (1L << (PREDICTION_COST - 450)) | (1L << (PREDICTION_DETAILS - 450)) | (1L << (PREDICTION_PROBABILITY - 450)) | (1L << (PREDICTION_SET - 450)) | (1L << (CUME_DIST - 450)) | (1L << (DENSE_RANK - 450)) | (1L << (LISTAGG - 450)) | (1L << (PERCENT_RANK - 450)) | (1L << (PERCENTILE_CONT - 450)) | (1L << (PERCENTILE_DISC - 450)) | (1L << (RANK - 450)) | (1L << (AVG - 450)) | (1L << (CORR - 450)) | (1L << (COVAR_ - 450)) | (1L << (DECODE - 450)) | (1L << (LAG - 450)) | (1L << (LEAD - 450)) | (1L << (MAX - 450)) | (1L << (MEDIAN - 450)) | (1L << (MIN - 450)) | (1L << (NTILE - 450)) | (1L << (NVL - 450)) | (1L << (RATIO_TO_REPORT - 450)) | (1L << (REGR_ - 450)) | (1L << (ROUND - 450)) | (1L << (ROW_NUMBER - 450)) | (1L << (SUBSTR - 450)) | (1L << (TO_CHAR - 450)) | (1L << (TRIM - 450)) | (1L << (SUM - 450)) | (1L << (STDDEV - 450)) | (1L << (VAR_ - 450)) | (1L << (VARIANCE - 450)) | (1L << (NATIONAL_CHAR_STRING_LIT - 450)) | (1L << (UNSIGNED_INTEGER - 450)) | (1L << (APPROXIMATE_NUM_LIT - 450)) | (1L << (CHAR_STRING - 450)) | (1L << (DELIMITED_ID - 450)) | (1L << (LEFT_PAREN - 450)) | (1L << (PLUS_SIGN - 450)) | (1L << (MINUS_SIGN - 450)) | (1L << (BINDVAR - 450)) | (1L << (COLON - 450)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 5159; argument();
				State = 5161;
				_la = _input.La(1);
				if (_la==IGNORE || _la==RESPECT) {
					{
					State = 5160; respect_or_ignore_nulls();
					}
				}

				}
			}

			State = 5172;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 5165; Match(COMMA);
				State = 5166; argument();
				State = 5168;
				_la = _input.La(1);
				if (_la==IGNORE || _la==RESPECT) {
					{
					State = 5167; respect_or_ignore_nulls();
					}
				}

				}
				}
				State = 5174;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 5175; Match(RIGHT_PAREN);
			State = 5177;
			switch ( Interpreter.AdaptivePredict(_input,676,_ctx) ) {
			case 1:
				{
				State = 5176; keep_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Function_argument_modelingContext : ParserRuleContext {
		public IReadOnlyList<NumericContext> numeric() {
			return GetRuleContexts<NumericContext>();
		}
		public ITerminalNode NULL(int i) {
			return GetToken(plsqlParser.NULL, i);
		}
		public Column_nameContext column_name() {
			return GetRuleContext<Column_nameContext>(0);
		}
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public IReadOnlyList<ITerminalNode> NULL() { return GetTokens(plsqlParser.NULL); }
		public Column_aliasContext column_alias(int i) {
			return GetRuleContext<Column_aliasContext>(i);
		}
		public NumericContext numeric(int i) {
			return GetRuleContext<NumericContext>(i);
		}
		public Keep_clauseContext keep_clause() {
			return GetRuleContext<Keep_clauseContext>(0);
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode USING() { return GetToken(plsqlParser.USING, 0); }
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public IReadOnlyList<Column_aliasContext> column_alias() {
			return GetRuleContexts<Column_aliasContext>();
		}
		public Function_argument_modelingContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function_argument_modeling; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterFunction_argument_modeling(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitFunction_argument_modeling(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction_argument_modeling(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Function_argument_modelingContext function_argument_modeling() {
		Function_argument_modelingContext _localctx = new Function_argument_modelingContext(_ctx, State);
		EnterRule(_localctx, 720, RULE_function_argument_modeling);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5179; Match(LEFT_PAREN);
			State = 5180; column_name();
			State = 5193;
			_la = _input.La(1);
			if (_la==COMMA) {
				{
				State = 5181; Match(COMMA);
				State = 5184;
				switch (_input.La(1)) {
				case UNSIGNED_INTEGER:
				case APPROXIMATE_NUM_LIT:
					{
					State = 5182; numeric();
					}
					break;
				case NULL:
					{
					State = 5183; Match(NULL);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 5191;
				_la = _input.La(1);
				if (_la==COMMA) {
					{
					State = 5186; Match(COMMA);
					State = 5189;
					switch (_input.La(1)) {
					case UNSIGNED_INTEGER:
					case APPROXIMATE_NUM_LIT:
						{
						State = 5187; numeric();
						}
						break;
					case NULL:
						{
						State = 5188; Match(NULL);
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
				}

				}
			}

			State = 5195; Match(USING);
			State = 5215;
			switch ( Interpreter.AdaptivePredict(_input,684,_ctx) ) {
			case 1:
				{
				State = 5196; tableview_name();
				State = 5197; Match(PERIOD);
				State = 5198; Match(ASTERISK);
				}
				break;

			case 2:
				{
				State = 5200; Match(ASTERISK);
				}
				break;

			case 3:
				{
				State = 5201; expression();
				State = 5203;
				_la = _input.La(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << AS) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (CONSTANT - 66)) | (1L << (CONSTRAINT - 66)) | (1L << (CONSTRAINTS - 66)) | (1L << (CONSTRUCTOR - 66)) | (1L << (CONTENT - 66)) | (1L << (CONTEXT - 66)) | (1L << (CONTINUE - 66)) | (1L << (CONVERT - 66)) | (1L << (CORRUPT_XID - 66)) | (1L << (CORRUPT_XID_ALL - 66)) | (1L << (COST - 66)) | (1L << (COUNT - 66)) | (1L << (CROSS - 66)) | (1L << (CUBE - 66)) | (1L << (CURRENT_USER - 66)) | (1L << (CURSOR - 66)) | (1L << (CUSTOMDATUM - 66)) | (1L << (CYCLE - 66)) | (1L << (DATA - 66)) | (1L << (DATABASE - 66)) | (1L << (DAY - 66)) | (1L << (DB_ROLE_CHANGE - 66)) | (1L << (DBTIMEZONE - 66)) | (1L << (DDL - 66)) | (1L << (DEBUG - 66)) | (1L << (DEC - 66)) | (1L << (DECIMAL - 66)) | (1L << (DECOMPOSE - 66)) | (1L << (DECREMENT - 66)) | (1L << (DEFAULTS - 66)) | (1L << (DEFERRED - 66)) | (1L << (DEFINER - 66)) | (1L << (DETERMINISTIC - 66)) | (1L << (DIMENSION - 66)) | (1L << (DISABLE - 66)) | (1L << (DISASSOCIATE - 66)) | (1L << (DOCUMENT - 66)) | (1L << (DOUBLE - 66)) | (1L << (DSINTERVAL_UNCONSTRAINED - 66)) | (1L << (EACH - 66)) | (1L << (ELEMENT - 66)) | (1L << (EMPTY - 66)) | (1L << (ENABLE - 66)) | (1L << (ENCODING - 66)) | (1L << (ENTITYESCAPING - 66)) | (1L << (ERR - 66)) | (1L << (ERRORS - 66)) | (1L << (ESCAPE - 66)) | (1L << (EVALNAME - 66)) | (1L << (EXCEPTION - 66)) | (1L << (EXCEPTION_INIT - 66)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)) | (1L << (EXIT - 130)) | (1L << (EXPLAIN - 130)) | (1L << (EXTERNAL - 130)) | (1L << (EXTRACT - 130)) | (1L << (FAILURE - 130)) | (1L << (FINAL - 130)) | (1L << (FIRST - 130)) | (1L << (FIRST_VALUE - 130)) | (1L << (FLOAT - 130)) | (1L << (FOLLOWING - 130)) | (1L << (FOLLOWS - 130)) | (1L << (FORALL - 130)) | (1L << (FORCE - 130)) | (1L << (FULL - 130)) | (1L << (FUNCTION - 130)) | (1L << (GROUPING - 130)) | (1L << (HASH - 130)) | (1L << (HIDE - 130)) | (1L << (HOUR - 130)) | (1L << (IGNORE - 130)) | (1L << (IMMEDIATE - 130)) | (1L << (INCLUDE - 130)) | (1L << (INCLUDING - 130)) | (1L << (INCREMENT - 130)) | (1L << (INDENT - 130)) | (1L << (INDEXED - 130)) | (1L << (INDICATOR - 130)) | (1L << (INDICES - 130)) | (1L << (INFINITE - 130)) | (1L << (INLINE - 130)) | (1L << (INNER - 130)) | (1L << (INOUT - 130)) | (1L << (INSTANTIABLE - 130)) | (1L << (INSTEAD - 130)) | (1L << (INT - 130)) | (1L << (INTEGER - 130)) | (1L << (INTERVAL - 130)) | (1L << (INVALIDATE - 130)) | (1L << (ISOLATION - 130)) | (1L << (ITERATE - 130)) | (1L << (JAVA - 130)) | (1L << (JOIN - 130)) | (1L << (KEEP - 130)) | (1L << (LANGUAGE - 130)))) != 0) || ((((_la - 194)) & ~0x3f) == 0 && ((1L << (_la - 194)) & ((1L << (LAST - 194)) | (1L << (LAST_VALUE - 194)) | (1L << (LEADING - 194)) | (1L << (LEFT - 194)) | (1L << (LEVEL - 194)) | (1L << (LIBRARY - 194)) | (1L << (LIKE2 - 194)) | (1L << (LIKE4 - 194)) | (1L << (LIKEC - 194)) | (1L << (LIMIT - 194)) | (1L << (LOCAL - 194)) | (1L << (LOCKED - 194)) | (1L << (LOG - 194)) | (1L << (LOGOFF - 194)) | (1L << (LOGON - 194)) | (1L << (LONG - 194)) | (1L << (LOOP - 194)) | (1L << (MAIN - 194)) | (1L << (MAP - 194)) | (1L << (MATCHED - 194)) | (1L << (MAXVALUE - 194)) | (1L << (MEASURES - 194)) | (1L << (MEMBER - 194)) | (1L << (MERGE - 194)) | (1L << (MINUTE - 194)) | (1L << (MINVALUE - 194)) | (1L << (MLSLABEL - 194)) | (1L << (MODEL - 194)) | (1L << (MODIFY - 194)) | (1L << (MONTH - 194)) | (1L << (MULTISET - 194)) | (1L << (NAME - 194)) | (1L << (NAN - 194)) | (1L << (NATURAL - 194)) | (1L << (NATURALN - 194)) | (1L << (NAV - 194)) | (1L << (NCHAR - 194)) | (1L << (NCHAR_CS - 194)) | (1L << (NCLOB - 194)) | (1L << (NESTED - 194)) | (1L << (NEW - 194)) | (1L << (NO - 194)) | (1L << (NOAUDIT - 194)) | (1L << (NOCOPY - 194)) | (1L << (NOCYCLE - 194)) | (1L << (NOENTITYESCAPING - 194)) | (1L << (NONE - 194)) | (1L << (NOSCHEMACHECK - 194)) | (1L << (NULLS - 194)) | (1L << (NUMBER - 194)) | (1L << (NUMERIC - 194)) | (1L << (NVARCHAR2 - 194)) | (1L << (OBJECT - 194)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (OFF - 259)) | (1L << (OID - 259)) | (1L << (OLD - 259)) | (1L << (ONLY - 259)) | (1L << (OPEN - 259)) | (1L << (ORADATA - 259)) | (1L << (ORDINALITY - 259)) | (1L << (OSERROR - 259)) | (1L << (OUT - 259)) | (1L << (OUTER - 259)) | (1L << (OVER - 259)) | (1L << (OVERRIDING - 259)) | (1L << (PACKAGE - 259)) | (1L << (PARALLEL_ENABLE - 259)) | (1L << (PARAMETERS - 259)) | (1L << (PARENT - 259)) | (1L << (PARTITION - 259)) | (1L << (PASSING - 259)) | (1L << (PATH - 259)) | (1L << (PIPELINED - 259)) | (1L << (PLAN - 259)) | (1L << (PLS_INTEGER - 259)) | (1L << (POSITIVE - 259)) | (1L << (POSITIVEN - 259)) | (1L << (PRAGMA - 259)) | (1L << (PRECEDING - 259)) | (1L << (PRECISION - 259)) | (1L << (PRESENT - 259)) | (1L << (RAISE - 259)) | (1L << (RANGE - 259)) | (1L << (RAW - 259)) | (1L << (READ - 259)) | (1L << (REAL - 259)) | (1L << (RECORD - 259)) | (1L << (REF - 259)) | (1L << (REFERENCE - 259)) | (1L << (REFERENCING - 259)) | (1L << (REJECT - 259)) | (1L << (RELIES_ON - 259)) | (1L << (RENAME - 259)) | (1L << (REPLACE - 259)) | (1L << (RESPECT - 259)) | (1L << (RESTRICT_REFERENCES - 259)) | (1L << (RESULT - 259)) | (1L << (RESULT_CACHE - 259)) | (1L << (RETURN - 259)) | (1L << (RETURNING - 259)) | (1L << (REUSE - 259)) | (1L << (REVERSE - 259)) | (1L << (RIGHT - 259)))) != 0) || ((((_la - 323)) & ~0x3f) == 0 && ((1L << (_la - 323)) & ((1L << (ROLLBACK - 323)) | (1L << (ROLLUP - 323)) | (1L << (ROW - 323)) | (1L << (ROWID - 323)) | (1L << (ROWS - 323)) | (1L << (RULES - 323)) | (1L << (SAMPLE - 323)) | (1L << (SAVE - 323)) | (1L << (SAVEPOINT - 323)) | (1L << (SCHEMA - 323)) | (1L << (SCHEMACHECK - 323)) | (1L << (SCN - 323)) | (1L << (SECOND - 323)) | (1L << (SEED - 323)) | (1L << (SEGMENT - 323)) | (1L << (SELF - 323)) | (1L << (SEQUENTIAL - 323)) | (1L << (SERIALIZABLE - 323)) | (1L << (SERIALLY_REUSABLE - 323)) | (1L << (SERVERERROR - 323)) | (1L << (SESSIONTIMEZONE - 323)) | (1L << (SET - 323)) | (1L << (SETS - 323)) | (1L << (SETTINGS - 323)) | (1L << (SHOW - 323)) | (1L << (SHUTDOWN - 323)) | (1L << (SIBLINGS - 323)) | (1L << (SIGNTYPE - 323)) | (1L << (SIMPLE_INTEGER - 323)) | (1L << (SINGLE - 323)) | (1L << (SKIP_ - 323)) | (1L << (SMALLINT - 323)) | (1L << (SNAPSHOT - 323)) | (1L << (SOME - 323)) | (1L << (SPECIFICATION - 323)) | (1L << (SQLDATA - 323)) | (1L << (SQLERROR - 323)) | (1L << (STANDALONE - 323)) | (1L << (STARTUP - 323)) | (1L << (STATEMENT - 323)) | (1L << (STATEMENT_ID - 323)) | (1L << (STATIC - 323)) | (1L << (STATISTICS - 323)) | (1L << (STRING - 323)) | (1L << (SUBMULTISET - 323)) | (1L << (SUBPARTITION - 323)) | (1L << (SUBSTITUTABLE - 323)) | (1L << (SUBTYPE - 323)) | (1L << (SUCCESS - 323)) | (1L << (SUSPEND - 323)) | (1L << (TIME - 323)) | (1L << (TIMESTAMP - 323)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_UNCONSTRAINED - 323)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TIMEZONE_ABBR - 387)) | (1L << (TIMEZONE_HOUR - 387)) | (1L << (TIMEZONE_MINUTE - 387)) | (1L << (TIMEZONE_REGION - 387)) | (1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (YMINTERVAL_UNCONSTRAINED - 451)) | (1L << (ZONE - 451)) | (1L << (PREDICTION - 451)) | (1L << (PREDICTION_BOUNDS - 451)) | (1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (COVAR_ - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (REGR_ - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (TRIM - 451)) | (1L << (SUM - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (VARIANCE - 451)) | (1L << (NATIONAL_CHAR_STRING_LIT - 451)) | (1L << (CHAR_STRING - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
					{
					State = 5202; column_alias();
					}
				}

				State = 5212;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 5205; Match(COMMA);
					State = 5206; expression();
					State = 5208;
					_la = _input.La(1);
					if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << AS) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (CONSTANT - 66)) | (1L << (CONSTRAINT - 66)) | (1L << (CONSTRAINTS - 66)) | (1L << (CONSTRUCTOR - 66)) | (1L << (CONTENT - 66)) | (1L << (CONTEXT - 66)) | (1L << (CONTINUE - 66)) | (1L << (CONVERT - 66)) | (1L << (CORRUPT_XID - 66)) | (1L << (CORRUPT_XID_ALL - 66)) | (1L << (COST - 66)) | (1L << (COUNT - 66)) | (1L << (CROSS - 66)) | (1L << (CUBE - 66)) | (1L << (CURRENT_USER - 66)) | (1L << (CURSOR - 66)) | (1L << (CUSTOMDATUM - 66)) | (1L << (CYCLE - 66)) | (1L << (DATA - 66)) | (1L << (DATABASE - 66)) | (1L << (DAY - 66)) | (1L << (DB_ROLE_CHANGE - 66)) | (1L << (DBTIMEZONE - 66)) | (1L << (DDL - 66)) | (1L << (DEBUG - 66)) | (1L << (DEC - 66)) | (1L << (DECIMAL - 66)) | (1L << (DECOMPOSE - 66)) | (1L << (DECREMENT - 66)) | (1L << (DEFAULTS - 66)) | (1L << (DEFERRED - 66)) | (1L << (DEFINER - 66)) | (1L << (DETERMINISTIC - 66)) | (1L << (DIMENSION - 66)) | (1L << (DISABLE - 66)) | (1L << (DISASSOCIATE - 66)) | (1L << (DOCUMENT - 66)) | (1L << (DOUBLE - 66)) | (1L << (DSINTERVAL_UNCONSTRAINED - 66)) | (1L << (EACH - 66)) | (1L << (ELEMENT - 66)) | (1L << (EMPTY - 66)) | (1L << (ENABLE - 66)) | (1L << (ENCODING - 66)) | (1L << (ENTITYESCAPING - 66)) | (1L << (ERR - 66)) | (1L << (ERRORS - 66)) | (1L << (ESCAPE - 66)) | (1L << (EVALNAME - 66)) | (1L << (EXCEPTION - 66)) | (1L << (EXCEPTION_INIT - 66)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)) | (1L << (EXIT - 130)) | (1L << (EXPLAIN - 130)) | (1L << (EXTERNAL - 130)) | (1L << (EXTRACT - 130)) | (1L << (FAILURE - 130)) | (1L << (FINAL - 130)) | (1L << (FIRST - 130)) | (1L << (FIRST_VALUE - 130)) | (1L << (FLOAT - 130)) | (1L << (FOLLOWING - 130)) | (1L << (FOLLOWS - 130)) | (1L << (FORALL - 130)) | (1L << (FORCE - 130)) | (1L << (FULL - 130)) | (1L << (FUNCTION - 130)) | (1L << (GROUPING - 130)) | (1L << (HASH - 130)) | (1L << (HIDE - 130)) | (1L << (HOUR - 130)) | (1L << (IGNORE - 130)) | (1L << (IMMEDIATE - 130)) | (1L << (INCLUDE - 130)) | (1L << (INCLUDING - 130)) | (1L << (INCREMENT - 130)) | (1L << (INDENT - 130)) | (1L << (INDEXED - 130)) | (1L << (INDICATOR - 130)) | (1L << (INDICES - 130)) | (1L << (INFINITE - 130)) | (1L << (INLINE - 130)) | (1L << (INNER - 130)) | (1L << (INOUT - 130)) | (1L << (INSTANTIABLE - 130)) | (1L << (INSTEAD - 130)) | (1L << (INT - 130)) | (1L << (INTEGER - 130)) | (1L << (INTERVAL - 130)) | (1L << (INVALIDATE - 130)) | (1L << (ISOLATION - 130)) | (1L << (ITERATE - 130)) | (1L << (JAVA - 130)) | (1L << (JOIN - 130)) | (1L << (KEEP - 130)) | (1L << (LANGUAGE - 130)))) != 0) || ((((_la - 194)) & ~0x3f) == 0 && ((1L << (_la - 194)) & ((1L << (LAST - 194)) | (1L << (LAST_VALUE - 194)) | (1L << (LEADING - 194)) | (1L << (LEFT - 194)) | (1L << (LEVEL - 194)) | (1L << (LIBRARY - 194)) | (1L << (LIKE2 - 194)) | (1L << (LIKE4 - 194)) | (1L << (LIKEC - 194)) | (1L << (LIMIT - 194)) | (1L << (LOCAL - 194)) | (1L << (LOCKED - 194)) | (1L << (LOG - 194)) | (1L << (LOGOFF - 194)) | (1L << (LOGON - 194)) | (1L << (LONG - 194)) | (1L << (LOOP - 194)) | (1L << (MAIN - 194)) | (1L << (MAP - 194)) | (1L << (MATCHED - 194)) | (1L << (MAXVALUE - 194)) | (1L << (MEASURES - 194)) | (1L << (MEMBER - 194)) | (1L << (MERGE - 194)) | (1L << (MINUTE - 194)) | (1L << (MINVALUE - 194)) | (1L << (MLSLABEL - 194)) | (1L << (MODEL - 194)) | (1L << (MODIFY - 194)) | (1L << (MONTH - 194)) | (1L << (MULTISET - 194)) | (1L << (NAME - 194)) | (1L << (NAN - 194)) | (1L << (NATURAL - 194)) | (1L << (NATURALN - 194)) | (1L << (NAV - 194)) | (1L << (NCHAR - 194)) | (1L << (NCHAR_CS - 194)) | (1L << (NCLOB - 194)) | (1L << (NESTED - 194)) | (1L << (NEW - 194)) | (1L << (NO - 194)) | (1L << (NOAUDIT - 194)) | (1L << (NOCOPY - 194)) | (1L << (NOCYCLE - 194)) | (1L << (NOENTITYESCAPING - 194)) | (1L << (NONE - 194)) | (1L << (NOSCHEMACHECK - 194)) | (1L << (NULLS - 194)) | (1L << (NUMBER - 194)) | (1L << (NUMERIC - 194)) | (1L << (NVARCHAR2 - 194)) | (1L << (OBJECT - 194)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (OFF - 259)) | (1L << (OID - 259)) | (1L << (OLD - 259)) | (1L << (ONLY - 259)) | (1L << (OPEN - 259)) | (1L << (ORADATA - 259)) | (1L << (ORDINALITY - 259)) | (1L << (OSERROR - 259)) | (1L << (OUT - 259)) | (1L << (OUTER - 259)) | (1L << (OVER - 259)) | (1L << (OVERRIDING - 259)) | (1L << (PACKAGE - 259)) | (1L << (PARALLEL_ENABLE - 259)) | (1L << (PARAMETERS - 259)) | (1L << (PARENT - 259)) | (1L << (PARTITION - 259)) | (1L << (PASSING - 259)) | (1L << (PATH - 259)) | (1L << (PIPELINED - 259)) | (1L << (PLAN - 259)) | (1L << (PLS_INTEGER - 259)) | (1L << (POSITIVE - 259)) | (1L << (POSITIVEN - 259)) | (1L << (PRAGMA - 259)) | (1L << (PRECEDING - 259)) | (1L << (PRECISION - 259)) | (1L << (PRESENT - 259)) | (1L << (RAISE - 259)) | (1L << (RANGE - 259)) | (1L << (RAW - 259)) | (1L << (READ - 259)) | (1L << (REAL - 259)) | (1L << (RECORD - 259)) | (1L << (REF - 259)) | (1L << (REFERENCE - 259)) | (1L << (REFERENCING - 259)) | (1L << (REJECT - 259)) | (1L << (RELIES_ON - 259)) | (1L << (RENAME - 259)) | (1L << (REPLACE - 259)) | (1L << (RESPECT - 259)) | (1L << (RESTRICT_REFERENCES - 259)) | (1L << (RESULT - 259)) | (1L << (RESULT_CACHE - 259)) | (1L << (RETURN - 259)) | (1L << (RETURNING - 259)) | (1L << (REUSE - 259)) | (1L << (REVERSE - 259)) | (1L << (RIGHT - 259)))) != 0) || ((((_la - 323)) & ~0x3f) == 0 && ((1L << (_la - 323)) & ((1L << (ROLLBACK - 323)) | (1L << (ROLLUP - 323)) | (1L << (ROW - 323)) | (1L << (ROWID - 323)) | (1L << (ROWS - 323)) | (1L << (RULES - 323)) | (1L << (SAMPLE - 323)) | (1L << (SAVE - 323)) | (1L << (SAVEPOINT - 323)) | (1L << (SCHEMA - 323)) | (1L << (SCHEMACHECK - 323)) | (1L << (SCN - 323)) | (1L << (SECOND - 323)) | (1L << (SEED - 323)) | (1L << (SEGMENT - 323)) | (1L << (SELF - 323)) | (1L << (SEQUENTIAL - 323)) | (1L << (SERIALIZABLE - 323)) | (1L << (SERIALLY_REUSABLE - 323)) | (1L << (SERVERERROR - 323)) | (1L << (SESSIONTIMEZONE - 323)) | (1L << (SET - 323)) | (1L << (SETS - 323)) | (1L << (SETTINGS - 323)) | (1L << (SHOW - 323)) | (1L << (SHUTDOWN - 323)) | (1L << (SIBLINGS - 323)) | (1L << (SIGNTYPE - 323)) | (1L << (SIMPLE_INTEGER - 323)) | (1L << (SINGLE - 323)) | (1L << (SKIP_ - 323)) | (1L << (SMALLINT - 323)) | (1L << (SNAPSHOT - 323)) | (1L << (SOME - 323)) | (1L << (SPECIFICATION - 323)) | (1L << (SQLDATA - 323)) | (1L << (SQLERROR - 323)) | (1L << (STANDALONE - 323)) | (1L << (STARTUP - 323)) | (1L << (STATEMENT - 323)) | (1L << (STATEMENT_ID - 323)) | (1L << (STATIC - 323)) | (1L << (STATISTICS - 323)) | (1L << (STRING - 323)) | (1L << (SUBMULTISET - 323)) | (1L << (SUBPARTITION - 323)) | (1L << (SUBSTITUTABLE - 323)) | (1L << (SUBTYPE - 323)) | (1L << (SUCCESS - 323)) | (1L << (SUSPEND - 323)) | (1L << (TIME - 323)) | (1L << (TIMESTAMP - 323)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_UNCONSTRAINED - 323)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TIMEZONE_ABBR - 387)) | (1L << (TIMEZONE_HOUR - 387)) | (1L << (TIMEZONE_MINUTE - 387)) | (1L << (TIMEZONE_REGION - 387)) | (1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (YMINTERVAL_UNCONSTRAINED - 451)) | (1L << (ZONE - 451)) | (1L << (PREDICTION - 451)) | (1L << (PREDICTION_BOUNDS - 451)) | (1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (COVAR_ - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (REGR_ - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (TRIM - 451)) | (1L << (SUM - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (VARIANCE - 451)) | (1L << (NATIONAL_CHAR_STRING_LIT - 451)) | (1L << (CHAR_STRING - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
						{
						State = 5207; column_alias();
						}
					}

					}
					}
					State = 5214;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
				break;
			}
			State = 5217; Match(RIGHT_PAREN);
			State = 5219;
			switch ( Interpreter.AdaptivePredict(_input,685,_ctx) ) {
			case 1:
				{
				State = 5218; keep_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Respect_or_ignore_nullsContext : ParserRuleContext {
		public ITerminalNode IGNORE() { return GetToken(plsqlParser.IGNORE, 0); }
		public ITerminalNode RESPECT() { return GetToken(plsqlParser.RESPECT, 0); }
		public ITerminalNode NULLS() { return GetToken(plsqlParser.NULLS, 0); }
		public Respect_or_ignore_nullsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_respect_or_ignore_nulls; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterRespect_or_ignore_nulls(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitRespect_or_ignore_nulls(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRespect_or_ignore_nulls(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Respect_or_ignore_nullsContext respect_or_ignore_nulls() {
		Respect_or_ignore_nullsContext _localctx = new Respect_or_ignore_nullsContext(_ctx, State);
		EnterRule(_localctx, 722, RULE_respect_or_ignore_nulls);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5221;
			_la = _input.La(1);
			if ( !(_la==IGNORE || _la==RESPECT) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			State = 5222; Match(NULLS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ArgumentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_argument; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterArgument(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitArgument(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArgument(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentContext argument() {
		ArgumentContext _localctx = new ArgumentContext(_ctx, State);
		EnterRule(_localctx, 724, RULE_argument);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5228;
			switch ( Interpreter.AdaptivePredict(_input,686,_ctx) ) {
			case 1:
				{
				State = 5224; identifier();
				State = 5225; Match(EQUALS_OP);
				State = 5226; Match(GREATER_THAN_OP);
				}
				break;
			}
			State = 5230; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Type_specContext : ParserRuleContext {
		public Type_nameContext type_name() {
			return GetRuleContext<Type_nameContext>(0);
		}
		public ITerminalNode PERCENT_ROWTYPE() { return GetToken(plsqlParser.PERCENT_ROWTYPE, 0); }
		public ITerminalNode REF() { return GetToken(plsqlParser.REF, 0); }
		public DatatypeContext datatype() {
			return GetRuleContext<DatatypeContext>(0);
		}
		public ITerminalNode PERCENT_TYPE() { return GetToken(plsqlParser.PERCENT_TYPE, 0); }
		public Type_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterType_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitType_spec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Type_specContext type_spec() {
		Type_specContext _localctx = new Type_specContext(_ctx, State);
		EnterRule(_localctx, 726, RULE_type_spec);
		int _la;
		try {
			State = 5240;
			switch ( Interpreter.AdaptivePredict(_input,689,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5232; datatype();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5234;
				switch ( Interpreter.AdaptivePredict(_input,687,_ctx) ) {
				case 1:
					{
					State = 5233; Match(REF);
					}
					break;
				}
				State = 5236; type_name();
				State = 5238;
				_la = _input.La(1);
				if (_la==PERCENT_ROWTYPE || _la==PERCENT_TYPE) {
					{
					State = 5237;
					_la = _input.La(1);
					if ( !(_la==PERCENT_ROWTYPE || _la==PERCENT_TYPE) ) {
					_errHandler.RecoverInline(this);
					}
					Consume();
					}
				}

				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DatatypeContext : ParserRuleContext {
		public ITerminalNode ZONE() { return GetToken(plsqlParser.ZONE, 0); }
		public ITerminalNode WITH() { return GetToken(plsqlParser.WITH, 0); }
		public ITerminalNode TIME() { return GetToken(plsqlParser.TIME, 0); }
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode TO() { return GetToken(plsqlParser.TO, 0); }
		public Precision_partContext precision_part() {
			return GetRuleContext<Precision_partContext>(0);
		}
		public Native_datatype_elementContext native_datatype_element() {
			return GetRuleContext<Native_datatype_elementContext>(0);
		}
		public ITerminalNode SECOND() { return GetToken(plsqlParser.SECOND, 0); }
		public ITerminalNode INTERVAL() { return GetToken(plsqlParser.INTERVAL, 0); }
		public ITerminalNode LOCAL() { return GetToken(plsqlParser.LOCAL, 0); }
		public ITerminalNode MONTH() { return GetToken(plsqlParser.MONTH, 0); }
		public ITerminalNode DAY() { return GetToken(plsqlParser.DAY, 0); }
		public IReadOnlyList<ExpressionContext> expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ITerminalNode YEAR() { return GetToken(plsqlParser.YEAR, 0); }
		public DatatypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_datatype; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterDatatype(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitDatatype(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDatatype(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DatatypeContext datatype() {
		DatatypeContext _localctx = new DatatypeContext(_ctx, State);
		EnterRule(_localctx, 728, RULE_datatype);
		int _la;
		try {
			State = 5270;
			switch (_input.La(1)) {
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BOOLEAN:
			case CHAR:
			case CHARACTER:
			case CLOB:
			case DATE:
			case DAY:
			case DEC:
			case DECIMAL:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case FLOAT:
			case HOUR:
			case INT:
			case INTEGER:
			case LONG:
			case MINUTE:
			case MLSLABEL:
			case MONTH:
			case NATURAL:
			case NATURALN:
			case NCHAR:
			case NCLOB:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case RAW:
			case REAL:
			case ROWID:
			case SECOND:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SMALLINT:
			case STRING:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case UROWID:
			case VARCHAR:
			case VARCHAR2:
			case YEAR:
			case YMINTERVAL_UNCONSTRAINED:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5242; native_datatype_element();
				State = 5244;
				switch ( Interpreter.AdaptivePredict(_input,690,_ctx) ) {
				case 1:
					{
					State = 5243; precision_part();
					}
					break;
				}
				State = 5252;
				_la = _input.La(1);
				if (_la==WITH) {
					{
					State = 5246; Match(WITH);
					State = 5248;
					_la = _input.La(1);
					if (_la==LOCAL) {
						{
						State = 5247; Match(LOCAL);
						}
					}

					State = 5250; Match(TIME);
					State = 5251; Match(ZONE);
					}
				}

				}
				break;
			case INTERVAL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5254; Match(INTERVAL);
				State = 5255;
				_la = _input.La(1);
				if ( !(_la==DAY || _la==YEAR) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				State = 5260;
				_la = _input.La(1);
				if (_la==LEFT_PAREN) {
					{
					State = 5256; Match(LEFT_PAREN);
					State = 5257; expression();
					State = 5258; Match(RIGHT_PAREN);
					}
				}

				State = 5262; Match(TO);
				State = 5263;
				_la = _input.La(1);
				if ( !(_la==MONTH || _la==SECOND) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				State = 5268;
				switch ( Interpreter.AdaptivePredict(_input,694,_ctx) ) {
				case 1:
					{
					State = 5264; Match(LEFT_PAREN);
					State = 5265; expression();
					State = 5266; Match(RIGHT_PAREN);
					}
					break;
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Precision_partContext : ParserRuleContext {
		public IReadOnlyList<NumericContext> numeric() {
			return GetRuleContexts<NumericContext>();
		}
		public NumericContext numeric(int i) {
			return GetRuleContext<NumericContext>(i);
		}
		public ITerminalNode BYTE() { return GetToken(plsqlParser.BYTE, 0); }
		public ITerminalNode CHAR() { return GetToken(plsqlParser.CHAR, 0); }
		public Precision_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_precision_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterPrecision_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitPrecision_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrecision_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Precision_partContext precision_part() {
		Precision_partContext _localctx = new Precision_partContext(_ctx, State);
		EnterRule(_localctx, 730, RULE_precision_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5272; Match(LEFT_PAREN);
			State = 5273; numeric();
			State = 5276;
			_la = _input.La(1);
			if (_la==COMMA) {
				{
				State = 5274; Match(COMMA);
				State = 5275; numeric();
				}
			}

			State = 5279;
			_la = _input.La(1);
			if (_la==BYTE || _la==CHAR) {
				{
				State = 5278;
				_la = _input.La(1);
				if ( !(_la==BYTE || _la==CHAR) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				}
			}

			State = 5281; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Native_datatype_elementContext : ParserRuleContext {
		public ITerminalNode DECIMAL() { return GetToken(plsqlParser.DECIMAL, 0); }
		public ITerminalNode MINUTE() { return GetToken(plsqlParser.MINUTE, 0); }
		public ITerminalNode INTEGER() { return GetToken(plsqlParser.INTEGER, 0); }
		public ITerminalNode BINARY_FLOAT() { return GetToken(plsqlParser.BINARY_FLOAT, 0); }
		public ITerminalNode DSINTERVAL_UNCONSTRAINED() { return GetToken(plsqlParser.DSINTERVAL_UNCONSTRAINED, 0); }
		public ITerminalNode NATURAL() { return GetToken(plsqlParser.NATURAL, 0); }
		public ITerminalNode TIMESTAMP_UNCONSTRAINED() { return GetToken(plsqlParser.TIMESTAMP_UNCONSTRAINED, 0); }
		public ITerminalNode HOUR() { return GetToken(plsqlParser.HOUR, 0); }
		public ITerminalNode POSITIVEN() { return GetToken(plsqlParser.POSITIVEN, 0); }
		public ITerminalNode NVARCHAR2() { return GetToken(plsqlParser.NVARCHAR2, 0); }
		public ITerminalNode DEC() { return GetToken(plsqlParser.DEC, 0); }
		public ITerminalNode SIMPLE_INTEGER() { return GetToken(plsqlParser.SIMPLE_INTEGER, 0); }
		public ITerminalNode PRECISION() { return GetToken(plsqlParser.PRECISION, 0); }
		public ITerminalNode NATURALN() { return GetToken(plsqlParser.NATURALN, 0); }
		public ITerminalNode SIGNTYPE() { return GetToken(plsqlParser.SIGNTYPE, 0); }
		public ITerminalNode PLS_INTEGER() { return GetToken(plsqlParser.PLS_INTEGER, 0); }
		public ITerminalNode NCLOB() { return GetToken(plsqlParser.NCLOB, 0); }
		public ITerminalNode STRING() { return GetToken(plsqlParser.STRING, 0); }
		public ITerminalNode BINARY_DOUBLE() { return GetToken(plsqlParser.BINARY_DOUBLE, 0); }
		public ITerminalNode DOUBLE() { return GetToken(plsqlParser.DOUBLE, 0); }
		public ITerminalNode VARCHAR() { return GetToken(plsqlParser.VARCHAR, 0); }
		public ITerminalNode TIMESTAMP_TZ_UNCONSTRAINED() { return GetToken(plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED, 0); }
		public ITerminalNode FLOAT() { return GetToken(plsqlParser.FLOAT, 0); }
		public ITerminalNode NUMERIC() { return GetToken(plsqlParser.NUMERIC, 0); }
		public ITerminalNode VARCHAR2() { return GetToken(plsqlParser.VARCHAR2, 0); }
		public ITerminalNode TIMEZONE_MINUTE() { return GetToken(plsqlParser.TIMEZONE_MINUTE, 0); }
		public ITerminalNode NUMBER() { return GetToken(plsqlParser.NUMBER, 0); }
		public ITerminalNode DATE() { return GetToken(plsqlParser.DATE, 0); }
		public ITerminalNode POSITIVE() { return GetToken(plsqlParser.POSITIVE, 0); }
		public ITerminalNode REAL() { return GetToken(plsqlParser.REAL, 0); }
		public ITerminalNode TIMESTAMP_LTZ_UNCONSTRAINED() { return GetToken(plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED, 0); }
		public ITerminalNode CLOB() { return GetToken(plsqlParser.CLOB, 0); }
		public ITerminalNode RAW() { return GetToken(plsqlParser.RAW, 0); }
		public ITerminalNode TIMEZONE_REGION() { return GetToken(plsqlParser.TIMEZONE_REGION, 0); }
		public ITerminalNode INT() { return GetToken(plsqlParser.INT, 0); }
		public ITerminalNode TIMEZONE_HOUR() { return GetToken(plsqlParser.TIMEZONE_HOUR, 0); }
		public ITerminalNode BFILE() { return GetToken(plsqlParser.BFILE, 0); }
		public ITerminalNode YMINTERVAL_UNCONSTRAINED() { return GetToken(plsqlParser.YMINTERVAL_UNCONSTRAINED, 0); }
		public ITerminalNode CHARACTER() { return GetToken(plsqlParser.CHARACTER, 0); }
		public ITerminalNode TIMEZONE_ABBR() { return GetToken(plsqlParser.TIMEZONE_ABBR, 0); }
		public ITerminalNode MONTH() { return GetToken(plsqlParser.MONTH, 0); }
		public ITerminalNode CHAR() { return GetToken(plsqlParser.CHAR, 0); }
		public ITerminalNode DAY() { return GetToken(plsqlParser.DAY, 0); }
		public ITerminalNode NCHAR() { return GetToken(plsqlParser.NCHAR, 0); }
		public ITerminalNode YEAR() { return GetToken(plsqlParser.YEAR, 0); }
		public ITerminalNode SMALLINT() { return GetToken(plsqlParser.SMALLINT, 0); }
		public ITerminalNode UROWID() { return GetToken(plsqlParser.UROWID, 0); }
		public ITerminalNode BOOLEAN() { return GetToken(plsqlParser.BOOLEAN, 0); }
		public ITerminalNode ROWID() { return GetToken(plsqlParser.ROWID, 0); }
		public ITerminalNode BINARY_INTEGER() { return GetToken(plsqlParser.BINARY_INTEGER, 0); }
		public ITerminalNode LONG() { return GetToken(plsqlParser.LONG, 0); }
		public ITerminalNode TIMESTAMP() { return GetToken(plsqlParser.TIMESTAMP, 0); }
		public ITerminalNode BLOB() { return GetToken(plsqlParser.BLOB, 0); }
		public ITerminalNode SECOND() { return GetToken(plsqlParser.SECOND, 0); }
		public ITerminalNode MLSLABEL() { return GetToken(plsqlParser.MLSLABEL, 0); }
		public Native_datatype_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_native_datatype_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterNative_datatype_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitNative_datatype_element(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNative_datatype_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Native_datatype_elementContext native_datatype_element() {
		Native_datatype_elementContext _localctx = new Native_datatype_elementContext(_ctx, State);
		EnterRule(_localctx, 732, RULE_native_datatype_element);
		int _la;
		try {
			State = 5343;
			switch (_input.La(1)) {
			case BINARY_INTEGER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5283; Match(BINARY_INTEGER);
				}
				break;
			case PLS_INTEGER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5284; Match(PLS_INTEGER);
				}
				break;
			case NATURAL:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5285; Match(NATURAL);
				}
				break;
			case BINARY_FLOAT:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5286; Match(BINARY_FLOAT);
				}
				break;
			case BINARY_DOUBLE:
				EnterOuterAlt(_localctx, 5);
				{
				State = 5287; Match(BINARY_DOUBLE);
				}
				break;
			case NATURALN:
				EnterOuterAlt(_localctx, 6);
				{
				State = 5288; Match(NATURALN);
				}
				break;
			case POSITIVE:
				EnterOuterAlt(_localctx, 7);
				{
				State = 5289; Match(POSITIVE);
				}
				break;
			case POSITIVEN:
				EnterOuterAlt(_localctx, 8);
				{
				State = 5290; Match(POSITIVEN);
				}
				break;
			case SIGNTYPE:
				EnterOuterAlt(_localctx, 9);
				{
				State = 5291; Match(SIGNTYPE);
				}
				break;
			case SIMPLE_INTEGER:
				EnterOuterAlt(_localctx, 10);
				{
				State = 5292; Match(SIMPLE_INTEGER);
				}
				break;
			case NVARCHAR2:
				EnterOuterAlt(_localctx, 11);
				{
				State = 5293; Match(NVARCHAR2);
				}
				break;
			case DEC:
				EnterOuterAlt(_localctx, 12);
				{
				State = 5294; Match(DEC);
				}
				break;
			case INTEGER:
				EnterOuterAlt(_localctx, 13);
				{
				State = 5295; Match(INTEGER);
				}
				break;
			case INT:
				EnterOuterAlt(_localctx, 14);
				{
				State = 5296; Match(INT);
				}
				break;
			case NUMERIC:
				EnterOuterAlt(_localctx, 15);
				{
				State = 5297; Match(NUMERIC);
				}
				break;
			case SMALLINT:
				EnterOuterAlt(_localctx, 16);
				{
				State = 5298; Match(SMALLINT);
				}
				break;
			case NUMBER:
				EnterOuterAlt(_localctx, 17);
				{
				State = 5299; Match(NUMBER);
				}
				break;
			case DECIMAL:
				EnterOuterAlt(_localctx, 18);
				{
				State = 5300; Match(DECIMAL);
				}
				break;
			case DOUBLE:
				EnterOuterAlt(_localctx, 19);
				{
				State = 5301; Match(DOUBLE);
				State = 5303;
				_la = _input.La(1);
				if (_la==PRECISION) {
					{
					State = 5302; Match(PRECISION);
					}
				}

				}
				break;
			case FLOAT:
				EnterOuterAlt(_localctx, 20);
				{
				State = 5305; Match(FLOAT);
				}
				break;
			case REAL:
				EnterOuterAlt(_localctx, 21);
				{
				State = 5306; Match(REAL);
				}
				break;
			case NCHAR:
				EnterOuterAlt(_localctx, 22);
				{
				State = 5307; Match(NCHAR);
				}
				break;
			case LONG:
				EnterOuterAlt(_localctx, 23);
				{
				State = 5308; Match(LONG);
				State = 5310;
				_la = _input.La(1);
				if (_la==RAW) {
					{
					State = 5309; Match(RAW);
					}
				}

				}
				break;
			case CHAR:
				EnterOuterAlt(_localctx, 24);
				{
				State = 5312; Match(CHAR);
				}
				break;
			case CHARACTER:
				EnterOuterAlt(_localctx, 25);
				{
				State = 5313; Match(CHARACTER);
				}
				break;
			case VARCHAR2:
				EnterOuterAlt(_localctx, 26);
				{
				State = 5314; Match(VARCHAR2);
				}
				break;
			case VARCHAR:
				EnterOuterAlt(_localctx, 27);
				{
				State = 5315; Match(VARCHAR);
				}
				break;
			case STRING:
				EnterOuterAlt(_localctx, 28);
				{
				State = 5316; Match(STRING);
				}
				break;
			case RAW:
				EnterOuterAlt(_localctx, 29);
				{
				State = 5317; Match(RAW);
				}
				break;
			case BOOLEAN:
				EnterOuterAlt(_localctx, 30);
				{
				State = 5318; Match(BOOLEAN);
				}
				break;
			case DATE:
				EnterOuterAlt(_localctx, 31);
				{
				State = 5319; Match(DATE);
				}
				break;
			case ROWID:
				EnterOuterAlt(_localctx, 32);
				{
				State = 5320; Match(ROWID);
				}
				break;
			case UROWID:
				EnterOuterAlt(_localctx, 33);
				{
				State = 5321; Match(UROWID);
				}
				break;
			case YEAR:
				EnterOuterAlt(_localctx, 34);
				{
				State = 5322; Match(YEAR);
				}
				break;
			case MONTH:
				EnterOuterAlt(_localctx, 35);
				{
				State = 5323; Match(MONTH);
				}
				break;
			case DAY:
				EnterOuterAlt(_localctx, 36);
				{
				State = 5324; Match(DAY);
				}
				break;
			case HOUR:
				EnterOuterAlt(_localctx, 37);
				{
				State = 5325; Match(HOUR);
				}
				break;
			case MINUTE:
				EnterOuterAlt(_localctx, 38);
				{
				State = 5326; Match(MINUTE);
				}
				break;
			case SECOND:
				EnterOuterAlt(_localctx, 39);
				{
				State = 5327; Match(SECOND);
				}
				break;
			case TIMEZONE_HOUR:
				EnterOuterAlt(_localctx, 40);
				{
				State = 5328; Match(TIMEZONE_HOUR);
				}
				break;
			case TIMEZONE_MINUTE:
				EnterOuterAlt(_localctx, 41);
				{
				State = 5329; Match(TIMEZONE_MINUTE);
				}
				break;
			case TIMEZONE_REGION:
				EnterOuterAlt(_localctx, 42);
				{
				State = 5330; Match(TIMEZONE_REGION);
				}
				break;
			case TIMEZONE_ABBR:
				EnterOuterAlt(_localctx, 43);
				{
				State = 5331; Match(TIMEZONE_ABBR);
				}
				break;
			case TIMESTAMP:
				EnterOuterAlt(_localctx, 44);
				{
				State = 5332; Match(TIMESTAMP);
				}
				break;
			case TIMESTAMP_UNCONSTRAINED:
				EnterOuterAlt(_localctx, 45);
				{
				State = 5333; Match(TIMESTAMP_UNCONSTRAINED);
				}
				break;
			case TIMESTAMP_TZ_UNCONSTRAINED:
				EnterOuterAlt(_localctx, 46);
				{
				State = 5334; Match(TIMESTAMP_TZ_UNCONSTRAINED);
				}
				break;
			case TIMESTAMP_LTZ_UNCONSTRAINED:
				EnterOuterAlt(_localctx, 47);
				{
				State = 5335; Match(TIMESTAMP_LTZ_UNCONSTRAINED);
				}
				break;
			case YMINTERVAL_UNCONSTRAINED:
				EnterOuterAlt(_localctx, 48);
				{
				State = 5336; Match(YMINTERVAL_UNCONSTRAINED);
				}
				break;
			case DSINTERVAL_UNCONSTRAINED:
				EnterOuterAlt(_localctx, 49);
				{
				State = 5337; Match(DSINTERVAL_UNCONSTRAINED);
				}
				break;
			case BFILE:
				EnterOuterAlt(_localctx, 50);
				{
				State = 5338; Match(BFILE);
				}
				break;
			case BLOB:
				EnterOuterAlt(_localctx, 51);
				{
				State = 5339; Match(BLOB);
				}
				break;
			case CLOB:
				EnterOuterAlt(_localctx, 52);
				{
				State = 5340; Match(CLOB);
				}
				break;
			case NCLOB:
				EnterOuterAlt(_localctx, 53);
				{
				State = 5341; Match(NCLOB);
				}
				break;
			case MLSLABEL:
				EnterOuterAlt(_localctx, 54);
				{
				State = 5342; Match(MLSLABEL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Bind_variableContext : ParserRuleContext {
		public IReadOnlyList<ITerminalNode> UNSIGNED_INTEGER() { return GetTokens(plsqlParser.UNSIGNED_INTEGER); }
		public ITerminalNode BINDVAR(int i) {
			return GetToken(plsqlParser.BINDVAR, i);
		}
		public IReadOnlyList<General_element_partContext> general_element_part() {
			return GetRuleContexts<General_element_partContext>();
		}
		public IReadOnlyList<ITerminalNode> BINDVAR() { return GetTokens(plsqlParser.BINDVAR); }
		public ITerminalNode UNSIGNED_INTEGER(int i) {
			return GetToken(plsqlParser.UNSIGNED_INTEGER, i);
		}
		public General_element_partContext general_element_part(int i) {
			return GetRuleContext<General_element_partContext>(i);
		}
		public ITerminalNode INDICATOR() { return GetToken(plsqlParser.INDICATOR, 0); }
		public Bind_variableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bind_variable; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterBind_variable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitBind_variable(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBind_variable(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Bind_variableContext bind_variable() {
		Bind_variableContext _localctx = new Bind_variableContext(_ctx, State);
		EnterRule(_localctx, 734, RULE_bind_variable);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 5348;
			switch (_input.La(1)) {
			case BINDVAR:
				{
				State = 5345; Match(BINDVAR);
				}
				break;
			case COLON:
				{
				State = 5346; Match(COLON);
				State = 5347; Match(UNSIGNED_INTEGER);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 5358;
			switch ( Interpreter.AdaptivePredict(_input,704,_ctx) ) {
			case 1:
				{
				State = 5351;
				_la = _input.La(1);
				if (_la==INDICATOR) {
					{
					State = 5350; Match(INDICATOR);
					}
				}

				State = 5356;
				switch (_input.La(1)) {
				case BINDVAR:
					{
					State = 5353; Match(BINDVAR);
					}
					break;
				case COLON:
					{
					State = 5354; Match(COLON);
					State = 5355; Match(UNSIGNED_INTEGER);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			}
			State = 5364;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,705,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 5360; Match(PERIOD);
					State = 5361; general_element_part();
					}
					} 
				}
				State = 5366;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,705,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class General_elementContext : ParserRuleContext {
		public IReadOnlyList<General_element_partContext> general_element_part() {
			return GetRuleContexts<General_element_partContext>();
		}
		public General_element_partContext general_element_part(int i) {
			return GetRuleContext<General_element_partContext>(i);
		}
		public General_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_general_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterGeneral_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitGeneral_element(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGeneral_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public General_elementContext general_element() {
		General_elementContext _localctx = new General_elementContext(_ctx, State);
		EnterRule(_localctx, 736, RULE_general_element);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 5367; general_element_part();
			State = 5372;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,706,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 5368; Match(PERIOD);
					State = 5369; general_element_part();
					}
					} 
				}
				State = 5374;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,706,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class General_element_partContext : ParserRuleContext {
		public IReadOnlyList<Id_expressionContext> id_expression() {
			return GetRuleContexts<Id_expressionContext>();
		}
		public Id_expressionContext id_expression(int i) {
			return GetRuleContext<Id_expressionContext>(i);
		}
		public Char_set_nameContext char_set_name() {
			return GetRuleContext<Char_set_nameContext>(0);
		}
		public Function_argumentContext function_argument() {
			return GetRuleContext<Function_argumentContext>(0);
		}
		public ITerminalNode INTRODUCER() { return GetToken(plsqlParser.INTRODUCER, 0); }
		public General_element_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_general_element_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterGeneral_element_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitGeneral_element_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGeneral_element_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public General_element_partContext general_element_part() {
		General_element_partContext _localctx = new General_element_partContext(_ctx, State);
		EnterRule(_localctx, 738, RULE_general_element_part);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 5377;
			_la = _input.La(1);
			if (_la==INTRODUCER) {
				{
				State = 5375; Match(INTRODUCER);
				State = 5376; char_set_name();
				}
			}

			State = 5379; id_expression();
			State = 5384;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,708,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 5380; Match(PERIOD);
					State = 5381; id_expression();
					}
					} 
				}
				State = 5386;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,708,_ctx);
			}
			State = 5388;
			switch ( Interpreter.AdaptivePredict(_input,709,_ctx) ) {
			case 1:
				{
				State = 5387; function_argument();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_elementContext : ParserRuleContext {
		public IReadOnlyList<Id_expressionContext> id_expression() {
			return GetRuleContexts<Id_expressionContext>();
		}
		public Id_expressionContext id_expression(int i) {
			return GetRuleContext<Id_expressionContext>(i);
		}
		public Char_set_nameContext char_set_name() {
			return GetRuleContext<Char_set_nameContext>(0);
		}
		public ITerminalNode INTRODUCER() { return GetToken(plsqlParser.INTRODUCER, 0); }
		public Table_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterTable_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitTable_element(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTable_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Table_elementContext table_element() {
		Table_elementContext _localctx = new Table_elementContext(_ctx, State);
		EnterRule(_localctx, 740, RULE_table_element);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5392;
			_la = _input.La(1);
			if (_la==INTRODUCER) {
				{
				State = 5390; Match(INTRODUCER);
				State = 5391; char_set_name();
				}
			}

			State = 5394; id_expression();
			State = 5399;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==PERIOD) {
				{
				{
				State = 5395; Match(PERIOD);
				State = 5396; id_expression();
				}
				}
				State = 5401;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstantContext : ParserRuleContext {
		public ITerminalNode AT() { return GetToken(plsqlParser.AT, 0); }
		public ITerminalNode ZONE() { return GetToken(plsqlParser.ZONE, 0); }
		public IReadOnlyList<Bind_variableContext> bind_variable() {
			return GetRuleContexts<Bind_variableContext>();
		}
		public IReadOnlyList<ITerminalNode> MINUTE() { return GetTokens(plsqlParser.MINUTE); }
		public ITerminalNode FALSE() { return GetToken(plsqlParser.FALSE, 0); }
		public ITerminalNode TIME() { return GetToken(plsqlParser.TIME, 0); }
		public ITerminalNode HOUR(int i) {
			return GetToken(plsqlParser.HOUR, i);
		}
		public ITerminalNode UNSIGNED_INTEGER(int i) {
			return GetToken(plsqlParser.UNSIGNED_INTEGER, i);
		}
		public ITerminalNode TO() { return GetToken(plsqlParser.TO, 0); }
		public IReadOnlyList<ITerminalNode> HOUR() { return GetTokens(plsqlParser.HOUR); }
		public ITerminalNode MAXVALUE() { return GetToken(plsqlParser.MAXVALUE, 0); }
		public IReadOnlyList<ITerminalNode> UNSIGNED_INTEGER() { return GetTokens(plsqlParser.UNSIGNED_INTEGER); }
		public ITerminalNode NULL() { return GetToken(plsqlParser.NULL, 0); }
		public ITerminalNode DBTIMEZONE() { return GetToken(plsqlParser.DBTIMEZONE, 0); }
		public IReadOnlyList<ITerminalNode> DAY() { return GetTokens(plsqlParser.DAY); }
		public ITerminalNode DEFAULT() { return GetToken(plsqlParser.DEFAULT, 0); }
		public General_element_partContext general_element_part() {
			return GetRuleContext<General_element_partContext>(0);
		}
		public ITerminalNode TRUE() { return GetToken(plsqlParser.TRUE, 0); }
		public IReadOnlyList<Quoted_stringContext> quoted_string() {
			return GetRuleContexts<Quoted_stringContext>();
		}
		public ITerminalNode SECOND(int i) {
			return GetToken(plsqlParser.SECOND, i);
		}
		public ITerminalNode DAY(int i) {
			return GetToken(plsqlParser.DAY, i);
		}
		public Bind_variableContext bind_variable(int i) {
			return GetRuleContext<Bind_variableContext>(i);
		}
		public NumericContext numeric() {
			return GetRuleContext<NumericContext>(0);
		}
		public ITerminalNode TIMESTAMP() { return GetToken(plsqlParser.TIMESTAMP, 0); }
		public ITerminalNode SESSIONTIMEZONE() { return GetToken(plsqlParser.SESSIONTIMEZONE, 0); }
		public Quoted_stringContext quoted_string(int i) {
			return GetRuleContext<Quoted_stringContext>(i);
		}
		public ITerminalNode MINUTE(int i) {
			return GetToken(plsqlParser.MINUTE, i);
		}
		public IReadOnlyList<ITerminalNode> SECOND() { return GetTokens(plsqlParser.SECOND); }
		public ITerminalNode INTERVAL() { return GetToken(plsqlParser.INTERVAL, 0); }
		public ITerminalNode MINVALUE() { return GetToken(plsqlParser.MINVALUE, 0); }
		public ITerminalNode DATE() { return GetToken(plsqlParser.DATE, 0); }
		public ConstantContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constant; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterConstant(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitConstant(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstant(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConstantContext constant() {
		ConstantContext _localctx = new ConstantContext(_ctx, State);
		EnterRule(_localctx, 742, RULE_constant);
		int _la;
		try {
			State = 5464;
			switch (_input.La(1)) {
			case TIMESTAMP:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5402; Match(TIMESTAMP);
				State = 5405;
				switch (_input.La(1)) {
				case NATIONAL_CHAR_STRING_LIT:
				case CHAR_STRING:
					{
					State = 5403; quoted_string();
					}
					break;
				case BINDVAR:
				case COLON:
					{
					State = 5404; bind_variable();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 5411;
				switch ( Interpreter.AdaptivePredict(_input,713,_ctx) ) {
				case 1:
					{
					State = 5407; Match(AT);
					State = 5408; Match(TIME);
					State = 5409; Match(ZONE);
					State = 5410; quoted_string();
					}
					break;
				}
				}
				break;
			case INTERVAL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5413; Match(INTERVAL);
				State = 5417;
				switch (_input.La(1)) {
				case NATIONAL_CHAR_STRING_LIT:
				case CHAR_STRING:
					{
					State = 5414; quoted_string();
					}
					break;
				case BINDVAR:
				case COLON:
					{
					State = 5415; bind_variable();
					}
					break;
				case A_LETTER:
				case ADD:
				case AFTER:
				case AGENT:
				case AGGREGATE:
				case ANALYZE:
				case ARRAY:
				case ASSOCIATE:
				case AT:
				case ATTRIBUTE:
				case AUDIT:
				case AUTHID:
				case AUTO:
				case AUTOMATIC:
				case AUTONOMOUS_TRANSACTION:
				case BATCH:
				case BEFORE:
				case BFILE:
				case BINARY_DOUBLE:
				case BINARY_FLOAT:
				case BINARY_INTEGER:
				case BLOB:
				case BLOCK:
				case BODY:
				case BOOLEAN:
				case BOTH:
				case BULK:
				case BYTE:
				case C_LETTER:
				case CALL:
				case CANONICAL:
				case CASCADE:
				case CAST:
				case CHAR:
				case CHAR_CS:
				case CHARACTER:
				case CHR:
				case CLOB:
				case CLOSE:
				case CLUSTER:
				case COLLECT:
				case COLUMNS:
				case COMMENT:
				case COMMIT:
				case COMMITTED:
				case COMPATIBILITY:
				case COMPILE:
				case COMPOUND:
				case CONSTANT:
				case CONSTRAINT:
				case CONSTRAINTS:
				case CONSTRUCTOR:
				case CONTENT:
				case CONTEXT:
				case CONTINUE:
				case CONVERT:
				case CORRUPT_XID:
				case CORRUPT_XID_ALL:
				case COST:
				case COUNT:
				case CROSS:
				case CUBE:
				case CURRENT_USER:
				case CURSOR:
				case CUSTOMDATUM:
				case CYCLE:
				case DATA:
				case DATABASE:
				case DAY:
				case DB_ROLE_CHANGE:
				case DBTIMEZONE:
				case DDL:
				case DEBUG:
				case DEC:
				case DECIMAL:
				case DECOMPOSE:
				case DECREMENT:
				case DEFAULTS:
				case DEFERRED:
				case DEFINER:
				case DETERMINISTIC:
				case DIMENSION:
				case DISABLE:
				case DISASSOCIATE:
				case DOCUMENT:
				case DOUBLE:
				case DSINTERVAL_UNCONSTRAINED:
				case EACH:
				case ELEMENT:
				case EMPTY:
				case ENABLE:
				case ENCODING:
				case ENTITYESCAPING:
				case ERR:
				case ERRORS:
				case ESCAPE:
				case EVALNAME:
				case EXCEPTION:
				case EXCEPTION_INIT:
				case EXCEPTIONS:
				case EXCLUDE:
				case EXECUTE:
				case EXIT:
				case EXPLAIN:
				case EXTERNAL:
				case EXTRACT:
				case FAILURE:
				case FINAL:
				case FIRST:
				case FIRST_VALUE:
				case FLOAT:
				case FOLLOWING:
				case FOLLOWS:
				case FORALL:
				case FORCE:
				case FULL:
				case FUNCTION:
				case GROUPING:
				case HASH:
				case HIDE:
				case HOUR:
				case IGNORE:
				case IMMEDIATE:
				case INCLUDE:
				case INCLUDING:
				case INCREMENT:
				case INDENT:
				case INDEXED:
				case INDICATOR:
				case INDICES:
				case INFINITE:
				case INLINE:
				case INNER:
				case INOUT:
				case INSTANTIABLE:
				case INSTEAD:
				case INT:
				case INTEGER:
				case INTERVAL:
				case INVALIDATE:
				case ISOLATION:
				case ITERATE:
				case JAVA:
				case JOIN:
				case KEEP:
				case LANGUAGE:
				case LAST:
				case LAST_VALUE:
				case LEADING:
				case LEFT:
				case LEVEL:
				case LIBRARY:
				case LIKE2:
				case LIKE4:
				case LIKEC:
				case LIMIT:
				case LOCAL:
				case LOCKED:
				case LOG:
				case LOGOFF:
				case LOGON:
				case LONG:
				case LOOP:
				case MAIN:
				case MAP:
				case MATCHED:
				case MAXVALUE:
				case MEASURES:
				case MEMBER:
				case MERGE:
				case MINUTE:
				case MINVALUE:
				case MLSLABEL:
				case MODEL:
				case MODIFY:
				case MONTH:
				case MULTISET:
				case NAME:
				case NAN:
				case NATURAL:
				case NATURALN:
				case NAV:
				case NCHAR:
				case NCHAR_CS:
				case NCLOB:
				case NESTED:
				case NEW:
				case NO:
				case NOAUDIT:
				case NOCOPY:
				case NOCYCLE:
				case NOENTITYESCAPING:
				case NONE:
				case NOSCHEMACHECK:
				case NULLS:
				case NUMBER:
				case NUMERIC:
				case NVARCHAR2:
				case OBJECT:
				case OFF:
				case OID:
				case OLD:
				case ONLY:
				case OPEN:
				case ORADATA:
				case ORDINALITY:
				case OSERROR:
				case OUT:
				case OUTER:
				case OVER:
				case OVERRIDING:
				case PACKAGE:
				case PARALLEL_ENABLE:
				case PARAMETERS:
				case PARENT:
				case PARTITION:
				case PASSING:
				case PATH:
				case PIPELINED:
				case PLAN:
				case PLS_INTEGER:
				case POSITIVE:
				case POSITIVEN:
				case PRAGMA:
				case PRECEDING:
				case PRECISION:
				case PRESENT:
				case RAISE:
				case RANGE:
				case RAW:
				case READ:
				case REAL:
				case RECORD:
				case REF:
				case REFERENCE:
				case REFERENCING:
				case REJECT:
				case RELIES_ON:
				case RENAME:
				case REPLACE:
				case RESPECT:
				case RESTRICT_REFERENCES:
				case RESULT:
				case RESULT_CACHE:
				case RETURN:
				case RETURNING:
				case REUSE:
				case REVERSE:
				case RIGHT:
				case ROLLBACK:
				case ROLLUP:
				case ROW:
				case ROWID:
				case ROWS:
				case RULES:
				case SAMPLE:
				case SAVE:
				case SAVEPOINT:
				case SCHEMA:
				case SCHEMACHECK:
				case SCN:
				case SECOND:
				case SEED:
				case SEGMENT:
				case SELF:
				case SEQUENTIAL:
				case SERIALIZABLE:
				case SERIALLY_REUSABLE:
				case SERVERERROR:
				case SESSIONTIMEZONE:
				case SET:
				case SETS:
				case SETTINGS:
				case SHOW:
				case SHUTDOWN:
				case SIBLINGS:
				case SIGNTYPE:
				case SIMPLE_INTEGER:
				case SINGLE:
				case SKIP_:
				case SMALLINT:
				case SNAPSHOT:
				case SOME:
				case SPECIFICATION:
				case SQLDATA:
				case SQLERROR:
				case STANDALONE:
				case STARTUP:
				case STATEMENT:
				case STATEMENT_ID:
				case STATIC:
				case STATISTICS:
				case STRING:
				case SUBMULTISET:
				case SUBPARTITION:
				case SUBSTITUTABLE:
				case SUBTYPE:
				case SUCCESS:
				case SUSPEND:
				case TIME:
				case TIMESTAMP:
				case TIMESTAMP_LTZ_UNCONSTRAINED:
				case TIMESTAMP_TZ_UNCONSTRAINED:
				case TIMESTAMP_UNCONSTRAINED:
				case TIMEZONE_ABBR:
				case TIMEZONE_HOUR:
				case TIMEZONE_MINUTE:
				case TIMEZONE_REGION:
				case TRAILING:
				case TRANSACTION:
				case TRANSLATE:
				case TREAT:
				case TRIGGER:
				case TRUNCATE:
				case TYPE:
				case UNBOUNDED:
				case UNDER:
				case UNLIMITED:
				case UNTIL:
				case UPDATED:
				case UPSERT:
				case UROWID:
				case USE:
				case VALIDATE:
				case VALUE:
				case VARCHAR:
				case VARCHAR2:
				case VARIABLE:
				case VARRAY:
				case VARYING:
				case VERSION:
				case VERSIONS:
				case WAIT:
				case WARNING:
				case WELLFORMED:
				case WHENEVER:
				case WHILE:
				case WITHIN:
				case WORK:
				case WRITE:
				case XML:
				case XMLAGG:
				case XMLATTRIBUTES:
				case XMLCAST:
				case XMLCOLATTVAL:
				case XMLELEMENT:
				case XMLEXISTS:
				case XMLFOREST:
				case XMLNAMESPACES:
				case XMLPARSE:
				case XMLPI:
				case XMLQUERY:
				case XMLROOT:
				case XMLSERIALIZE:
				case XMLTABLE:
				case YEAR:
				case YES:
				case YMINTERVAL_UNCONSTRAINED:
				case ZONE:
				case PREDICTION:
				case PREDICTION_BOUNDS:
				case PREDICTION_COST:
				case PREDICTION_DETAILS:
				case PREDICTION_PROBABILITY:
				case PREDICTION_SET:
				case CUME_DIST:
				case DENSE_RANK:
				case LISTAGG:
				case PERCENT_RANK:
				case PERCENTILE_CONT:
				case PERCENTILE_DISC:
				case RANK:
				case AVG:
				case CORR:
				case COVAR_:
				case LAG:
				case LEAD:
				case MAX:
				case MEDIAN:
				case MIN:
				case NTILE:
				case RATIO_TO_REPORT:
				case REGR_:
				case ROW_NUMBER:
				case TRIM:
				case SUM:
				case STDDEV:
				case VAR_:
				case VARIANCE:
				case DELIMITED_ID:
				case INTRODUCER:
				case REGULAR_ID:
					{
					State = 5416; general_element_part();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 5419;
				_la = _input.La(1);
				if ( !(_la==DAY || _la==HOUR || _la==MINUTE || _la==SECOND) ) {
				_errHandler.RecoverInline(this);
				}
				Consume();
				State = 5433;
				switch ( Interpreter.AdaptivePredict(_input,718,_ctx) ) {
				case 1:
					{
					State = 5420; Match(LEFT_PAREN);
					State = 5423;
					switch (_input.La(1)) {
					case UNSIGNED_INTEGER:
						{
						State = 5421; Match(UNSIGNED_INTEGER);
						}
						break;
					case BINDVAR:
					case COLON:
						{
						State = 5422; bind_variable();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 5430;
					_la = _input.La(1);
					if (_la==COMMA) {
						{
						State = 5425; Match(COMMA);
						State = 5428;
						switch (_input.La(1)) {
						case UNSIGNED_INTEGER:
							{
							State = 5426; Match(UNSIGNED_INTEGER);
							}
							break;
						case BINDVAR:
						case COLON:
							{
							State = 5427; bind_variable();
							}
							break;
						default:
							throw new NoViableAltException(this);
						}
						}
					}

					State = 5432; Match(RIGHT_PAREN);
					}
					break;
				}
				State = 5450;
				switch ( Interpreter.AdaptivePredict(_input,722,_ctx) ) {
				case 1:
					{
					State = 5435; Match(TO);
					State = 5448;
					switch (_input.La(1)) {
					case DAY:
						{
						State = 5436; Match(DAY);
						}
						break;
					case HOUR:
						{
						State = 5437; Match(HOUR);
						}
						break;
					case MINUTE:
						{
						State = 5438; Match(MINUTE);
						}
						break;
					case SECOND:
						{
						State = 5439; Match(SECOND);
						State = 5446;
						switch ( Interpreter.AdaptivePredict(_input,720,_ctx) ) {
						case 1:
							{
							State = 5440; Match(LEFT_PAREN);
							State = 5443;
							switch (_input.La(1)) {
							case UNSIGNED_INTEGER:
								{
								State = 5441; Match(UNSIGNED_INTEGER);
								}
								break;
							case BINDVAR:
							case COLON:
								{
								State = 5442; bind_variable();
								}
								break;
							default:
								throw new NoViableAltException(this);
							}
							State = 5445; Match(RIGHT_PAREN);
							}
							break;
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					break;
				}
				}
				break;
			case UNSIGNED_INTEGER:
			case APPROXIMATE_NUM_LIT:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5452; numeric();
				}
				break;
			case DATE:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5453; Match(DATE);
				State = 5454; quoted_string();
				}
				break;
			case NATIONAL_CHAR_STRING_LIT:
			case CHAR_STRING:
				EnterOuterAlt(_localctx, 5);
				{
				State = 5455; quoted_string();
				}
				break;
			case NULL:
				EnterOuterAlt(_localctx, 6);
				{
				State = 5456; Match(NULL);
				}
				break;
			case TRUE:
				EnterOuterAlt(_localctx, 7);
				{
				State = 5457; Match(TRUE);
				}
				break;
			case FALSE:
				EnterOuterAlt(_localctx, 8);
				{
				State = 5458; Match(FALSE);
				}
				break;
			case DBTIMEZONE:
				EnterOuterAlt(_localctx, 9);
				{
				State = 5459; Match(DBTIMEZONE);
				}
				break;
			case SESSIONTIMEZONE:
				EnterOuterAlt(_localctx, 10);
				{
				State = 5460; Match(SESSIONTIMEZONE);
				}
				break;
			case MINVALUE:
				EnterOuterAlt(_localctx, 11);
				{
				State = 5461; Match(MINVALUE);
				}
				break;
			case MAXVALUE:
				EnterOuterAlt(_localctx, 12);
				{
				State = 5462; Match(MAXVALUE);
				}
				break;
			case DEFAULT:
				EnterOuterAlt(_localctx, 13);
				{
				State = 5463; Match(DEFAULT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NumericContext : ParserRuleContext {
		public ITerminalNode UNSIGNED_INTEGER() { return GetToken(plsqlParser.UNSIGNED_INTEGER, 0); }
		public ITerminalNode APPROXIMATE_NUM_LIT() { return GetToken(plsqlParser.APPROXIMATE_NUM_LIT, 0); }
		public NumericContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_numeric; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterNumeric(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitNumeric(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumeric(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NumericContext numeric() {
		NumericContext _localctx = new NumericContext(_ctx, State);
		EnterRule(_localctx, 744, RULE_numeric);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5466;
			_la = _input.La(1);
			if ( !(_la==UNSIGNED_INTEGER || _la==APPROXIMATE_NUM_LIT) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Numeric_negativeContext : ParserRuleContext {
		public NumericContext numeric() {
			return GetRuleContext<NumericContext>(0);
		}
		public ITerminalNode MINUS_SIGN() { return GetToken(plsqlParser.MINUS_SIGN, 0); }
		public Numeric_negativeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_numeric_negative; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterNumeric_negative(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitNumeric_negative(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumeric_negative(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Numeric_negativeContext numeric_negative() {
		Numeric_negativeContext _localctx = new Numeric_negativeContext(_ctx, State);
		EnterRule(_localctx, 746, RULE_numeric_negative);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5468; Match(MINUS_SIGN);
			State = 5469; numeric();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Quoted_stringContext : ParserRuleContext {
		public ITerminalNode CHAR_STRING() { return GetToken(plsqlParser.CHAR_STRING, 0); }
		public ITerminalNode NATIONAL_CHAR_STRING_LIT() { return GetToken(plsqlParser.NATIONAL_CHAR_STRING_LIT, 0); }
		public Quoted_stringContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_quoted_string; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterQuoted_string(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitQuoted_string(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQuoted_string(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Quoted_stringContext quoted_string() {
		Quoted_stringContext _localctx = new Quoted_stringContext(_ctx, State);
		EnterRule(_localctx, 748, RULE_quoted_string);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5471;
			_la = _input.La(1);
			if ( !(_la==NATIONAL_CHAR_STRING_LIT || _la==CHAR_STRING) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierContext : ParserRuleContext {
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public Char_set_nameContext char_set_name() {
			return GetRuleContext<Char_set_nameContext>(0);
		}
		public ITerminalNode INTRODUCER() { return GetToken(plsqlParser.INTRODUCER, 0); }
		public IdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierContext identifier() {
		IdentifierContext _localctx = new IdentifierContext(_ctx, State);
		EnterRule(_localctx, 750, RULE_identifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5475;
			_la = _input.La(1);
			if (_la==INTRODUCER) {
				{
				State = 5473; Match(INTRODUCER);
				State = 5474; char_set_name();
				}
			}

			State = 5477; id_expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Id_expressionContext : ParserRuleContext {
		public Regular_idContext regular_id() {
			return GetRuleContext<Regular_idContext>(0);
		}
		public ITerminalNode DELIMITED_ID() { return GetToken(plsqlParser.DELIMITED_ID, 0); }
		public Id_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_id_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterId_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitId_expression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitId_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Id_expressionContext id_expression() {
		Id_expressionContext _localctx = new Id_expressionContext(_ctx, State);
		EnterRule(_localctx, 752, RULE_id_expression);
		try {
			State = 5481;
			switch (_input.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case COVAR_:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case REGR_:
			case ROW_NUMBER:
			case TRIM:
			case SUM:
			case STDDEV:
			case VAR_:
			case VARIANCE:
			case REGULAR_ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5479; regular_id();
				}
				break;
			case DELIMITED_ID:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5480; Match(DELIMITED_ID);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Not_equal_opContext : ParserRuleContext {
		public ITerminalNode NOT_EQUAL_OP() { return GetToken(plsqlParser.NOT_EQUAL_OP, 0); }
		public Not_equal_opContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_not_equal_op; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterNot_equal_op(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitNot_equal_op(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNot_equal_op(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Not_equal_opContext not_equal_op() {
		Not_equal_opContext _localctx = new Not_equal_opContext(_ctx, State);
		EnterRule(_localctx, 754, RULE_not_equal_op);
		try {
			State = 5490;
			switch (_input.La(1)) {
			case NOT_EQUAL_OP:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5483; Match(NOT_EQUAL_OP);
				}
				break;
			case LESS_THAN_OP:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5484; Match(LESS_THAN_OP);
				State = 5485; Match(GREATER_THAN_OP);
				}
				break;
			case EXCLAMATION_OPERATOR_PART:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5486; Match(EXCLAMATION_OPERATOR_PART);
				State = 5487; Match(EQUALS_OP);
				}
				break;
			case CARRET_OPERATOR_PART:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5488; Match(CARRET_OPERATOR_PART);
				State = 5489; Match(EQUALS_OP);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Greater_than_or_equals_opContext : ParserRuleContext {
		public Greater_than_or_equals_opContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_greater_than_or_equals_op; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterGreater_than_or_equals_op(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitGreater_than_or_equals_op(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGreater_than_or_equals_op(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Greater_than_or_equals_opContext greater_than_or_equals_op() {
		Greater_than_or_equals_opContext _localctx = new Greater_than_or_equals_opContext(_ctx, State);
		EnterRule(_localctx, 756, RULE_greater_than_or_equals_op);
		try {
			State = 5495;
			switch (_input.La(1)) {
			case GREATER_THAN_OR_EQUALS_OP:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5492; Match(GREATER_THAN_OR_EQUALS_OP);
				}
				break;
			case GREATER_THAN_OP:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5493; Match(GREATER_THAN_OP);
				State = 5494; Match(EQUALS_OP);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Less_than_or_equals_opContext : ParserRuleContext {
		public Less_than_or_equals_opContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_less_than_or_equals_op; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterLess_than_or_equals_op(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitLess_than_or_equals_op(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLess_than_or_equals_op(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Less_than_or_equals_opContext less_than_or_equals_op() {
		Less_than_or_equals_opContext _localctx = new Less_than_or_equals_opContext(_ctx, State);
		EnterRule(_localctx, 758, RULE_less_than_or_equals_op);
		try {
			State = 5500;
			switch (_input.La(1)) {
			case LESS_THAN_OR_EQUALS_OP:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5497; Match(LESS_THAN_OR_EQUALS_OP);
				}
				break;
			case LESS_THAN_OP:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5498; Match(LESS_THAN_OP);
				State = 5499; Match(EQUALS_OP);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Concatenation_opContext : ParserRuleContext {
		public Concatenation_opContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_concatenation_op; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterConcatenation_op(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitConcatenation_op(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConcatenation_op(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Concatenation_opContext concatenation_op() {
		Concatenation_opContext _localctx = new Concatenation_opContext(_ctx, State);
		EnterRule(_localctx, 760, RULE_concatenation_op);
		try {
			State = 5505;
			switch (_input.La(1)) {
			case CONCATENATION_OP:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5502; Match(CONCATENATION_OP);
				}
				break;
			case VERTICAL_BAR:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5503; Match(VERTICAL_BAR);
				State = 5504; Match(VERTICAL_BAR);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Outer_join_signContext : ParserRuleContext {
		public Outer_join_signContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_outer_join_sign; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterOuter_join_sign(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitOuter_join_sign(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOuter_join_sign(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Outer_join_signContext outer_join_sign() {
		Outer_join_signContext _localctx = new Outer_join_signContext(_ctx, State);
		EnterRule(_localctx, 762, RULE_outer_join_sign);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5507; Match(LEFT_PAREN);
			State = 5508; Match(PLUS_SIGN);
			State = 5509; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Regular_idContext : ParserRuleContext {
		public ITerminalNode MINUTE() { return GetToken(plsqlParser.MINUTE, 0); }
		public ITerminalNode INDEXED() { return GetToken(plsqlParser.INDEXED, 0); }
		public ITerminalNode BINARY_FLOAT() { return GetToken(plsqlParser.BINARY_FLOAT, 0); }
		public ITerminalNode INSTEAD() { return GetToken(plsqlParser.INSTEAD, 0); }
		public ITerminalNode FIRST() { return GetToken(plsqlParser.FIRST, 0); }
		public ITerminalNode DEC() { return GetToken(plsqlParser.DEC, 0); }
		public ITerminalNode DEBUG() { return GetToken(plsqlParser.DEBUG, 0); }
		public ITerminalNode SIMPLE_INTEGER() { return GetToken(plsqlParser.SIMPLE_INTEGER, 0); }
		public ITerminalNode SHUTDOWN() { return GetToken(plsqlParser.SHUTDOWN, 0); }
		public ITerminalNode PARAMETERS() { return GetToken(plsqlParser.PARAMETERS, 0); }
		public ITerminalNode STATEMENT_ID() { return GetToken(plsqlParser.STATEMENT_ID, 0); }
		public ITerminalNode TRAILING() { return GetToken(plsqlParser.TRAILING, 0); }
		public ITerminalNode TIMESTAMP_TZ_UNCONSTRAINED() { return GetToken(plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED, 0); }
		public ITerminalNode PREDICTION_SET() { return GetToken(plsqlParser.PREDICTION_SET, 0); }
		public ITerminalNode SCHEMACHECK() { return GetToken(plsqlParser.SCHEMACHECK, 0); }
		public ITerminalNode MINVALUE() { return GetToken(plsqlParser.MINVALUE, 0); }
		public ITerminalNode BODY() { return GetToken(plsqlParser.BODY, 0); }
		public ITerminalNode SINGLE() { return GetToken(plsqlParser.SINGLE, 0); }
		public ITerminalNode SELF() { return GetToken(plsqlParser.SELF, 0); }
		public ITerminalNode SERIALLY_REUSABLE() { return GetToken(plsqlParser.SERIALLY_REUSABLE, 0); }
		public ITerminalNode TIMEZONE_HOUR() { return GetToken(plsqlParser.TIMEZONE_HOUR, 0); }
		public ITerminalNode XMLFOREST() { return GetToken(plsqlParser.XMLFOREST, 0); }
		public ITerminalNode REUSE() { return GetToken(plsqlParser.REUSE, 0); }
		public ITerminalNode EXCEPTION_INIT() { return GetToken(plsqlParser.EXCEPTION_INIT, 0); }
		public ITerminalNode STATIC() { return GetToken(plsqlParser.STATIC, 0); }
		public ITerminalNode PATH() { return GetToken(plsqlParser.PATH, 0); }
		public ITerminalNode CROSS() { return GetToken(plsqlParser.CROSS, 0); }
		public ITerminalNode COMPATIBILITY() { return GetToken(plsqlParser.COMPATIBILITY, 0); }
		public ITerminalNode DAY() { return GetToken(plsqlParser.DAY, 0); }
		public ITerminalNode YEAR() { return GetToken(plsqlParser.YEAR, 0); }
		public ITerminalNode REGULAR_ID() { return GetToken(plsqlParser.REGULAR_ID, 0); }
		public ITerminalNode MEDIAN() { return GetToken(plsqlParser.MEDIAN, 0); }
		public ITerminalNode STARTUP() { return GetToken(plsqlParser.STARTUP, 0); }
		public ITerminalNode UNDER() { return GetToken(plsqlParser.UNDER, 0); }
		public ITerminalNode CORR() { return GetToken(plsqlParser.CORR, 0); }
		public ITerminalNode LONG() { return GetToken(plsqlParser.LONG, 0); }
		public ITerminalNode LOCKED() { return GetToken(plsqlParser.LOCKED, 0); }
		public ITerminalNode TRUNCATE() { return GetToken(plsqlParser.TRUNCATE, 0); }
		public ITerminalNode ATTRIBUTE() { return GetToken(plsqlParser.ATTRIBUTE, 0); }
		public ITerminalNode RETURNING() { return GetToken(plsqlParser.RETURNING, 0); }
		public ITerminalNode ROW() { return GetToken(plsqlParser.ROW, 0); }
		public ITerminalNode OFF() { return GetToken(plsqlParser.OFF, 0); }
		public ITerminalNode DISABLE() { return GetToken(plsqlParser.DISABLE, 0); }
		public ITerminalNode INCLUDE() { return GetToken(plsqlParser.INCLUDE, 0); }
		public ITerminalNode COMMITTED() { return GetToken(plsqlParser.COMMITTED, 0); }
		public ITerminalNode POSITIVEN() { return GetToken(plsqlParser.POSITIVEN, 0); }
		public ITerminalNode RETURN() { return GetToken(plsqlParser.RETURN, 0); }
		public ITerminalNode SCN() { return GetToken(plsqlParser.SCN, 0); }
		public ITerminalNode FOLLOWS() { return GetToken(plsqlParser.FOLLOWS, 0); }
		public ITerminalNode PERCENTILE_DISC() { return GetToken(plsqlParser.PERCENTILE_DISC, 0); }
		public ITerminalNode HIDE() { return GetToken(plsqlParser.HIDE, 0); }
		public ITerminalNode ITERATE() { return GetToken(plsqlParser.ITERATE, 0); }
		public ITerminalNode NATURALN() { return GetToken(plsqlParser.NATURALN, 0); }
		public ITerminalNode JOIN() { return GetToken(plsqlParser.JOIN, 0); }
		public ITerminalNode RANGE() { return GetToken(plsqlParser.RANGE, 0); }
		public ITerminalNode REVERSE() { return GetToken(plsqlParser.REVERSE, 0); }
		public ITerminalNode BYTE() { return GetToken(plsqlParser.BYTE, 0); }
		public ITerminalNode C_LETTER() { return GetToken(plsqlParser.C_LETTER, 0); }
		public ITerminalNode DECOMPOSE() { return GetToken(plsqlParser.DECOMPOSE, 0); }
		public ITerminalNode AUTO() { return GetToken(plsqlParser.AUTO, 0); }
		public ITerminalNode BOTH() { return GetToken(plsqlParser.BOTH, 0); }
		public ITerminalNode SEED() { return GetToken(plsqlParser.SEED, 0); }
		public ITerminalNode XMLTABLE() { return GetToken(plsqlParser.XMLTABLE, 0); }
		public ITerminalNode CONSTANT() { return GetToken(plsqlParser.CONSTANT, 0); }
		public ITerminalNode COMPOUND() { return GetToken(plsqlParser.COMPOUND, 0); }
		public ITerminalNode REAL() { return GetToken(plsqlParser.REAL, 0); }
		public ITerminalNode LIKEC() { return GetToken(plsqlParser.LIKEC, 0); }
		public ITerminalNode CLUSTER() { return GetToken(plsqlParser.CLUSTER, 0); }
		public ITerminalNode MAIN() { return GetToken(plsqlParser.MAIN, 0); }
		public ITerminalNode XMLSERIALIZE() { return GetToken(plsqlParser.XMLSERIALIZE, 0); }
		public ITerminalNode SETS() { return GetToken(plsqlParser.SETS, 0); }
		public ITerminalNode CLOSE() { return GetToken(plsqlParser.CLOSE, 0); }
		public ITerminalNode XMLEXISTS() { return GetToken(plsqlParser.XMLEXISTS, 0); }
		public ITerminalNode XMLPI() { return GetToken(plsqlParser.XMLPI, 0); }
		public ITerminalNode WRITE() { return GetToken(plsqlParser.WRITE, 0); }
		public ITerminalNode NEW() { return GetToken(plsqlParser.NEW, 0); }
		public ITerminalNode SUM() { return GetToken(plsqlParser.SUM, 0); }
		public ITerminalNode CUBE() { return GetToken(plsqlParser.CUBE, 0); }
		public ITerminalNode DB_ROLE_CHANGE() { return GetToken(plsqlParser.DB_ROLE_CHANGE, 0); }
		public ITerminalNode CORRUPT_XID_ALL() { return GetToken(plsqlParser.CORRUPT_XID_ALL, 0); }
		public ITerminalNode PREDICTION() { return GetToken(plsqlParser.PREDICTION, 0); }
		public ITerminalNode FORCE() { return GetToken(plsqlParser.FORCE, 0); }
		public ITerminalNode UNTIL() { return GetToken(plsqlParser.UNTIL, 0); }
		public ITerminalNode DDL() { return GetToken(plsqlParser.DDL, 0); }
		public ITerminalNode MODEL() { return GetToken(plsqlParser.MODEL, 0); }
		public ITerminalNode CHR() { return GetToken(plsqlParser.CHR, 0); }
		public ITerminalNode COMMENT() { return GetToken(plsqlParser.COMMENT, 0); }
		public ITerminalNode AGENT() { return GetToken(plsqlParser.AGENT, 0); }
		public ITerminalNode REGR_() { return GetToken(plsqlParser.REGR_, 0); }
		public ITerminalNode NTILE() { return GetToken(plsqlParser.NTILE, 0); }
		public ITerminalNode A_LETTER() { return GetToken(plsqlParser.A_LETTER, 0); }
		public ITerminalNode DSINTERVAL_UNCONSTRAINED() { return GetToken(plsqlParser.DSINTERVAL_UNCONSTRAINED, 0); }
		public ITerminalNode INDENT() { return GetToken(plsqlParser.INDENT, 0); }
		public ITerminalNode WORK() { return GetToken(plsqlParser.WORK, 0); }
		public ITerminalNode SUBTYPE() { return GetToken(plsqlParser.SUBTYPE, 0); }
		public ITerminalNode XMLNAMESPACES() { return GetToken(plsqlParser.XMLNAMESPACES, 0); }
		public ITerminalNode REPLACE() { return GetToken(plsqlParser.REPLACE, 0); }
		public ITerminalNode EXTRACT() { return GetToken(plsqlParser.EXTRACT, 0); }
		public ITerminalNode PRECISION() { return GetToken(plsqlParser.PRECISION, 0); }
		public ITerminalNode STATEMENT() { return GetToken(plsqlParser.STATEMENT, 0); }
		public ITerminalNode SIGNTYPE() { return GetToken(plsqlParser.SIGNTYPE, 0); }
		public ITerminalNode EXCEPTION() { return GetToken(plsqlParser.EXCEPTION, 0); }
		public ITerminalNode WELLFORMED() { return GetToken(plsqlParser.WELLFORMED, 0); }
		public ITerminalNode MIN() { return GetToken(plsqlParser.MIN, 0); }
		public ITerminalNode IGNORE() { return GetToken(plsqlParser.IGNORE, 0); }
		public ITerminalNode NOSCHEMACHECK() { return GetToken(plsqlParser.NOSCHEMACHECK, 0); }
		public ITerminalNode LIMIT() { return GetToken(plsqlParser.LIMIT, 0); }
		public ITerminalNode NAN() { return GetToken(plsqlParser.NAN, 0); }
		public ITerminalNode MODIFY() { return GetToken(plsqlParser.MODIFY, 0); }
		public ITerminalNode STRING() { return GetToken(plsqlParser.STRING, 0); }
		public ITerminalNode VARCHAR() { return GetToken(plsqlParser.VARCHAR, 0); }
		public ITerminalNode CUME_DIST() { return GetToken(plsqlParser.CUME_DIST, 0); }
		public ITerminalNode REF() { return GetToken(plsqlParser.REF, 0); }
		public ITerminalNode MERGE() { return GetToken(plsqlParser.MERGE, 0); }
		public ITerminalNode RAW() { return GetToken(plsqlParser.RAW, 0); }
		public ITerminalNode CALL() { return GetToken(plsqlParser.CALL, 0); }
		public ITerminalNode REFERENCING() { return GetToken(plsqlParser.REFERENCING, 0); }
		public ITerminalNode COMPILE() { return GetToken(plsqlParser.COMPILE, 0); }
		public ITerminalNode TIMEZONE_REGION() { return GetToken(plsqlParser.TIMEZONE_REGION, 0); }
		public ITerminalNode DECREMENT() { return GetToken(plsqlParser.DECREMENT, 0); }
		public ITerminalNode SKIP_() { return GetToken(plsqlParser.SKIP_, 0); }
		public ITerminalNode CHARACTER() { return GetToken(plsqlParser.CHARACTER, 0); }
		public ITerminalNode CONSTRAINT() { return GetToken(plsqlParser.CONSTRAINT, 0); }
		public ITerminalNode INCREMENT() { return GetToken(plsqlParser.INCREMENT, 0); }
		public ITerminalNode NCHAR() { return GetToken(plsqlParser.NCHAR, 0); }
		public ITerminalNode SHOW() { return GetToken(plsqlParser.SHOW, 0); }
		public ITerminalNode ERR() { return GetToken(plsqlParser.ERR, 0); }
		public ITerminalNode WHILE() { return GetToken(plsqlParser.WHILE, 0); }
		public ITerminalNode EXPLAIN() { return GetToken(plsqlParser.EXPLAIN, 0); }
		public ITerminalNode ESCAPE() { return GetToken(plsqlParser.ESCAPE, 0); }
		public ITerminalNode ROWID() { return GetToken(plsqlParser.ROWID, 0); }
		public ITerminalNode BINARY_INTEGER() { return GetToken(plsqlParser.BINARY_INTEGER, 0); }
		public ITerminalNode FUNCTION() { return GetToken(plsqlParser.FUNCTION, 0); }
		public ITerminalNode SUBPARTITION() { return GetToken(plsqlParser.SUBPARTITION, 0); }
		public ITerminalNode TRANSLATE() { return GetToken(plsqlParser.TRANSLATE, 0); }
		public ITerminalNode FORALL() { return GetToken(plsqlParser.FORALL, 0); }
		public ITerminalNode JAVA() { return GetToken(plsqlParser.JAVA, 0); }
		public ITerminalNode SET() { return GetToken(plsqlParser.SET, 0); }
		public ITerminalNode RULES() { return GetToken(plsqlParser.RULES, 0); }
		public ITerminalNode PREDICTION_DETAILS() { return GetToken(plsqlParser.PREDICTION_DETAILS, 0); }
		public ITerminalNode MULTISET() { return GetToken(plsqlParser.MULTISET, 0); }
		public ITerminalNode UNBOUNDED() { return GetToken(plsqlParser.UNBOUNDED, 0); }
		public ITerminalNode EXCLUDE() { return GetToken(plsqlParser.EXCLUDE, 0); }
		public ITerminalNode VAR_() { return GetToken(plsqlParser.VAR_, 0); }
		public ITerminalNode RANK() { return GetToken(plsqlParser.RANK, 0); }
		public ITerminalNode ASSOCIATE() { return GetToken(plsqlParser.ASSOCIATE, 0); }
		public ITerminalNode CONTENT() { return GetToken(plsqlParser.CONTENT, 0); }
		public ITerminalNode TRIGGER() { return GetToken(plsqlParser.TRIGGER, 0); }
		public ITerminalNode NO() { return GetToken(plsqlParser.NO, 0); }
		public ITerminalNode INLINE() { return GetToken(plsqlParser.INLINE, 0); }
		public ITerminalNode MAP() { return GetToken(plsqlParser.MAP, 0); }
		public ITerminalNode XMLPARSE() { return GetToken(plsqlParser.XMLPARSE, 0); }
		public ITerminalNode TIMEZONE_MINUTE() { return GetToken(plsqlParser.TIMEZONE_MINUTE, 0); }
		public ITerminalNode RESULT_CACHE() { return GetToken(plsqlParser.RESULT_CACHE, 0); }
		public ITerminalNode NOAUDIT() { return GetToken(plsqlParser.NOAUDIT, 0); }
		public ITerminalNode ROLLUP() { return GetToken(plsqlParser.ROLLUP, 0); }
		public ITerminalNode AGGREGATE() { return GetToken(plsqlParser.AGGREGATE, 0); }
		public ITerminalNode TRANSACTION() { return GetToken(plsqlParser.TRANSACTION, 0); }
		public ITerminalNode ENTITYESCAPING() { return GetToken(plsqlParser.ENTITYESCAPING, 0); }
		public ITerminalNode BFILE() { return GetToken(plsqlParser.BFILE, 0); }
		public ITerminalNode ROW_NUMBER() { return GetToken(plsqlParser.ROW_NUMBER, 0); }
		public ITerminalNode LIKE4() { return GetToken(plsqlParser.LIKE4, 0); }
		public ITerminalNode YMINTERVAL_UNCONSTRAINED() { return GetToken(plsqlParser.YMINTERVAL_UNCONSTRAINED, 0); }
		public ITerminalNode FAILURE() { return GetToken(plsqlParser.FAILURE, 0); }
		public ITerminalNode ADD() { return GetToken(plsqlParser.ADD, 0); }
		public ITerminalNode MONTH() { return GetToken(plsqlParser.MONTH, 0); }
		public ITerminalNode CANONICAL() { return GetToken(plsqlParser.CANONICAL, 0); }
		public ITerminalNode DIMENSION() { return GetToken(plsqlParser.DIMENSION, 0); }
		public ITerminalNode SQLERROR() { return GetToken(plsqlParser.SQLERROR, 0); }
		public ITerminalNode PRESENT() { return GetToken(plsqlParser.PRESENT, 0); }
		public ITerminalNode SOME() { return GetToken(plsqlParser.SOME, 0); }
		public ITerminalNode SAVEPOINT() { return GetToken(plsqlParser.SAVEPOINT, 0); }
		public ITerminalNode DECIMAL() { return GetToken(plsqlParser.DECIMAL, 0); }
		public ITerminalNode XMLATTRIBUTES() { return GetToken(plsqlParser.XMLATTRIBUTES, 0); }
		public ITerminalNode UNLIMITED() { return GetToken(plsqlParser.UNLIMITED, 0); }
		public ITerminalNode XMLCOLATTVAL() { return GetToken(plsqlParser.XMLCOLATTVAL, 0); }
		public ITerminalNode NATURAL() { return GetToken(plsqlParser.NATURAL, 0); }
		public ITerminalNode CURRENT_USER() { return GetToken(plsqlParser.CURRENT_USER, 0); }
		public ITerminalNode ORADATA() { return GetToken(plsqlParser.ORADATA, 0); }
		public ITerminalNode EXECUTE() { return GetToken(plsqlParser.EXECUTE, 0); }
		public ITerminalNode STDDEV() { return GetToken(plsqlParser.STDDEV, 0); }
		public ITerminalNode ELEMENT() { return GetToken(plsqlParser.ELEMENT, 0); }
		public ITerminalNode XMLELEMENT() { return GetToken(plsqlParser.XMLELEMENT, 0); }
		public ITerminalNode NOCYCLE() { return GetToken(plsqlParser.NOCYCLE, 0); }
		public ITerminalNode CYCLE() { return GetToken(plsqlParser.CYCLE, 0); }
		public ITerminalNode AFTER() { return GetToken(plsqlParser.AFTER, 0); }
		public ITerminalNode REFERENCE() { return GetToken(plsqlParser.REFERENCE, 0); }
		public ITerminalNode INFINITE() { return GetToken(plsqlParser.INFINITE, 0); }
		public ITerminalNode OVER() { return GetToken(plsqlParser.OVER, 0); }
		public ITerminalNode DOCUMENT() { return GetToken(plsqlParser.DOCUMENT, 0); }
		public ITerminalNode AVG() { return GetToken(plsqlParser.AVG, 0); }
		public ITerminalNode BATCH() { return GetToken(plsqlParser.BATCH, 0); }
		public ITerminalNode BLOCK() { return GetToken(plsqlParser.BLOCK, 0); }
		public ITerminalNode XMLCAST() { return GetToken(plsqlParser.XMLCAST, 0); }
		public ITerminalNode OSERROR() { return GetToken(plsqlParser.OSERROR, 0); }
		public ITerminalNode MATCHED() { return GetToken(plsqlParser.MATCHED, 0); }
		public ITerminalNode LIKE2() { return GetToken(plsqlParser.LIKE2, 0); }
		public ITerminalNode SEQUENTIAL() { return GetToken(plsqlParser.SEQUENTIAL, 0); }
		public ITerminalNode INCLUDING() { return GetToken(plsqlParser.INCLUDING, 0); }
		public ITerminalNode GROUPING() { return GetToken(plsqlParser.GROUPING, 0); }
		public ITerminalNode INTERVAL() { return GetToken(plsqlParser.INTERVAL, 0); }
		public ITerminalNode RAISE() { return GetToken(plsqlParser.RAISE, 0); }
		public ITerminalNode NUMBER() { return GetToken(plsqlParser.NUMBER, 0); }
		public ITerminalNode LEADING() { return GetToken(plsqlParser.LEADING, 0); }
		public ITerminalNode AUDIT() { return GetToken(plsqlParser.AUDIT, 0); }
		public ITerminalNode LAST_VALUE() { return GetToken(plsqlParser.LAST_VALUE, 0); }
		public ITerminalNode OUT() { return GetToken(plsqlParser.OUT, 0); }
		public ITerminalNode INT() { return GetToken(plsqlParser.INT, 0); }
		public ITerminalNode FULL() { return GetToken(plsqlParser.FULL, 0); }
		public ITerminalNode STATISTICS() { return GetToken(plsqlParser.STATISTICS, 0); }
		public ITerminalNode SUCCESS() { return GetToken(plsqlParser.SUCCESS, 0); }
		public ITerminalNode UPDATED() { return GetToken(plsqlParser.UPDATED, 0); }
		public ITerminalNode TIMEZONE_ABBR() { return GetToken(plsqlParser.TIMEZONE_ABBR, 0); }
		public ITerminalNode PRAGMA() { return GetToken(plsqlParser.PRAGMA, 0); }
		public ITerminalNode XMLROOT() { return GetToken(plsqlParser.XMLROOT, 0); }
		public ITerminalNode MEMBER() { return GetToken(plsqlParser.MEMBER, 0); }
		public ITerminalNode PARALLEL_ENABLE() { return GetToken(plsqlParser.PARALLEL_ENABLE, 0); }
		public ITerminalNode CONTEXT() { return GetToken(plsqlParser.CONTEXT, 0); }
		public ITerminalNode LEFT() { return GetToken(plsqlParser.LEFT, 0); }
		public ITerminalNode ARRAY() { return GetToken(plsqlParser.ARRAY, 0); }
		public ITerminalNode VERSION() { return GetToken(plsqlParser.VERSION, 0); }
		public ITerminalNode EXCEPTIONS() { return GetToken(plsqlParser.EXCEPTIONS, 0); }
		public ITerminalNode VARYING() { return GetToken(plsqlParser.VARYING, 0); }
		public ITerminalNode BOOLEAN() { return GetToken(plsqlParser.BOOLEAN, 0); }
		public ITerminalNode INSTANTIABLE() { return GetToken(plsqlParser.INSTANTIABLE, 0); }
		public ITerminalNode EXIT() { return GetToken(plsqlParser.EXIT, 0); }
		public ITerminalNode DEFINER() { return GetToken(plsqlParser.DEFINER, 0); }
		public ITerminalNode RENAME() { return GetToken(plsqlParser.RENAME, 0); }
		public ITerminalNode OLD() { return GetToken(plsqlParser.OLD, 0); }
		public ITerminalNode IMMEDIATE() { return GetToken(plsqlParser.IMMEDIATE, 0); }
		public ITerminalNode KEEP() { return GetToken(plsqlParser.KEEP, 0); }
		public ITerminalNode INNER() { return GetToken(plsqlParser.INNER, 0); }
		public ITerminalNode NOCOPY() { return GetToken(plsqlParser.NOCOPY, 0); }
		public ITerminalNode DEFAULTS() { return GetToken(plsqlParser.DEFAULTS, 0); }
		public ITerminalNode VARIABLE() { return GetToken(plsqlParser.VARIABLE, 0); }
		public ITerminalNode NULLS() { return GetToken(plsqlParser.NULLS, 0); }
		public ITerminalNode SERIALIZABLE() { return GetToken(plsqlParser.SERIALIZABLE, 0); }
		public ITerminalNode AT() { return GetToken(plsqlParser.AT, 0); }
		public ITerminalNode INTEGER() { return GetToken(plsqlParser.INTEGER, 0); }
		public ITerminalNode TIMESTAMP_UNCONSTRAINED() { return GetToken(plsqlParser.TIMESTAMP_UNCONSTRAINED, 0); }
		public ITerminalNode XMLAGG() { return GetToken(plsqlParser.XMLAGG, 0); }
		public ITerminalNode RIGHT() { return GetToken(plsqlParser.RIGHT, 0); }
		public ITerminalNode ANALYZE() { return GetToken(plsqlParser.ANALYZE, 0); }
		public ITerminalNode OID() { return GetToken(plsqlParser.OID, 0); }
		public ITerminalNode SERVERERROR() { return GetToken(plsqlParser.SERVERERROR, 0); }
		public ITerminalNode CAST() { return GetToken(plsqlParser.CAST, 0); }
		public ITerminalNode ERRORS() { return GetToken(plsqlParser.ERRORS, 0); }
		public ITerminalNode COST() { return GetToken(plsqlParser.COST, 0); }
		public ITerminalNode SEGMENT() { return GetToken(plsqlParser.SEGMENT, 0); }
		public ITerminalNode PACKAGE() { return GetToken(plsqlParser.PACKAGE, 0); }
		public ITerminalNode PLS_INTEGER() { return GetToken(plsqlParser.PLS_INTEGER, 0); }
		public ITerminalNode DATABASE() { return GetToken(plsqlParser.DATABASE, 0); }
		public ITerminalNode VARRAY() { return GetToken(plsqlParser.VARRAY, 0); }
		public ITerminalNode WHENEVER() { return GetToken(plsqlParser.WHENEVER, 0); }
		public ITerminalNode SAMPLE() { return GetToken(plsqlParser.SAMPLE, 0); }
		public ITerminalNode PREDICTION_BOUNDS() { return GetToken(plsqlParser.PREDICTION_BOUNDS, 0); }
		public ITerminalNode CONVERT() { return GetToken(plsqlParser.CONVERT, 0); }
		public ITerminalNode LOOP() { return GetToken(plsqlParser.LOOP, 0); }
		public ITerminalNode NUMERIC() { return GetToken(plsqlParser.NUMERIC, 0); }
		public ITerminalNode STANDALONE() { return GetToken(plsqlParser.STANDALONE, 0); }
		public ITerminalNode SESSIONTIMEZONE() { return GetToken(plsqlParser.SESSIONTIMEZONE, 0); }
		public ITerminalNode SQLDATA() { return GetToken(plsqlParser.SQLDATA, 0); }
		public ITerminalNode PERCENT_RANK() { return GetToken(plsqlParser.PERCENT_RANK, 0); }
		public ITerminalNode RESULT() { return GetToken(plsqlParser.RESULT, 0); }
		public ITerminalNode ROLLBACK() { return GetToken(plsqlParser.ROLLBACK, 0); }
		public ITerminalNode TREAT() { return GetToken(plsqlParser.TREAT, 0); }
		public ITerminalNode OBJECT() { return GetToken(plsqlParser.OBJECT, 0); }
		public ITerminalNode LANGUAGE() { return GetToken(plsqlParser.LANGUAGE, 0); }
		public ITerminalNode WITHIN() { return GetToken(plsqlParser.WITHIN, 0); }
		public ITerminalNode DETERMINISTIC() { return GetToken(plsqlParser.DETERMINISTIC, 0); }
		public ITerminalNode BULK() { return GetToken(plsqlParser.BULK, 0); }
		public ITerminalNode VALUE() { return GetToken(plsqlParser.VALUE, 0); }
		public ITerminalNode FIRST_VALUE() { return GetToken(plsqlParser.FIRST_VALUE, 0); }
		public ITerminalNode PREDICTION_COST() { return GetToken(plsqlParser.PREDICTION_COST, 0); }
		public ITerminalNode SNAPSHOT() { return GetToken(plsqlParser.SNAPSHOT, 0); }
		public ITerminalNode SMALLINT() { return GetToken(plsqlParser.SMALLINT, 0); }
		public ITerminalNode SUBMULTISET() { return GetToken(plsqlParser.SUBMULTISET, 0); }
		public ITerminalNode RELIES_ON() { return GetToken(plsqlParser.RELIES_ON, 0); }
		public ITerminalNode ENABLE() { return GetToken(plsqlParser.ENABLE, 0); }
		public ITerminalNode DATA() { return GetToken(plsqlParser.DATA, 0); }
		public ITerminalNode EACH() { return GetToken(plsqlParser.EACH, 0); }
		public ITerminalNode CONSTRUCTOR() { return GetToken(plsqlParser.CONSTRUCTOR, 0); }
		public ITerminalNode ROWS() { return GetToken(plsqlParser.ROWS, 0); }
		public ITerminalNode LEAD() { return GetToken(plsqlParser.LEAD, 0); }
		public ITerminalNode PREDICTION_PROBABILITY() { return GetToken(plsqlParser.PREDICTION_PROBABILITY, 0); }
		public ITerminalNode BLOB() { return GetToken(plsqlParser.BLOB, 0); }
		public ITerminalNode SECOND() { return GetToken(plsqlParser.SECOND, 0); }
		public ITerminalNode INDICATOR() { return GetToken(plsqlParser.INDICATOR, 0); }
		public ITerminalNode CORRUPT_XID() { return GetToken(plsqlParser.CORRUPT_XID, 0); }
		public ITerminalNode LOG() { return GetToken(plsqlParser.LOG, 0); }
		public ITerminalNode LOGON() { return GetToken(plsqlParser.LOGON, 0); }
		public ITerminalNode EVALNAME() { return GetToken(plsqlParser.EVALNAME, 0); }
		public ITerminalNode NONE() { return GetToken(plsqlParser.NONE, 0); }
		public ITerminalNode TIME() { return GetToken(plsqlParser.TIME, 0); }
		public ITerminalNode ORDINALITY() { return GetToken(plsqlParser.ORDINALITY, 0); }
		public ITerminalNode PARTITION() { return GetToken(plsqlParser.PARTITION, 0); }
		public ITerminalNode AUTOMATIC() { return GetToken(plsqlParser.AUTOMATIC, 0); }
		public ITerminalNode NVARCHAR2() { return GetToken(plsqlParser.NVARCHAR2, 0); }
		public ITerminalNode PARENT() { return GetToken(plsqlParser.PARENT, 0); }
		public ITerminalNode RECORD() { return GetToken(plsqlParser.RECORD, 0); }
		public ITerminalNode DISASSOCIATE() { return GetToken(plsqlParser.DISASSOCIATE, 0); }
		public ITerminalNode VARIANCE() { return GetToken(plsqlParser.VARIANCE, 0); }
		public ITerminalNode CONSTRAINTS() { return GetToken(plsqlParser.CONSTRAINTS, 0); }
		public ITerminalNode PASSING() { return GetToken(plsqlParser.PASSING, 0); }
		public ITerminalNode EXTERNAL() { return GetToken(plsqlParser.EXTERNAL, 0); }
		public ITerminalNode PERCENTILE_CONT() { return GetToken(plsqlParser.PERCENTILE_CONT, 0); }
		public ITerminalNode AUTHID() { return GetToken(plsqlParser.AUTHID, 0); }
		public ITerminalNode SIBLINGS() { return GetToken(plsqlParser.SIBLINGS, 0); }
		public ITerminalNode DOUBLE() { return GetToken(plsqlParser.DOUBLE, 0); }
		public ITerminalNode FLOAT() { return GetToken(plsqlParser.FLOAT, 0); }
		public ITerminalNode NAV() { return GetToken(plsqlParser.NAV, 0); }
		public ITerminalNode VERSIONS() { return GetToken(plsqlParser.VERSIONS, 0); }
		public ITerminalNode PRECEDING() { return GetToken(plsqlParser.PRECEDING, 0); }
		public ITerminalNode VARCHAR2() { return GetToken(plsqlParser.VARCHAR2, 0); }
		public ITerminalNode LIBRARY() { return GetToken(plsqlParser.LIBRARY, 0); }
		public ITerminalNode POSITIVE() { return GetToken(plsqlParser.POSITIVE, 0); }
		public ITerminalNode CLOB() { return GetToken(plsqlParser.CLOB, 0); }
		public ITerminalNode ENCODING() { return GetToken(plsqlParser.ENCODING, 0); }
		public ITerminalNode NESTED() { return GetToken(plsqlParser.NESTED, 0); }
		public ITerminalNode TYPE() { return GetToken(plsqlParser.TYPE, 0); }
		public ITerminalNode OVERRIDING() { return GetToken(plsqlParser.OVERRIDING, 0); }
		public ITerminalNode COMMIT() { return GetToken(plsqlParser.COMMIT, 0); }
		public ITerminalNode CURSOR() { return GetToken(plsqlParser.CURSOR, 0); }
		public ITerminalNode DBTIMEZONE() { return GetToken(plsqlParser.DBTIMEZONE, 0); }
		public ITerminalNode CHAR() { return GetToken(plsqlParser.CHAR, 0); }
		public ITerminalNode COLLECT() { return GetToken(plsqlParser.COLLECT, 0); }
		public ITerminalNode BEFORE() { return GetToken(plsqlParser.BEFORE, 0); }
		public ITerminalNode REJECT() { return GetToken(plsqlParser.REJECT, 0); }
		public ITerminalNode LOGOFF() { return GetToken(plsqlParser.LOGOFF, 0); }
		public ITerminalNode AUTONOMOUS_TRANSACTION() { return GetToken(plsqlParser.AUTONOMOUS_TRANSACTION, 0); }
		public ITerminalNode COLUMNS() { return GetToken(plsqlParser.COLUMNS, 0); }
		public ITerminalNode MLSLABEL() { return GetToken(plsqlParser.MLSLABEL, 0); }
		public ITerminalNode INOUT() { return GetToken(plsqlParser.INOUT, 0); }
		public ITerminalNode EMPTY() { return GetToken(plsqlParser.EMPTY, 0); }
		public ITerminalNode CASCADE() { return GetToken(plsqlParser.CASCADE, 0); }
		public ITerminalNode COUNT() { return GetToken(plsqlParser.COUNT, 0); }
		public ITerminalNode ZONE() { return GetToken(plsqlParser.ZONE, 0); }
		public ITerminalNode SAVE() { return GetToken(plsqlParser.SAVE, 0); }
		public ITerminalNode HOUR() { return GetToken(plsqlParser.HOUR, 0); }
		public ITerminalNode USE() { return GetToken(plsqlParser.USE, 0); }
		public ITerminalNode MAXVALUE() { return GetToken(plsqlParser.MAXVALUE, 0); }
		public ITerminalNode YES() { return GetToken(plsqlParser.YES, 0); }
		public ITerminalNode FINAL() { return GetToken(plsqlParser.FINAL, 0); }
		public ITerminalNode NAME() { return GetToken(plsqlParser.NAME, 0); }
		public ITerminalNode RESPECT() { return GetToken(plsqlParser.RESPECT, 0); }
		public ITerminalNode INDICES() { return GetToken(plsqlParser.INDICES, 0); }
		public ITerminalNode ISOLATION() { return GetToken(plsqlParser.ISOLATION, 0); }
		public ITerminalNode FOLLOWING() { return GetToken(plsqlParser.FOLLOWING, 0); }
		public ITerminalNode INVALIDATE() { return GetToken(plsqlParser.INVALIDATE, 0); }
		public ITerminalNode MEASURES() { return GetToken(plsqlParser.MEASURES, 0); }
		public ITerminalNode CHAR_CS() { return GetToken(plsqlParser.CHAR_CS, 0); }
		public ITerminalNode NCLOB() { return GetToken(plsqlParser.NCLOB, 0); }
		public ITerminalNode RATIO_TO_REPORT() { return GetToken(plsqlParser.RATIO_TO_REPORT, 0); }
		public ITerminalNode OUTER() { return GetToken(plsqlParser.OUTER, 0); }
		public ITerminalNode SETTINGS() { return GetToken(plsqlParser.SETTINGS, 0); }
		public ITerminalNode NCHAR_CS() { return GetToken(plsqlParser.NCHAR_CS, 0); }
		public ITerminalNode PLAN() { return GetToken(plsqlParser.PLAN, 0); }
		public ITerminalNode BINARY_DOUBLE() { return GetToken(plsqlParser.BINARY_DOUBLE, 0); }
		public ITerminalNode SPECIFICATION() { return GetToken(plsqlParser.SPECIFICATION, 0); }
		public ITerminalNode WAIT() { return GetToken(plsqlParser.WAIT, 0); }
		public ITerminalNode DENSE_RANK() { return GetToken(plsqlParser.DENSE_RANK, 0); }
		public ITerminalNode NOENTITYESCAPING() { return GetToken(plsqlParser.NOENTITYESCAPING, 0); }
		public ITerminalNode RESTRICT_REFERENCES() { return GetToken(plsqlParser.RESTRICT_REFERENCES, 0); }
		public ITerminalNode SUBSTITUTABLE() { return GetToken(plsqlParser.SUBSTITUTABLE, 0); }
		public ITerminalNode CUSTOMDATUM() { return GetToken(plsqlParser.CUSTOMDATUM, 0); }
		public ITerminalNode CONTINUE() { return GetToken(plsqlParser.CONTINUE, 0); }
		public ITerminalNode WARNING() { return GetToken(plsqlParser.WARNING, 0); }
		public ITerminalNode PIPELINED() { return GetToken(plsqlParser.PIPELINED, 0); }
		public ITerminalNode UPSERT() { return GetToken(plsqlParser.UPSERT, 0); }
		public ITerminalNode XML() { return GetToken(plsqlParser.XML, 0); }
		public ITerminalNode LAG() { return GetToken(plsqlParser.LAG, 0); }
		public ITerminalNode TIMESTAMP_LTZ_UNCONSTRAINED() { return GetToken(plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED, 0); }
		public ITerminalNode LEVEL() { return GetToken(plsqlParser.LEVEL, 0); }
		public ITerminalNode READ() { return GetToken(plsqlParser.READ, 0); }
		public ITerminalNode SUSPEND() { return GetToken(plsqlParser.SUSPEND, 0); }
		public ITerminalNode TRIM() { return GetToken(plsqlParser.TRIM, 0); }
		public ITerminalNode OPEN() { return GetToken(plsqlParser.OPEN, 0); }
		public ITerminalNode MAX() { return GetToken(plsqlParser.MAX, 0); }
		public ITerminalNode VALIDATE() { return GetToken(plsqlParser.VALIDATE, 0); }
		public ITerminalNode LOCAL() { return GetToken(plsqlParser.LOCAL, 0); }
		public ITerminalNode ONLY() { return GetToken(plsqlParser.ONLY, 0); }
		public ITerminalNode SCHEMA() { return GetToken(plsqlParser.SCHEMA, 0); }
		public ITerminalNode HASH() { return GetToken(plsqlParser.HASH, 0); }
		public ITerminalNode DEFERRED() { return GetToken(plsqlParser.DEFERRED, 0); }
		public ITerminalNode UROWID() { return GetToken(plsqlParser.UROWID, 0); }
		public ITerminalNode LAST() { return GetToken(plsqlParser.LAST, 0); }
		public ITerminalNode TIMESTAMP() { return GetToken(plsqlParser.TIMESTAMP, 0); }
		public ITerminalNode COVAR_() { return GetToken(plsqlParser.COVAR_, 0); }
		public ITerminalNode XMLQUERY() { return GetToken(plsqlParser.XMLQUERY, 0); }
		public ITerminalNode LISTAGG() { return GetToken(plsqlParser.LISTAGG, 0); }
		public Regular_idContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_regular_id; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterRegular_id(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitRegular_id(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRegular_id(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Regular_idContext regular_id() {
		Regular_idContext _localctx = new Regular_idContext(_ctx, State);
		EnterRule(_localctx, 764, RULE_regular_id);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5511;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (CONSTANT - 66)) | (1L << (CONSTRAINT - 66)) | (1L << (CONSTRAINTS - 66)) | (1L << (CONSTRUCTOR - 66)) | (1L << (CONTENT - 66)) | (1L << (CONTEXT - 66)) | (1L << (CONTINUE - 66)) | (1L << (CONVERT - 66)) | (1L << (CORRUPT_XID - 66)) | (1L << (CORRUPT_XID_ALL - 66)) | (1L << (COST - 66)) | (1L << (COUNT - 66)) | (1L << (CROSS - 66)) | (1L << (CUBE - 66)) | (1L << (CURRENT_USER - 66)) | (1L << (CURSOR - 66)) | (1L << (CUSTOMDATUM - 66)) | (1L << (CYCLE - 66)) | (1L << (DATA - 66)) | (1L << (DATABASE - 66)) | (1L << (DAY - 66)) | (1L << (DB_ROLE_CHANGE - 66)) | (1L << (DBTIMEZONE - 66)) | (1L << (DDL - 66)) | (1L << (DEBUG - 66)) | (1L << (DEC - 66)) | (1L << (DECIMAL - 66)) | (1L << (DECOMPOSE - 66)) | (1L << (DECREMENT - 66)) | (1L << (DEFAULTS - 66)) | (1L << (DEFERRED - 66)) | (1L << (DEFINER - 66)) | (1L << (DETERMINISTIC - 66)) | (1L << (DIMENSION - 66)) | (1L << (DISABLE - 66)) | (1L << (DISASSOCIATE - 66)) | (1L << (DOCUMENT - 66)) | (1L << (DOUBLE - 66)) | (1L << (DSINTERVAL_UNCONSTRAINED - 66)) | (1L << (EACH - 66)) | (1L << (ELEMENT - 66)) | (1L << (EMPTY - 66)) | (1L << (ENABLE - 66)) | (1L << (ENCODING - 66)) | (1L << (ENTITYESCAPING - 66)) | (1L << (ERR - 66)) | (1L << (ERRORS - 66)) | (1L << (ESCAPE - 66)) | (1L << (EVALNAME - 66)) | (1L << (EXCEPTION - 66)) | (1L << (EXCEPTION_INIT - 66)))) != 0) || ((((_la - 130)) & ~0x3f) == 0 && ((1L << (_la - 130)) & ((1L << (EXCEPTIONS - 130)) | (1L << (EXCLUDE - 130)) | (1L << (EXECUTE - 130)) | (1L << (EXIT - 130)) | (1L << (EXPLAIN - 130)) | (1L << (EXTERNAL - 130)) | (1L << (EXTRACT - 130)) | (1L << (FAILURE - 130)) | (1L << (FINAL - 130)) | (1L << (FIRST - 130)) | (1L << (FIRST_VALUE - 130)) | (1L << (FLOAT - 130)) | (1L << (FOLLOWING - 130)) | (1L << (FOLLOWS - 130)) | (1L << (FORALL - 130)) | (1L << (FORCE - 130)) | (1L << (FULL - 130)) | (1L << (FUNCTION - 130)) | (1L << (GROUPING - 130)) | (1L << (HASH - 130)) | (1L << (HIDE - 130)) | (1L << (HOUR - 130)) | (1L << (IGNORE - 130)) | (1L << (IMMEDIATE - 130)) | (1L << (INCLUDE - 130)) | (1L << (INCLUDING - 130)) | (1L << (INCREMENT - 130)) | (1L << (INDENT - 130)) | (1L << (INDEXED - 130)) | (1L << (INDICATOR - 130)) | (1L << (INDICES - 130)) | (1L << (INFINITE - 130)) | (1L << (INLINE - 130)) | (1L << (INNER - 130)) | (1L << (INOUT - 130)) | (1L << (INSTANTIABLE - 130)) | (1L << (INSTEAD - 130)) | (1L << (INT - 130)) | (1L << (INTEGER - 130)) | (1L << (INTERVAL - 130)) | (1L << (INVALIDATE - 130)) | (1L << (ISOLATION - 130)) | (1L << (ITERATE - 130)) | (1L << (JAVA - 130)) | (1L << (JOIN - 130)) | (1L << (KEEP - 130)) | (1L << (LANGUAGE - 130)))) != 0) || ((((_la - 194)) & ~0x3f) == 0 && ((1L << (_la - 194)) & ((1L << (LAST - 194)) | (1L << (LAST_VALUE - 194)) | (1L << (LEADING - 194)) | (1L << (LEFT - 194)) | (1L << (LEVEL - 194)) | (1L << (LIBRARY - 194)) | (1L << (LIKE2 - 194)) | (1L << (LIKE4 - 194)) | (1L << (LIKEC - 194)) | (1L << (LIMIT - 194)) | (1L << (LOCAL - 194)) | (1L << (LOCKED - 194)) | (1L << (LOG - 194)) | (1L << (LOGOFF - 194)) | (1L << (LOGON - 194)) | (1L << (LONG - 194)) | (1L << (LOOP - 194)) | (1L << (MAIN - 194)) | (1L << (MAP - 194)) | (1L << (MATCHED - 194)) | (1L << (MAXVALUE - 194)) | (1L << (MEASURES - 194)) | (1L << (MEMBER - 194)) | (1L << (MERGE - 194)) | (1L << (MINUTE - 194)) | (1L << (MINVALUE - 194)) | (1L << (MLSLABEL - 194)) | (1L << (MODEL - 194)) | (1L << (MODIFY - 194)) | (1L << (MONTH - 194)) | (1L << (MULTISET - 194)) | (1L << (NAME - 194)) | (1L << (NAN - 194)) | (1L << (NATURAL - 194)) | (1L << (NATURALN - 194)) | (1L << (NAV - 194)) | (1L << (NCHAR - 194)) | (1L << (NCHAR_CS - 194)) | (1L << (NCLOB - 194)) | (1L << (NESTED - 194)) | (1L << (NEW - 194)) | (1L << (NO - 194)) | (1L << (NOAUDIT - 194)) | (1L << (NOCOPY - 194)) | (1L << (NOCYCLE - 194)) | (1L << (NOENTITYESCAPING - 194)) | (1L << (NONE - 194)) | (1L << (NOSCHEMACHECK - 194)) | (1L << (NULLS - 194)) | (1L << (NUMBER - 194)) | (1L << (NUMERIC - 194)) | (1L << (NVARCHAR2 - 194)) | (1L << (OBJECT - 194)))) != 0) || ((((_la - 259)) & ~0x3f) == 0 && ((1L << (_la - 259)) & ((1L << (OFF - 259)) | (1L << (OID - 259)) | (1L << (OLD - 259)) | (1L << (ONLY - 259)) | (1L << (OPEN - 259)) | (1L << (ORADATA - 259)) | (1L << (ORDINALITY - 259)) | (1L << (OSERROR - 259)) | (1L << (OUT - 259)) | (1L << (OUTER - 259)) | (1L << (OVER - 259)) | (1L << (OVERRIDING - 259)) | (1L << (PACKAGE - 259)) | (1L << (PARALLEL_ENABLE - 259)) | (1L << (PARAMETERS - 259)) | (1L << (PARENT - 259)) | (1L << (PARTITION - 259)) | (1L << (PASSING - 259)) | (1L << (PATH - 259)) | (1L << (PIPELINED - 259)) | (1L << (PLAN - 259)) | (1L << (PLS_INTEGER - 259)) | (1L << (POSITIVE - 259)) | (1L << (POSITIVEN - 259)) | (1L << (PRAGMA - 259)) | (1L << (PRECEDING - 259)) | (1L << (PRECISION - 259)) | (1L << (PRESENT - 259)) | (1L << (RAISE - 259)) | (1L << (RANGE - 259)) | (1L << (RAW - 259)) | (1L << (READ - 259)) | (1L << (REAL - 259)) | (1L << (RECORD - 259)) | (1L << (REF - 259)) | (1L << (REFERENCE - 259)) | (1L << (REFERENCING - 259)) | (1L << (REJECT - 259)) | (1L << (RELIES_ON - 259)) | (1L << (RENAME - 259)) | (1L << (REPLACE - 259)) | (1L << (RESPECT - 259)) | (1L << (RESTRICT_REFERENCES - 259)) | (1L << (RESULT - 259)) | (1L << (RESULT_CACHE - 259)) | (1L << (RETURN - 259)) | (1L << (RETURNING - 259)) | (1L << (REUSE - 259)) | (1L << (REVERSE - 259)) | (1L << (RIGHT - 259)))) != 0) || ((((_la - 323)) & ~0x3f) == 0 && ((1L << (_la - 323)) & ((1L << (ROLLBACK - 323)) | (1L << (ROLLUP - 323)) | (1L << (ROW - 323)) | (1L << (ROWID - 323)) | (1L << (ROWS - 323)) | (1L << (RULES - 323)) | (1L << (SAMPLE - 323)) | (1L << (SAVE - 323)) | (1L << (SAVEPOINT - 323)) | (1L << (SCHEMA - 323)) | (1L << (SCHEMACHECK - 323)) | (1L << (SCN - 323)) | (1L << (SECOND - 323)) | (1L << (SEED - 323)) | (1L << (SEGMENT - 323)) | (1L << (SELF - 323)) | (1L << (SEQUENTIAL - 323)) | (1L << (SERIALIZABLE - 323)) | (1L << (SERIALLY_REUSABLE - 323)) | (1L << (SERVERERROR - 323)) | (1L << (SESSIONTIMEZONE - 323)) | (1L << (SET - 323)) | (1L << (SETS - 323)) | (1L << (SETTINGS - 323)) | (1L << (SHOW - 323)) | (1L << (SHUTDOWN - 323)) | (1L << (SIBLINGS - 323)) | (1L << (SIGNTYPE - 323)) | (1L << (SIMPLE_INTEGER - 323)) | (1L << (SINGLE - 323)) | (1L << (SKIP_ - 323)) | (1L << (SMALLINT - 323)) | (1L << (SNAPSHOT - 323)) | (1L << (SOME - 323)) | (1L << (SPECIFICATION - 323)) | (1L << (SQLDATA - 323)) | (1L << (SQLERROR - 323)) | (1L << (STANDALONE - 323)) | (1L << (STARTUP - 323)) | (1L << (STATEMENT - 323)) | (1L << (STATEMENT_ID - 323)) | (1L << (STATIC - 323)) | (1L << (STATISTICS - 323)) | (1L << (STRING - 323)) | (1L << (SUBMULTISET - 323)) | (1L << (SUBPARTITION - 323)) | (1L << (SUBSTITUTABLE - 323)) | (1L << (SUBTYPE - 323)) | (1L << (SUCCESS - 323)) | (1L << (SUSPEND - 323)) | (1L << (TIME - 323)) | (1L << (TIMESTAMP - 323)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 323)) | (1L << (TIMESTAMP_UNCONSTRAINED - 323)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TIMEZONE_ABBR - 387)) | (1L << (TIMEZONE_HOUR - 387)) | (1L << (TIMEZONE_MINUTE - 387)) | (1L << (TIMEZONE_REGION - 387)) | (1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (YMINTERVAL_UNCONSTRAINED - 451)) | (1L << (ZONE - 451)) | (1L << (PREDICTION - 451)) | (1L << (PREDICTION_BOUNDS - 451)) | (1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (COVAR_ - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (REGR_ - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (TRIM - 451)) | (1L << (SUM - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (VARIANCE - 451)))) != 0) || _la==REGULAR_ID) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class String_function_nameContext : ParserRuleContext {
		public ITerminalNode TO_CHAR() { return GetToken(plsqlParser.TO_CHAR, 0); }
		public ITerminalNode DECODE() { return GetToken(plsqlParser.DECODE, 0); }
		public ITerminalNode SUBSTR() { return GetToken(plsqlParser.SUBSTR, 0); }
		public ITerminalNode TRIM() { return GetToken(plsqlParser.TRIM, 0); }
		public ITerminalNode CHR() { return GetToken(plsqlParser.CHR, 0); }
		public String_function_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_string_function_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterString_function_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitString_function_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitString_function_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public String_function_nameContext string_function_name() {
		String_function_nameContext _localctx = new String_function_nameContext(_ctx, State);
		EnterRule(_localctx, 766, RULE_string_function_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5513;
			_la = _input.La(1);
			if ( !(_la==CHR || ((((_la - 469)) & ~0x3f) == 0 && ((1L << (_la - 469)) & ((1L << (DECODE - 469)) | (1L << (SUBSTR - 469)) | (1L << (TO_CHAR - 469)) | (1L << (TRIM - 469)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Numeric_function_nameContext : ParserRuleContext {
		public ITerminalNode COUNT() { return GetToken(plsqlParser.COUNT, 0); }
		public ITerminalNode ROUND() { return GetToken(plsqlParser.ROUND, 0); }
		public ITerminalNode AVG() { return GetToken(plsqlParser.AVG, 0); }
		public ITerminalNode NVL() { return GetToken(plsqlParser.NVL, 0); }
		public ITerminalNode SUM() { return GetToken(plsqlParser.SUM, 0); }
		public Numeric_function_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_numeric_function_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterNumeric_function_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitNumeric_function_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IplsqlVisitor<TResult> typedVisitor = visitor as IplsqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumeric_function_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Numeric_function_nameContext numeric_function_name() {
		Numeric_function_nameContext _localctx = new Numeric_function_nameContext(_ctx, State);
		EnterRule(_localctx, 768, RULE_numeric_function_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5515;
			_la = _input.La(1);
			if ( !(_la==COUNT || ((((_la - 466)) & ~0x3f) == 0 && ((1L << (_la - 466)) & ((1L << (AVG - 466)) | (1L << (NVL - 466)) | (1L << (ROUND - 466)) | (1L << (SUM - 466)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 249: return logical_or_expression_sempred((Logical_or_expressionContext)_localctx, predIndex);

		case 250: return logical_and_expression_sempred((Logical_and_expressionContext)_localctx, predIndex);

		case 255: return relational_expression_sempred((Relational_expressionContext)_localctx, predIndex);
		}
		return true;
	}
	private bool logical_and_expression_sempred(Logical_and_expressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 1: return Precpred(_ctx, 1);
		}
		return true;
	}
	private bool relational_expression_sempred(Relational_expressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 2: return Precpred(_ctx, 2);
		}
		return true;
	}
	private bool logical_or_expression_sempred(Logical_or_expressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(_ctx, 1);
		}
		return true;
	}

	public static readonly string _serializedATN =
		"\x3\xAF6F\x8320\x479D\xB75C\x4880\x1605\x191C\xAB37\x3\x215\x1590\x4\x2"+
		"\t\x2\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4"+
		"\t\t\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r\x4\xE\t\xE\x4\xF\t\xF\x4\x10"+
		"\t\x10\x4\x11\t\x11\x4\x12\t\x12\x4\x13\t\x13\x4\x14\t\x14\x4\x15\t\x15"+
		"\x4\x16\t\x16\x4\x17\t\x17\x4\x18\t\x18\x4\x19\t\x19\x4\x1A\t\x1A\x4\x1B"+
		"\t\x1B\x4\x1C\t\x1C\x4\x1D\t\x1D\x4\x1E\t\x1E\x4\x1F\t\x1F\x4 \t \x4!"+
		"\t!\x4\"\t\"\x4#\t#\x4$\t$\x4%\t%\x4&\t&\x4\'\t\'\x4(\t(\x4)\t)\x4*\t"+
		"*\x4+\t+\x4,\t,\x4-\t-\x4.\t.\x4/\t/\x4\x30\t\x30\x4\x31\t\x31\x4\x32"+
		"\t\x32\x4\x33\t\x33\x4\x34\t\x34\x4\x35\t\x35\x4\x36\t\x36\x4\x37\t\x37"+
		"\x4\x38\t\x38\x4\x39\t\x39\x4:\t:\x4;\t;\x4<\t<\x4=\t=\x4>\t>\x4?\t?\x4"+
		"@\t@\x4\x41\t\x41\x4\x42\t\x42\x4\x43\t\x43\x4\x44\t\x44\x4\x45\t\x45"+
		"\x4\x46\t\x46\x4G\tG\x4H\tH\x4I\tI\x4J\tJ\x4K\tK\x4L\tL\x4M\tM\x4N\tN"+
		"\x4O\tO\x4P\tP\x4Q\tQ\x4R\tR\x4S\tS\x4T\tT\x4U\tU\x4V\tV\x4W\tW\x4X\t"+
		"X\x4Y\tY\x4Z\tZ\x4[\t[\x4\\\t\\\x4]\t]\x4^\t^\x4_\t_\x4`\t`\x4\x61\t\x61"+
		"\x4\x62\t\x62\x4\x63\t\x63\x4\x64\t\x64\x4\x65\t\x65\x4\x66\t\x66\x4g"+
		"\tg\x4h\th\x4i\ti\x4j\tj\x4k\tk\x4l\tl\x4m\tm\x4n\tn\x4o\to\x4p\tp\x4"+
		"q\tq\x4r\tr\x4s\ts\x4t\tt\x4u\tu\x4v\tv\x4w\tw\x4x\tx\x4y\ty\x4z\tz\x4"+
		"{\t{\x4|\t|\x4}\t}\x4~\t~\x4\x7F\t\x7F\x4\x80\t\x80\x4\x81\t\x81\x4\x82"+
		"\t\x82\x4\x83\t\x83\x4\x84\t\x84\x4\x85\t\x85\x4\x86\t\x86\x4\x87\t\x87"+
		"\x4\x88\t\x88\x4\x89\t\x89\x4\x8A\t\x8A\x4\x8B\t\x8B\x4\x8C\t\x8C\x4\x8D"+
		"\t\x8D\x4\x8E\t\x8E\x4\x8F\t\x8F\x4\x90\t\x90\x4\x91\t\x91\x4\x92\t\x92"+
		"\x4\x93\t\x93\x4\x94\t\x94\x4\x95\t\x95\x4\x96\t\x96\x4\x97\t\x97\x4\x98"+
		"\t\x98\x4\x99\t\x99\x4\x9A\t\x9A\x4\x9B\t\x9B\x4\x9C\t\x9C\x4\x9D\t\x9D"+
		"\x4\x9E\t\x9E\x4\x9F\t\x9F\x4\xA0\t\xA0\x4\xA1\t\xA1\x4\xA2\t\xA2\x4\xA3"+
		"\t\xA3\x4\xA4\t\xA4\x4\xA5\t\xA5\x4\xA6\t\xA6\x4\xA7\t\xA7\x4\xA8\t\xA8"+
		"\x4\xA9\t\xA9\x4\xAA\t\xAA\x4\xAB\t\xAB\x4\xAC\t\xAC\x4\xAD\t\xAD\x4\xAE"+
		"\t\xAE\x4\xAF\t\xAF\x4\xB0\t\xB0\x4\xB1\t\xB1\x4\xB2\t\xB2\x4\xB3\t\xB3"+
		"\x4\xB4\t\xB4\x4\xB5\t\xB5\x4\xB6\t\xB6\x4\xB7\t\xB7\x4\xB8\t\xB8\x4\xB9"+
		"\t\xB9\x4\xBA\t\xBA\x4\xBB\t\xBB\x4\xBC\t\xBC\x4\xBD\t\xBD\x4\xBE\t\xBE"+
		"\x4\xBF\t\xBF\x4\xC0\t\xC0\x4\xC1\t\xC1\x4\xC2\t\xC2\x4\xC3\t\xC3\x4\xC4"+
		"\t\xC4\x4\xC5\t\xC5\x4\xC6\t\xC6\x4\xC7\t\xC7\x4\xC8\t\xC8\x4\xC9\t\xC9"+
		"\x4\xCA\t\xCA\x4\xCB\t\xCB\x4\xCC\t\xCC\x4\xCD\t\xCD\x4\xCE\t\xCE\x4\xCF"+
		"\t\xCF\x4\xD0\t\xD0\x4\xD1\t\xD1\x4\xD2\t\xD2\x4\xD3\t\xD3\x4\xD4\t\xD4"+
		"\x4\xD5\t\xD5\x4\xD6\t\xD6\x4\xD7\t\xD7\x4\xD8\t\xD8\x4\xD9\t\xD9\x4\xDA"+
		"\t\xDA\x4\xDB\t\xDB\x4\xDC\t\xDC\x4\xDD\t\xDD\x4\xDE\t\xDE\x4\xDF\t\xDF"+
		"\x4\xE0\t\xE0\x4\xE1\t\xE1\x4\xE2\t\xE2\x4\xE3\t\xE3\x4\xE4\t\xE4\x4\xE5"+
		"\t\xE5\x4\xE6\t\xE6\x4\xE7\t\xE7\x4\xE8\t\xE8\x4\xE9\t\xE9\x4\xEA\t\xEA"+
		"\x4\xEB\t\xEB\x4\xEC\t\xEC\x4\xED\t\xED\x4\xEE\t\xEE\x4\xEF\t\xEF\x4\xF0"+
		"\t\xF0\x4\xF1\t\xF1\x4\xF2\t\xF2\x4\xF3\t\xF3\x4\xF4\t\xF4\x4\xF5\t\xF5"+
		"\x4\xF6\t\xF6\x4\xF7\t\xF7\x4\xF8\t\xF8\x4\xF9\t\xF9\x4\xFA\t\xFA\x4\xFB"+
		"\t\xFB\x4\xFC\t\xFC\x4\xFD\t\xFD\x4\xFE\t\xFE\x4\xFF\t\xFF\x4\x100\t\x100"+
		"\x4\x101\t\x101\x4\x102\t\x102\x4\x103\t\x103\x4\x104\t\x104\x4\x105\t"+
		"\x105\x4\x106\t\x106\x4\x107\t\x107\x4\x108\t\x108\x4\x109\t\x109\x4\x10A"+
		"\t\x10A\x4\x10B\t\x10B\x4\x10C\t\x10C\x4\x10D\t\x10D\x4\x10E\t\x10E\x4"+
		"\x10F\t\x10F\x4\x110\t\x110\x4\x111\t\x111\x4\x112\t\x112\x4\x113\t\x113"+
		"\x4\x114\t\x114\x4\x115\t\x115\x4\x116\t\x116\x4\x117\t\x117\x4\x118\t"+
		"\x118\x4\x119\t\x119\x4\x11A\t\x11A\x4\x11B\t\x11B\x4\x11C\t\x11C\x4\x11D"+
		"\t\x11D\x4\x11E\t\x11E\x4\x11F\t\x11F\x4\x120\t\x120\x4\x121\t\x121\x4"+
		"\x122\t\x122\x4\x123\t\x123\x4\x124\t\x124\x4\x125\t\x125\x4\x126\t\x126"+
		"\x4\x127\t\x127\x4\x128\t\x128\x4\x129\t\x129\x4\x12A\t\x12A\x4\x12B\t"+
		"\x12B\x4\x12C\t\x12C\x4\x12D\t\x12D\x4\x12E\t\x12E\x4\x12F\t\x12F\x4\x130"+
		"\t\x130\x4\x131\t\x131\x4\x132\t\x132\x4\x133\t\x133\x4\x134\t\x134\x4"+
		"\x135\t\x135\x4\x136\t\x136\x4\x137\t\x137\x4\x138\t\x138\x4\x139\t\x139"+
		"\x4\x13A\t\x13A\x4\x13B\t\x13B\x4\x13C\t\x13C\x4\x13D\t\x13D\x4\x13E\t"+
		"\x13E\x4\x13F\t\x13F\x4\x140\t\x140\x4\x141\t\x141\x4\x142\t\x142\x4\x143"+
		"\t\x143\x4\x144\t\x144\x4\x145\t\x145\x4\x146\t\x146\x4\x147\t\x147\x4"+
		"\x148\t\x148\x4\x149\t\x149\x4\x14A\t\x14A\x4\x14B\t\x14B\x4\x14C\t\x14C"+
		"\x4\x14D\t\x14D\x4\x14E\t\x14E\x4\x14F\t\x14F\x4\x150\t\x150\x4\x151\t"+
		"\x151\x4\x152\t\x152\x4\x153\t\x153\x4\x154\t\x154\x4\x155\t\x155\x4\x156"+
		"\t\x156\x4\x157\t\x157\x4\x158\t\x158\x4\x159\t\x159\x4\x15A\t\x15A\x4"+
		"\x15B\t\x15B\x4\x15C\t\x15C\x4\x15D\t\x15D\x4\x15E\t\x15E\x4\x15F\t\x15F"+
		"\x4\x160\t\x160\x4\x161\t\x161\x4\x162\t\x162\x4\x163\t\x163\x4\x164\t"+
		"\x164\x4\x165\t\x165\x4\x166\t\x166\x4\x167\t\x167\x4\x168\t\x168\x4\x169"+
		"\t\x169\x4\x16A\t\x16A\x4\x16B\t\x16B\x4\x16C\t\x16C\x4\x16D\t\x16D\x4"+
		"\x16E\t\x16E\x4\x16F\t\x16F\x4\x170\t\x170\x4\x171\t\x171\x4\x172\t\x172"+
		"\x4\x173\t\x173\x4\x174\t\x174\x4\x175\t\x175\x4\x176\t\x176\x4\x177\t"+
		"\x177\x4\x178\t\x178\x4\x179\t\x179\x4\x17A\t\x17A\x4\x17B\t\x17B\x4\x17C"+
		"\t\x17C\x4\x17D\t\x17D\x4\x17E\t\x17E\x4\x17F\t\x17F\x4\x180\t\x180\x4"+
		"\x181\t\x181\x4\x182\t\x182\x3\x2\x6\x2\x306\n\x2\r\x2\xE\x2\x307\x3\x3"+
		"\a\x3\x30B\n\x3\f\x3\xE\x3\x30E\v\x3\x3\x3\x3\x3\x3\x4\x3\x4\a\x4\x314"+
		"\n\x4\f\x4\xE\x4\x317\v\x4\x3\x4\x3\x4\x3\x5\a\x5\x31C\n\x5\f\x5\xE\x5"+
		"\x31F\v\x5\x3\x5\x3\x5\x6\x5\x323\n\x5\r\x5\xE\x5\x324\x3\x5\a\x5\x328"+
		"\n\x5\f\x5\xE\x5\x32B\v\x5\x3\x5\a\x5\x32E\n\x5\f\x5\xE\x5\x331\v\x5\x3"+
		"\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6"+
		"\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x5\x6\x347\n\x6\x3\a"+
		"\x3\a\x3\a\x3\a\x3\a\x3\b\x3\b\x3\b\x3\b\x3\b\x5\b\x353\n\b\x3\b\a\b\x356"+
		"\n\b\f\b\xE\b\x359\v\b\x3\b\x3\b\x5\b\x35D\n\b\x3\b\x3\b\x3\t\x3\t\x3"+
		"\t\x5\t\x364\n\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\a\t\x36C\n\t\f\t\xE\t\x36F"+
		"\v\t\x3\t\x3\t\x5\t\x373\n\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\a\t\x37B\n"+
		"\t\f\t\xE\t\x37E\v\t\x3\t\x5\t\x381\n\t\x3\t\x3\t\x5\t\x385\n\t\x3\t\a"+
		"\t\x388\n\t\f\t\xE\t\x38B\v\t\x3\t\x3\t\x5\t\x38F\n\t\x3\t\x3\t\x3\t\x5"+
		"\t\x394\n\t\x3\t\x3\t\x3\n\x3\n\x5\n\x39A\n\n\x3\v\x3\v\x3\v\x3\v\x3\v"+
		"\x3\v\x3\v\x3\v\x3\v\x3\v\a\v\x3A6\n\v\f\v\xE\v\x3A9\v\v\x3\v\x3\v\x5"+
		"\v\x3AD\n\v\x3\v\x5\v\x3B0\n\v\x3\v\x3\v\x3\f\x3\f\x5\f\x3B6\n\f\x3\r"+
		"\x3\r\x3\r\x3\r\x3\r\a\r\x3BD\n\r\f\r\xE\r\x3C0\v\r\x3\r\x3\r\x3\xE\x3"+
		"\xE\x3\xE\x3\xE\x3\xE\x3\xE\x3\xE\a\xE\x3CB\n\xE\f\xE\xE\xE\x3CE\v\xE"+
		"\x3\xE\x3\xE\x3\xF\x3\xF\x3\xF\x5\xF\x3D5\n\xF\x3\xF\x3\xF\x3\xF\x3\x10"+
		"\x3\x10\x3\x10\x3\x10\x3\x10\x5\x10\x3DF\n\x10\x3\x10\x5\x10\x3E2\n\x10"+
		"\x3\x10\a\x10\x3E5\n\x10\f\x10\xE\x10\x3E8\v\x10\x3\x10\x3\x10\x5\x10"+
		"\x3EC\n\x10\x3\x10\x3\x10\x3\x11\x3\x11\x3\x11\x5\x11\x3F3\n\x11\x3\x11"+
		"\x3\x11\x3\x11\x5\x11\x3F8\n\x11\x3\x11\x3\x11\a\x11\x3FC\n\x11\f\x11"+
		"\xE\x11\x3FF\v\x11\x3\x11\x3\x11\x5\x11\x403\n\x11\x3\x11\x3\x11\x3\x12"+
		"\x3\x12\x3\x12\x5\x12\x40A\n\x12\x3\x12\x3\x12\x3\x12\x3\x12\x3\x12\a"+
		"\x12\x411\n\x12\f\x12\xE\x12\x414\v\x12\x3\x12\x3\x12\x3\x12\x3\x12\x5"+
		"\x12\x41A\n\x12\x5\x12\x41C\n\x12\x3\x12\x3\x12\x3\x13\x3\x13\x3\x13\x3"+
		"\x13\x3\x13\x3\x13\x3\x13\x3\x13\x5\x13\x428\n\x13\x3\x14\x3\x14\x3\x14"+
		"\x3\x14\x3\x14\x3\x14\a\x14\x430\n\x14\f\x14\xE\x14\x433\v\x14\x3\x14"+
		"\x3\x14\x5\x14\x437\n\x14\x3\x14\x3\x14\x3\x15\x3\x15\x3\x15\x3\x15\x3"+
		"\x15\x3\x15\a\x15\x441\n\x15\f\x15\xE\x15\x444\v\x15\x3\x15\x3\x15\x5"+
		"\x15\x448\n\x15\x3\x15\x3\x15\x3\x15\x5\x15\x44D\n\x15\x3\x15\x5\x15\x450"+
		"\n\x15\x3\x15\x3\x15\x3\x16\x3\x16\x3\x16\x3\x16\x3\x16\x3\x16\x3\x16"+
		"\x3\x16\x3\x16\x5\x16\x45D\n\x16\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3"+
		"\x18\x3\x18\x3\x18\x3\x18\x3\x18\x5\x18\x469\n\x18\x3\x18\a\x18\x46C\n"+
		"\x18\f\x18\xE\x18\x46F\v\x18\x3\x18\x3\x18\x5\x18\x473\n\x18\x3\x18\x3"+
		"\x18\x3\x19\x3\x19\x3\x19\x3\x19\x3\x19\x3\x19\a\x19\x47D\n\x19\f\x19"+
		"\xE\x19\x480\v\x19\x3\x19\x3\x19\x5\x19\x484\n\x19\x3\x19\x3\x19\x3\x19"+
		"\x3\x19\x3\x19\x3\x19\a\x19\x48C\n\x19\f\x19\xE\x19\x48F\v\x19\x3\x19"+
		"\x5\x19\x492\n\x19\x3\x19\x3\x19\x5\x19\x496\n\x19\x3\x19\a\x19\x499\n"+
		"\x19\f\x19\xE\x19\x49C\v\x19\x3\x19\x3\x19\x5\x19\x4A0\n\x19\x3\x19\x3"+
		"\x19\x3\x19\x5\x19\x4A5\n\x19\x3\x19\x3\x19\x3\x1A\x3\x1A\x3\x1A\x3\x1A"+
		"\x3\x1A\x3\x1A\a\x1A\x4AF\n\x1A\f\x1A\xE\x1A\x4B2\v\x1A\x3\x1A\x3\x1A"+
		"\x5\x1A\x4B6\n\x1A\x3\x1A\x3\x1A\x5\x1A\x4BA\n\x1A\x3\x1A\a\x1A\x4BD\n"+
		"\x1A\f\x1A\xE\x1A\x4C0\v\x1A\x3\x1A\x3\x1A\x3\x1A\x5\x1A\x4C5\n\x1A\x3"+
		"\x1A\x3\x1A\x3\x1B\x3\x1B\x3\x1B\x5\x1B\x4CC\n\x1B\x3\x1B\x3\x1B\x3\x1B"+
		"\x3\x1B\x3\x1B\x3\x1B\a\x1B\x4D4\n\x1B\f\x1B\xE\x1B\x4D7\v\x1B\x3\x1B"+
		"\x3\x1B\x5\x1B\x4DB\n\x1B\x3\x1B\x5\x1B\x4DE\n\x1B\x3\x1B\x3\x1B\x5\x1B"+
		"\x4E2\n\x1B\x3\x1B\a\x1B\x4E5\n\x1B\f\x1B\xE\x1B\x4E8\v\x1B\x3\x1B\x3"+
		"\x1B\x3\x1B\x5\x1B\x4ED\n\x1B\x3\x1B\x3\x1B\x3\x1C\x3\x1C\x3\x1C\x3\x1C"+
		"\x3\x1C\x3\x1D\x3\x1D\x3\x1D\x3\x1D\x3\x1D\x3\x1D\x3\x1D\x3\x1D\x3\x1D"+
		"\x5\x1D\x4FF\n\x1D\x3\x1D\a\x1D\x502\n\x1D\f\x1D\xE\x1D\x505\v\x1D\x3"+
		"\x1D\x3\x1D\x5\x1D\x509\n\x1D\x5\x1D\x50B\n\x1D\x3\x1D\x3\x1D\x3\x1E\x3"+
		"\x1E\x3\x1E\x5\x1E\x512\n\x1E\x3\x1E\x3\x1E\x3\x1E\x3\x1E\x3\x1E\x5\x1E"+
		"\x519\n\x1E\x3\x1E\x5\x1E\x51C\n\x1E\x3\x1E\x5\x1E\x51F\n\x1E\x3\x1E\x5"+
		"\x1E\x522\n\x1E\x3\x1E\x3\x1E\x3\x1E\x3\x1F\x3\x1F\x3\x1F\x3\x1F\a\x1F"+
		"\x52B\n\x1F\f\x1F\xE\x1F\x52E\v\x1F\x3 \x3 \x3 \x3 \x3 \x3!\x3!\x3!\x3"+
		"!\x5!\x539\n!\x3!\x3!\x5!\x53D\n!\x3!\x5!\x540\n!\x3\"\x3\"\x3\"\x3\""+
		"\x3#\x3#\x3#\x5#\x549\n#\x3$\x3$\x3$\x3$\a$\x54F\n$\f$\xE$\x552\v$\x3"+
		"$\x3$\x3$\x3$\x3$\x5$\x559\n$\x3$\x5$\x55C\n$\x3%\x3%\x3%\x3%\x3%\x5%"+
		"\x563\n%\x3&\x3&\x5&\x567\n&\x3\'\x3\'\x3\'\a\'\x56C\n\'\f\'\xE\'\x56F"+
		"\v\'\x3\'\x6\'\x572\n\'\r\'\xE\'\x573\x3\'\x3\'\x3\'\x3(\x3(\x3(\x3(\x3"+
		"(\x3(\x3(\x3(\x3(\x3(\x3(\x3(\x3(\x3(\x3(\x3(\x3(\x3(\x3(\x3(\x3(\x3("+
		"\x3(\x3(\x3(\x3(\x3(\x3(\x3(\x3(\x3(\x3(\x3(\x3(\x3(\x3(\x5(\x59D\n(\x3"+
		")\x3)\x3)\x3)\x3)\x3)\x3)\x3)\x3)\x3)\x3)\x3)\x3)\x3)\x3)\x3)\x3)\x3)"+
		"\x3)\x3)\x3)\x3)\x3)\x3)\x3)\x3)\x5)\x5B9\n)\x3*\x3*\x3*\a*\x5BE\n*\f"+
		"*\xE*\x5C1\v*\x3*\x3*\x5*\x5C5\n*\x3*\x3*\x3+\x3+\x3+\x3+\x3+\a+\x5CE"+
		"\n+\f+\xE+\x5D1\v+\x5+\x5D3\n+\x3,\x3,\x3,\x3,\x3,\x3-\x3-\x6-\x5DC\n"+
		"-\r-\xE-\x5DD\x3.\x3.\x3.\x3/\x3/\x3/\x5/\x5E6\n/\x3/\x3/\x5/\x5EA\n/"+
		"\x3/\x3/\x3\x30\x3\x30\x3\x30\x3\x30\x3\x30\x3\x30\x3\x30\x3\x30\x5\x30"+
		"\x5F6\n\x30\x3\x30\x5\x30\x5F9\n\x30\x3\x30\x3\x30\x3\x31\x3\x31\x5\x31"+
		"\x5FF\n\x31\x3\x31\x5\x31\x602\n\x31\x3\x31\a\x31\x605\n\x31\f\x31\xE"+
		"\x31\x608\v\x31\x3\x31\x3\x31\x5\x31\x60C\n\x31\x3\x32\x3\x32\x5\x32\x610"+
		"\n\x32\x3\x32\x3\x32\x3\x32\x3\x32\x3\x32\x3\x32\a\x32\x618\n\x32\f\x32"+
		"\xE\x32\x61B\v\x32\x3\x32\x3\x32\x3\x33\x3\x33\x3\x33\a\x33\x622\n\x33"+
		"\f\x33\xE\x33\x625\v\x33\x3\x34\x3\x34\x3\x34\x5\x34\x62A\n\x34\x3\x35"+
		"\x3\x35\x3\x35\x3\x35\x3\x35\x3\x35\x3\x35\a\x35\x633\n\x35\f\x35\xE\x35"+
		"\x636\v\x35\x3\x35\x3\x35\x5\x35\x63A\n\x35\x3\x36\x3\x36\x5\x36\x63E"+
		"\n\x36\x3\x37\x3\x37\x3\x37\x3\x37\x3\x37\x3\x37\x5\x37\x646\n\x37\x3"+
		"\x38\x3\x38\x3\x38\x3\x38\x3\x38\x3\x38\x5\x38\x64E\n\x38\x3\x38\x3\x38"+
		"\x3\x38\x5\x38\x653\n\x38\x3\x38\x5\x38\x656\n\x38\x5\x38\x658\n\x38\x3"+
		"\x39\x5\x39\x65B\n\x39\x3\x39\x3\x39\x3\x39\x3\x39\x3:\x3:\x3:\x5:\x664"+
		"\n:\x3:\x3:\x3:\x5:\x669\n:\x3:\x3:\x3;\x3;\x3;\x5;\x670\n;\x3;\x5;\x673"+
		"\n;\x3<\x5<\x676\n<\x3<\x3<\x5<\x67A\n<\x3<\x5<\x67D\n<\x3<\x3<\x3<\x3"+
		"<\a<\x683\n<\f<\xE<\x686\v<\x3<\x3<\x5<\x68A\n<\x3<\a<\x68D\n<\f<\xE<"+
		"\x690\v<\x3=\x3=\x3=\x3=\x5=\x696\n=\x3>\x3>\x3>\x3?\x3?\x3?\x3?\x3?\x5"+
		"?\x6A0\n?\x3@\x3@\x3@\x3@\x3@\x3@\x3@\x3@\x3\x41\x3\x41\x3\x41\x3\x41"+
		"\x6\x41\x6AE\n\x41\r\x41\xE\x41\x6AF\x3\x41\x3\x41\x3\x42\x3\x42\x5\x42"+
		"\x6B6\n\x42\x3\x43\x3\x43\x3\x43\x3\x43\x3\x44\x3\x44\x3\x44\x3\x44\x5"+
		"\x44\x6C0\n\x44\x3\x45\x3\x45\x3\x45\x3\x45\x3\x45\x3\x45\a\x45\x6C8\n"+
		"\x45\f\x45\xE\x45\x6CB\v\x45\x3\x45\x3\x45\x3\x45\x3\x45\x5\x45\x6D1\n"+
		"\x45\x3\x45\a\x45\x6D4\n\x45\f\x45\xE\x45\x6D7\v\x45\x3\x45\x3\x45\x3"+
		"\x45\x5\x45\x6DC\n\x45\x3\x46\x3\x46\x3\x46\x3\x46\x3\x46\x3\x46\a\x46"+
		"\x6E4\n\x46\f\x46\xE\x46\x6E7\v\x46\x3\x46\x3\x46\x5\x46\x6EB\n\x46\x3"+
		"\x46\x3\x46\x3\x46\x3\x46\x3\x46\x5\x46\x6F2\n\x46\x3\x46\a\x46\x6F5\n"+
		"\x46\f\x46\xE\x46\x6F8\v\x46\x3\x46\x3\x46\x3\x46\x5\x46\x6FD\n\x46\x3"+
		"G\x5G\x700\nG\x3G\x5G\x703\nG\x3G\x3G\x3G\x3G\x3G\x3G\x3G\x3G\x3G\x3G"+
		"\x3G\x3G\x3G\aG\x712\nG\fG\xEG\x715\vG\x3G\x3G\x5G\x719\nG\x3G\x3G\x3"+
		"G\x3G\x3G\x3G\x3G\x5G\x722\nG\x3G\aG\x725\nG\fG\xEG\x728\vG\x3G\x3G\x3"+
		"G\x5G\x72D\nG\x3H\x5H\x730\nH\x3H\x3H\x3I\x3I\x3I\x5I\x737\nI\x3I\x5I"+
		"\x73A\nI\x3J\x3J\x3J\x3J\x3K\x5K\x741\nK\x3K\x6K\x744\nK\rK\xEK\x745\x3"+
		"K\x3K\x5K\x74A\nK\x3L\x3L\x3L\x5L\x74F\nL\x3M\x3M\x3M\x5M\x754\nM\x3N"+
		"\x3N\x3N\x3N\x3N\x3N\aN\x75C\nN\fN\xEN\x75F\vN\x3N\x3N\x3N\x5N\x764\n"+
		"N\x3O\x3O\x3O\x3O\x3O\x3O\aO\x76C\nO\fO\xEO\x76F\vO\x3O\x3O\x5O\x773\n"+
		"O\x3O\x3O\x3O\x3O\x3O\x5O\x77A\nO\x3O\x3O\x3O\x3O\x5O\x780\nO\x3O\x3O"+
		"\x5O\x784\nO\x3P\x5P\x787\nP\x3P\x5P\x78A\nP\x3P\x3P\x3P\x3P\x3P\x3P\x3"+
		"P\x3P\x3P\x3P\x3P\x3P\x3P\aP\x799\nP\fP\xEP\x79C\vP\x3P\x3P\x5P\x7A0\n"+
		"P\x3P\x3P\x3P\x3P\x3P\x3P\x5P\x7A8\nP\x3Q\x3Q\x3Q\x3Q\x3R\x3R\x3R\x3R"+
		"\x3R\x3R\aR\x7B4\nR\fR\xER\x7B7\vR\x3R\x3R\x3S\x3S\x5S\x7BD\nS\x3T\x3"+
		"T\x3T\x3U\x3U\x3U\x3U\x3U\x3V\x3V\x3V\x3V\x6V\x7CB\nV\rV\xEV\x7CC\x3V"+
		"\x3V\x3W\x3W\x3W\x3W\x3W\aW\x7D6\nW\fW\xEW\x7D9\vW\x3W\x3W\x3X\x3X\x3"+
		"X\x3X\x3X\x3X\x3X\x3X\x3X\x3X\x3X\x3X\x3X\x3X\x3X\x3X\x5X\x7ED\nX\x3Y"+
		"\x3Y\x3Y\x3Y\x3Z\x3Z\x3Z\x3[\x3[\x3[\x3[\x3\\\x3\\\x3\\\x5\\\x7FD\n\\"+
		"\x3]\x3]\x3]\x3]\x3^\x3^\x3^\x5^\x806\n^\x3^\x3^\x3^\x5^\x80B\n^\x3^\x3"+
		"^\x5^\x80F\n^\x3^\x5^\x812\n^\x3_\x3_\x3_\x3_\x3_\x3_\a_\x81A\n_\f_\xE"+
		"_\x81D\v_\x3_\x3_\x3`\x3`\x3`\x3`\x3`\a`\x826\n`\f`\xE`\x829\v`\x3`\x3"+
		"`\x3`\x5`\x82E\n`\x3`\x3`\x3\x61\x3\x61\a\x61\x834\n\x61\f\x61\xE\x61"+
		"\x837\v\x61\x3\x61\x5\x61\x83A\n\x61\x3\x61\x5\x61\x83D\n\x61\x3\x62\x3"+
		"\x62\x3\x62\x3\x63\x3\x63\x3\x63\x3\x63\x3\x63\x3\x63\x3\x63\x3\x63\x3"+
		"\x63\x3\x63\x5\x63\x84C\n\x63\x3\x64\x3\x64\x5\x64\x850\n\x64\x3\x64\x3"+
		"\x64\x3\x64\x5\x64\x855\n\x64\x3\x64\x5\x64\x858\n\x64\x3\x64\x3\x64\x3"+
		"\x65\x3\x65\x3\x65\x3\x65\x3\x65\x3\x65\x3\x65\x3\x65\x3\x65\x5\x65\x865"+
		"\n\x65\x3\x65\x3\x65\x5\x65\x869\n\x65\x3\x65\x3\x65\x3\x66\x3\x66\x3"+
		"\x66\x3\x66\x3\x66\x3\x66\a\x66\x873\n\x66\f\x66\xE\x66\x876\v\x66\x3"+
		"\x66\x3\x66\x5\x66\x87A\n\x66\x3\x66\x3\x66\x5\x66\x87E\n\x66\x3\x66\x3"+
		"\x66\x5\x66\x882\n\x66\x3\x66\x3\x66\x3g\x3g\x5g\x888\ng\x3g\x5g\x88B"+
		"\ng\x3g\x5g\x88E\ng\x3h\x3h\x3h\x3h\x3i\x3i\x3i\x3i\x3i\x3i\x3i\x3i\x3"+
		"i\x3i\x3i\x3i\x3i\x3i\x3i\x3i\x3i\x3i\x3i\x3i\x3i\x5i\x8A9\ni\x3i\x3i"+
		"\x6i\x8AD\ni\ri\xEi\x8AE\x3i\x3i\x5i\x8B3\ni\x3i\x3i\x3j\x3j\x3j\x3j\x3"+
		"j\aj\x8BC\nj\fj\xEj\x8BF\vj\x3j\x3j\x3k\x3k\x5k\x8C5\nk\x3k\x3k\x5k\x8C9"+
		"\nk\x3k\x5k\x8CC\nk\x3l\x3l\x3l\x3l\x5l\x8D2\nl\x3m\x3m\x3m\x3m\x3m\x3"+
		"m\x3m\x5m\x8DB\nm\x3m\x3m\x3n\x3n\x3n\x3n\x5n\x8E3\nn\x3n\x3n\x5n\x8E7"+
		"\nn\x3o\x3o\x5o\x8EB\no\x3o\x3o\x3o\x3p\x3p\x3p\x5p\x8F3\np\x3p\x3p\x3"+
		"p\x3p\x3p\x3p\x3p\x5p\x8FC\np\x3q\x3q\x3q\x3q\x6q\x902\nq\rq\xEq\x903"+
		"\x3r\x3r\x3r\x3r\x3r\x3r\x3s\x3s\x3s\x3s\x3s\x3s\x5s\x912\ns\x3s\x3s\x3"+
		"s\x3s\x3s\x3s\x3s\x3s\x3s\x3s\x3s\x3s\x3s\x3s\x3s\x3s\x3s\x3s\x5s\x926"+
		"\ns\x3t\x3t\x5t\x92A\nt\x3t\x3t\x3t\x3u\x3u\x5u\x931\nu\x3u\x3u\x5u\x935"+
		"\nu\x3v\x3v\x5v\x939\nv\x3v\x3v\x5v\x93D\nv\x3w\x3w\x3w\x3x\x3x\x3x\x3"+
		"x\x3x\ax\x947\nx\fx\xEx\x94A\vx\x3x\x5x\x94D\nx\x3x\x3x\x3x\x3y\x3y\x3"+
		"y\x3y\x3y\x3z\x3z\x3z\x3{\x5{\x95B\n{\x3{\x3{\x3{\x3{\x5{\x961\n{\x3{"+
		"\x3{\x3{\x3{\x3{\x5{\x968\n{\x3|\x3|\x3|\x5|\x96D\n|\x3|\x3|\x3|\x3|\x3"+
		"|\x3|\x3|\x3|\x5|\x977\n|\x3|\x3|\x3|\x3|\x5|\x97D\n|\x5|\x97F\n|\x3}"+
		"\x3}\x3}\x3}\x3}\x3}\x3}\x5}\x988\n}\x3~\x3~\x3~\x3~\x3~\x3~\x3~\x3~\x5"+
		"~\x992\n~\x3~\x3~\x3~\x5~\x997\n~\x3\x7F\x3\x7F\x3\x7F\x3\x7F\x3\x7F\x3"+
		"\x80\x3\x80\x3\x81\x3\x81\x3\x82\x3\x82\x3\x83\x3\x83\x5\x83\x9A6\n\x83"+
		"\x3\x84\x3\x84\x5\x84\x9AA\n\x84\x3\x85\x5\x85\x9AD\n\x85\x3\x85\x3\x85"+
		"\x5\x85\x9B1\n\x85\x3\x86\x3\x86\x3\x86\x3\x86\x6\x86\x9B7\n\x86\r\x86"+
		"\xE\x86\x9B8\x5\x86\x9BB\n\x86\x3\x86\x3\x86\x5\x86\x9BF\n\x86\x3\x87"+
		"\x3\x87\x3\x87\x3\x87\a\x87\x9C5\n\x87\f\x87\xE\x87\x9C8\v\x87\x3\x87"+
		"\x3\x87\x3\x87\x3\x88\x5\x88\x9CE\n\x88\x3\x88\x6\x88\x9D1\n\x88\r\x88"+
		"\xE\x88\x9D2\x5\x88\x9D5\n\x88\x3\x88\x3\x88\x3\x89\x5\x89\x9DA\n\x89"+
		"\x3\x89\x6\x89\x9DD\n\x89\r\x89\xE\x89\x9DE\x3\x89\x3\x89\x3\x8A\x3\x8A"+
		"\x3\x8A\x3\x8A\x5\x8A\x9E7\n\x8A\x3\x8B\x3\x8B\x3\x8B\x3\x8B\x3\x8B\x5"+
		"\x8B\x9EE\n\x8B\x3\x8B\x3\x8B\x5\x8B\x9F2\n\x8B\x3\x8B\x5\x8B\x9F5\n\x8B"+
		"\x3\x8C\x3\x8C\x3\x8C\x3\x8D\x3\x8D\x3\x8D\x3\x8D\x3\x8D\x3\x8D\x3\x8D"+
		"\x5\x8D\xA01\n\x8D\x3\x8E\x3\x8E\x3\x8E\x3\x8E\x5\x8E\xA07\n\x8E\x3\x8F"+
		"\x3\x8F\x3\x8F\x3\x90\x3\x90\x3\x90\x5\x90\xA0F\n\x90\x3\x91\x3\x91\x3"+
		"\x91\x3\x91\x3\x91\x3\x91\a\x91\xA17\n\x91\f\x91\xE\x91\xA1A\v\x91\x3"+
		"\x91\x3\x91\x3\x91\x3\x91\x3\x91\x3\x91\a\x91\xA22\n\x91\f\x91\xE\x91"+
		"\xA25\v\x91\x5\x91\xA27\n\x91\x3\x92\x3\x92\x3\x92\x3\x92\x3\x92\x5\x92"+
		"\xA2E\n\x92\x3\x92\x5\x92\xA31\n\x92\x3\x93\x3\x93\x3\x93\x3\x93\x3\x93"+
		"\x5\x93\xA38\n\x93\x3\x94\x3\x94\x3\x94\x3\x94\x3\x94\x3\x94\x3\x94\x3"+
		"\x94\x3\x94\x5\x94\xA43\n\x94\x3\x94\x3\x94\x3\x94\x3\x94\x5\x94\xA49"+
		"\n\x94\x3\x94\x3\x94\x5\x94\xA4D\n\x94\x3\x95\x3\x95\x3\x95\x3\x95\x3"+
		"\x95\x3\x95\a\x95\xA55\n\x95\f\x95\xE\x95\xA58\v\x95\x5\x95\xA5A\n\x95"+
		"\x3\x95\x3\x95\x3\x96\x3\x96\x5\x96\xA60\n\x96\x3\x96\x3\x96\x3\x96\x3"+
		"\x96\x3\x96\x3\x96\x3\x96\x3\x96\x3\x96\x5\x96\xA6B\n\x96\x5\x96\xA6D"+
		"\n\x96\x5\x96\xA6F\n\x96\x3\x96\x5\x96\xA72\n\x96\x3\x97\x3\x97\x5\x97"+
		"\xA76\n\x97\x3\x97\x5\x97\xA79\n\x97\x3\x98\x3\x98\x5\x98\xA7D\n\x98\x3"+
		"\x98\x3\x98\x5\x98\xA81\n\x98\x3\x98\x3\x98\x3\x98\x5\x98\xA86\n\x98\x3"+
		"\x99\x3\x99\x3\x99\x3\x9A\x3\x9A\x3\x9A\x3\x9A\x3\x9A\x3\x9A\x5\x9A\xA91"+
		"\n\x9A\x3\x9A\x3\x9A\x5\x9A\xA95\n\x9A\x3\x9A\x3\x9A\x3\x9A\x3\x9A\x3"+
		"\x9A\x3\x9A\x5\x9A\xA9D\n\x9A\x3\x9B\x5\x9B\xAA0\n\x9B\x3\x9B\x3\x9B\x3"+
		"\x9B\a\x9B\xAA5\n\x9B\f\x9B\xE\x9B\xAA8\v\x9B\x3\x9C\x3\x9C\x3\x9C\x3"+
		"\x9C\a\x9C\xAAE\n\x9C\f\x9C\xE\x9C\xAB1\v\x9C\x3\x9D\x3\x9D\x3\x9D\x3"+
		"\x9D\x3\x9D\a\x9D\xAB8\n\x9D\f\x9D\xE\x9D\xABB\v\x9D\x3\x9D\x3\x9D\x5"+
		"\x9D\xABF\n\x9D\x3\x9D\x3\x9D\x3\x9D\x3\x9D\x5\x9D\xAC5\n\x9D\x3\x9D\x3"+
		"\x9D\x5\x9D\xAC9\n\x9D\x3\x9D\x5\x9D\xACC\n\x9D\x3\x9E\x3\x9E\x3\x9E\x3"+
		"\x9E\x3\x9E\x3\x9E\x5\x9E\xAD4\n\x9E\x3\x9E\x5\x9E\xAD7\n\x9E\x3\x9E\x3"+
		"\x9E\x5\x9E\xADB\n\x9E\x3\x9E\x3\x9E\x5\x9E\xADF\n\x9E\x3\x9E\x3\x9E\x3"+
		"\x9E\x5\x9E\xAE4\n\x9E\x3\x9E\x5\x9E\xAE7\n\x9E\x3\x9E\x3\x9E\x5\x9E\xAEB"+
		"\n\x9E\x3\x9E\x3\x9E\x5\x9E\xAEF\n\x9E\a\x9E\xAF1\n\x9E\f\x9E\xE\x9E\xAF4"+
		"\v\x9E\x3\x9E\x3\x9E\x3\x9E\x3\x9F\x3\x9F\x3\x9F\x3\x9F\a\x9F\xAFD\n\x9F"+
		"\f\x9F\xE\x9F\xB00\v\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3"+
		"\x9F\x3\xA0\x3\xA0\a\xA0\xB0B\n\xA0\f\xA0\xE\xA0\xB0E\v\xA0\x3\xA1\x3"+
		"\xA1\x5\xA1\xB12\n\xA1\x3\xA1\x3\xA1\x5\xA1\xB16\n\xA1\x3\xA1\x3\xA1\x3"+
		"\xA2\x3\xA2\x3\xA2\x3\xA2\x3\xA2\x5\xA2\xB1F\n\xA2\x3\xA3\x3\xA3\x5\xA3"+
		"\xB23\n\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\a\xA3\xB29\n\xA3\f\xA3\xE\xA3"+
		"\xB2C\v\xA3\x5\xA3\xB2E\n\xA3\x3\xA3\x5\xA3\xB31\n\xA3\x3\xA3\x3\xA3\x5"+
		"\xA3\xB35\n\xA3\x3\xA3\x5\xA3\xB38\n\xA3\x3\xA3\x5\xA3\xB3B\n\xA3\x3\xA3"+
		"\x5\xA3\xB3E\n\xA3\x3\xA4\x3\xA4\x5\xA4\xB42\n\xA4\x3\xA5\x3\xA5\x3\xA5"+
		"\x3\xA6\x3\xA6\x3\xA6\x3\xA6\x3\xA6\x5\xA6\xB4C\n\xA6\x3\xA7\x3\xA7\x3"+
		"\xA7\a\xA7\xB51\n\xA7\f\xA7\xE\xA7\xB54\v\xA7\x3\xA8\x3\xA8\a\xA8\xB58"+
		"\n\xA8\f\xA8\xE\xA8\xB5B\v\xA8\x3\xA8\x3\xA8\x5\xA8\xB5F\n\xA8\x3\xA9"+
		"\x3\xA9\a\xA9\xB63\n\xA9\f\xA9\xE\xA9\xB66\v\xA9\x3\xA9\x5\xA9\xB69\n"+
		"\xA9\x3\xAA\x3\xAA\x3\xAA\x5\xAA\xB6E\n\xAA\x3\xAA\x3\xAA\x3\xAA\a\xAA"+
		"\xB73\n\xAA\f\xAA\xE\xAA\xB76\v\xAA\x3\xAA\x3\xAA\x3\xAA\x5\xAA\xB7B\n"+
		"\xAA\x3\xAA\x3\xAA\x3\xAA\x3\xAA\x3\xAA\x5\xAA\xB82\n\xAA\x3\xAB\x5\xAB"+
		"\xB85\n\xAB\x3\xAB\x5\xAB\xB88\n\xAB\x3\xAB\x3\xAB\x5\xAB\xB8C\n\xAB\x3"+
		"\xAB\x3\xAB\x3\xAB\x5\xAB\xB91\n\xAB\x3\xAB\x3\xAB\a\xAB\xB95\n\xAB\f"+
		"\xAB\xE\xAB\xB98\v\xAB\x3\xAC\x3\xAC\x3\xAC\x3\xAD\x3\xAD\x3\xAD\x3\xAD"+
		"\x3\xAD\a\xAD\xBA2\n\xAD\f\xAD\xE\xAD\xBA5\v\xAD\x3\xAD\x3\xAD\x3\xAE"+
		"\x3\xAE\x5\xAE\xBAB\n\xAE\x3\xAF\x3\xAF\x3\xAF\x3\xAF\x3\xAF\x3\xAF\x3"+
		"\xAF\x3\xAF\x3\xAF\x3\xAF\a\xAF\xBB7\n\xAF\f\xAF\xE\xAF\xBBA\v\xAF\x5"+
		"\xAF\xBBC\n\xAF\x3\xB0\x3\xB0\x3\xB0\x3\xB0\x3\xB0\x3\xB0\x3\xB0\x3\xB0"+
		"\x5\xB0\xBC6\n\xB0\x3\xB1\x3\xB1\x5\xB1\xBCA\n\xB1\x3\xB1\x3\xB1\x3\xB1"+
		"\x3\xB1\a\xB1\xBD0\n\xB1\f\xB1\xE\xB1\xBD3\v\xB1\x3\xB1\x3\xB1\x3\xB1"+
		"\x3\xB1\x3\xB2\x3\xB2\x3\xB2\x3\xB2\x3\xB2\x5\xB2\xBDE\n\xB2\x3\xB3\x3"+
		"\xB3\x3\xB3\x3\xB3\x3\xB3\x3\xB3\a\xB3\xBE6\n\xB3\f\xB3\xE\xB3\xBE9\v"+
		"\xB3\x3\xB3\x3\xB3\x5\xB3\xBED\n\xB3\x3\xB4\x3\xB4\x3\xB4\x3\xB4\x3\xB4"+
		"\x3\xB4\a\xB4\xBF5\n\xB4\f\xB4\xE\xB4\xBF8\v\xB4\x3\xB4\x3\xB4\x3\xB4"+
		"\a\xB4\xBFD\n\xB4\f\xB4\xE\xB4\xC00\v\xB4\x5\xB4\xC02\n\xB4\x3\xB4\x3"+
		"\xB4\x3\xB5\x3\xB5\x5\xB5\xC08\n\xB5\x3\xB6\x3\xB6\x5\xB6\xC0C\n\xB6\x3"+
		"\xB7\x3\xB7\x3\xB7\x5\xB7\xC11\n\xB7\x3\xB7\x3\xB7\x3\xB7\x3\xB7\x3\xB7"+
		"\x3\xB7\a\xB7\xC19\n\xB7\f\xB7\xE\xB7\xC1C\v\xB7\x3\xB7\x3\xB7\x5\xB7"+
		"\xC20\n\xB7\x3\xB7\x3\xB7\x3\xB7\x3\xB7\x3\xB8\x3\xB8\x3\xB8\x3\xB8\x3"+
		"\xB8\a\xB8\xC2B\n\xB8\f\xB8\xE\xB8\xC2E\v\xB8\x3\xB8\x3\xB8\x3\xB9\x3"+
		"\xB9\x3\xB9\x3\xB9\x3\xB9\a\xB9\xC37\n\xB9\f\xB9\xE\xB9\xC3A\v\xB9\x3"+
		"\xB9\x3\xB9\x5\xB9\xC3E\n\xB9\x3\xB9\x3\xB9\x3\xB9\x3\xB9\x3\xB9\x3\xB9"+
		"\a\xB9\xC46\n\xB9\f\xB9\xE\xB9\xC49\v\xB9\x3\xB9\x3\xB9\x5\xB9\xC4D\n"+
		"\xB9\x5\xB9\xC4F\n\xB9\x3\xBA\x3\xBA\x3\xBA\x5\xBA\xC54\n\xBA\x3\xBA\x3"+
		"\xBA\x5\xBA\xC58\n\xBA\x3\xBA\x3\xBA\x3\xBA\x3\xBA\x5\xBA\xC5E\n\xBA\x3"+
		"\xBA\x3\xBA\x5\xBA\xC62\n\xBA\x3\xBB\x3\xBB\x3\xBB\x3\xBB\x3\xBC\x3\xBC"+
		"\x3\xBC\x3\xBC\x3\xBC\a\xBC\xC6D\n\xBC\f\xBC\xE\xBC\xC70\v\xBC\x3\xBC"+
		"\x5\xBC\xC73\n\xBC\x3\xBC\x3\xBC\x3\xBC\x3\xBC\x3\xBC\x3\xBC\a\xBC\xC7B"+
		"\n\xBC\f\xBC\xE\xBC\xC7E\v\xBC\x5\xBC\xC80\n\xBC\x5\xBC\xC82\n\xBC\x3"+
		"\xBD\x3\xBD\x3\xBD\x5\xBD\xC87\n\xBD\x3\xBE\x3\xBE\x3\xBE\x3\xBE\x3\xBE"+
		"\a\xBE\xC8E\n\xBE\f\xBE\xE\xBE\xC91\v\xBE\x3\xBE\x3\xBE\x3\xBF\x3\xBF"+
		"\x3\xBF\x3\xBF\x3\xBF\x3\xBF\a\xBF\xC9B\n\xBF\f\xBF\xE\xBF\xC9E\v\xBF"+
		"\x3\xBF\x3\xBF\x3\xC0\x3\xC0\x3\xC0\x5\xC0\xCA5\n\xC0\x3\xC1\x3\xC1\x3"+
		"\xC1\x3\xC2\x3\xC2\a\xC2\xCAC\n\xC2\f\xC2\xE\xC2\xCAF\v\xC2\x3\xC2\x5"+
		"\xC2\xCB2\n\xC2\x3\xC2\a\xC2\xCB5\n\xC2\f\xC2\xE\xC2\xCB8\v\xC2\x3\xC2"+
		"\x3\xC2\x3\xC3\x3\xC3\x3\xC3\x3\xC3\x3\xC3\x3\xC3\x5\xC3\xCC2\n\xC3\x5"+
		"\xC3\xCC4\n\xC3\x3\xC4\x3\xC4\x3\xC4\x3\xC4\x3\xC5\x3\xC5\x3\xC5\x3\xC5"+
		"\x3\xC5\x3\xC5\x3\xC5\x3\xC5\a\xC5\xCD2\n\xC5\f\xC5\xE\xC5\xCD5\v\xC5"+
		"\x3\xC6\x3\xC6\x5\xC6\xCD9\n\xC6\x3\xC6\x3\xC6\a\xC6\xCDD\n\xC6\f\xC6"+
		"\xE\xC6\xCE0\v\xC6\x3\xC6\x3\xC6\x3\xC7\x5\xC7\xCE5\n\xC7\x3\xC7\x3\xC7"+
		"\x3\xC7\x3\xC7\x3\xC7\x3\xC7\x3\xC8\x3\xC8\x3\xC8\x3\xC8\x3\xC9\x3\xC9"+
		"\x3\xC9\x3\xC9\a\xC9\xCF5\n\xC9\f\xC9\xE\xC9\xCF8\v\xC9\x3\xC9\x3\xC9"+
		"\x3\xCA\x3\xCA\x5\xCA\xCFE\n\xCA\x3\xCA\x5\xCA\xD01\n\xCA\x3\xCB\x5\xCB"+
		"\xD04\n\xCB\x3\xCB\x3\xCB\x3\xCB\x3\xCB\a\xCB\xD0A\n\xCB\f\xCB\xE\xCB"+
		"\xD0D\v\xCB\x5\xCB\xD0F\n\xCB\x3\xCB\x3\xCB\x3\xCC\x3\xCC\x3\xCC\x3\xCC"+
		"\x5\xCC\xD17\n\xCC\x5\xCC\xD19\n\xCC\x3\xCC\x3\xCC\x5\xCC\xD1D\n\xCC\x3"+
		"\xCC\x5\xCC\xD20\n\xCC\x3\xCD\x3\xCD\x3\xCD\x5\xCD\xD25\n\xCD\x5\xCD\xD27"+
		"\n\xCD\x3\xCD\x3\xCD\x5\xCD\xD2B\n\xCD\x3\xCD\x3\xCD\x3\xCD\x3\xCE\x3"+
		"\xCE\x3\xCF\x3\xCF\x3\xCF\x3\xCF\x3\xCF\x5\xCF\xD37\n\xCF\x3\xD0\x3\xD0"+
		"\x3\xD0\x3\xD0\x3\xD0\x3\xD1\x3\xD1\x5\xD1\xD40\n\xD1\x3\xD1\x3\xD1\x3"+
		"\xD1\x3\xD1\a\xD1\xD46\n\xD1\f\xD1\xE\xD1\xD49\v\xD1\x3\xD2\x3\xD2\x5"+
		"\xD2\xD4D\n\xD2\x3\xD2\x3\xD2\x5\xD2\xD51\n\xD2\x3\xD3\x3\xD3\x3\xD3\x5"+
		"\xD3\xD56\n\xD3\x3\xD3\x5\xD3\xD59\n\xD3\x3\xD4\x3\xD4\x3\xD4\x3\xD4\a"+
		"\xD4\xD5F\n\xD4\f\xD4\xE\xD4\xD62\v\xD4\x3\xD5\x3\xD5\x3\xD5\x3\xD5\x3"+
		"\xD5\x5\xD5\xD69\n\xD5\x3\xD6\x3\xD6\x3\xD6\x3\xD6\x5\xD6\xD6F\n\xD6\x3"+
		"\xD6\x5\xD6\xD72\n\xD6\x3\xD6\x5\xD6\xD75\n\xD6\x3\xD7\x3\xD7\x3\xD7\x3"+
		"\xD7\a\xD7\xD7B\n\xD7\f\xD7\xE\xD7\xD7E\v\xD7\x3\xD7\x3\xD7\x3\xD7\x3"+
		"\xD7\x3\xD7\x3\xD7\x3\xD7\x5\xD7\xD87\n\xD7\x3\xD8\x3\xD8\x3\xD8\x3\xD8"+
		"\x3\xD8\x3\xD8\x3\xD8\x3\xD8\a\xD8\xD91\n\xD8\f\xD8\xE\xD8\xD94\v\xD8"+
		"\x3\xD8\x3\xD8\x3\xD8\x3\xD8\x5\xD8\xD9A\n\xD8\x3\xD9\x3\xD9\x5\xD9\xD9E"+
		"\n\xD9\x3\xD9\x3\xD9\x5\xD9\xDA2\n\xD9\x3\xD9\x5\xD9\xDA5\n\xD9\x3\xD9"+
		"\x5\xD9\xDA8\n\xD9\x3\xDA\x3\xDA\x3\xDA\x5\xDA\xDAD\n\xDA\x3\xDB\x3\xDB"+
		"\x3\xDB\x5\xDB\xDB2\n\xDB\x3\xDB\x5\xDB\xDB5\n\xDB\x3\xDB\x5\xDB\xDB8"+
		"\n\xDB\x3\xDC\x3\xDC\x6\xDC\xDBC\n\xDC\r\xDC\xE\xDC\xDBD\x3\xDC\x5\xDC"+
		"\xDC1\n\xDC\x3\xDC\x3\xDC\x3\xDD\x3\xDD\x5\xDD\xDC7\n\xDD\x3\xDD\x5\xDD"+
		"\xDCA\n\xDD\x3\xDE\x5\xDE\xDCD\n\xDE\x3\xDE\x6\xDE\xDD0\n\xDE\r\xDE\xE"+
		"\xDE\xDD1\x3\xDE\x5\xDE\xDD5\n\xDE\x3\xDF\x3\xDF\x3\xDF\x3\xDF\x6\xDF"+
		"\xDDB\n\xDF\r\xDF\xE\xDF\xDDC\x3\xE0\x3\xE0\x6\xE0\xDE1\n\xE0\r\xE0\xE"+
		"\xE0\xDE2\x3\xE1\x3\xE1\x3\xE1\x3\xE1\x3\xE1\x3\xE1\a\xE1\xDEB\n\xE1\f"+
		"\xE1\xE\xE1\xDEE\v\xE1\x3\xE1\x3\xE1\x5\xE1\xDF2\n\xE1\x3\xE2\x3\xE2\x3"+
		"\xE2\x3\xE3\x3\xE3\x3\xE3\x3\xE3\x5\xE3\xDFB\n\xE3\x3\xE3\x3\xE3\x3\xE3"+
		"\x3\xE3\x3\xE3\x3\xE3\x3\xE3\x3\xE3\x5\xE3\xE05\n\xE3\x3\xE3\x3\xE3\x5"+
		"\xE3\xE09\n\xE3\x5\xE3\xE0B\n\xE3\x3\xE3\x5\xE3\xE0E\n\xE3\x3\xE4\x3\xE4"+
		"\x3\xE4\x3\xE4\x3\xE4\x3\xE4\x3\xE4\x3\xE4\a\xE4\xE18\n\xE4\f\xE4\xE\xE4"+
		"\xE1B\v\xE4\x3\xE4\x5\xE4\xE1E\n\xE4\x3\xE4\x5\xE4\xE21\n\xE4\x3\xE5\x3"+
		"\xE5\x3\xE5\x3\xE5\x3\xE6\x3\xE6\x3\xE6\x3\xE7\x3\xE7\x3\xE7\x3\xE7\x3"+
		"\xE7\x3\xE7\x3\xE7\x3\xE7\x3\xE7\a\xE7\xE33\n\xE7\f\xE7\xE\xE7\xE36\v"+
		"\xE7\x3\xE7\x3\xE7\x5\xE7\xE3A\n\xE7\x3\xE7\x3\xE7\x3\xE7\x5\xE7\xE3F"+
		"\n\xE7\x3\xE8\x3\xE8\x3\xE8\x3\xE8\x3\xE8\x5\xE8\xE46\n\xE8\x3\xE8\x5"+
		"\xE8\xE49\n\xE8\x3\xE9\x3\xE9\x3\xE9\x3\xE9\x3\xE9\a\xE9\xE50\n\xE9\f"+
		"\xE9\xE\xE9\xE53\v\xE9\x3\xE9\x3\xE9\x3\xE9\x3\xE9\x5\xE9\xE59\n\xE9\x3"+
		"\xEA\x3\xEA\x3\xEA\x5\xEA\xE5E\n\xEA\x3\xEB\x3\xEB\x5\xEB\xE62\n\xEB\x3"+
		"\xEC\x3\xEC\x3\xEC\x3\xEC\x3\xEC\x3\xEC\x5\xEC\xE6A\n\xEC\x3\xEC\x3\xEC"+
		"\x3\xEC\x3\xEC\x5\xEC\xE70\n\xEC\x3\xED\x3\xED\x3\xED\x3\xED\x3\xED\x3"+
		"\xED\x5\xED\xE78\n\xED\x3\xED\x5\xED\xE7B\n\xED\x3\xEE\x3\xEE\x3\xEE\x3"+
		"\xEE\a\xEE\xE81\n\xEE\f\xEE\xE\xEE\xE84\v\xEE\x3\xEE\x3\xEE\x3\xEF\x3"+
		"\xEF\x3\xEF\x5\xEF\xE8B\n\xEF\x3\xEF\x5\xEF\xE8E\n\xEF\x3\xEF\x5\xEF\xE91"+
		"\n\xEF\x3\xF0\x3\xF0\x3\xF0\x3\xF1\x3\xF1\x3\xF1\x3\xF1\x5\xF1\xE9A\n"+
		"\xF1\x3\xF2\x3\xF2\x3\xF2\x3\xF2\x5\xF2\xEA0\n\xF2\x3\xF2\x3\xF2\x3\xF2"+
		"\x3\xF2\x5\xF2\xEA6\n\xF2\x5\xF2\xEA8\n\xF2\x3\xF3\x3\xF3\x3\xF3\x3\xF3"+
		"\x3\xF3\x3\xF3\x3\xF3\x3\xF3\x3\xF3\x3\xF3\x3\xF3\x5\xF3\xEB5\n\xF3\x5"+
		"\xF3\xEB7\n\xF3\x3\xF4\x3\xF4\x3\xF4\x3\xF4\x3\xF4\x3\xF4\x3\xF4\x5\xF4"+
		"\xEC0\n\xF4\x5\xF4\xEC2\n\xF4\x3\xF5\x3\xF5\x5\xF5\xEC6\n\xF5\x3\xF5\x3"+
		"\xF5\x3\xF5\x3\xF5\x5\xF5\xECC\n\xF5\x3\xF5\x3\xF5\x5\xF5\xED0\n\xF5\x3"+
		"\xF6\x3\xF6\x3\xF6\x3\xF6\x3\xF6\x3\xF7\x3\xF7\x3\xF7\x3\xF7\x3\xF7\x3"+
		"\xF8\x3\xF8\x5\xF8\xEDE\n\xF8\x3\xF8\x3\xF8\a\xF8\xEE2\n\xF8\f\xF8\xE"+
		"\xF8\xEE5\v\xF8\x3\xF8\x3\xF8\x3\xF9\x3\xF9\x3\xFA\x3\xFA\x5\xFA\xEED"+
		"\n\xFA\x3\xFB\x3\xFB\x3\xFB\x3\xFB\x3\xFB\x3\xFB\a\xFB\xEF5\n\xFB\f\xFB"+
		"\xE\xFB\xEF8\v\xFB\x3\xFC\x3\xFC\x3\xFC\x3\xFC\x3\xFC\x3\xFC\a\xFC\xF00"+
		"\n\xFC\f\xFC\xE\xFC\xF03\v\xFC\x3\xFD\x3\xFD\x3\xFD\x5\xFD\xF08\n\xFD"+
		"\x3\xFE\x3\xFE\x3\xFE\x5\xFE\xF0D\n\xFE\x3\xFE\x3\xFE\x3\xFE\x3\xFE\x3"+
		"\xFE\x3\xFE\x3\xFE\x3\xFE\x3\xFE\x5\xFE\xF18\n\xFE\x3\xFE\x3\xFE\x5\xFE"+
		"\xF1C\n\xFE\x3\xFE\x3\xFE\x3\xFE\a\xFE\xF21\n\xFE\f\xFE\xE\xFE\xF24\v"+
		"\xFE\x3\xFE\x3\xFE\x5\xFE\xF28\n\xFE\a\xFE\xF2A\n\xFE\f\xFE\xE\xFE\xF2D"+
		"\v\xFE\x3\xFF\x3\xFF\x3\xFF\x5\xFF\xF32\n\xFF\x3\xFF\x3\xFF\x5\xFF\xF36"+
		"\n\xFF\x3\x100\x3\x100\x3\x101\x3\x101\x3\x101\x3\x101\x3\x101\x3\x101"+
		"\x3\x101\a\x101\xF41\n\x101\f\x101\xE\x101\xF44\v\x101\x3\x102\x3\x102"+
		"\x5\x102\xF48\n\x102\x3\x102\x3\x102\x3\x102\x3\x102\x3\x102\x3\x102\x3"+
		"\x102\x5\x102\xF51\n\x102\x5\x102\xF53\n\x102\x5\x102\xF55\n\x102\x3\x103"+
		"\x3\x103\x3\x103\x3\x103\x3\x103\x3\x103\x5\x103\xF5D\n\x103\x3\x104\x3"+
		"\x104\x3\x105\x3\x105\x3\x105\x3\x106\x3\x106\x3\x106\x3\x106\x3\x106"+
		"\x3\x106\x3\x106\x3\x106\a\x106\xF6C\n\x106\f\x106\xE\x106\xF6F\v\x106"+
		"\x3\x106\x3\x106\x3\x106\x3\x106\x3\x106\x5\x106\xF76\n\x106\x3\x107\x3"+
		"\x107\x3\x107\x3\x107\x3\x108\x3\x108\x3\x108\x3\x108\a\x108\xF80\n\x108"+
		"\f\x108\xE\x108\xF83\v\x108\x3\x109\x3\x109\x3\x109\a\x109\xF88\n\x109"+
		"\f\x109\xE\x109\xF8B\v\x109\x3\x10A\x3\x10A\x3\x10A\a\x10A\xF90\n\x10A"+
		"\f\x10A\xE\x10A\xF93\v\x10A\x3\x10B\x3\x10B\x3\x10B\x3\x10B\x3\x10B\x3"+
		"\x10B\x5\x10B\xF9B\n\x10B\x3\x10B\x5\x10B\xF9E\n\x10B\x3\x10C\x3\x10C"+
		"\x3\x10C\x3\x10C\x3\x10C\x5\x10C\xFA5\n\x10C\x3\x10C\x3\x10C\x3\x10C\x3"+
		"\x10C\x3\x10C\x3\x10C\x5\x10C\xFAD\n\x10C\x3\x10C\x3\x10C\x3\x10C\x3\x10C"+
		"\x3\x10C\x5\x10C\xFB4\n\x10C\x3\x10C\x3\x10C\x5\x10C\xFB8\n\x10C\x3\x10D"+
		"\x3\x10D\x3\x10D\x3\x10D\x3\x10D\x5\x10D\xFBF\n\x10D\x3\x10E\x3\x10E\x5"+
		"\x10E\xFC3\n\x10E\x3\x10E\x3\x10E\x3\x10E\x5\x10E\xFC8\n\x10E\a\x10E\xFCA"+
		"\n\x10E\f\x10E\xE\x10E\xFCD\v\x10E\x3\x10E\x3\x10E\x3\x10E\a\x10E\xFD2"+
		"\n\x10E\f\x10E\xE\x10E\xFD5\v\x10E\x3\x10E\x5\x10E\xFD8\n\x10E\x3\x10F"+
		"\x3\x10F\x3\x10F\x3\x10F\x3\x10F\x5\x10F\xFDF\n\x10F\x3\x10F\x3\x10F\x3"+
		"\x10F\x3\x10F\x3\x10F\x3\x10F\x3\x10F\x5\x10F\xFE8\n\x10F\x3\x110\x3\x110"+
		"\x3\x110\x3\x111\x3\x111\x3\x112\x3\x112\x3\x112\x3\x112\x3\x112\a\x112"+
		"\xFF4\n\x112\f\x112\xE\x112\xFF7\v\x112\x3\x112\x3\x112\x3\x112\x3\x112"+
		"\x3\x112\x3\x112\x3\x112\x3\x112\a\x112\x1001\n\x112\f\x112\xE\x112\x1004"+
		"\v\x112\x3\x112\x3\x112\x5\x112\x1008\n\x112\x3\x112\x3\x112\x3\x113\x3"+
		"\x113\x3\x113\x3\x113\x3\x113\x3\x113\x3\x113\x3\x113\x3\x113\x3\x113"+
		"\x3\x113\x3\x113\x3\x113\x3\x113\x3\x113\x3\x113\x5\x113\x101C\n\x113"+
		"\x3\x114\x3\x114\x5\x114\x1020\n\x114\x3\x115\x5\x115\x1023\n\x115\x3"+
		"\x115\x3\x115\x3\x115\x6\x115\x1028\n\x115\r\x115\xE\x115\x1029\x3\x115"+
		"\x5\x115\x102D\n\x115\x3\x115\x3\x115\x5\x115\x1031\n\x115\x3\x115\x5"+
		"\x115\x1034\n\x115\x3\x116\x3\x116\x3\x116\x3\x116\x3\x116\x5\x116\x103B"+
		"\n\x116\x3\x117\x5\x117\x103E\n\x117\x3\x117\x3\x117\x6\x117\x1042\n\x117"+
		"\r\x117\xE\x117\x1043\x3\x117\x5\x117\x1047\n\x117\x3\x117\x3\x117\x5"+
		"\x117\x104B\n\x117\x3\x117\x5\x117\x104E\n\x117\x3\x118\x3\x118\x3\x118"+
		"\x3\x118\x3\x118\x5\x118\x1055\n\x118\x3\x119\x3\x119\x3\x119\x5\x119"+
		"\x105A\n\x119\x3\x11A\x3\x11A\x3\x11A\x3\x11A\x3\x11A\x3\x11A\x3\x11A"+
		"\x3\x11A\x3\x11A\x3\x11A\a\x11A\x1066\n\x11A\f\x11A\xE\x11A\x1069\v\x11A"+
		"\x3\x11A\x3\x11A\x3\x11A\x5\x11A\x106E\n\x11A\x5\x11A\x1070\n\x11A\x3"+
		"\x11B\x3\x11B\x5\x11B\x1074\n\x11B\x3\x11C\x3\x11C\x3\x11C\x3\x11C\a\x11C"+
		"\x107A\n\x11C\f\x11C\xE\x11C\x107D\v\x11C\x3\x11D\x3\x11D\x3\x11D\x3\x11D"+
		"\x3\x11D\x3\x11D\x3\x11D\x3\x11D\x3\x11D\x5\x11D\x1088\n\x11D\x3\x11E"+
		"\x3\x11E\x3\x11E\x3\x11E\x3\x11E\x3\x11E\x3\x11E\x5\x11E\x1091\n\x11E"+
		"\x3\x11E\x3\x11E\x3\x11E\x3\x11E\x3\x11E\x3\x11E\x5\x11E\x1099\n\x11E"+
		"\x3\x11E\x3\x11E\x5\x11E\x109D\n\x11E\x3\x11E\x3\x11E\x3\x11E\x3\x11E"+
		"\x3\x11E\x3\x11E\x3\x11E\a\x11E\x10A6\n\x11E\f\x11E\xE\x11E\x10A9\v\x11E"+
		"\x3\x11E\x3\x11E\x3\x11E\x3\x11E\x3\x11E\x3\x11E\x3\x11E\x3\x11E\x3\x11E"+
		"\x3\x11E\x3\x11E\x3\x11E\x3\x11E\x3\x11E\x3\x11E\x3\x11E\x3\x11E\x3\x11E"+
		"\x3\x11E\x5\x11E\x10BE\n\x11E\x3\x11E\x5\x11E\x10C1\n\x11E\x3\x11E\x5"+
		"\x11E\x10C4\n\x11E\x3\x11E\x3\x11E\x3\x11E\x5\x11E\x10C9\n\x11E\x3\x11F"+
		"\x3\x11F\x3\x11F\x5\x11F\x10CE\n\x11F\x3\x120\x3\x120\x3\x120\x5\x120"+
		"\x10D3\n\x120\x3\x121\x3\x121\x3\x121\x5\x121\x10D8\n\x121\x3\x121\x3"+
		"\x121\x3\x121\x3\x121\x3\x121\x3\x121\x3\x121\x5\x121\x10E1\n\x121\x3"+
		"\x121\x5\x121\x10E4\n\x121\x5\x121\x10E6\n\x121\x3\x121\x3\x121\x5\x121"+
		"\x10EA\n\x121\x3\x121\x3\x121\x3\x121\x3\x121\x3\x121\x5\x121\x10F1\n"+
		"\x121\x3\x121\x3\x121\x3\x121\x3\x121\x3\x121\x5\x121\x10F8\n\x121\x3"+
		"\x121\x3\x121\x3\x121\x3\x121\x3\x121\x3\x121\x5\x121\x1100\n\x121\x3"+
		"\x121\x3\x121\x3\x121\x5\x121\x1105\n\x121\x3\x122\x3\x122\x3\x122\x5"+
		"\x122\x110A\n\x122\x3\x122\x3\x122\x3\x122\x5\x122\x110F\n\x122\x3\x122"+
		"\x3\x122\x3\x122\x3\x122\x5\x122\x1115\n\x122\x3\x122\x5\x122\x1118\n"+
		"\x122\x3\x122\x3\x122\x5\x122\x111C\n\x122\x3\x122\x3\x122\x3\x122\x3"+
		"\x122\x3\x122\x3\x122\x3\x122\x3\x122\x5\x122\x1126\n\x122\x3\x122\x3"+
		"\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122"+
		"\x5\x122\x1132\n\x122\x5\x122\x1134\n\x122\x3\x122\x3\x122\x3\x122\x3"+
		"\x122\x3\x122\x5\x122\x113B\n\x122\x3\x122\x3\x122\x5\x122\x113F\n\x122"+
		"\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x6\x122\x1146\n\x122\r\x122\xE"+
		"\x122\x1147\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x5"+
		"\x122\x1151\n\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3"+
		"\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x5\x122\x115F\n\x122\x3"+
		"\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\a\x122\x1168\n\x122"+
		"\f\x122\xE\x122\x116B\v\x122\x3\x122\x5\x122\x116E\n\x122\x3\x122\x5\x122"+
		"\x1171\n\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122"+
		"\x5\x122\x117A\n\x122\x3\x122\x3\x122\a\x122\x117E\n\x122\f\x122\xE\x122"+
		"\x1181\v\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122"+
		"\x5\x122\x118A\n\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122"+
		"\x5\x122\x1192\n\x122\x3\x122\x5\x122\x1195\n\x122\x3\x122\x5\x122\x1198"+
		"\n\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x5\x122"+
		"\x11A1\n\x122\x3\x122\x3\x122\x3\x122\x5\x122\x11A6\n\x122\x3\x122\x3"+
		"\x122\x3\x122\x3\x122\x3\x122\a\x122\x11AD\n\x122\f\x122\xE\x122\x11B0"+
		"\v\x122\x3\x122\x3\x122\x3\x122\x5\x122\x11B5\n\x122\x3\x122\x3\x122\x3"+
		"\x122\x5\x122\x11BA\n\x122\x3\x122\x5\x122\x11BD\n\x122\x3\x122\x3\x122"+
		"\x3\x122\x5\x122\x11C2\n\x122\x3\x122\x3\x122\x3\x122\x5\x122\x11C7\n"+
		"\x122\a\x122\x11C9\n\x122\f\x122\xE\x122\x11CC\v\x122\x3\x122\x3\x122"+
		"\x3\x122\x5\x122\x11D1\n\x122\x3\x122\x3\x122\x3\x122\x3\x122\x5\x122"+
		"\x11D7\n\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122"+
		"\x5\x122\x11E0\n\x122\x3\x122\x3\x122\x3\x122\x5\x122\x11E5\n\x122\x3"+
		"\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x5\x122\x11ED\n\x122\x3"+
		"\x122\x3\x122\x5\x122\x11F1\n\x122\x3\x122\x3\x122\x3\x122\x5\x122\x11F6"+
		"\n\x122\x3\x122\x3\x122\x3\x122\x3\x122\x5\x122\x11FC\n\x122\x3\x122\x3"+
		"\x122\x3\x122\x3\x122\x3\x122\x5\x122\x1203\n\x122\x3\x122\x3\x122\x3"+
		"\x122\x5\x122\x1208\n\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x5"+
		"\x122\x120F\n\x122\x3\x122\x3\x122\x5\x122\x1213\n\x122\x3\x122\x3\x122"+
		"\x3\x122\x5\x122\x1218\n\x122\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122"+
		"\x3\x122\x5\x122\x1220\n\x122\x3\x122\x5\x122\x1223\n\x122\x3\x122\x5"+
		"\x122\x1226\n\x122\x3\x122\x5\x122\x1229\n\x122\x3\x122\x3\x122\x5\x122"+
		"\x122D\n\x122\x3\x122\x3\x122\x3\x122\x5\x122\x1232\n\x122\x3\x122\x3"+
		"\x122\x3\x122\x5\x122\x1237\n\x122\x3\x122\x3\x122\x5\x122\x123B\n\x122"+
		"\x3\x122\x3\x122\x3\x122\x3\x122\x3\x122\x5\x122\x1242\n\x122\x3\x122"+
		"\x3\x122\x3\x122\x5\x122\x1247\n\x122\x5\x122\x1249\n\x122\x3\x123\x3"+
		"\x123\x3\x124\x3\x124\x3\x125\x3\x125\x3\x126\x3\x126\x3\x126\x5\x126"+
		"\x1254\n\x126\x3\x126\x3\x126\x5\x126\x1258\n\x126\x5\x126\x125A\n\x126"+
		"\x3\x126\x3\x126\x3\x127\x3\x127\x3\x127\x3\x127\x3\x127\x3\x127\x3\x127"+
		"\x5\x127\x1265\n\x127\x3\x128\x3\x128\x3\x129\x3\x129\x3\x129\x3\x129"+
		"\x3\x129\x3\x129\x3\x129\x5\x129\x1270\n\x129\x3\x12A\x3\x12A\x3\x12A"+
		"\x3\x12A\x3\x12A\a\x12A\x1277\n\x12A\f\x12A\xE\x12A\x127A\v\x12A\x5\x12A"+
		"\x127C\n\x12A\x3\x12B\x3\x12B\x5\x12B\x1280\n\x12B\x3\x12B\x5\x12B\x1283"+
		"\n\x12B\x3\x12B\x3\x12B\x5\x12B\x1287\n\x12B\x3\x12C\x3\x12C\x3\x12C\x3"+
		"\x12C\x3\x12D\x3\x12D\x3\x12D\x3\x12D\x3\x12D\x3\x12D\x3\x12D\x5\x12D"+
		"\x1294\n\x12D\x3\x12E\x3\x12E\x3\x12E\x5\x12E\x1299\n\x12E\x3\x12E\x3"+
		"\x12E\x3\x12E\x3\x12E\a\x12E\x129F\n\x12E\f\x12E\xE\x12E\x12A2\v\x12E"+
		"\x3\x12E\x3\x12E\x3\x12E\x3\x12E\x5\x12E\x12A8\n\x12E\x3\x12F\x3\x12F"+
		"\x3\x12F\x5\x12F\x12AD\n\x12F\x3\x12F\x3\x12F\x5\x12F\x12B1\n\x12F\x3"+
		"\x12F\x3\x12F\x3\x12F\x5\x12F\x12B6\n\x12F\x3\x130\x3\x130\x3\x130\x5"+
		"\x130\x12BB\n\x130\x3\x130\x5\x130\x12BE\n\x130\x3\x130\x3\x130\x3\x130"+
		"\a\x130\x12C3\n\x130\f\x130\xE\x130\x12C6\v\x130\x3\x130\x3\x130\x3\x131"+
		"\x3\x131\x3\x131\x3\x131\x3\x131\x5\x131\x12CF\n\x131\x3\x131\x3\x131"+
		"\x3\x131\x3\x131\a\x131\x12D5\n\x131\f\x131\xE\x131\x12D8\v\x131\x3\x131"+
		"\x5\x131\x12DB\n\x131\x3\x131\x3\x131\x3\x132\x3\x132\x3\x132\x3\x132"+
		"\x3\x132\x3\x132\x5\x132\x12E5\n\x132\x3\x132\x5\x132\x12E8\n\x132\x5"+
		"\x132\x12EA\n\x132\x3\x133\x3\x133\x3\x133\x3\x134\x3\x134\x3\x134\x3"+
		"\x134\x3\x134\x5\x134\x12F4\n\x134\x5\x134\x12F6\n\x134\x3\x135\x3\x135"+
		"\x3\x135\x3\x135\x5\x135\x12FC\n\x135\x3\x136\x3\x136\x3\x136\x3\x136"+
		"\x5\x136\x1302\n\x136\x5\x136\x1304\n\x136\x3\x137\x3\x137\x3\x137\x3"+
		"\x138\x3\x138\x3\x138\x3\x139\x3\x139\x3\x139\x3\x139\x3\x139\x3\x139"+
		"\x5\x139\x1312\n\x139\x5\x139\x1314\n\x139\x3\x13A\x3\x13A\x3\x13A\x3"+
		"\x13A\x3\x13A\x3\x13A\x5\x13A\x131C\n\x13A\x3\x13A\x5\x13A\x131F\n\x13A"+
		"\x3\x13B\x3\x13B\x3\x13B\x3\x13B\x3\x13B\x3\x13B\x3\x13B\x5\x13B\x1328"+
		"\n\x13B\x3\x13C\x3\x13C\x3\x13C\x3\x13C\x3\x13C\x3\x13C\x3\x13C\x5\x13C"+
		"\x1331\n\x13C\x3\x13D\x3\x13D\x3\x13E\x3\x13E\x3\x13F\x3\x13F\x3\x13F"+
		"\x3\x13F\x5\x13F\x133B\n\x13F\x3\x140\x3\x140\x5\x140\x133F\n\x140\x3"+
		"\x140\x3\x140\x3\x141\x5\x141\x1344\n\x141\x3\x141\x3\x141\x5\x141\x1348"+
		"\n\x141\x3\x141\x5\x141\x134B\n\x141\x3\x142\x3\x142\x5\x142\x134F\n\x142"+
		"\x3\x143\x3\x143\x3\x144\x3\x144\x3\x144\x5\x144\x1356\n\x144\x3\x145"+
		"\x3\x145\x3\x145\x3\x145\x3\x146\x3\x146\x3\x146\x3\x146\a\x146\x1360"+
		"\n\x146\f\x146\xE\x146\x1363\v\x146\x3\x146\x3\x146\x3\x146\x3\x146\x3"+
		"\x146\x3\x146\a\x146\x136B\n\x146\f\x146\xE\x146\x136E\v\x146\x5\x146"+
		"\x1370\n\x146\x3\x147\x3\x147\x5\x147\x1374\n\x147\x3\x148\x3\x148\x3"+
		"\x149\x3\x149\x3\x14A\x3\x14A\x3\x14B\x3\x14B\x3\x14C\x3\x14C\x3\x14D"+
		"\x3\x14D\x3\x14E\x3\x14E\x3\x14E\a\x14E\x1385\n\x14E\f\x14E\xE\x14E\x1388"+
		"\v\x14E\x3\x14E\x3\x14E\x5\x14E\x138C\n\x14E\x3\x14F\x3\x14F\x3\x150\x3"+
		"\x150\x3\x150\x5\x150\x1393\n\x150\x3\x151\x3\x151\x3\x152\x3\x152\x3"+
		"\x153\x3\x153\x3\x154\x3\x154\x3\x154\a\x154\x139E\n\x154\f\x154\xE\x154"+
		"\x13A1\v\x154\x3\x155\x3\x155\x3\x156\x3\x156\x3\x156\a\x156\x13A8\n\x156"+
		"\f\x156\xE\x156\x13AB\v\x156\x3\x156\x3\x156\x5\x156\x13AF\n\x156\x3\x157"+
		"\x3\x157\x3\x158\x3\x158\x3\x158\a\x158\x13B6\n\x158\f\x158\xE\x158\x13B9"+
		"\v\x158\x3\x159\x3\x159\x3\x159\a\x159\x13BE\n\x159\f\x159\xE\x159\x13C1"+
		"\v\x159\x3\x15A\x3\x15A\x3\x15A\a\x15A\x13C6\n\x15A\f\x15A\xE\x15A\x13C9"+
		"\v\x15A\x3\x15B\x3\x15B\x3\x15B\x5\x15B\x13CE\n\x15B\x3\x15C\x3\x15C\x3"+
		"\x15C\x5\x15C\x13D3\n\x15C\x3\x15D\x3\x15D\x3\x15D\x5\x15D\x13D8\n\x15D"+
		"\x3\x15E\x3\x15E\x5\x15E\x13DC\n\x15E\x3\x15E\x3\x15E\x3\x15E\x5\x15E"+
		"\x13E1\n\x15E\x3\x15E\x5\x15E\x13E4\n\x15E\x3\x15F\x3\x15F\x3\x160\x3"+
		"\x160\x5\x160\x13EA\n\x160\x3\x161\x3\x161\x5\x161\x13EE\n\x161\x3\x162"+
		"\x3\x162\x3\x162\x5\x162\x13F3\n\x162\x3\x163\x3\x163\x3\x164\x3\x164"+
		"\x3\x164\a\x164\x13FA\n\x164\f\x164\xE\x164\x13FD\v\x164\x3\x165\x3\x165"+
		"\x3\x165\x5\x165\x1402\n\x165\x3\x165\x3\x165\x3\x165\x5\x165\x1407\n"+
		"\x165\x3\x166\x3\x166\x3\x166\a\x166\x140C\n\x166\f\x166\xE\x166\x140F"+
		"\v\x166\x3\x167\x3\x167\x3\x167\x3\x167\x3\x167\x3\x167\x3\x167\x5\x167"+
		"\x1418\n\x167\x3\x168\x3\x168\x5\x168\x141C\n\x168\x3\x168\x3\x168\a\x168"+
		"\x1420\n\x168\f\x168\xE\x168\x1423\v\x168\x3\x168\x3\x168\x5\x168\x1427"+
		"\n\x168\x3\x169\x3\x169\x3\x169\x5\x169\x142C\n\x169\x5\x169\x142E\n\x169"+
		"\x3\x169\x3\x169\x3\x169\x5\x169\x1433\n\x169\a\x169\x1435\n\x169\f\x169"+
		"\xE\x169\x1438\v\x169\x3\x169\x3\x169\x5\x169\x143C\n\x169\x3\x16A\x3"+
		"\x16A\x3\x16A\x3\x16A\x3\x16A\x5\x16A\x1443\n\x16A\x3\x16A\x3\x16A\x3"+
		"\x16A\x5\x16A\x1448\n\x16A\x5\x16A\x144A\n\x16A\x5\x16A\x144C\n\x16A\x3"+
		"\x16A\x3\x16A\x3\x16A\x3\x16A\x3\x16A\x3\x16A\x3\x16A\x3\x16A\x5\x16A"+
		"\x1456\n\x16A\x3\x16A\x3\x16A\x3\x16A\x5\x16A\x145B\n\x16A\a\x16A\x145D"+
		"\n\x16A\f\x16A\xE\x16A\x1460\v\x16A\x5\x16A\x1462\n\x16A\x3\x16A\x3\x16A"+
		"\x5\x16A\x1466\n\x16A\x3\x16B\x3\x16B\x3\x16B\x3\x16C\x3\x16C\x3\x16C"+
		"\x3\x16C\x5\x16C\x146F\n\x16C\x3\x16C\x3\x16C\x3\x16D\x3\x16D\x5\x16D"+
		"\x1475\n\x16D\x3\x16D\x3\x16D\x5\x16D\x1479\n\x16D\x5\x16D\x147B\n\x16D"+
		"\x3\x16E\x3\x16E\x5\x16E\x147F\n\x16E\x3\x16E\x3\x16E\x5\x16E\x1483\n"+
		"\x16E\x3\x16E\x3\x16E\x5\x16E\x1487\n\x16E\x3\x16E\x3\x16E\x3\x16E\x3"+
		"\x16E\x3\x16E\x3\x16E\x5\x16E\x148F\n\x16E\x3\x16E\x3\x16E\x3\x16E\x3"+
		"\x16E\x3\x16E\x3\x16E\x5\x16E\x1497\n\x16E\x5\x16E\x1499\n\x16E\x3\x16F"+
		"\x3\x16F\x3\x16F\x3\x16F\x5\x16F\x149F\n\x16F\x3\x16F\x5\x16F\x14A2\n"+
		"\x16F\x3\x16F\x3\x16F\x3\x170\x3\x170\x3\x170\x3\x170\x3\x170\x3\x170"+
		"\x3\x170\x3\x170\x3\x170\x3\x170\x3\x170\x3\x170\x3\x170\x3\x170\x3\x170"+
		"\x3\x170\x3\x170\x3\x170\x3\x170\x3\x170\x5\x170\x14BA\n\x170\x3\x170"+
		"\x3\x170\x3\x170\x3\x170\x3\x170\x5\x170\x14C1\n\x170\x3\x170\x3\x170"+
		"\x3\x170\x3\x170\x3\x170\x3\x170\x3\x170\x3\x170\x3\x170\x3\x170\x3\x170"+
		"\x3\x170\x3\x170\x3\x170\x3\x170\x3\x170\x3\x170\x3\x170\x3\x170\x3\x170"+
		"\x3\x170\x3\x170\x3\x170\x3\x170\x3\x170\x3\x170\x3\x170\x3\x170\x3\x170"+
		"\x3\x170\x3\x170\x5\x170\x14E2\n\x170\x3\x171\x3\x171\x3\x171\x5\x171"+
		"\x14E7\n\x171\x3\x171\x5\x171\x14EA\n\x171\x3\x171\x3\x171\x3\x171\x5"+
		"\x171\x14EF\n\x171\x5\x171\x14F1\n\x171\x3\x171\x3\x171\a\x171\x14F5\n"+
		"\x171\f\x171\xE\x171\x14F8\v\x171\x3\x172\x3\x172\x3\x172\a\x172\x14FD"+
		"\n\x172\f\x172\xE\x172\x1500\v\x172\x3\x173\x3\x173\x5\x173\x1504\n\x173"+
		"\x3\x173\x3\x173\x3\x173\a\x173\x1509\n\x173\f\x173\xE\x173\x150C\v\x173"+
		"\x3\x173\x5\x173\x150F\n\x173\x3\x174\x3\x174\x5\x174\x1513\n\x174\x3"+
		"\x174\x3\x174\x3\x174\a\x174\x1518\n\x174\f\x174\xE\x174\x151B\v\x174"+
		"\x3\x175\x3\x175\x3\x175\x5\x175\x1520\n\x175\x3\x175\x3\x175\x3\x175"+
		"\x3\x175\x5\x175\x1526\n\x175\x3\x175\x3\x175\x3\x175\x3\x175\x5\x175"+
		"\x152C\n\x175\x3\x175\x3\x175\x3\x175\x3\x175\x5\x175\x1532\n\x175\x3"+
		"\x175\x3\x175\x3\x175\x5\x175\x1537\n\x175\x5\x175\x1539\n\x175\x3\x175"+
		"\x5\x175\x153C\n\x175\x3\x175\x3\x175\x3\x175\x3\x175\x3\x175\x3\x175"+
		"\x3\x175\x3\x175\x5\x175\x1546\n\x175\x3\x175\x5\x175\x1549\n\x175\x5"+
		"\x175\x154B\n\x175\x5\x175\x154D\n\x175\x3\x175\x3\x175\x3\x175\x3\x175"+
		"\x3\x175\x3\x175\x3\x175\x3\x175\x3\x175\x3\x175\x3\x175\x3\x175\x5\x175"+
		"\x155B\n\x175\x3\x176\x3\x176\x3\x177\x3\x177\x3\x177\x3\x178\x3\x178"+
		"\x3\x179\x3\x179\x5\x179\x1566\n\x179\x3\x179\x3\x179\x3\x17A\x3\x17A"+
		"\x5\x17A\x156C\n\x17A\x3\x17B\x3\x17B\x3\x17B\x3\x17B\x3\x17B\x3\x17B"+
		"\x3\x17B\x5\x17B\x1575\n\x17B\x3\x17C\x3\x17C\x3\x17C\x5\x17C\x157A\n"+
		"\x17C\x3\x17D\x3\x17D\x3\x17D\x5\x17D\x157F\n\x17D\x3\x17E\x3\x17E\x3"+
		"\x17E\x5\x17E\x1584\n\x17E\x3\x17F\x3\x17F\x3\x17F\x3\x17F\x3\x180\x3"+
		"\x180\x3\x181\x3\x181\x3\x182\x3\x182\x3\x182\x2\x2\x5\x1F4\x1F6\x200"+
		"\x183\x2\x2\x4\x2\x6\x2\b\x2\n\x2\f\x2\xE\x2\x10\x2\x12\x2\x14\x2\x16"+
		"\x2\x18\x2\x1A\x2\x1C\x2\x1E\x2 \x2\"\x2$\x2&\x2(\x2*\x2,\x2.\x2\x30\x2"+
		"\x32\x2\x34\x2\x36\x2\x38\x2:\x2<\x2>\x2@\x2\x42\x2\x44\x2\x46\x2H\x2"+
		"J\x2L\x2N\x2P\x2R\x2T\x2V\x2X\x2Z\x2\\\x2^\x2`\x2\x62\x2\x64\x2\x66\x2"+
		"h\x2j\x2l\x2n\x2p\x2r\x2t\x2v\x2x\x2z\x2|\x2~\x2\x80\x2\x82\x2\x84\x2"+
		"\x86\x2\x88\x2\x8A\x2\x8C\x2\x8E\x2\x90\x2\x92\x2\x94\x2\x96\x2\x98\x2"+
		"\x9A\x2\x9C\x2\x9E\x2\xA0\x2\xA2\x2\xA4\x2\xA6\x2\xA8\x2\xAA\x2\xAC\x2"+
		"\xAE\x2\xB0\x2\xB2\x2\xB4\x2\xB6\x2\xB8\x2\xBA\x2\xBC\x2\xBE\x2\xC0\x2"+
		"\xC2\x2\xC4\x2\xC6\x2\xC8\x2\xCA\x2\xCC\x2\xCE\x2\xD0\x2\xD2\x2\xD4\x2"+
		"\xD6\x2\xD8\x2\xDA\x2\xDC\x2\xDE\x2\xE0\x2\xE2\x2\xE4\x2\xE6\x2\xE8\x2"+
		"\xEA\x2\xEC\x2\xEE\x2\xF0\x2\xF2\x2\xF4\x2\xF6\x2\xF8\x2\xFA\x2\xFC\x2"+
		"\xFE\x2\x100\x2\x102\x2\x104\x2\x106\x2\x108\x2\x10A\x2\x10C\x2\x10E\x2"+
		"\x110\x2\x112\x2\x114\x2\x116\x2\x118\x2\x11A\x2\x11C\x2\x11E\x2\x120"+
		"\x2\x122\x2\x124\x2\x126\x2\x128\x2\x12A\x2\x12C\x2\x12E\x2\x130\x2\x132"+
		"\x2\x134\x2\x136\x2\x138\x2\x13A\x2\x13C\x2\x13E\x2\x140\x2\x142\x2\x144"+
		"\x2\x146\x2\x148\x2\x14A\x2\x14C\x2\x14E\x2\x150\x2\x152\x2\x154\x2\x156"+
		"\x2\x158\x2\x15A\x2\x15C\x2\x15E\x2\x160\x2\x162\x2\x164\x2\x166\x2\x168"+
		"\x2\x16A\x2\x16C\x2\x16E\x2\x170\x2\x172\x2\x174\x2\x176\x2\x178\x2\x17A"+
		"\x2\x17C\x2\x17E\x2\x180\x2\x182\x2\x184\x2\x186\x2\x188\x2\x18A\x2\x18C"+
		"\x2\x18E\x2\x190\x2\x192\x2\x194\x2\x196\x2\x198\x2\x19A\x2\x19C\x2\x19E"+
		"\x2\x1A0\x2\x1A2\x2\x1A4\x2\x1A6\x2\x1A8\x2\x1AA\x2\x1AC\x2\x1AE\x2\x1B0"+
		"\x2\x1B2\x2\x1B4\x2\x1B6\x2\x1B8\x2\x1BA\x2\x1BC\x2\x1BE\x2\x1C0\x2\x1C2"+
		"\x2\x1C4\x2\x1C6\x2\x1C8\x2\x1CA\x2\x1CC\x2\x1CE\x2\x1D0\x2\x1D2\x2\x1D4"+
		"\x2\x1D6\x2\x1D8\x2\x1DA\x2\x1DC\x2\x1DE\x2\x1E0\x2\x1E2\x2\x1E4\x2\x1E6"+
		"\x2\x1E8\x2\x1EA\x2\x1EC\x2\x1EE\x2\x1F0\x2\x1F2\x2\x1F4\x2\x1F6\x2\x1F8"+
		"\x2\x1FA\x2\x1FC\x2\x1FE\x2\x200\x2\x202\x2\x204\x2\x206\x2\x208\x2\x20A"+
		"\x2\x20C\x2\x20E\x2\x210\x2\x212\x2\x214\x2\x216\x2\x218\x2\x21A\x2\x21C"+
		"\x2\x21E\x2\x220\x2\x222\x2\x224\x2\x226\x2\x228\x2\x22A\x2\x22C\x2\x22E"+
		"\x2\x230\x2\x232\x2\x234\x2\x236\x2\x238\x2\x23A\x2\x23C\x2\x23E\x2\x240"+
		"\x2\x242\x2\x244\x2\x246\x2\x248\x2\x24A\x2\x24C\x2\x24E\x2\x250\x2\x252"+
		"\x2\x254\x2\x256\x2\x258\x2\x25A\x2\x25C\x2\x25E\x2\x260\x2\x262\x2\x264"+
		"\x2\x266\x2\x268\x2\x26A\x2\x26C\x2\x26E\x2\x270\x2\x272\x2\x274\x2\x276"+
		"\x2\x278\x2\x27A\x2\x27C\x2\x27E\x2\x280\x2\x282\x2\x284\x2\x286\x2\x288"+
		"\x2\x28A\x2\x28C\x2\x28E\x2\x290\x2\x292\x2\x294\x2\x296\x2\x298\x2\x29A"+
		"\x2\x29C\x2\x29E\x2\x2A0\x2\x2A2\x2\x2A4\x2\x2A6\x2\x2A8\x2\x2AA\x2\x2AC"+
		"\x2\x2AE\x2\x2B0\x2\x2B2\x2\x2B4\x2\x2B6\x2\x2B8\x2\x2BA\x2\x2BC\x2\x2BE"+
		"\x2\x2C0\x2\x2C2\x2\x2C4\x2\x2C6\x2\x2C8\x2\x2CA\x2\x2CC\x2\x2CE\x2\x2D0"+
		"\x2\x2D2\x2\x2D4\x2\x2D6\x2\x2D8\x2\x2DA\x2\x2DC\x2\x2DE\x2\x2E0\x2\x2E2"+
		"\x2\x2E4\x2\x2E6\x2\x2E8\x2\x2EA\x2\x2EC\x2\x2EE\x2\x2F0\x2\x2F2\x2\x2F4"+
		"\x2\x2F6\x2\x2F8\x2\x2FA\x2\x2FC\x2\x2FE\x2\x300\x2\x302\x2\x2V\x3\x2"+
		"\x201\x201\x4\x2\xF\xF\xBD\xBD\x4\x2\b\b\x122\x122\x4\x2\xA0\xA0\x12F"+
		"\x12F\x4\x2\x38\x38\x10E\x10E\x5\x2##\x115\x115\x16C\x16C\x4\x2nnzz\x4"+
		"\x2\x6\x6\x1A\x1A\x5\x2ii\xB4\xB4\x199\x199\x5\x2\xF0\xF0\x107\x107\x118"+
		"\x118\x4\x2\x98\x98\x19F\x19F\x4\x2##\x16C\x16C\x4\x2\x5\x5ss\x5\x2\x5"+
		"\x5ss\xE4\xE4\x5\x2VV\x10D\x10D\x16D\x16D\x4\x2\xD8\xD8\x10E\x10E\x4\x2"+
		"\xDC\xDC\x174\x174\x5\x2\x90\x90\xB5\xB5\x114\x114\x4\x2TThh\x6\x2\xA7"+
		"\xA7\xB3\xB3\xF4\xF4\x111\x111\x4\x2\x65\x65\x1FE\x1FE\x3\x3\x201\x201"+
		"\x3\x2\x13F\x140\x4\x2\x109\x109\x1B3\x1B3\x3\x2\x45\x46\x4\x2gg\xA6\xA6"+
		"\x4\x2\xFD\xFD\x1A9\x1A9\x4\x2\x19\x19\xA6\xA6\x4\x2&&jj\x5\x2\t\tpp\x195"+
		"\x195\x4\x2QQ\xE9\xE9\x5\x2\x9A\x9A\xC7\xC7\x144\x144\x4\x2\x150\x150"+
		"\x181\x181\x5\x2\x150\x150\x16A\x16A\x181\x181\x4\x2\x85\x85\xA8\xA8\x4"+
		"\x2RR\x146\x146\x4\x2\xA5\xA5\xC2\xC2\x4\x2\t\t\x19A\x19A\x4\x2\x17\x17"+
		"\x158\x158\x4\x2\x10\x10kk\x4\x2\x91\x91\xC4\xC4\x4\x2\t\t\x91\x91\x3"+
		"\x2\x17D\x17E\x4\x2\xDC\xDC\x177\x177\x3\x2\xCA\xCD\x3\x2\x1F9\x1FA\x4"+
		"\x2\x1F8\x1F8\x1FC\x1FC\x4\x2\x64\x64\xAA\xAA\x6\x2\t\t\r\r\x88\x88\x16B"+
		"\x16B\x5\x2%%\xC6\xC6\x18A\x18A\x4\x2\t\tpp\x4\x2\x30\x30\x1B7\x1B7\x4"+
		"\x2pp\x195\x195\x3\x2\x11C\x11F\x4\x2--??\x4\x2\x92\x92\xC5\xC5\x4\x2"+
		"\x32\x32\xED\xED\x4\x2\x1B8\x1B8\x1BB\x1BB\x4\x2}}\xF6\xF6\x4\x2\x81\x81"+
		"\xE7\xE7\x4\x2HHqq\x4\x2\xA2\xA2\x161\x161\a\x2\x1D4\x1D6\x1D8\x1DD\x1DF"+
		"\x1E0\x1E2\x1E2\x1E6\x1E9\x3\x2\x1CD\x1D3\x3\x2\x1C7\x1CC\x4\x2\x12F\x12F"+
		"\x149\x149\x4\x2\x94\x94\x129\x129\x4\x2\xFB\xFB\x14F\x14F\x4\x2\x110"+
		"\x110\x16E\x16E\x5\x2\x8D\x8D\x17B\x17B\x1AA\x1AA\x4\x2==\x145\x145\x5"+
		"\x2==\xF9\xF9\x145\x145\x4\x2\x119\x119\x178\x178\x4\x2\xA5\xA5\x13B\x13B"+
		"\x3\x2\x120\x121\x4\x2[[\x1C3\x1C3\x4\x2\xE5\xE5\x152\x152\x4\x2))\x31"+
		"\x31\x6\x2[[\xA3\xA3\xDF\xDF\x152\x152\x3\x2\x1EF\x1F0\x4\x2\x1EA\x1EA"+
		"\x1F1\x1F1L\x2\x4\b\v\v\xE\xE\x11\x1A\x1D%\'\')*,.\x30\x33\x35\x38:\x41"+
		"\x44OQRTY[\x61\x63\x64\x66hloqrtvy{}\x85\x87\x87\x89\x8D\x90\x95\x97\x98"+
		"\x9A\x9B\x9F\xA0\xA2\xA3\xA5\xA6\xA8\xAB\xAD\xB3\xB5\xB8\xBA\xBA\xBC\xBC"+
		"\xBE\xC9\xCB\xCF\xD1\xDD\xDF\xE1\xE3\xF2\xF4\xF6\xF9\xF9\xFB\xFB\xFF\x103"+
		"\x105\x107\x109\x10A\x10D\x10D\x10F\x11B\x122\x122\x124\x12B\x12E\x142"+
		"\x144\x150\x152\x154\x156\x156\x158\x15F\x161\x166\x168\x16F\x171\x17C"+
		"\x180\x188\x18A\x18E\x190\x193\x196\x196\x198\x198\x19A\x19D\x19F\x1A0"+
		"\x1A2\x1AB\x1AD\x1AD\x1AF\x1AF\x1B1\x1D6\x1D8\x1DD\x1DF\x1E0\x1E2\x1E2"+
		"\x1E5\x1E9\x214\x214\x5\x2\x35\x35\x1D7\x1D7\x1E3\x1E5\a\x2OO\x1D4\x1D4"+
		"\x1DE\x1DE\x1E1\x1E1\x1E6\x1E6\x180B\x2\x305\x3\x2\x2\x2\x4\x30C\x3\x2"+
		"\x2\x2\x6\x315\x3\x2\x2\x2\b\x31D\x3\x2\x2\x2\n\x346\x3\x2\x2\x2\f\x348"+
		"\x3\x2\x2\x2\xE\x34D\x3\x2\x2\x2\x10\x360\x3\x2\x2\x2\x12\x397\x3\x2\x2"+
		"\x2\x14\x39B\x3\x2\x2\x2\x16\x3B3\x3\x2\x2\x2\x18\x3B7\x3\x2\x2\x2\x1A"+
		"\x3C3\x3\x2\x2\x2\x1C\x3D1\x3\x2\x2\x2\x1E\x3D9\x3\x2\x2\x2 \x3EF\x3\x2"+
		"\x2\x2\"\x406\x3\x2\x2\x2$\x427\x3\x2\x2\x2&\x429\x3\x2\x2\x2(\x43A\x3"+
		"\x2\x2\x2*\x45C\x3\x2\x2\x2,\x45E\x3\x2\x2\x2.\x463\x3\x2\x2\x2\x30\x476"+
		"\x3\x2\x2\x2\x32\x4A8\x3\x2\x2\x2\x34\x4C8\x3\x2\x2\x2\x36\x4F0\x3\x2"+
		"\x2\x2\x38\x4F5\x3\x2\x2\x2:\x50E\x3\x2\x2\x2<\x526\x3\x2\x2\x2>\x52F"+
		"\x3\x2\x2\x2@\x538\x3\x2\x2\x2\x42\x541\x3\x2\x2\x2\x44\x545\x3\x2\x2"+
		"\x2\x46\x54A\x3\x2\x2\x2H\x562\x3\x2\x2\x2J\x564\x3\x2\x2\x2L\x568\x3"+
		"\x2\x2\x2N\x59C\x3\x2\x2\x2P\x5B8\x3\x2\x2\x2R\x5BA\x3\x2\x2\x2T\x5C8"+
		"\x3\x2\x2\x2V\x5D4\x3\x2\x2\x2X\x5D9\x3\x2\x2\x2Z\x5DF\x3\x2\x2\x2\\\x5E2"+
		"\x3\x2\x2\x2^\x5ED\x3\x2\x2\x2`\x5FC\x3\x2\x2\x2\x62\x60D\x3\x2\x2\x2"+
		"\x64\x61E\x3\x2\x2\x2\x66\x626\x3\x2\x2\x2h\x62B\x3\x2\x2\x2j\x63B\x3"+
		"\x2\x2\x2l\x63F\x3\x2\x2\x2n\x657\x3\x2\x2\x2p\x65A\x3\x2\x2\x2r\x660"+
		"\x3\x2\x2\x2t\x66C\x3\x2\x2\x2v\x675\x3\x2\x2\x2x\x691\x3\x2\x2\x2z\x697"+
		"\x3\x2\x2\x2|\x69A\x3\x2\x2\x2~\x6A1\x3\x2\x2\x2\x80\x6A9\x3\x2\x2\x2"+
		"\x82\x6B5\x3\x2\x2\x2\x84\x6B7\x3\x2\x2\x2\x86\x6BB\x3\x2\x2\x2\x88\x6C1"+
		"\x3\x2\x2\x2\x8A\x6DD\x3\x2\x2\x2\x8C\x6FF\x3\x2\x2\x2\x8E\x72F\x3\x2"+
		"\x2\x2\x90\x739\x3\x2\x2\x2\x92\x73B\x3\x2\x2\x2\x94\x740\x3\x2\x2\x2"+
		"\x96\x74E\x3\x2\x2\x2\x98\x750\x3\x2\x2\x2\x9A\x755\x3\x2\x2\x2\x9C\x765"+
		"\x3\x2\x2\x2\x9E\x786\x3\x2\x2\x2\xA0\x7A9\x3\x2\x2\x2\xA2\x7AD\x3\x2"+
		"\x2\x2\xA4\x7BC\x3\x2\x2\x2\xA6\x7BE\x3\x2\x2\x2\xA8\x7C1\x3\x2\x2\x2"+
		"\xAA\x7C6\x3\x2\x2\x2\xAC\x7D0\x3\x2\x2\x2\xAE\x7EC\x3\x2\x2\x2\xB0\x7EE"+
		"\x3\x2\x2\x2\xB2\x7F2\x3\x2\x2\x2\xB4\x7F5\x3\x2\x2\x2\xB6\x7F9\x3\x2"+
		"\x2\x2\xB8\x7FE\x3\x2\x2\x2\xBA\x802\x3\x2\x2\x2\xBC\x813\x3\x2\x2\x2"+
		"\xBE\x820\x3\x2\x2\x2\xC0\x831\x3\x2\x2\x2\xC2\x83E\x3\x2\x2\x2\xC4\x84B"+
		"\x3\x2\x2\x2\xC6\x84D\x3\x2\x2\x2\xC8\x85B\x3\x2\x2\x2\xCA\x86C\x3\x2"+
		"\x2\x2\xCC\x885\x3\x2\x2\x2\xCE\x88F\x3\x2\x2\x2\xD0\x893\x3\x2\x2\x2"+
		"\xD2\x8B6\x3\x2\x2\x2\xD4\x8C2\x3\x2\x2\x2\xD6\x8CD\x3\x2\x2\x2\xD8\x8D3"+
		"\x3\x2\x2\x2\xDA\x8DE\x3\x2\x2\x2\xDC\x8EA\x3\x2\x2\x2\xDE\x8F2\x3\x2"+
		"\x2\x2\xE0\x901\x3\x2\x2\x2\xE2\x905\x3\x2\x2\x2\xE4\x925\x3\x2\x2\x2"+
		"\xE6\x929\x3\x2\x2\x2\xE8\x92E\x3\x2\x2\x2\xEA\x936\x3\x2\x2\x2\xEC\x93E"+
		"\x3\x2\x2\x2\xEE\x941\x3\x2\x2\x2\xF0\x951\x3\x2\x2\x2\xF2\x956\x3\x2"+
		"\x2\x2\xF4\x95A\x3\x2\x2\x2\xF6\x97E\x3\x2\x2\x2\xF8\x980\x3\x2\x2\x2"+
		"\xFA\x996\x3\x2\x2\x2\xFC\x998\x3\x2\x2\x2\xFE\x99D\x3\x2\x2\x2\x100\x99F"+
		"\x3\x2\x2\x2\x102\x9A1\x3\x2\x2\x2\x104\x9A3\x3\x2\x2\x2\x106\x9A7\x3"+
		"\x2\x2\x2\x108\x9AC\x3\x2\x2\x2\x10A\x9B2\x3\x2\x2\x2\x10C\x9C0\x3\x2"+
		"\x2\x2\x10E\x9D4\x3\x2\x2\x2\x110\x9D9\x3\x2\x2\x2\x112\x9E6\x3\x2\x2"+
		"\x2\x114\x9E8\x3\x2\x2\x2\x116\x9F6\x3\x2\x2\x2\x118\xA00\x3\x2\x2\x2"+
		"\x11A\xA06\x3\x2\x2\x2\x11C\xA08\x3\x2\x2\x2\x11E\xA0B\x3\x2\x2\x2\x120"+
		"\xA10\x3\x2\x2\x2\x122\xA28\x3\x2\x2\x2\x124\xA37\x3\x2\x2\x2\x126\xA39"+
		"\x3\x2\x2\x2\x128\xA4E\x3\x2\x2\x2\x12A\xA5D\x3\x2\x2\x2\x12C\xA73\x3"+
		"\x2\x2\x2\x12E\xA7A\x3\x2\x2\x2\x130\xA87\x3\x2\x2\x2\x132\xA8A\x3\x2"+
		"\x2\x2\x134\xA9F\x3\x2\x2\x2\x136\xAA9\x3\x2\x2\x2\x138\xAB2\x3\x2\x2"+
		"\x2\x13A\xACD\x3\x2\x2\x2\x13C\xAF8\x3\x2\x2\x2\x13E\xB08\x3\x2\x2\x2"+
		"\x140\xB15\x3\x2\x2\x2\x142\xB1E\x3\x2\x2\x2\x144\xB20\x3\x2\x2\x2\x146"+
		"\xB3F\x3\x2\x2\x2\x148\xB43\x3\x2\x2\x2\x14A\xB4B\x3\x2\x2\x2\x14C\xB4D"+
		"\x3\x2\x2\x2\x14E\xB55\x3\x2\x2\x2\x150\xB60\x3\x2\x2\x2\x152\xB81\x3"+
		"\x2\x2\x2\x154\xB84\x3\x2\x2\x2\x156\xB99\x3\x2\x2\x2\x158\xB9C\x3\x2"+
		"\x2\x2\x15A\xBA8\x3\x2\x2\x2\x15C\xBAC\x3\x2\x2\x2\x15E\xBC5\x3\x2\x2"+
		"\x2\x160\xBC7\x3\x2\x2\x2\x162\xBD8\x3\x2\x2\x2\x164\xBDF\x3\x2\x2\x2"+
		"\x166\xBEE\x3\x2\x2\x2\x168\xC05\x3\x2\x2\x2\x16A\xC0B\x3\x2\x2\x2\x16C"+
		"\xC0D\x3\x2\x2\x2\x16E\xC25\x3\x2\x2\x2\x170\xC3D\x3\x2\x2\x2\x172\xC61"+
		"\x3\x2\x2\x2\x174\xC63\x3\x2\x2\x2\x176\xC81\x3\x2\x2\x2\x178\xC86\x3"+
		"\x2\x2\x2\x17A\xC88\x3\x2\x2\x2\x17C\xC94\x3\x2\x2\x2\x17E\xCA4\x3\x2"+
		"\x2\x2\x180\xCA6\x3\x2\x2\x2\x182\xCA9\x3\x2\x2\x2\x184\xCC3\x3\x2\x2"+
		"\x2\x186\xCC5\x3\x2\x2\x2\x188\xCC9\x3\x2\x2\x2\x18A\xCD8\x3\x2\x2\x2"+
		"\x18C\xCE4\x3\x2\x2\x2\x18E\xCEC\x3\x2\x2\x2\x190\xCF0\x3\x2\x2\x2\x192"+
		"\xCFD\x3\x2\x2\x2\x194\xD03\x3\x2\x2\x2\x196\xD12\x3\x2\x2\x2\x198\xD26"+
		"\x3\x2\x2\x2\x19A\xD2F\x3\x2\x2\x2\x19C\xD31\x3\x2\x2\x2\x19E\xD38\x3"+
		"\x2\x2\x2\x1A0\xD3D\x3\x2\x2\x2\x1A2\xD4A\x3\x2\x2\x2\x1A4\xD52\x3\x2"+
		"\x2\x2\x1A6\xD5A\x3\x2\x2\x2\x1A8\xD68\x3\x2\x2\x2\x1AA\xD6A\x3\x2\x2"+
		"\x2\x1AC\xD76\x3\x2\x2\x2\x1AE\xD99\x3\x2\x2\x2\x1B0\xD9B\x3\x2\x2\x2"+
		"\x1B2\xDA9\x3\x2\x2\x2\x1B4\xDAE\x3\x2\x2\x2\x1B6\xDC0\x3\x2\x2\x2\x1B8"+
		"\xDC4\x3\x2\x2\x2\x1BA\xDCC\x3\x2\x2\x2\x1BC\xDD6\x3\x2\x2\x2\x1BE\xDDE"+
		"\x3\x2\x2\x2\x1C0\xDE4\x3\x2\x2\x2\x1C2\xDF3\x3\x2\x2\x2\x1C4\xDF6\x3"+
		"\x2\x2\x2\x1C6\xE0F\x3\x2\x2\x2\x1C8\xE22\x3\x2\x2\x2\x1CA\xE26\x3\x2"+
		"\x2\x2\x1CC\xE29\x3\x2\x2\x2\x1CE\xE45\x3\x2\x2\x2\x1D0\xE4A\x3\x2\x2"+
		"\x2\x1D2\xE5D\x3\x2\x2\x2\x1D4\xE5F\x3\x2\x2\x2\x1D6\xE6F\x3\x2\x2\x2"+
		"\x1D8\xE77\x3\x2\x2\x2\x1DA\xE7C\x3\x2\x2\x2\x1DC\xE87\x3\x2\x2\x2\x1DE"+
		"\xE92\x3\x2\x2\x2\x1E0\xE95\x3\x2\x2\x2\x1E2\xEA7\x3\x2\x2\x2\x1E4\xEA9"+
		"\x3\x2\x2\x2\x1E6\xEB8\x3\x2\x2\x2\x1E8\xEC3\x3\x2\x2\x2\x1EA\xED1\x3"+
		"\x2\x2\x2\x1EC\xED6\x3\x2\x2\x2\x1EE\xEDB\x3\x2\x2\x2\x1F0\xEE8\x3\x2"+
		"\x2\x2\x1F2\xEEC\x3\x2\x2\x2\x1F4\xEEE\x3\x2\x2\x2\x1F6\xEF9\x3\x2\x2"+
		"\x2\x1F8\xF07\x3\x2\x2\x2\x1FA\xF09\x3\x2\x2\x2\x1FC\xF2E\x3\x2\x2\x2"+
		"\x1FE\xF37\x3\x2\x2\x2\x200\xF39\x3\x2\x2\x2\x202\xF45\x3\x2\x2\x2\x204"+
		"\xF5C\x3\x2\x2\x2\x206\xF5E\x3\x2\x2\x2\x208\xF60\x3\x2\x2\x2\x20A\xF75"+
		"\x3\x2\x2\x2\x20C\xF77\x3\x2\x2\x2\x20E\xF7B\x3\x2\x2\x2\x210\xF84\x3"+
		"\x2\x2\x2\x212\xF8C\x3\x2\x2\x2\x214\xF94\x3\x2\x2\x2\x216\xFB7\x3\x2"+
		"\x2\x2\x218\xFB9\x3\x2\x2\x2\x21A\xFD7\x3\x2\x2\x2\x21C\xFD9\x3\x2\x2"+
		"\x2\x21E\xFE9\x3\x2\x2\x2\x220\xFEC\x3\x2\x2\x2\x222\xFEE\x3\x2\x2\x2"+
		"\x224\x101B\x3\x2\x2\x2\x226\x101F\x3\x2\x2\x2\x228\x1022\x3\x2\x2\x2"+
		"\x22A\x1035\x3\x2\x2\x2\x22C\x103D\x3\x2\x2\x2\x22E\x104F\x3\x2\x2\x2"+
		"\x230\x1056\x3\x2\x2\x2\x232\x106F\x3\x2\x2\x2\x234\x1071\x3\x2\x2\x2"+
		"\x236\x1075\x3\x2\x2\x2\x238\x107E\x3\x2\x2\x2\x23A\x10C8\x3\x2\x2\x2"+
		"\x23C\x10CD\x3\x2\x2\x2\x23E\x10CF\x3\x2\x2\x2\x240\x1104\x3\x2\x2\x2"+
		"\x242\x1248\x3\x2\x2\x2\x244\x124A\x3\x2\x2\x2\x246\x124C\x3\x2\x2\x2"+
		"\x248\x124E\x3\x2\x2\x2\x24A\x1250\x3\x2\x2\x2\x24C\x125D\x3\x2\x2\x2"+
		"\x24E\x1266\x3\x2\x2\x2\x250\x126F\x3\x2\x2\x2\x252\x1271\x3\x2\x2\x2"+
		"\x254\x1282\x3\x2\x2\x2\x256\x1288\x3\x2\x2\x2\x258\x1293\x3\x2\x2\x2"+
		"\x25A\x1295\x3\x2\x2\x2\x25C\x12A9\x3\x2\x2\x2\x25E\x12B7\x3\x2\x2\x2"+
		"\x260\x12C9\x3\x2\x2\x2\x262\x12DE\x3\x2\x2\x2\x264\x12EB\x3\x2\x2\x2"+
		"\x266\x12EE\x3\x2\x2\x2\x268\x12F7\x3\x2\x2\x2\x26A\x12FD\x3\x2\x2\x2"+
		"\x26C\x1305\x3\x2\x2\x2\x26E\x1308\x3\x2\x2\x2\x270\x1313\x3\x2\x2\x2"+
		"\x272\x131B\x3\x2\x2\x2\x274\x1320\x3\x2\x2\x2\x276\x1329\x3\x2\x2\x2"+
		"\x278\x1332\x3\x2\x2\x2\x27A\x1334\x3\x2\x2\x2\x27C\x133A\x3\x2\x2\x2"+
		"\x27E\x133C\x3\x2\x2\x2\x280\x134A\x3\x2\x2\x2\x282\x134E\x3\x2\x2\x2"+
		"\x284\x1350\x3\x2\x2\x2\x286\x1352\x3\x2\x2\x2\x288\x1357\x3\x2\x2\x2"+
		"\x28A\x136F\x3\x2\x2\x2\x28C\x1373\x3\x2\x2\x2\x28E\x1375\x3\x2\x2\x2"+
		"\x290\x1377\x3\x2\x2\x2\x292\x1379\x3\x2\x2\x2\x294\x137B\x3\x2\x2\x2"+
		"\x296\x137D\x3\x2\x2\x2\x298\x137F\x3\x2\x2\x2\x29A\x1381\x3\x2\x2\x2"+
		"\x29C\x138D\x3\x2\x2\x2\x29E\x138F\x3\x2\x2\x2\x2A0\x1394\x3\x2\x2\x2"+
		"\x2A2\x1396\x3\x2\x2\x2\x2A4\x1398\x3\x2\x2\x2\x2A6\x139A\x3\x2\x2\x2"+
		"\x2A8\x13A2\x3\x2\x2\x2\x2AA\x13A4\x3\x2\x2\x2\x2AC\x13B0\x3\x2\x2\x2"+
		"\x2AE\x13B2\x3\x2\x2\x2\x2B0\x13BA\x3\x2\x2\x2\x2B2\x13C2\x3\x2\x2\x2"+
		"\x2B4\x13CA\x3\x2\x2\x2\x2B6\x13CF\x3\x2\x2\x2\x2B8\x13D4\x3\x2\x2\x2"+
		"\x2BA\x13E3\x3\x2\x2\x2\x2BC\x13E5\x3\x2\x2\x2\x2BE\x13E9\x3\x2\x2\x2"+
		"\x2C0\x13ED\x3\x2\x2\x2\x2C2\x13EF\x3\x2\x2\x2\x2C4\x13F4\x3\x2\x2\x2"+
		"\x2C6\x13F6\x3\x2\x2\x2\x2C8\x13FE\x3\x2\x2\x2\x2CA\x1408\x3\x2\x2\x2"+
		"\x2CC\x1410\x3\x2\x2\x2\x2CE\x1419\x3\x2\x2\x2\x2D0\x1428\x3\x2\x2\x2"+
		"\x2D2\x143D\x3\x2\x2\x2\x2D4\x1467\x3\x2\x2\x2\x2D6\x146E\x3\x2\x2\x2"+
		"\x2D8\x147A\x3\x2\x2\x2\x2DA\x1498\x3\x2\x2\x2\x2DC\x149A\x3\x2\x2\x2"+
		"\x2DE\x14E1\x3\x2\x2\x2\x2E0\x14E6\x3\x2\x2\x2\x2E2\x14F9\x3\x2\x2\x2"+
		"\x2E4\x1503\x3\x2\x2\x2\x2E6\x1512\x3\x2\x2\x2\x2E8\x155A\x3\x2\x2\x2"+
		"\x2EA\x155C\x3\x2\x2\x2\x2EC\x155E\x3\x2\x2\x2\x2EE\x1561\x3\x2\x2\x2"+
		"\x2F0\x1565\x3\x2\x2\x2\x2F2\x156B\x3\x2\x2\x2\x2F4\x1574\x3\x2\x2\x2"+
		"\x2F6\x1579\x3\x2\x2\x2\x2F8\x157E\x3\x2\x2\x2\x2FA\x1583\x3\x2\x2\x2"+
		"\x2FC\x1585\x3\x2\x2\x2\x2FE\x1589\x3\x2\x2\x2\x300\x158B\x3\x2\x2\x2"+
		"\x302\x158D\x3\x2\x2\x2\x304\x306\n\x2\x2\x2\x305\x304\x3\x2\x2\x2\x306"+
		"\x307\x3\x2\x2\x2\x307\x305\x3\x2\x2\x2\x307\x308\x3\x2\x2\x2\x308\x3"+
		"\x3\x2\x2\x2\x309\x30B\x5\b\x5\x2\x30A\x309\x3\x2\x2\x2\x30B\x30E\x3\x2"+
		"\x2\x2\x30C\x30A\x3\x2\x2\x2\x30C\x30D\x3\x2\x2\x2\x30D\x30F\x3\x2\x2"+
		"\x2\x30E\x30C\x3\x2\x2\x2\x30F\x310\a\x2\x2\x3\x310\x5\x3\x2\x2\x2\x311"+
		"\x314\x5\n\x6\x2\x312\x314\x5\x272\x13A\x2\x313\x311\x3\x2\x2\x2\x313"+
		"\x312\x3\x2\x2\x2\x314\x317\x3\x2\x2\x2\x315\x313\x3\x2\x2\x2\x315\x316"+
		"\x3\x2\x2\x2\x316\x318\x3\x2\x2\x2\x317\x315\x3\x2\x2\x2\x318\x319\a\x2"+
		"\x2\x3\x319\a\x3\x2\x2\x2\x31A\x31C\a\x201\x2\x2\x31B\x31A\x3\x2\x2\x2"+
		"\x31C\x31F\x3\x2\x2\x2\x31D\x31B\x3\x2\x2\x2\x31D\x31E\x3\x2\x2\x2\x31E"+
		"\x320\x3\x2\x2\x2\x31F\x31D\x3\x2\x2\x2\x320\x329\x5\n\x6\x2\x321\x323"+
		"\a\x201\x2\x2\x322\x321\x3\x2\x2\x2\x323\x324\x3\x2\x2\x2\x324\x322\x3"+
		"\x2\x2\x2\x324\x325\x3\x2\x2\x2\x325\x326\x3\x2\x2\x2\x326\x328\x5\n\x6"+
		"\x2\x327\x322\x3\x2\x2\x2\x328\x32B\x3\x2\x2\x2\x329\x327\x3\x2\x2\x2"+
		"\x329\x32A\x3\x2\x2\x2\x32A\x32F\x3\x2\x2\x2\x32B\x329\x3\x2\x2\x2\x32C"+
		"\x32E\a\x201\x2\x2\x32D\x32C\x3\x2\x2\x2\x32E\x331\x3\x2\x2\x2\x32F\x32D"+
		"\x3\x2\x2\x2\x32F\x330\x3\x2\x2\x2\x330\t\x3\x2\x2\x2\x331\x32F\x3\x2"+
		"\x2\x2\x332\x347\x5\xE\b\x2\x333\x347\x5\x1E\x10\x2\x334\x347\x5.\x18"+
		"\x2\x335\x347\x5\xAAV\x2\x336\x347\x5\x38\x1D\x2\x337\x347\x5^\x30\x2"+
		"\x338\x347\x5\x10\t\x2\x339\x347\x5\x34\x1B\x2\x33A\x347\x5 \x11\x2\x33B"+
		"\x347\x5\"\x12\x2\x33C\x347\x5\xACW\x2\x33D\x347\x5:\x1E\x2\x33E\x347"+
		"\x5r:\x2\x33F\x347\x5\f\a\x2\x340\x347\x5\x1C\xF\x2\x341\x347\x5,\x17"+
		"\x2\x342\x347\x5\xA8U\x2\x343\x347\x5\x36\x1C\x2\x344\x347\x5\\/\x2\x345"+
		"\x347\x5\x118\x8D\x2\x346\x332\x3\x2\x2\x2\x346\x333\x3\x2\x2\x2\x346"+
		"\x334\x3\x2\x2\x2\x346\x335\x3\x2\x2\x2\x346\x336\x3\x2\x2\x2\x346\x337"+
		"\x3\x2\x2\x2\x346\x338\x3\x2\x2\x2\x346\x339\x3\x2\x2\x2\x346\x33A\x3"+
		"\x2\x2\x2\x346\x33B\x3\x2\x2\x2\x346\x33C\x3\x2\x2\x2\x346\x33D\x3\x2"+
		"\x2\x2\x346\x33E\x3\x2\x2\x2\x346\x33F\x3\x2\x2\x2\x346\x340\x3\x2\x2"+
		"\x2\x346\x341\x3\x2\x2\x2\x346\x342\x3\x2\x2\x2\x346\x343\x3\x2\x2\x2"+
		"\x346\x344\x3\x2\x2\x2\x346\x345\x3\x2\x2\x2\x347\v\x3\x2\x2\x2\x348\x349"+
		"\as\x2\x2\x349\x34A\a\x9B\x2\x2\x34A\x34B\x5\x2B4\x15B\x2\x34B\x34C\a"+
		"\x201\x2\x2\x34C\r\x3\x2\x2\x2\x34D\x34E\a\n\x2\x2\x34E\x34F\a\x9B\x2"+
		"\x2\x34F\x350\x5\x2B4\x15B\x2\x350\x352\a@\x2\x2\x351\x353\a_\x2\x2\x352"+
		"\x351\x3\x2\x2\x2\x352\x353\x3\x2\x2\x2\x353\x357\x3\x2\x2\x2\x354\x356"+
		"\x5\xB4[\x2\x355\x354\x3\x2\x2\x2\x356\x359\x3\x2\x2\x2\x357\x355\x3\x2"+
		"\x2\x2\x357\x358\x3\x2\x2\x2\x358\x35C\x3\x2\x2\x2\x359\x357\x3\x2\x2"+
		"\x2\x35A\x35B\a\x141\x2\x2\x35B\x35D\a\x15F\x2\x2\x35C\x35A\x3\x2\x2\x2"+
		"\x35C\x35D\x3\x2\x2\x2\x35D\x35E\x3\x2\x2\x2\x35E\x35F\a\x201\x2\x2\x35F"+
		"\xF\x3\x2\x2\x2\x360\x363\aP\x2\x2\x361\x362\a\x10C\x2\x2\x362\x364\a"+
		"\x13A\x2\x2\x363\x361\x3\x2\x2\x2\x363\x364\x3\x2\x2\x2\x364\x365\x3\x2"+
		"\x2\x2\x365\x366\a\x9B\x2\x2\x366\x372\x5\x2B4\x15B\x2\x367\x368\a\x1F5"+
		"\x2\x2\x368\x36D\x5\xC0\x61\x2\x369\x36A\a\x1FB\x2\x2\x36A\x36C\x5\xC0"+
		"\x61\x2\x36B\x369\x3\x2\x2\x2\x36C\x36F\x3\x2\x2\x2\x36D\x36B\x3\x2\x2"+
		"\x2\x36D\x36E\x3\x2\x2\x2\x36E\x370\x3\x2\x2\x2\x36F\x36D\x3\x2\x2\x2"+
		"\x370\x371\a\x1F6\x2\x2\x371\x373\x3\x2\x2\x2\x372\x367\x3\x2\x2\x2\x372"+
		"\x373\x3\x2\x2\x2\x373\x374\x3\x2\x2\x2\x374\x375\a\x13F\x2\x2\x375\x37C"+
		"\x5\x2D8\x16D\x2\x376\x37B\x5\xB2Z\x2\x377\x37B\x5\x12\n\x2\x378\x37B"+
		"\x5\x16\f\x2\x379\x37B\al\x2\x2\x37A\x376\x3\x2\x2\x2\x37A\x377\x3\x2"+
		"\x2\x2\x37A\x378\x3\x2\x2\x2\x37A\x379\x3\x2\x2\x2\x37B\x37E\x3\x2\x2"+
		"\x2\x37C\x37A\x3\x2\x2\x2\x37C\x37D\x3\x2\x2\x2\x37D\x393\x3\x2\x2\x2"+
		"\x37E\x37C\x3\x2\x2\x2\x37F\x381\a\x122\x2\x2\x380\x37F\x3\x2\x2\x2\x380"+
		"\x381\x3\x2\x2\x2\x381\x382\x3\x2\x2\x2\x382\x38E\t\x3\x2\x2\x383\x385"+
		"\a\x62\x2\x2\x384\x383\x3\x2\x2\x2\x384\x385\x3\x2\x2\x2\x385\x389\x3"+
		"\x2\x2\x2\x386\x388\x5\xC4\x63\x2\x387\x386\x3\x2\x2\x2\x388\x38B\x3\x2"+
		"\x2\x2\x389\x387\x3\x2\x2\x2\x389\x38A\x3\x2\x2\x2\x38A\x38C\x3\x2\x2"+
		"\x2\x38B\x389\x3\x2\x2\x2\x38C\x38F\x5\x10A\x86\x2\x38D\x38F\x5\xB6\\"+
		"\x2\x38E\x384\x3\x2\x2\x2\x38E\x38D\x3\x2\x2\x2\x38F\x394\x3\x2\x2\x2"+
		"\x390\x391\t\x4\x2\x2\x391\x392\a\x19E\x2\x2\x392\x394\x5\x29E\x150\x2"+
		"\x393\x380\x3\x2\x2\x2\x393\x390\x3\x2\x2\x2\x394\x395\x3\x2\x2\x2\x395"+
		"\x396\a\x201\x2\x2\x396\x11\x3\x2\x2\x2\x397\x399\a\x116\x2\x2\x398\x39A"+
		"\x5\x14\v\x2\x399\x398\x3\x2\x2\x2\x399\x39A\x3\x2\x2\x2\x39A\x13\x3\x2"+
		"\x2\x2\x39B\x39C\a\x1F5\x2\x2\x39C\x39D\a\x119\x2\x2\x39D\x39E\x5\x1F2"+
		"\xFA\x2\x39E\x3AC\a(\x2\x2\x39F\x3AD\a\r\x2\x2\x3A0\x3A1\t\x5\x2\x2\x3A1"+
		"\x3A2\a\x1F5\x2\x2\x3A2\x3A7\x5\x2C6\x164\x2\x3A3\x3A4\a\x1FB\x2\x2\x3A4"+
		"\x3A6\x5\x2C6\x164\x2\x3A5\x3A3\x3\x2\x2\x2\x3A6\x3A9\x3\x2\x2\x2\x3A7"+
		"\x3A5\x3\x2\x2\x2\x3A7\x3A8\x3\x2\x2\x2\x3A8\x3AA\x3\x2\x2\x2\x3A9\x3A7"+
		"\x3\x2\x2\x2\x3AA\x3AB\a\x1F6\x2\x2\x3AB\x3AD\x3\x2\x2\x2\x3AC\x39F\x3"+
		"\x2\x2\x2\x3AC\x3A0\x3\x2\x2\x2\x3AD\x3AF\x3\x2\x2\x2\x3AE\x3B0\x5\x1A"+
		"\xE\x2\x3AF\x3AE\x3\x2\x2\x2\x3AF\x3B0\x3\x2\x2\x2\x3B0\x3B1\x3\x2\x2"+
		"\x2\x3B1\x3B2\a\x1F6\x2\x2\x3B2\x15\x3\x2\x2\x2\x3B3\x3B5\a\x13E\x2\x2"+
		"\x3B4\x3B6\x5\x18\r\x2\x3B5\x3B4\x3\x2\x2\x2\x3B5\x3B6\x3\x2\x2\x2\x3B6"+
		"\x17\x3\x2\x2\x2\x3B7\x3B8\a\x138\x2\x2\x3B8\x3B9\a\x1F5\x2\x2\x3B9\x3BE"+
		"\x5\x2C8\x165\x2\x3BA\x3BB\a\x1FB\x2\x2\x3BB\x3BD\x5\x2C8\x165\x2\x3BC"+
		"\x3BA\x3\x2\x2\x2\x3BD\x3C0\x3\x2\x2\x2\x3BE\x3BC\x3\x2\x2\x2\x3BE\x3BF"+
		"\x3\x2\x2\x2\x3BF\x3C1\x3\x2\x2\x2\x3C0\x3BE\x3\x2\x2\x2\x3C1\x3C2\a\x1F6"+
		"\x2\x2\x3C2\x19\x3\x2\x2\x2\x3C3\x3C4\t\x6\x2\x2\x3C4\x3C5\x5\x1F2\xFA"+
		"\x2\x3C5\x3C6\a(\x2\x2\x3C6\x3C7\a\x1F5\x2\x2\x3C7\x3CC\x5\x2C6\x164\x2"+
		"\x3C8\x3C9\a\x1FB\x2\x2\x3C9\x3CB\x5\x2C6\x164\x2\x3CA\x3C8\x3\x2\x2\x2"+
		"\x3CB\x3CE\x3\x2\x2\x2\x3CC\x3CA\x3\x2\x2\x2\x3CC\x3CD\x3\x2\x2\x2\x3CD"+
		"\x3CF\x3\x2\x2\x2\x3CE\x3CC\x3\x2\x2\x2\x3CF\x3D0\a\x1F6\x2\x2\x3D0\x1B"+
		"\x3\x2\x2\x2\x3D1\x3D2\as\x2\x2\x3D2\x3D4\a\x115\x2\x2\x3D3\x3D5\a#\x2"+
		"\x2\x3D4\x3D3\x3\x2\x2\x2\x3D4\x3D5\x3\x2\x2\x2\x3D5\x3D6\x3\x2\x2\x2"+
		"\x3D6\x3D7\x5\x29C\x14F\x2\x3D7\x3D8\a\x201\x2\x2\x3D8\x1D\x3\x2\x2\x2"+
		"\x3D9\x3DA\a\n\x2\x2\x3DA\x3DB\a\x115\x2\x2\x3DB\x3DC\x5\x29C\x14F\x2"+
		"\x3DC\x3DE\a@\x2\x2\x3DD\x3DF\a_\x2\x2\x3DE\x3DD\x3\x2\x2\x2\x3DE\x3DF"+
		"\x3\x2\x2\x2\x3DF\x3E1\x3\x2\x2\x2\x3E0\x3E2\t\a\x2\x2\x3E1\x3E0\x3\x2"+
		"\x2\x2\x3E1\x3E2\x3\x2\x2\x2\x3E2\x3E6\x3\x2\x2\x2\x3E3\x3E5\x5\xB4[\x2"+
		"\x3E4\x3E3\x3\x2\x2\x2\x3E5\x3E8\x3\x2\x2\x2\x3E6\x3E4\x3\x2\x2\x2\x3E6"+
		"\x3E7\x3\x2\x2\x2\x3E7\x3EB\x3\x2\x2\x2\x3E8\x3E6\x3\x2\x2\x2\x3E9\x3EA"+
		"\a\x141\x2\x2\x3EA\x3EC\a\x15F\x2\x2\x3EB\x3E9\x3\x2\x2\x2\x3EB\x3EC\x3"+
		"\x2\x2\x2\x3EC\x3ED\x3\x2\x2\x2\x3ED\x3EE\a\x201\x2\x2\x3EE\x1F\x3\x2"+
		"\x2\x2\x3EF\x3F2\aP\x2\x2\x3F0\x3F1\a\x10C\x2\x2\x3F1\x3F3\a\x13A\x2\x2"+
		"\x3F2\x3F0\x3\x2\x2\x2\x3F2\x3F3\x3\x2\x2\x2\x3F3\x3F4\x3\x2\x2\x2\x3F4"+
		"\x3F5\a\x115\x2\x2\x3F5\x3F7\x5\x29C\x14F\x2\x3F6\x3F8\x5\xB2Z\x2\x3F7"+
		"\x3F6\x3\x2\x2\x2\x3F7\x3F8\x3\x2\x2\x2\x3F8\x3F9\x3\x2\x2\x2\x3F9\x3FD"+
		"\t\x3\x2\x2\x3FA\x3FC\x5$\x13\x2\x3FB\x3FA\x3\x2\x2\x2\x3FC\x3FF\x3\x2"+
		"\x2\x2\x3FD\x3FB\x3\x2\x2\x2\x3FD\x3FE\x3\x2\x2\x2\x3FE\x400\x3\x2\x2"+
		"\x2\x3FF\x3FD\x3\x2\x2\x2\x400\x402\a|\x2\x2\x401\x403\x5\x29C\x14F\x2"+
		"\x402\x401\x3\x2\x2\x2\x402\x403\x3\x2\x2\x2\x403\x404\x3\x2\x2\x2\x404"+
		"\x405\a\x201\x2\x2\x405!\x3\x2\x2\x2\x406\x409\aP\x2\x2\x407\x408\a\x10C"+
		"\x2\x2\x408\x40A\a\x13A\x2\x2\x409\x407\x3\x2\x2\x2\x409\x40A\x3\x2\x2"+
		"\x2\x40A\x40B\x3\x2\x2\x2\x40B\x40C\a\x115\x2\x2\x40C\x40D\a#\x2\x2\x40D"+
		"\x40E\x5\x29C\x14F\x2\x40E\x412\t\x3\x2\x2\x40F\x411\x5*\x16\x2\x410\x40F"+
		"\x3\x2\x2\x2\x411\x414\x3\x2\x2\x2\x412\x410\x3\x2\x2\x2\x412\x413\x3"+
		"\x2\x2\x2\x413\x41B\x3\x2\x2\x2\x414\x412\x3\x2\x2\x2\x415\x416\a\x1B"+
		"\x2\x2\x416\x41C\x5\xE0q\x2\x417\x419\a|\x2\x2\x418\x41A\x5\x29C\x14F"+
		"\x2\x419\x418\x3\x2\x2\x2\x419\x41A\x3\x2\x2\x2\x41A\x41C\x3\x2\x2\x2"+
		"\x41B\x415\x3\x2\x2\x2\x41B\x417\x3\x2\x2\x2\x41C\x41D\x3\x2\x2\x2\x41D"+
		"\x41E\a\x201\x2\x2\x41E#\x3\x2\x2\x2\x41F\x428\x5\xC6\x64\x2\x420\x428"+
		"\x5\xC8\x65\x2\x421\x428\x5\xCA\x66\x2\x422\x428\x5\xCEh\x2\x423\x428"+
		"\x5\xD0i\x2\x424\x428\x5\xD8m\x2\x425\x428\x5&\x14\x2\x426\x428\x5(\x15"+
		"\x2\x427\x41F\x3\x2\x2\x2\x427\x420\x3\x2\x2\x2\x427\x421\x3\x2\x2\x2"+
		"\x427\x422\x3\x2\x2\x2\x427\x423\x3\x2\x2\x2\x427\x424\x3\x2\x2\x2\x427"+
		"\x425\x3\x2\x2\x2\x427\x426\x3\x2\x2\x2\x428%\x3\x2\x2\x2\x429\x42A\a"+
		"\x12D\x2\x2\x42A\x436\x5\x2F0\x179\x2\x42B\x42C\a\x1F5\x2\x2\x42C\x431"+
		"\x5\xC0\x61\x2\x42D\x42E\a\x1FB\x2\x2\x42E\x430\x5\xC0\x61\x2\x42F\x42D"+
		"\x3\x2\x2\x2\x430\x433\x3\x2\x2\x2\x431\x42F\x3\x2\x2\x2\x431\x432\x3"+
		"\x2\x2\x2\x432\x434\x3\x2\x2\x2\x433\x431\x3\x2\x2\x2\x434\x435\a\x1F6"+
		"\x2\x2\x435\x437\x3\x2\x2\x2\x436\x42B\x3\x2\x2\x2\x436\x437\x3\x2\x2"+
		"\x2\x437\x438\x3\x2\x2\x2\x438\x439\a\x201\x2\x2\x439\'\x3\x2\x2\x2\x43A"+
		"\x43B\a\x9B\x2\x2\x43B\x447\x5\x2F0\x179\x2\x43C\x43D\a\x1F5\x2\x2\x43D"+
		"\x442\x5\xC0\x61\x2\x43E\x43F\a\x1FB\x2\x2\x43F\x441\x5\xC0\x61\x2\x440"+
		"\x43E\x3\x2\x2\x2\x441\x444\x3\x2\x2\x2\x442\x440\x3\x2\x2\x2\x442\x443"+
		"\x3\x2\x2\x2\x443\x445\x3\x2\x2\x2\x444\x442\x3\x2\x2\x2\x445\x446\a\x1F6"+
		"\x2\x2\x446\x448\x3\x2\x2\x2\x447\x43C\x3\x2\x2\x2\x447\x448\x3\x2\x2"+
		"\x2\x448\x449\x3\x2\x2\x2\x449\x44A\a\x13F\x2\x2\x44A\x44C\x5\x2D8\x16D"+
		"\x2\x44B\x44D\al\x2\x2\x44C\x44B\x3\x2\x2\x2\x44C\x44D\x3\x2\x2\x2\x44D"+
		"\x44F\x3\x2\x2\x2\x44E\x450\a\x13E\x2\x2\x44F\x44E\x3\x2\x2\x2\x44F\x450"+
		"\x3\x2\x2\x2\x450\x451\x3\x2\x2\x2\x451\x452\a\x201\x2\x2\x452)\x3\x2"+
		"\x2\x2\x453\x45D\x5\xC6\x64\x2\x454\x45D\x5\xC8\x65\x2\x455\x45D\x5\xCA"+
		"\x66\x2\x456\x45D\x5\xCEh\x2\x457\x45D\x5\xD8m\x2\x458\x45D\x5\x32\x1A"+
		"\x2\x459\x45D\x5\x30\x19\x2\x45A\x45D\x5&\x14\x2\x45B\x45D\x5(\x15\x2"+
		"\x45C\x453\x3\x2\x2\x2\x45C\x454\x3\x2\x2\x2\x45C\x455\x3\x2\x2\x2\x45C"+
		"\x456\x3\x2\x2\x2\x45C\x457\x3\x2\x2\x2\x45C\x458\x3\x2\x2\x2\x45C\x459"+
		"\x3\x2\x2\x2\x45C\x45A\x3\x2\x2\x2\x45C\x45B\x3\x2\x2\x2\x45D+\x3\x2\x2"+
		"\x2\x45E\x45F\as\x2\x2\x45F\x460\a\x12D\x2\x2\x460\x461\x5\x2B6\x15C\x2"+
		"\x461\x462\a\x201\x2\x2\x462-\x3\x2\x2\x2\x463\x464\a\n\x2\x2\x464\x465"+
		"\a\x12D\x2\x2\x465\x466\x5\x2B6\x15C\x2\x466\x468\a@\x2\x2\x467\x469\a"+
		"_\x2\x2\x468\x467\x3\x2\x2\x2\x468\x469\x3\x2\x2\x2\x469\x46D\x3\x2\x2"+
		"\x2\x46A\x46C\x5\xB4[\x2\x46B\x46A\x3\x2\x2\x2\x46C\x46F\x3\x2\x2\x2\x46D"+
		"\x46B\x3\x2\x2\x2\x46D\x46E\x3\x2\x2\x2\x46E\x472\x3\x2\x2\x2\x46F\x46D"+
		"\x3\x2\x2\x2\x470\x471\a\x141\x2\x2\x471\x473\a\x15F\x2\x2\x472\x470\x3"+
		"\x2\x2\x2\x472\x473\x3\x2\x2\x2\x473\x474\x3\x2\x2\x2\x474\x475\a\x201"+
		"\x2\x2\x475/\x3\x2\x2\x2\x476\x477\a\x9B\x2\x2\x477\x483\x5\x2F0\x179"+
		"\x2\x478\x479\a\x1F5\x2\x2\x479\x47E\x5\xC0\x61\x2\x47A\x47B\a\x1FB\x2"+
		"\x2\x47B\x47D\x5\xC0\x61\x2\x47C\x47A\x3\x2\x2\x2\x47D\x480\x3\x2\x2\x2"+
		"\x47E\x47C\x3\x2\x2\x2\x47E\x47F\x3\x2\x2\x2\x47F\x481\x3\x2\x2\x2\x480"+
		"\x47E\x3\x2\x2\x2\x481\x482\a\x1F6\x2\x2\x482\x484\x3\x2\x2\x2\x483\x478"+
		"\x3\x2\x2\x2\x483\x484\x3\x2\x2\x2\x484\x485\x3\x2\x2\x2\x485\x486\a\x13F"+
		"\x2\x2\x486\x48D\x5\x2D8\x16D\x2\x487\x48C\x5\xB2Z\x2\x488\x48C\x5\x12"+
		"\n\x2\x489\x48C\x5\x16\f\x2\x48A\x48C\al\x2\x2\x48B\x487\x3\x2\x2\x2\x48B"+
		"\x488\x3\x2\x2\x2\x48B\x489\x3\x2\x2\x2\x48B\x48A\x3\x2\x2\x2\x48C\x48F"+
		"\x3\x2\x2\x2\x48D\x48B\x3\x2\x2\x2\x48D\x48E\x3\x2\x2\x2\x48E\x4A4\x3"+
		"\x2\x2\x2\x48F\x48D\x3\x2\x2\x2\x490\x492\a\x122\x2\x2\x491\x490\x3\x2"+
		"\x2\x2\x491\x492\x3\x2\x2\x2\x492\x493\x3\x2\x2\x2\x493\x49F\t\x3\x2\x2"+
		"\x494\x496\a\x62\x2\x2\x495\x494\x3\x2\x2\x2\x495\x496\x3\x2\x2\x2\x496"+
		"\x49A\x3\x2\x2\x2\x497\x499\x5\xC4\x63\x2\x498\x497\x3\x2\x2\x2\x499\x49C"+
		"\x3\x2\x2\x2\x49A\x498\x3\x2\x2\x2\x49A\x49B\x3\x2\x2\x2\x49B\x49D\x3"+
		"\x2\x2\x2\x49C\x49A\x3\x2\x2\x2\x49D\x4A0\x5\x10A\x86\x2\x49E\x4A0\x5"+
		"\xB6\\\x2\x49F\x495\x3\x2\x2\x2\x49F\x49E\x3\x2\x2\x2\x4A0\x4A5\x3\x2"+
		"\x2\x2\x4A1\x4A2\t\x4\x2\x2\x4A2\x4A3\a\x19E\x2\x2\x4A3\x4A5\x5\x29E\x150"+
		"\x2\x4A4\x491\x3\x2\x2\x2\x4A4\x4A1\x3\x2\x2\x2\x4A5\x4A6\x3\x2\x2\x2"+
		"\x4A6\x4A7\a\x201\x2\x2\x4A7\x31\x3\x2\x2\x2\x4A8\x4A9\a\x12D\x2\x2\x4A9"+
		"\x4B5\x5\x2F0\x179\x2\x4AA\x4AB\a\x1F5\x2\x2\x4AB\x4B0\x5\xC0\x61\x2\x4AC"+
		"\x4AD\a\x1FB\x2\x2\x4AD\x4AF\x5\xC0\x61\x2\x4AE\x4AC\x3\x2\x2\x2\x4AF"+
		"\x4B2\x3\x2\x2\x2\x4B0\x4AE\x3\x2\x2\x2\x4B0\x4B1\x3\x2\x2\x2\x4B1\x4B3"+
		"\x3\x2\x2\x2\x4B2\x4B0\x3\x2\x2\x2\x4B3\x4B4\a\x1F6\x2\x2\x4B4\x4B6\x3"+
		"\x2\x2\x2\x4B5\x4AA\x3\x2\x2\x2\x4B5\x4B6\x3\x2\x2\x2\x4B6\x4B7\x3\x2"+
		"\x2\x2\x4B7\x4C4\t\x3\x2\x2\x4B8\x4BA\a\x62\x2\x2\x4B9\x4B8\x3\x2\x2\x2"+
		"\x4B9\x4BA\x3\x2\x2\x2\x4BA\x4BE\x3\x2\x2\x2\x4BB\x4BD\x5\xC4\x63\x2\x4BC"+
		"\x4BB\x3\x2\x2\x2\x4BD\x4C0\x3\x2\x2\x2\x4BE\x4BC\x3\x2\x2\x2\x4BE\x4BF"+
		"\x3\x2\x2\x2\x4BF\x4C1\x3\x2\x2\x2\x4C0\x4BE\x3\x2\x2\x2\x4C1\x4C5\x5"+
		"\x10A\x86\x2\x4C2\x4C5\x5\xB6\\\x2\x4C3\x4C5\a\x8B\x2\x2\x4C4\x4B9\x3"+
		"\x2\x2\x2\x4C4\x4C2\x3\x2\x2\x2\x4C4\x4C3\x3\x2\x2\x2\x4C5\x4C6\x3\x2"+
		"\x2\x2\x4C6\x4C7\a\x201\x2\x2\x4C7\x33\x3\x2\x2\x2\x4C8\x4CB\aP\x2\x2"+
		"\x4C9\x4CA\a\x10C\x2\x2\x4CA\x4CC\a\x13A\x2\x2\x4CB\x4C9\x3\x2\x2\x2\x4CB"+
		"\x4CC\x3\x2\x2\x2\x4CC\x4CD\x3\x2\x2\x2\x4CD\x4CE\a\x12D\x2\x2\x4CE\x4DA"+
		"\x5\x2B6\x15C\x2\x4CF\x4D0\a\x1F5\x2\x2\x4D0\x4D5\x5\xC0\x61\x2\x4D1\x4D2"+
		"\a\x1FB\x2\x2\x4D2\x4D4\x5\xC0\x61\x2\x4D3\x4D1\x3\x2\x2\x2\x4D4\x4D7"+
		"\x3\x2\x2\x2\x4D5\x4D3\x3\x2\x2\x2\x4D5\x4D6\x3\x2\x2\x2\x4D6\x4D8\x3"+
		"\x2\x2\x2\x4D7\x4D5\x3\x2\x2\x2\x4D8\x4D9\a\x1F6\x2\x2\x4D9\x4DB\x3\x2"+
		"\x2\x2\x4DA\x4CF\x3\x2\x2\x2\x4DA\x4DB\x3\x2\x2\x2\x4DB\x4DD\x3\x2\x2"+
		"\x2\x4DC\x4DE\x5\xB2Z\x2\x4DD\x4DC\x3\x2\x2\x2\x4DD\x4DE\x3\x2\x2\x2\x4DE"+
		"\x4DF\x3\x2\x2\x2\x4DF\x4EC\t\x3\x2\x2\x4E0\x4E2\a\x62\x2\x2\x4E1\x4E0"+
		"\x3\x2\x2\x2\x4E1\x4E2\x3\x2\x2\x2\x4E2\x4E6\x3\x2\x2\x2\x4E3\x4E5\x5"+
		"\xC4\x63\x2\x4E4\x4E3\x3\x2\x2\x2\x4E5\x4E8\x3\x2\x2\x2\x4E6\x4E4\x3\x2"+
		"\x2\x2\x4E6\x4E7\x3\x2\x2\x2\x4E7\x4E9\x3\x2\x2\x2\x4E8\x4E6\x3\x2\x2"+
		"\x2\x4E9\x4ED\x5\x10A\x86\x2\x4EA\x4ED\x5\xB6\\\x2\x4EB\x4ED\a\x8B\x2"+
		"\x2\x4EC\x4E1\x3\x2\x2\x2\x4EC\x4EA\x3\x2\x2\x2\x4EC\x4EB\x3\x2\x2\x2"+
		"\x4ED\x4EE\x3\x2\x2\x2\x4EE\x4EF\a\x201\x2\x2\x4EF\x35\x3\x2\x2\x2\x4F0"+
		"\x4F1\as\x2\x2\x4F1\x4F2\a\x18E\x2\x2\x4F2\x4F3\x5\x2B8\x15D\x2\x4F3\x4F4"+
		"\a\x201\x2\x2\x4F4\x37\x3\x2\x2\x2\x4F5\x4F6\a\n\x2\x2\x4F6\x4F7\a\x18E"+
		"\x2\x2\x4F7\x50A\x5\x2B8\x15D\x2\x4F8\x50B\t\b\x2\x2\x4F9\x4FA\a\x139"+
		"\x2\x2\x4FA\x4FB\a\x189\x2\x2\x4FB\x50B\x5\x2B8\x15D\x2\x4FC\x4FE\a@\x2"+
		"\x2\x4FD\x4FF\a_\x2\x2\x4FE\x4FD\x3\x2\x2\x2\x4FE\x4FF\x3\x2\x2\x2\x4FF"+
		"\x503\x3\x2\x2\x2\x500\x502\x5\xB4[\x2\x501\x500\x3\x2\x2\x2\x502\x505"+
		"\x3\x2\x2\x2\x503\x501\x3\x2\x2\x2\x503\x504\x3\x2\x2\x2\x504\x508\x3"+
		"\x2\x2\x2\x505\x503\x3\x2\x2\x2\x506\x507\a\x141\x2\x2\x507\x509\a\x15F"+
		"\x2\x2\x508\x506\x3\x2\x2\x2\x508\x509\x3\x2\x2\x2\x509\x50B\x3\x2\x2"+
		"\x2\x50A\x4F8\x3\x2\x2\x2\x50A\x4F9\x3\x2\x2\x2\x50A\x4FC\x3\x2\x2\x2"+
		"\x50B\x50C\x3\x2\x2\x2\x50C\x50D\a\x201\x2\x2\x50D\x39\x3\x2\x2\x2\x50E"+
		"\x511\aP\x2\x2\x50F\x510\a\x10C\x2\x2\x510\x512\a\x13A\x2\x2\x511\x50F"+
		"\x3\x2\x2\x2\x511\x512\x3\x2\x2\x2\x512\x513\x3\x2\x2\x2\x513\x514\a\x18E"+
		"\x2\x2\x514\x518\x5\x2B8\x15D\x2\x515\x519\x5@!\x2\x516\x519\x5\x44#\x2"+
		"\x517\x519\x5\x46$\x2\x518\x515\x3\x2\x2\x2\x518\x516\x3\x2\x2\x2\x518"+
		"\x517\x3\x2\x2\x2\x519\x51B\x3\x2\x2\x2\x51A\x51C\x5<\x1F\x2\x51B\x51A"+
		"\x3\x2\x2\x2\x51B\x51C\x3\x2\x2\x2\x51C\x51E\x3\x2\x2\x2\x51D\x51F\t\b"+
		"\x2\x2\x51E\x51D\x3\x2\x2\x2\x51E\x51F\x3\x2\x2\x2\x51F\x521\x3\x2\x2"+
		"\x2\x520\x522\x5> \x2\x521\x520\x3\x2\x2\x2\x521\x522\x3\x2\x2\x2\x522"+
		"\x523\x3\x2\x2\x2\x523\x524\x5H%\x2\x524\x525\a\x201\x2\x2\x525;\x3\x2"+
		"\x2\x2\x526\x527\a\x95\x2\x2\x527\x52C\x5\x2B8\x15D\x2\x528\x529\a\x1FB"+
		"\x2\x2\x529\x52B\x5\x2B8\x15D\x2\x52A\x528\x3\x2\x2\x2\x52B\x52E\x3\x2"+
		"\x2\x2\x52C\x52A\x3\x2\x2\x2\x52C\x52D\x3\x2\x2\x2\x52D=\x3\x2\x2\x2\x52E"+
		"\x52C\x3\x2\x2\x2\x52F\x530\a\x1AC\x2\x2\x530\x531\a\x1F5\x2\x2\x531\x532"+
		"\x5\x1F0\xF9\x2\x532\x533\a\x1F6\x2\x2\x533?\x3\x2\x2\x2\x534\x539\a\x1A"+
		"\x2\x2\x535\x539\a\x6\x2\x2\x536\x537\a\xB6\x2\x2\x537\x539\a\x104\x2"+
		"\x2\x538\x534\x3\x2\x2\x2\x538\x535\x3\x2\x2\x2\x538\x536\x3\x2\x2\x2"+
		"\x539\x53A\x3\x2\x2\x2\x53A\x53C\x5R*\x2\x53B\x53D\x5X-\x2\x53C\x53B\x3"+
		"\x2\x2\x2\x53C\x53D\x3\x2\x2\x2\x53D\x53F\x3\x2\x2\x2\x53E\x540\x5\x42"+
		"\"\x2\x53F\x53E\x3\x2\x2\x2\x53F\x540\x3\x2\x2\x2\x540\x41\x3\x2\x2\x2"+
		"\x541\x542\a\x96\x2\x2\x542\x543\au\x2\x2\x543\x544\a\x147\x2\x2\x544"+
		"\x43\x3\x2\x2\x2\x545\x546\a\x96\x2\x2\x546\x548\x5R*\x2\x547\x549\x5"+
		"X-\x2\x548\x547\x3\x2\x2\x2\x548\x549\x3\x2\x2\x2\x549\x45\x3\x2\x2\x2"+
		"\x54A\x54B\t\t\x2\x2\x54B\x550\x5P)\x2\x54C\x54D\a\x10C\x2\x2\x54D\x54F"+
		"\x5P)\x2\x54E\x54C\x3\x2\x2\x2\x54F\x552\x3\x2\x2\x2\x550\x54E\x3\x2\x2"+
		"\x2\x550\x551\x3\x2\x2\x2\x551\x553\x3\x2\x2\x2\x552\x550\x3\x2\x2\x2"+
		"\x553\x55B\a\x108\x2\x2\x554\x55C\aY\x2\x2\x555\x556\x5\x298\x14D\x2\x556"+
		"\x557\a\x1EE\x2\x2\x557\x559\x3\x2\x2\x2\x558\x555\x3\x2\x2\x2\x558\x559"+
		"\x3\x2\x2\x2\x559\x55A\x3\x2\x2\x2\x55A\x55C\a\x14E\x2\x2\x55B\x554\x3"+
		"\x2\x2\x2\x55B\x558\x3\x2\x2\x2\x55CG\x3\x2\x2\x2\x55D\x55E\a\x41\x2\x2"+
		"\x55E\x563\a\x18E\x2\x2\x55F\x560\a,\x2\x2\x560\x563\x5\x2F0\x179\x2\x561"+
		"\x563\x5\x10E\x88\x2\x562\x55D\x3\x2\x2\x2\x562\x55F\x3\x2\x2\x2\x562"+
		"\x561\x3\x2\x2\x2\x563I\x3\x2\x2\x2\x564\x566\x5\x29A\x14E\x2\x565\x567"+
		"\x5\x2CE\x168\x2\x566\x565\x3\x2\x2\x2\x566\x567\x3\x2\x2\x2\x567K\x3"+
		"\x2\x2\x2\x568\x569\a\x41\x2\x2\x569\x56D\a\x18E\x2\x2\x56A\x56C\x5\xC4"+
		"\x63\x2\x56B\x56A\x3\x2\x2\x2\x56C\x56F\x3\x2\x2\x2\x56D\x56B\x3\x2\x2"+
		"\x2\x56D\x56E\x3\x2\x2\x2\x56E\x571\x3\x2\x2\x2\x56F\x56D\x3\x2\x2\x2"+
		"\x570\x572\x5N(\x2\x571\x570\x3\x2\x2\x2\x572\x573\x3\x2\x2\x2\x573\x571"+
		"\x3\x2\x2\x2\x573\x574\x3\x2\x2\x2\x574\x575\x3\x2\x2\x2\x575\x576\a|"+
		"\x2\x2\x576\x577\x5\x2B8\x15D\x2\x577M\x3\x2\x2\x2\x578\x579\a\x1A\x2"+
		"\x2\x579\x57A\a\x172\x2\x2\x57A\x57B\a\xBD\x2\x2\x57B\x57C\x5\x10E\x88"+
		"\x2\x57C\x57D\a\x1A\x2\x2\x57D\x57E\a\x172\x2\x2\x57E\x57F\a\x201\x2\x2"+
		"\x57F\x59D\x3\x2\x2\x2\x580\x581\a\x1A\x2\x2\x581\x582\au\x2\x2\x582\x583"+
		"\a\x147\x2\x2\x583\x584\a\xBD\x2\x2\x584\x585\x5\x10E\x88\x2\x585\x586"+
		"\a\x1A\x2\x2\x586\x587\au\x2\x2\x587\x588\a\x147\x2\x2\x588\x589\a\x201"+
		"\x2\x2\x589\x59D\x3\x2\x2\x2\x58A\x58B\a\x6\x2\x2\x58B\x58C\a\x172\x2"+
		"\x2\x58C\x58D\a\xBD\x2\x2\x58D\x58E\x5\x10E\x88\x2\x58E\x58F\a\x6\x2\x2"+
		"\x58F\x590\a\x172\x2\x2\x590\x591\a\x201\x2\x2\x591\x59D\x3\x2\x2\x2\x592"+
		"\x593\a\x6\x2\x2\x593\x594\au\x2\x2\x594\x595\a\x147\x2\x2\x595\x596\a"+
		"\xBD\x2\x2\x596\x597\x5\x10E\x88\x2\x597\x598\a\x6\x2\x2\x598\x599\au"+
		"\x2\x2\x599\x59A\a\x147\x2\x2\x59A\x59B\a\x201\x2\x2\x59B\x59D\x3\x2\x2"+
		"\x2\x59C\x578\x3\x2\x2\x2\x59C\x580\x3\x2\x2\x2\x59C\x58A\x3\x2\x2\x2"+
		"\x59C\x592\x3\x2\x2\x2\x59DO\x3\x2\x2\x2\x59E\x5B9\a\n\x2\x2\x59F\x5B9"+
		"\a\v\x2\x2\x5A0\x5A1\a\x11\x2\x2\x5A1\x5B9\a\x175\x2\x2\x5A2\x5B9\a\x14"+
		"\x2\x2\x5A3\x5B9\a<\x2\x2\x5A4\x5B9\aP\x2\x2\x5A5\x5A6\ao\x2\x2\x5A6\x5B9"+
		"\a\x175\x2\x2\x5A7\x5B9\as\x2\x2\x5A8\x5B9\a\x9D\x2\x2\x5A9\x5B9\a\xF2"+
		"\x2\x2\x5AA\x5B9\a\x139\x2\x2\x5AB\x5B9\a\x143\x2\x2\x5AC\x5B9\a\x190"+
		"\x2\x2\x5AD\x5B9\a^\x2\x2\x5AE\x5B9\a\x171\x2\x2\x5AF\x5B9\a\x162\x2\x2"+
		"\x5B0\x5B9\a\\\x2\x2\x5B1\x5B9\a\xD4\x2\x2\x5B2\x5B9\a\xD3\x2\x2\x5B3"+
		"\x5B9\a\x15B\x2\x2\x5B4\x5B9\a\x17C\x2\x2\x5B5\x5B9\aY\x2\x2\x5B6\x5B9"+
		"\a\x14E\x2\x2\x5B7\x5B9\a\x95\x2\x2\x5B8\x59E\x3\x2\x2\x2\x5B8\x59F\x3"+
		"\x2\x2\x2\x5B8\x5A0\x3\x2\x2\x2\x5B8\x5A2\x3\x2\x2\x2\x5B8\x5A3\x3\x2"+
		"\x2\x2\x5B8\x5A4\x3\x2\x2\x2\x5B8\x5A5\x3\x2\x2\x2\x5B8\x5A7\x3\x2\x2"+
		"\x2\x5B8\x5A8\x3\x2\x2\x2\x5B8\x5A9\x3\x2\x2\x2\x5B8\x5AA\x3\x2\x2\x2"+
		"\x5B8\x5AB\x3\x2\x2\x2\x5B8\x5AC\x3\x2\x2\x2\x5B8\x5AD\x3\x2\x2\x2\x5B8"+
		"\x5AE\x3\x2\x2\x2\x5B8\x5AF\x3\x2\x2\x2\x5B8\x5B0\x3\x2\x2\x2\x5B8\x5B1"+
		"\x3\x2\x2\x2\x5B8\x5B2\x3\x2\x2\x2\x5B8\x5B3\x3\x2\x2\x2\x5B8\x5B4\x3"+
		"\x2\x2\x2\x5B8\x5B5\x3\x2\x2\x2\x5B8\x5B6\x3\x2\x2\x2\x5B8\x5B7\x3\x2"+
		"\x2\x2\x5B9Q\x3\x2\x2\x2\x5BA\x5BF\x5T+\x2\x5BB\x5BC\a\x10C\x2\x2\x5BC"+
		"\x5BE\x5T+\x2\x5BD\x5BB\x3\x2\x2\x2\x5BE\x5C1\x3\x2\x2\x2\x5BF\x5BD\x3"+
		"\x2\x2\x2\x5BF\x5C0\x3\x2\x2\x2\x5C0\x5C2\x3\x2\x2\x2\x5C1\x5BF\x3\x2"+
		"\x2\x2\x5C2\x5C4\a\x108\x2\x2\x5C3\x5C5\x5V,\x2\x5C4\x5C3\x3\x2\x2\x2"+
		"\x5C4\x5C5\x3\x2\x2\x2\x5C5\x5C6\x3\x2\x2\x2\x5C6\x5C7\x5\x2C8\x165\x2"+
		"\x5C7S\x3\x2\x2\x2\x5C8\x5D2\t\n\x2\x2\x5C9\x5CA\a\x104\x2\x2\x5CA\x5CF"+
		"\x5\x2C6\x164\x2\x5CB\x5CC\a\x1FB\x2\x2\x5CC\x5CE\x5\x2C6\x164\x2\x5CD"+
		"\x5CB\x3\x2\x2\x2\x5CE\x5D1\x3\x2\x2\x2\x5CF\x5CD\x3\x2\x2\x2\x5CF\x5D0"+
		"\x3\x2\x2\x2\x5D0\x5D3\x3\x2\x2\x2\x5D1\x5CF\x3\x2\x2\x2\x5D2\x5C9\x3"+
		"\x2\x2\x2\x5D2\x5D3\x3\x2\x2\x2\x5D3U\x3\x2\x2\x2\x5D4\x5D5\a\xEF\x2\x2"+
		"\x5D5\x5D6\a\x17D\x2\x2\x5D6\x5D7\x5\x2C8\x165\x2\x5D7\x5D8\a\x104\x2"+
		"\x2\x5D8W\x3\x2\x2\x2\x5D9\x5DB\a\x136\x2\x2\x5DA\x5DC\x5Z.\x2\x5DB\x5DA"+
		"\x3\x2\x2\x2\x5DC\x5DD\x3\x2\x2\x2\x5DD\x5DB\x3\x2\x2\x2\x5DD\x5DE\x3"+
		"\x2\x2\x2\x5DEY\x3\x2\x2\x2\x5DF\x5E0\t\v\x2\x2\x5E0\x5E1\x5\x280\x141"+
		"\x2\x5E1[\x3\x2\x2\x2\x5E2\x5E3\as\x2\x2\x5E3\x5E5\a\x191\x2\x2\x5E4\x5E6"+
		"\a#\x2\x2\x5E5\x5E4\x3\x2\x2\x2\x5E5\x5E6\x3\x2\x2\x2\x5E6\x5E7\x3\x2"+
		"\x2\x2\x5E7\x5E9\x5\x2AE\x158\x2\x5E8\x5EA\t\f\x2\x2\x5E9\x5E8\x3\x2\x2"+
		"\x2\x5E9\x5EA\x3\x2\x2\x2\x5EA\x5EB\x3\x2\x2\x2\x5EB\x5EC\a\x201\x2\x2"+
		"\x5EC]\x3\x2\x2\x2\x5ED\x5EE\a\n\x2\x2\x5EE\x5EF\a\x191\x2\x2\x5EF\x5F5"+
		"\x5\x2AE\x158\x2\x5F0\x5F6\x5`\x31\x2\x5F1\x5F6\x5\x62\x32\x2\x5F2\x5F6"+
		"\x5\x64\x33\x2\x5F3\x5F6\x5l\x37\x2\x5F4\x5F6\x5\x8EH\x2\x5F5\x5F0\x3"+
		"\x2\x2\x2\x5F5\x5F1\x3\x2\x2\x2\x5F5\x5F2\x3\x2\x2\x2\x5F5\x5F3\x3\x2"+
		"\x2\x2\x5F5\x5F4\x3\x2\x2\x2\x5F6\x5F8\x3\x2\x2\x2\x5F7\x5F9\x5n\x38\x2"+
		"\x5F8\x5F7\x3\x2\x2\x2\x5F8\x5F9\x3\x2\x2\x2\x5F9\x5FA\x3\x2\x2\x2\x5FA"+
		"\x5FB\a\x201\x2\x2\x5FB_\x3\x2\x2\x2\x5FC\x5FE\a@\x2\x2\x5FD\x5FF\a_\x2"+
		"\x2\x5FE\x5FD\x3\x2\x2\x2\x5FE\x5FF\x3\x2\x2\x2\x5FF\x601\x3\x2\x2\x2"+
		"\x600\x602\t\r\x2\x2\x601\x600\x3\x2\x2\x2\x601\x602\x3\x2\x2\x2\x602"+
		"\x606\x3\x2\x2\x2\x603\x605\x5\xB4[\x2\x604\x603\x3\x2\x2\x2\x605\x608"+
		"\x3\x2\x2\x2\x606\x604\x3\x2\x2\x2\x606\x607\x3\x2\x2\x2\x607\x60B\x3"+
		"\x2\x2\x2\x608\x606\x3\x2\x2\x2\x609\x60A\a\x141\x2\x2\x60A\x60C\a\x15F"+
		"\x2\x2\x60B\x609\x3\x2\x2\x2\x60B\x60C\x3\x2\x2\x2\x60C\x61\x3\x2\x2\x2"+
		"\x60D\x60F\a\x13A\x2\x2\x60E\x610\x5\xB2Z\x2\x60F\x60E\x3\x2\x2\x2\x60F"+
		"\x610\x3\x2\x2\x2\x610\x611\x3\x2\x2\x2\x611\x612\a\xF\x2\x2\x612\x613"+
		"\a\x103\x2\x2\x613\x614\a\x1F5\x2\x2\x614\x619\x5\x90I\x2\x615\x616\a"+
		"\x1FB\x2\x2\x616\x618\x5\x90I\x2\x617\x615\x3\x2\x2\x2\x618\x61B\x3\x2"+
		"\x2\x2\x619\x617\x3\x2\x2\x2\x619\x61A\x3\x2\x2\x2\x61A\x61C\x3\x2\x2"+
		"\x2\x61B\x619\x3\x2\x2\x2\x61C\x61D\a\x1F6\x2\x2\x61D\x63\x3\x2\x2\x2"+
		"\x61E\x623\x5\x66\x34\x2\x61F\x620\a\x1FB\x2\x2\x620\x622\x5\x66\x34\x2"+
		"\x621\x61F\x3\x2\x2\x2\x622\x625\x3\x2\x2\x2\x623\x621\x3\x2\x2\x2\x623"+
		"\x624\x3\x2\x2\x2\x624\x65\x3\x2\x2\x2\x625\x623\x3\x2\x2\x2\x626\x629"+
		"\t\xE\x2\x2\x627\x62A\x5\xA0Q\x2\x628\x62A\x5\x98M\x2\x629\x627\x3\x2"+
		"\x2\x2\x629\x628\x3\x2\x2\x2\x62Ag\x3\x2\x2\x2\x62B\x62C\t\xF\x2\x2\x62C"+
		"\x639\a\x13\x2\x2\x62D\x63A\x5j\x36\x2\x62E\x62F\a\x1F5\x2\x2\x62F\x634"+
		"\x5j\x36\x2\x630\x631\a\x1FB\x2\x2\x631\x633\x5j\x36\x2\x632\x630\x3\x2"+
		"\x2\x2\x633\x636\x3\x2\x2\x2\x634\x632\x3\x2\x2\x2\x634\x635\x3\x2\x2"+
		"\x2\x635\x637\x3\x2\x2\x2\x636\x634\x3\x2\x2\x2\x637\x638\a\x1F6\x2\x2"+
		"\x638\x63A\x3\x2\x2\x2\x639\x62D\x3\x2\x2\x2\x639\x62E\x3\x2\x2\x2\x63A"+
		"i\x3\x2\x2\x2\x63B\x63D\x5\x290\x149\x2\x63C\x63E\x5\x2D8\x16D\x2\x63D"+
		"\x63C\x3\x2\x2\x2\x63D\x63E\x3\x2\x2\x2\x63Ek\x3\x2\x2\x2\x63F\x645\a"+
		"\xE4\x2\x2\x640\x641\a\xCE\x2\x2\x641\x646\x5\x1F2\xFA\x2\x642\x643\a"+
		"v\x2\x2\x643\x644\a\x191\x2\x2\x644\x646\x5\x2D8\x16D\x2\x645\x640\x3"+
		"\x2\x2\x2\x645\x642\x3\x2\x2\x2\x646m\x3\x2\x2\x2\x647\x658\a\xBC\x2\x2"+
		"\x648\x652\a.\x2\x2\x649\x64A\aK\x2\x2\x64A\x64B\a\x189\x2\x2\x64B\x653"+
		"\a\x179\x2\x2\x64C\x64E\a\xFC\x2\x2\x64D\x64C\x3\x2\x2\x2\x64D\x64E\x3"+
		"\x2\x2\x2\x64E\x64F\x3\x2\x2\x2\x64F\x650\a\xA9\x2\x2\x650\x651\a\x17D"+
		"\x2\x2\x651\x653\aX\x2\x2\x652\x649\x3\x2\x2\x2\x652\x64D\x3\x2\x2\x2"+
		"\x652\x653\x3\x2\x2\x2\x653\x655\x3\x2\x2\x2\x654\x656\x5p\x39\x2\x655"+
		"\x654\x3\x2\x2\x2\x655\x656\x3\x2\x2\x2\x656\x658\x3\x2\x2\x2\x657\x647"+
		"\x3\x2\x2\x2\x657\x648\x3\x2\x2\x2\x658o\x3\x2\x2\x2\x659\x65B\a\x98\x2"+
		"\x2\x65A\x659\x3\x2\x2\x2\x65A\x65B\x3\x2\x2\x2\x65B\x65C\x3\x2\x2\x2"+
		"\x65C\x65D\a\x84\x2\x2\x65D\x65E\a\xBB\x2\x2\x65E\x65F\x5\x2C8\x165\x2"+
		"\x65Fq\x3\x2\x2\x2\x660\x663\aP\x2\x2\x661\x662\a\x10C\x2\x2\x662\x664"+
		"\a\x13A\x2\x2\x663\x661\x3\x2\x2\x2\x663\x664\x3\x2\x2\x2\x664\x665\x3"+
		"\x2\x2\x2\x665\x668\a\x191\x2\x2\x666\x669\x5t;\x2\x667\x669\x5\x80\x41"+
		"\x2\x668\x666\x3\x2\x2\x2\x668\x667\x3\x2\x2\x2\x669\x66A\x3\x2\x2\x2"+
		"\x66A\x66B\a\x201\x2\x2\x66Bs\x3\x2\x2\x2\x66C\x66F\x5\x2AE\x158\x2\x66D"+
		"\x66E\a\x106\x2\x2\x66E\x670\a\x1F1\x2\x2\x66F\x66D\x3\x2\x2\x2\x66F\x670"+
		"\x3\x2\x2\x2\x670\x672\x3\x2\x2\x2\x671\x673\x5v<\x2\x672\x671\x3\x2\x2"+
		"\x2\x672\x673\x3\x2\x2\x2\x673u\x3\x2\x2\x2\x674\x676\x5\xB2Z\x2\x675"+
		"\x674\x3\x2\x2\x2\x675\x676\x3\x2\x2\x2\x676\x679\x3\x2\x2\x2\x677\x67A"+
		"\x5x=\x2\x678\x67A\x5z>\x2\x679\x677\x3\x2\x2\x2\x679\x678\x3\x2\x2\x2"+
		"\x67A\x67C\x3\x2\x2\x2\x67B\x67D\x5~@\x2\x67C\x67B\x3\x2\x2\x2\x67C\x67D"+
		"\x3\x2\x2\x2\x67D\x689\x3\x2\x2\x2\x67E\x67F\a\x1F5\x2\x2\x67F\x684\x5"+
		"\x90I\x2\x680\x681\a\x1FB\x2\x2\x681\x683\x5\x90I\x2\x682\x680\x3\x2\x2"+
		"\x2\x683\x686\x3\x2\x2\x2\x684\x682\x3\x2\x2\x2\x684\x685\x3\x2\x2\x2"+
		"\x685\x687\x3\x2\x2\x2\x686\x684\x3\x2\x2\x2\x687\x688\a\x1F6\x2\x2\x688"+
		"\x68A\x3\x2\x2\x2\x689\x67E\x3\x2\x2\x2\x689\x68A\x3\x2\x2\x2\x68A\x68E"+
		"\x3\x2\x2\x2\x68B\x68D\x5\x8EH\x2\x68C\x68B\x3\x2\x2\x2\x68D\x690\x3\x2"+
		"\x2\x2\x68E\x68C\x3\x2\x2\x2\x68E\x68F\x3\x2\x2\x2\x68Fw\x3\x2\x2\x2\x690"+
		"\x68E\x3\x2\x2\x2\x691\x695\t\x3\x2\x2\x692\x696\a\x103\x2\x2\x693\x696"+
		"\x5\xDEp\x2\x694\x696\x5|?\x2\x695\x692\x3\x2\x2\x2\x695\x693\x3\x2\x2"+
		"\x2\x695\x694\x3\x2\x2\x2\x696y\x3\x2\x2\x2\x697\x698\a\x193\x2\x2\x698"+
		"\x699\x5\x2D8\x16D\x2\x699{\x3\x2\x2\x2\x69A\x69B\a\x17D\x2\x2\x69B\x69C"+
		"\a\x104\x2\x2\x69C\x69F\x5\x2D8\x16D\x2\x69D\x69E\a\xFC\x2\x2\x69E\x6A0"+
		"\a\xFE\x2\x2\x69F\x69D\x3\x2\x2\x2\x69F\x6A0\x3\x2\x2\x2\x6A0}\x3\x2\x2"+
		"\x2\x6A1\x6A2\a\x8B\x2\x2\x6A2\x6A3\a\xE7\x2\x2\x6A3\x6A4\x5\x1F2\xFA"+
		"\x2\x6A4\x6A5\a\xC3\x2\x2\x6A5\x6A6\a\xC0\x2\x2\x6A6\x6A7\a\x19E\x2\x2"+
		"\x6A7\x6A8\t\x10\x2\x2\x6A8\x7F\x3\x2\x2\x2\x6A9\x6AA\a#\x2\x2\x6AA\x6AB"+
		"\x5\x2AE\x158\x2\x6AB\x6AD\t\x3\x2\x2\x6AC\x6AE\x5\x82\x42\x2\x6AD\x6AC"+
		"\x3\x2\x2\x2\x6AE\x6AF\x3\x2\x2\x2\x6AF\x6AD\x3\x2\x2\x2\x6AF\x6B0\x3"+
		"\x2\x2\x2\x6B0\x6B1\x3\x2\x2\x2\x6B1\x6B2\a|\x2\x2\x6B2\x81\x3\x2\x2\x2"+
		"\x6B3\x6B6\x5\x84\x43\x2\x6B4\x6B6\x5\x86\x44\x2\x6B5\x6B3\x3\x2\x2\x2"+
		"\x6B5\x6B4\x3\x2\x2\x2\x6B6\x83\x3\x2\x2\x2\x6B7\x6B8\t\x11\x2\x2\x6B8"+
		"\x6B9\a\xDC\x2\x2\x6B9\x6BA\x5\x8A\x46\x2\x6BA\x85\x3\x2\x2\x2\x6BB\x6BF"+
		"\t\x12\x2\x2\x6BC\x6C0\x5\x88\x45\x2\x6BD\x6C0\x5\x8A\x46\x2\x6BE\x6C0"+
		"\x5\x8CG\x2\x6BF\x6BC\x3\x2\x2\x2\x6BF\x6BD\x3\x2\x2\x2\x6BF\x6BE\x3\x2"+
		"\x2\x2\x6C0\x87\x3\x2\x2\x2\x6C1\x6C2\a\x12D\x2\x2\x6C2\x6C3\x5\x2B6\x15C"+
		"\x2\x6C3\x6C4\a\x1F5\x2\x2\x6C4\x6C9\x5\xA6T\x2\x6C5\x6C6\a\x1FB\x2\x2"+
		"\x6C6\x6C8\x5\xA6T\x2\x6C7\x6C5\x3\x2\x2\x2\x6C8\x6CB\x3\x2\x2\x2\x6C9"+
		"\x6C7\x3\x2\x2\x2\x6C9\x6CA\x3\x2\x2\x2\x6CA\x6CC\x3\x2\x2\x2\x6CB\x6C9"+
		"\x3\x2\x2\x2\x6CC\x6CD\a\x1F6\x2\x2\x6CD\x6DB\t\x3\x2\x2\x6CE\x6DC\x5"+
		"\xB6\\\x2\x6CF\x6D1\a\x62\x2\x2\x6D0\x6CF\x3\x2\x2\x2\x6D0\x6D1\x3\x2"+
		"\x2\x2\x6D1\x6D5\x3\x2\x2\x2\x6D2\x6D4\x5\xC4\x63\x2\x6D3\x6D2\x3\x2\x2"+
		"\x2\x6D4\x6D7\x3\x2\x2\x2\x6D5\x6D3\x3\x2\x2\x2\x6D5\x6D6\x3\x2\x2\x2"+
		"\x6D6\x6D8\x3\x2\x2\x2\x6D7\x6D5\x3\x2\x2\x2\x6D8\x6D9\x5\x10A\x86\x2"+
		"\x6D9\x6DA\a\x201\x2\x2\x6DA\x6DC\x3\x2\x2\x2\x6DB\x6CE\x3\x2\x2\x2\x6DB"+
		"\x6D0\x3\x2\x2\x2\x6DC\x89\x3\x2\x2\x2\x6DD\x6DE\a\x9B\x2\x2\x6DE\x6EA"+
		"\x5\x2B4\x15B\x2\x6DF\x6E0\a\x1F5\x2\x2\x6E0\x6E5\x5\xA6T\x2\x6E1\x6E2"+
		"\a\x1FB\x2\x2\x6E2\x6E4\x5\xA6T\x2\x6E3\x6E1\x3\x2\x2\x2\x6E4\x6E7\x3"+
		"\x2\x2\x2\x6E5\x6E3\x3\x2\x2\x2\x6E5\x6E6\x3\x2\x2\x2\x6E6\x6E8\x3\x2"+
		"\x2\x2\x6E7\x6E5\x3\x2\x2\x2\x6E8\x6E9\a\x1F6\x2\x2\x6E9\x6EB\x3\x2\x2"+
		"\x2\x6EA\x6DF\x3\x2\x2\x2\x6EA\x6EB\x3\x2\x2\x2\x6EB\x6EC\x3\x2\x2\x2"+
		"\x6EC\x6ED\a\x13F\x2\x2\x6ED\x6EE\x5\x2D8\x16D\x2\x6EE\x6FC\t\x3\x2\x2"+
		"\x6EF\x6FD\x5\xB6\\\x2\x6F0\x6F2\a\x62\x2\x2\x6F1\x6F0\x3\x2\x2\x2\x6F1"+
		"\x6F2\x3\x2\x2\x2\x6F2\x6F6\x3\x2\x2\x2\x6F3\x6F5\x5\xC4\x63\x2\x6F4\x6F3"+
		"\x3\x2\x2\x2\x6F5\x6F8\x3\x2\x2\x2\x6F6\x6F4\x3\x2\x2\x2\x6F6\x6F7\x3"+
		"\x2\x2\x2\x6F7\x6F9\x3\x2\x2\x2\x6F8\x6F6\x3\x2\x2\x2\x6F9\x6FA\x5\x10A"+
		"\x86\x2\x6FA\x6FB\a\x201\x2\x2\x6FB\x6FD\x3\x2\x2\x2\x6FC\x6EF\x3\x2\x2"+
		"\x2\x6FC\x6F1\x3\x2\x2\x2\x6FD\x8B\x3\x2\x2\x2\x6FE\x700\a\x90\x2\x2\x6FF"+
		"\x6FE\x3\x2\x2\x2\x6FF\x700\x3\x2\x2\x2\x700\x702\x3\x2\x2\x2\x701\x703"+
		"\a\xB5\x2\x2\x702\x701\x3\x2\x2\x2\x702\x703\x3\x2\x2\x2\x703\x704\x3"+
		"\x2\x2\x2\x704\x705\aG\x2\x2\x705\x706\a\x9B\x2\x2\x706\x718\x5\x2D8\x16D"+
		"\x2\x707\x708\a\x1F5\x2\x2\x708\x709\a\x156\x2\x2\x709\x70A\a\xA7\x2\x2"+
		"\x70A\x70B\a\x111\x2\x2\x70B\x70C\x5\x2D8\x16D\x2\x70C\x70D\a\x1FB\x2"+
		"\x2\x70D\x70E\x3\x2\x2\x2\x70E\x713\x5\xA6T\x2\x70F\x710\a\x1FB\x2\x2"+
		"\x710\x712\x5\xA6T\x2\x711\x70F\x3\x2\x2\x2\x712\x715\x3\x2\x2\x2\x713"+
		"\x711\x3\x2\x2\x2\x713\x714\x3\x2\x2\x2\x714\x716\x3\x2\x2\x2\x715\x713"+
		"\x3\x2\x2\x2\x716\x717\a\x1F6\x2\x2\x717\x719\x3\x2\x2\x2\x718\x707\x3"+
		"\x2\x2\x2\x718\x719\x3\x2\x2\x2\x719\x71A\x3\x2\x2\x2\x71A\x71B\a\x13F"+
		"\x2\x2\x71B\x71C\a\x156\x2\x2\x71C\x71D\a\xF\x2\x2\x71D\x71E\a\x13D\x2"+
		"\x2\x71E\x72C\t\x3\x2\x2\x71F\x72D\x5\xB6\\\x2\x720\x722\a\x62\x2\x2\x721"+
		"\x720\x3\x2\x2\x2\x721\x722\x3\x2\x2\x2\x722\x726\x3\x2\x2\x2\x723\x725"+
		"\x5\xC4\x63\x2\x724\x723\x3\x2\x2\x2\x725\x728\x3\x2\x2\x2\x726\x724\x3"+
		"\x2\x2\x2\x726\x727\x3\x2\x2\x2\x727\x729\x3\x2\x2\x2\x728\x726\x3\x2"+
		"\x2\x2\x729\x72A\x5\x10A\x86\x2\x72A\x72B\a\x201\x2\x2\x72B\x72D\x3\x2"+
		"\x2\x2\x72C\x71F\x3\x2\x2\x2\x72C\x721\x3\x2\x2\x2\x72D\x8D\x3\x2\x2\x2"+
		"\x72E\x730\a\xFC\x2\x2\x72F\x72E\x3\x2\x2\x2\x72F\x730\x3\x2\x2\x2\x730"+
		"\x731\x3\x2\x2\x2\x731\x732\t\x13\x2\x2\x732\x8F\x3\x2\x2\x2\x733\x734"+
		"\x5\x2F0\x179\x2\x734\x736\x5\x2D8\x16D\x2\x735\x737\x5\x92J\x2\x736\x735"+
		"\x3\x2\x2\x2\x736\x737\x3\x2\x2\x2\x737\x73A\x3\x2\x2\x2\x738\x73A\x5"+
		"\x94K\x2\x739\x733\x3\x2\x2\x2\x739\x738\x3\x2\x2\x2\x73A\x91\x3\x2\x2"+
		"\x2\x73B\x73C\a\x8B\x2\x2\x73C\x73D\a\xE7\x2\x2\x73D\x73E\x5\x1F2\xFA"+
		"\x2\x73E\x93\x3\x2\x2\x2\x73F\x741\x5\x8EH\x2\x740\x73F\x3\x2\x2\x2\x740"+
		"\x741\x3\x2\x2\x2\x741\x743\x3\x2\x2\x2\x742\x744\x5\x96L\x2\x743\x742"+
		"\x3\x2\x2\x2\x744\x745\x3\x2\x2\x2\x745\x743\x3\x2\x2\x2\x745\x746\x3"+
		"\x2\x2\x2\x746\x749\x3\x2\x2\x2\x747\x748\a\x1FB\x2\x2\x748\x74A\x5\xA2"+
		"R\x2\x749\x747\x3\x2\x2\x2\x749\x74A\x3\x2\x2\x2\x74A\x95\x3\x2\x2\x2"+
		"\x74B\x74F\x5\x98M\x2\x74C\x74F\x5\x9EP\x2\x74D\x74F\x5\xA0Q\x2\x74E\x74B"+
		"\x3\x2\x2\x2\x74E\x74C\x3\x2\x2\x2\x74E\x74D\x3\x2\x2\x2\x74F\x97\x3\x2"+
		"\x2\x2\x750\x753\t\x12\x2\x2\x751\x754\x5\x9AN\x2\x752\x754\x5\x9CO\x2"+
		"\x753\x751\x3\x2\x2\x2\x753\x752\x3\x2\x2\x2\x754\x99\x3\x2\x2\x2\x755"+
		"\x756\a\x12D\x2\x2\x756\x757\x5\x2B6\x15C\x2\x757\x758\a\x1F5\x2\x2\x758"+
		"\x75D\x5\xA6T\x2\x759\x75A\a\x1FB\x2\x2\x75A\x75C\x5\xA6T\x2\x75B\x759"+
		"\x3\x2\x2\x2\x75C\x75F\x3\x2\x2\x2\x75D\x75B\x3\x2\x2\x2\x75D\x75E\x3"+
		"\x2\x2\x2\x75E\x760\x3\x2\x2\x2\x75F\x75D\x3\x2\x2\x2\x760\x763\a\x1F6"+
		"\x2\x2\x761\x762\t\x3\x2\x2\x762\x764\x5\xB6\\\x2\x763\x761\x3\x2\x2\x2"+
		"\x763\x764\x3\x2\x2\x2\x764\x9B\x3\x2\x2\x2\x765\x766\a\x9B\x2\x2\x766"+
		"\x772\x5\x2B4\x15B\x2\x767\x768\a\x1F5\x2\x2\x768\x76D\x5\xA6T\x2\x769"+
		"\x76A\a\x1FB\x2\x2\x76A\x76C\x5\xA6T\x2\x76B\x769\x3\x2\x2\x2\x76C\x76F"+
		"\x3\x2\x2\x2\x76D\x76B\x3\x2\x2\x2\x76D\x76E\x3\x2\x2\x2\x76E\x770\x3"+
		"\x2\x2\x2\x76F\x76D\x3\x2\x2\x2\x770\x771\a\x1F6\x2\x2\x771\x773\x3\x2"+
		"\x2\x2\x772\x767\x3\x2\x2\x2\x772\x773\x3\x2\x2\x2\x773\x774\x3\x2\x2"+
		"\x2\x774\x779\a\x13F\x2\x2\x775\x77A\x5\x2D8\x16D\x2\x776\x777\a\x156"+
		"\x2\x2\x777\x778\a\xF\x2\x2\x778\x77A\a\x13D\x2\x2\x779\x775\x3\x2\x2"+
		"\x2\x779\x776\x3\x2\x2\x2\x77A\x783\x3\x2\x2\x2\x77B\x77C\t\x3\x2\x2\x77C"+
		"\x784\x5\xB6\\\x2\x77D\x77F\a\x8B\x2\x2\x77E\x780\a\x1A4\x2\x2\x77F\x77E"+
		"\x3\x2\x2\x2\x77F\x780\x3\x2\x2\x2\x780\x781\x3\x2\x2\x2\x781\x782\a\xE7"+
		"\x2\x2\x782\x784\x5\x1F2\xFA\x2\x783\x77B\x3\x2\x2\x2\x783\x77D\x3\x2"+
		"\x2\x2\x783\x784\x3\x2\x2\x2\x784\x9D\x3\x2\x2\x2\x785\x787\a\x90\x2\x2"+
		"\x786\x785\x3\x2\x2\x2\x786\x787\x3\x2\x2\x2\x787\x789\x3\x2\x2\x2\x788"+
		"\x78A\a\xB5\x2\x2\x789\x788\x3\x2\x2\x2\x789\x78A\x3\x2\x2\x2\x78A\x78B"+
		"\x3\x2\x2\x2\x78B\x78C\aG\x2\x2\x78C\x78D\a\x9B\x2\x2\x78D\x79F\x5\x2D8"+
		"\x16D\x2\x78E\x78F\a\x1F5\x2\x2\x78F\x790\a\x156\x2\x2\x790\x791\a\xA7"+
		"\x2\x2\x791\x792\a\x111\x2\x2\x792\x793\x5\x2D8\x16D\x2\x793\x794\a\x1FB"+
		"\x2\x2\x794\x795\x3\x2\x2\x2\x795\x79A\x5\xA6T\x2\x796\x797\a\x1FB\x2"+
		"\x2\x797\x799\x5\xA6T\x2\x798\x796\x3\x2\x2\x2\x799\x79C\x3\x2\x2\x2\x79A"+
		"\x798\x3\x2\x2\x2\x79A\x79B\x3\x2\x2\x2\x79B\x79D\x3\x2\x2\x2\x79C\x79A"+
		"\x3\x2\x2\x2\x79D\x79E\a\x1F6\x2\x2\x79E\x7A0\x3\x2\x2\x2\x79F\x78E\x3"+
		"\x2\x2\x2\x79F\x7A0\x3\x2\x2\x2\x7A0\x7A1\x3\x2\x2\x2\x7A1\x7A2\a\x13F"+
		"\x2\x2\x7A2\x7A3\a\x156\x2\x2\x7A3\x7A4\a\xF\x2\x2\x7A4\x7A7\a\x13D\x2"+
		"\x2\x7A5\x7A6\t\x3\x2\x2\x7A6\x7A8\x5\xB6\\\x2\x7A7\x7A5\x3\x2\x2\x2\x7A7"+
		"\x7A8\x3\x2\x2\x2\x7A8\x9F\x3\x2\x2\x2\x7A9\x7AA\t\x11\x2\x2\x7AA\x7AB"+
		"\a\xDC\x2\x2\x7AB\x7AC\x5\x9CO\x2\x7AC\xA1\x3\x2\x2\x2\x7AD\x7AE\a\x128"+
		"\x2\x2\x7AE\x7AF\a\x13C\x2\x2\x7AF\x7B0\a\x1F5\x2\x2\x7B0\x7B5\x5\xA4"+
		"S\x2\x7B1\x7B2\a\x1FB\x2\x2\x7B2\x7B4\x5\xA4S\x2\x7B3\x7B1\x3\x2\x2\x2"+
		"\x7B4\x7B7\x3\x2\x2\x2\x7B5\x7B3\x3\x2\x2\x2\x7B5\x7B6\x3\x2\x2\x2\x7B6"+
		"\x7B8\x3\x2\x2\x2\x7B7\x7B5\x3\x2\x2\x2\x7B8\x7B9\a\x1F6\x2\x2\x7B9\xA3"+
		"\x3\x2\x2\x2\x7BA\x7BD\x5\x2F0\x179\x2\x7BB\x7BD\a\x65\x2\x2\x7BC\x7BA"+
		"\x3\x2\x2\x2\x7BC\x7BB\x3\x2\x2\x2\x7BD\xA5\x3\x2\x2\x2\x7BE\x7BF\x5\x2A0"+
		"\x151\x2\x7BF\x7C0\x5\x2D8\x16D\x2\x7C0\xA7\x3\x2\x2\x2\x7C1\x7C2\as\x2"+
		"\x2\x7C2\x7C3\a\x157\x2\x2\x7C3\x7C4\x5\x2B0\x159\x2\x7C4\x7C5\a\x201"+
		"\x2\x2\x7C5\xA9\x3\x2\x2\x2\x7C6\x7C7\a\n\x2\x2\x7C7\x7C8\a\x157\x2\x2"+
		"\x7C8\x7CA\x5\x2B0\x159\x2\x7C9\x7CB\x5\xAEX\x2\x7CA\x7C9\x3\x2\x2\x2"+
		"\x7CB\x7CC\x3\x2\x2\x2\x7CC\x7CA\x3\x2\x2\x2\x7CC\x7CD\x3\x2\x2\x2\x7CD"+
		"\x7CE\x3\x2\x2\x2\x7CE\x7CF\a\x201\x2\x2\x7CF\xAB\x3\x2\x2\x2\x7D0\x7D1"+
		"\aP\x2\x2\x7D1\x7D2\a\x157\x2\x2\x7D2\x7D7\x5\x2B0\x159\x2\x7D3\x7D6\x5"+
		"\xB0Y\x2\x7D4\x7D6\x5\xAEX\x2\x7D5\x7D3\x3\x2\x2\x2\x7D5\x7D4\x3\x2\x2"+
		"\x2\x7D6\x7D9\x3\x2\x2\x2\x7D7\x7D5\x3\x2\x2\x2\x7D7\x7D8\x3\x2\x2\x2"+
		"\x7D8\x7DA\x3\x2\x2\x2\x7D9\x7D7\x3\x2\x2\x2\x7DA\x7DB\a\x201\x2\x2\x7DB"+
		"\xAD\x3\x2\x2\x2\x7DC\x7DD\a\xAA\x2\x2\x7DD\x7DE\a(\x2\x2\x7DE\x7ED\a"+
		"\x1EF\x2\x2\x7DF\x7E0\a\xDA\x2\x2\x7E0\x7ED\a\x1EF\x2\x2\x7E1\x7ED\a\xF7"+
		"\x2\x2\x7E2\x7E3\a\xE0\x2\x2\x7E3\x7ED\a\x1EF\x2\x2\x7E4\x7ED\a\xF8\x2"+
		"\x2\x7E5\x7ED\aW\x2\x2\x7E6\x7ED\a\xF5\x2\x2\x7E7\x7E8\a+\x2\x2\x7E8\x7ED"+
		"\a\x1EF\x2\x2\x7E9\x7ED\a\xF3\x2\x2\x7EA\x7ED\a\x10E\x2\x2\x7EB\x7ED\a"+
		"\xFA\x2\x2\x7EC\x7DC\x3\x2\x2\x2\x7EC\x7DF\x3\x2\x2\x2\x7EC\x7E1\x3\x2"+
		"\x2\x2\x7EC\x7E2\x3\x2\x2\x2\x7EC\x7E4\x3\x2\x2\x2\x7EC\x7E5\x3\x2\x2"+
		"\x2\x7EC\x7E6\x3\x2\x2\x2\x7EC\x7E7\x3\x2\x2\x2\x7EC\x7E9\x3\x2\x2\x2"+
		"\x7EC\x7EA\x3\x2\x2\x2\x7EC\x7EB\x3\x2\x2\x2\x7ED\xAF\x3\x2\x2\x2\x7EE"+
		"\x7EF\a\x170\x2\x2\x7EF\x7F0\a\x1B0\x2\x2\x7F0\x7F1\a\x1EF\x2\x2\x7F1"+
		"\xB1\x3\x2\x2\x2\x7F2\x7F3\a\x15\x2\x2\x7F3\x7F4\t\x14\x2\x2\x7F4\xB3"+
		"\x3\x2\x2\x2\x7F5\x7F6\x5\x2F0\x179\x2\x7F6\x7F7\a\x20C\x2\x2\x7F7\x7F8"+
		"\x5\x1F2\xFA\x2\x7F8\xB5\x3\x2\x2\x2\x7F9\x7FC\a\xC3\x2\x2\x7FA\x7FD\x5"+
		"\xB8]\x2\x7FB\x7FD\x5\xBA^\x2\x7FC\x7FA\x3\x2\x2\x2\x7FC\x7FB\x3\x2\x2"+
		"\x2\x7FD\xB7\x3\x2\x2\x2\x7FE\x7FF\a\xC0\x2\x2\x7FF\x800\a\xE7\x2\x2\x800"+
		"\x801\a\x1F1\x2\x2\x801\xB9\x3\x2\x2\x2\x802\x805\a*\x2\x2\x803\x804\a"+
		"\xE7\x2\x2\x804\x806\a\x1F1\x2\x2\x805\x803\x3\x2\x2\x2\x805\x806\x3\x2"+
		"\x2\x2\x806\x807\x3\x2\x2\x2\x807\x808\a\xC9\x2\x2\x808\x80A\x5\x2F0\x179"+
		"\x2\x809\x80B\x5\xBC_\x2\x80A\x809\x3\x2\x2\x2\x80A\x80B\x3\x2\x2\x2\x80B"+
		"\x80E\x3\x2\x2\x2\x80C\x80D\a\x1B0\x2\x2\x80D\x80F\aI\x2\x2\x80E\x80C"+
		"\x3\x2\x2\x2\x80E\x80F\x3\x2\x2\x2\x80F\x811\x3\x2\x2\x2\x810\x812\x5"+
		"\xBE`\x2\x811\x810\x3\x2\x2\x2\x811\x812\x3\x2\x2\x2\x812\xBB\x3\x2\x2"+
		"\x2\x813\x814\a\a\x2\x2\x814\x815\a\xA7\x2\x2\x815\x816\a\x1F5\x2\x2\x816"+
		"\x81B\x5\x1F2\xFA\x2\x817\x818\a\x1FB\x2\x2\x818\x81A\x5\x1F2\xFA\x2\x819"+
		"\x817\x3\x2\x2\x2\x81A\x81D\x3\x2\x2\x2\x81B\x819\x3\x2\x2\x2\x81B\x81C"+
		"\x3\x2\x2\x2\x81C\x81E\x3\x2\x2\x2\x81D\x81B\x3\x2\x2\x2\x81E\x81F\a\x1F6"+
		"\x2\x2\x81F\xBD\x3\x2\x2\x2\x820\x821\a\x117\x2\x2\x821\x82D\a\x1F5\x2"+
		"\x2\x822\x827\x5\x1F2\xFA\x2\x823\x824\a\x1FB\x2\x2\x824\x826\x5\x1F2"+
		"\xFA\x2\x825\x823\x3\x2\x2\x2\x826\x829\x3\x2\x2\x2\x827\x825\x3\x2\x2"+
		"\x2\x827\x828\x3\x2\x2\x2\x828\x82E\x3\x2\x2\x2\x829\x827\x3\x2\x2\x2"+
		"\x82A\x82B\a\x1EE\x2\x2\x82B\x82C\a\x1EE\x2\x2\x82C\x82E\a\x1EE\x2\x2"+
		"\x82D\x822\x3\x2\x2\x2\x82D\x82A\x3\x2\x2\x2\x82E\x82F\x3\x2\x2\x2\x82F"+
		"\x830\a\x1F6\x2\x2\x830\xBF\x3\x2\x2\x2\x831\x835\x5\x2A0\x151\x2\x832"+
		"\x834\t\x15\x2\x2\x833\x832\x3\x2\x2\x2\x834\x837\x3\x2\x2\x2\x835\x833"+
		"\x3\x2\x2\x2\x835\x836\x3\x2\x2\x2\x836\x839\x3\x2\x2\x2\x837\x835\x3"+
		"\x2\x2\x2\x838\x83A\x5\x2D8\x16D\x2\x839\x838\x3\x2\x2\x2\x839\x83A\x3"+
		"\x2\x2\x2\x83A\x83C\x3\x2\x2\x2\x83B\x83D\x5\xC2\x62\x2\x83C\x83B\x3\x2"+
		"\x2\x2\x83C\x83D\x3\x2\x2\x2\x83D\xC1\x3\x2\x2\x2\x83E\x83F\t\x16\x2\x2"+
		"\x83F\x840\x5\x1F2\xFA\x2\x840\xC3\x3\x2\x2\x2\x841\x84C\x5\xC6\x64\x2"+
		"\x842\x84C\x5\xC8\x65\x2\x843\x84C\x5\xCA\x66\x2\x844\x84C\x5\xCEh\x2"+
		"\x845\x84C\x5\xD0i\x2\x846\x84C\x5\xD8m\x2\x847\x84C\x5&\x14\x2\x848\x84C"+
		"\x5(\x15\x2\x849\x84C\x5\x32\x1A\x2\x84A\x84C\x5\x30\x19\x2\x84B\x841"+
		"\x3\x2\x2\x2\x84B\x842\x3\x2\x2\x2\x84B\x843\x3\x2\x2\x2\x84B\x844\x3"+
		"\x2\x2\x2\x84B\x845\x3\x2\x2\x2\x84B\x846\x3\x2\x2\x2\x84B\x847\x3\x2"+
		"\x2\x2\x84B\x848\x3\x2\x2\x2\x84B\x849\x3\x2\x2\x2\x84B\x84A\x3\x2\x2"+
		"\x2\x84C\xC5\x3\x2\x2\x2\x84D\x84F\x5\x2F0\x179\x2\x84E\x850\a\x44\x2"+
		"\x2\x84F\x84E\x3\x2\x2\x2\x84F\x850\x3\x2\x2\x2\x850\x851\x3\x2\x2\x2"+
		"\x851\x854\x5\x2D8\x16D\x2\x852\x853\a\xFC\x2\x2\x853\x855\a\xFE\x2\x2"+
		"\x854\x852\x3\x2\x2\x2\x854\x855\x3\x2\x2\x2\x855\x857\x3\x2\x2\x2\x856"+
		"\x858\x5\xC2\x62\x2\x857\x856\x3\x2\x2\x2\x857\x858\x3\x2\x2\x2\x858\x859"+
		"\x3\x2\x2\x2\x859\x85A\a\x201\x2\x2\x85A\xC7\x3\x2\x2\x2\x85B\x85C\a\x17A"+
		"\x2\x2\x85C\x85D\x5\x2F0\x179\x2\x85D\x85E\a\xBD\x2\x2\x85E\x864\x5\x2D8"+
		"\x16D\x2\x85F\x860\a\x12F\x2\x2\x860\x861\x5\x1F2\xFA\x2\x861\x862\a\x3"+
		"\x2\x2\x862\x863\x5\x1F2\xFA\x2\x863\x865\x3\x2\x2\x2\x864\x85F\x3\x2"+
		"\x2\x2\x864\x865\x3\x2\x2\x2\x865\x868\x3\x2\x2\x2\x866\x867\a\xFC\x2"+
		"\x2\x867\x869\a\xFE\x2\x2\x868\x866\x3\x2\x2\x2\x868\x869\x3\x2\x2\x2"+
		"\x869\x86A\x3\x2\x2\x2\x86A\x86B\a\x201\x2\x2\x86B\xC9\x3\x2\x2\x2\x86C"+
		"\x86D\aU\x2\x2\x86D\x879\x5\x2F0\x179\x2\x86E\x86F\a\x1F5\x2\x2\x86F\x874"+
		"\x5\xCCg\x2\x870\x871\a\x1FB\x2\x2\x871\x873\x5\xCCg\x2\x872\x870\x3\x2"+
		"\x2\x2\x873\x876\x3\x2\x2\x2\x874\x872\x3\x2\x2\x2\x874\x875\x3\x2\x2"+
		"\x2\x875\x877\x3\x2\x2\x2\x876\x874\x3\x2\x2\x2\x877\x878\a\x1F6\x2\x2"+
		"\x878\x87A\x3\x2\x2\x2\x879\x86E\x3\x2\x2\x2\x879\x87A\x3\x2\x2\x2\x87A"+
		"\x87D\x3\x2\x2\x2\x87B\x87C\a\x13F\x2\x2\x87C\x87E\x5\x2D8\x16D\x2\x87D"+
		"\x87B\x3\x2\x2\x2\x87D\x87E\x3\x2\x2\x2\x87E\x881\x3\x2\x2\x2\x87F\x880"+
		"\a\xBD\x2\x2\x880\x882\x5\x134\x9B\x2\x881\x87F\x3\x2\x2\x2\x881\x882"+
		"\x3\x2\x2\x2\x882\x883\x3\x2\x2\x2\x883\x884\a\x201\x2\x2\x884\xCB\x3"+
		"\x2\x2\x2\x885\x88A\x5\x2A0\x151\x2\x886\x888\a\xA7\x2\x2\x887\x886\x3"+
		"\x2\x2\x2\x887\x888\x3\x2\x2\x2\x888\x889\x3\x2\x2\x2\x889\x88B\x5\x2D8"+
		"\x16D\x2\x88A\x887\x3\x2\x2\x2\x88A\x88B\x3\x2\x2\x2\x88B\x88D\x3\x2\x2"+
		"\x2\x88C\x88E\x5\xC2\x62\x2\x88D\x88C\x3\x2\x2\x2\x88D\x88E\x3\x2\x2\x2"+
		"\x88E\xCD\x3\x2\x2\x2\x88F\x890\x5\x2F0\x179\x2\x890\x891\a\x82\x2\x2"+
		"\x891\x892\a\x201\x2\x2\x892\xCF\x3\x2\x2\x2\x893\x8B2\a\x128\x2\x2\x894"+
		"\x8B3\a\x15A\x2\x2\x895\x8B3\a\x18\x2\x2\x896\x897\a\x83\x2\x2\x897\x898"+
		"\a\x1F5\x2\x2\x898\x899\x5\x2B2\x15A\x2\x899\x89A\a\x1FB\x2\x2\x89A\x89B"+
		"\x5\x2EC\x177\x2\x89B\x89C\a\x1F6\x2\x2\x89C\x8B3\x3\x2\x2\x2\x89D\x89E"+
		"\a\xB1\x2\x2\x89E\x89F\a\x1F5\x2\x2\x89F\x8A0\x5\x2F0\x179\x2\x8A0\x8A1"+
		"\a\x1FB\x2\x2\x8A1\x8A2\x5\x1F2\xFA\x2\x8A2\x8A3\a\x1F6\x2\x2\x8A3\x8B3"+
		"\x3\x2\x2\x2\x8A4\x8A5\a\x13C\x2\x2\x8A5\x8A8\a\x1F5\x2\x2\x8A6\x8A9\x5"+
		"\x2F0\x179\x2\x8A7\x8A9\a\x65\x2\x2\x8A8\x8A6\x3\x2\x2\x2\x8A8\x8A7\x3"+
		"\x2\x2\x2\x8A9\x8AC\x3\x2\x2\x2\x8AA\x8AB\a\x1FB\x2\x2\x8AB\x8AD\x5\x2F0"+
		"\x179\x2\x8AC\x8AA\x3\x2\x2\x2\x8AD\x8AE\x3\x2\x2\x2\x8AE\x8AC\x3\x2\x2"+
		"\x2\x8AE\x8AF\x3\x2\x2\x2\x8AF\x8B0\x3\x2\x2\x2\x8B0\x8B1\a\x1F6\x2\x2"+
		"\x8B1\x8B3\x3\x2\x2\x2\x8B2\x894\x3\x2\x2\x2\x8B2\x895\x3\x2\x2\x2\x8B2"+
		"\x896\x3\x2\x2\x2\x8B2\x89D\x3\x2\x2\x2\x8B2\x8A4\x3\x2\x2\x2\x8B3\x8B4"+
		"\x3\x2\x2\x2\x8B4\x8B5\a\x201\x2\x2\x8B5\xD1\x3\x2\x2\x2\x8B6\x8B7\a\x133"+
		"\x2\x2\x8B7\x8B8\a\x1F5\x2\x2\x8B8\x8BD\x5\xD4k\x2\x8B9\x8BA\a\x1FB\x2"+
		"\x2\x8BA\x8BC\x5\xD4k\x2\x8BB\x8B9\x3\x2\x2\x2\x8BC\x8BF\x3\x2\x2\x2\x8BD"+
		"\x8BB\x3\x2\x2\x2\x8BD\x8BE\x3\x2\x2\x2\x8BE\x8C0\x3\x2\x2\x2\x8BF\x8BD"+
		"\x3\x2\x2\x2\x8C0\x8C1\a\x1F6\x2\x2\x8C1\xD3\x3\x2\x2\x2\x8C2\x8C4\x5"+
		"\x2C6\x164\x2\x8C3\x8C5\x5\x2D8\x16D\x2\x8C4\x8C3\x3\x2\x2\x2\x8C4\x8C5"+
		"\x3\x2\x2\x2\x8C5\x8C8\x3\x2\x2\x2\x8C6\x8C7\a\xFC\x2\x2\x8C7\x8C9\a\xFE"+
		"\x2\x2\x8C8\x8C6\x3\x2\x2\x2\x8C8\x8C9\x3\x2\x2\x2\x8C9\x8CB\x3\x2\x2"+
		"\x2\x8CA\x8CC\x5\xC2\x62\x2\x8CB\x8CA\x3\x2\x2\x2\x8CB\x8CC\x3\x2\x2\x2"+
		"\x8CC\xD5\x3\x2\x2\x2\x8CD\x8CE\a\x134\x2\x2\x8CE\x8D1\aU\x2\x2\x8CF\x8D0"+
		"\a\x13F\x2\x2\x8D0\x8D2\x5\x2D8\x16D\x2\x8D1\x8CF\x3\x2\x2\x2\x8D1\x8D2"+
		"\x3\x2\x2\x2\x8D2\xD7\x3\x2\x2\x2\x8D3\x8D4\a\x191\x2\x2\x8D4\x8D5\x5"+
		"\x2F0\x179\x2\x8D5\x8DA\a\xBD\x2\x2\x8D6\x8DB\x5\xDAn\x2\x8D7\x8DB\x5"+
		"\xDEp\x2\x8D8\x8DB\x5\xD2j\x2\x8D9\x8DB\x5\xD6l\x2\x8DA\x8D6\x3\x2\x2"+
		"\x2\x8DA\x8D7\x3\x2\x2\x2\x8DA\x8D8\x3\x2\x2\x2\x8DA\x8D9\x3\x2\x2\x2"+
		"\x8DB\x8DC\x3\x2\x2\x2\x8DC\x8DD\a\x201\x2\x2\x8DD\xD9\x3\x2\x2\x2\x8DE"+
		"\x8DF\a\x17D\x2\x2\x8DF\x8E0\a\x104\x2\x2\x8E0\x8E2\x5\x2D8\x16D\x2\x8E1"+
		"\x8E3\x5\xDCo\x2\x8E2\x8E1\x3\x2\x2\x2\x8E2\x8E3\x3\x2\x2\x2\x8E3\x8E6"+
		"\x3\x2\x2\x2\x8E4\x8E5\a\xFC\x2\x2\x8E5\x8E7\a\xFE\x2\x2\x8E6\x8E4\x3"+
		"\x2\x2\x2\x8E6\x8E7\x3\x2\x2\x2\x8E7\xDB\x3\x2\x2\x2\x8E8\x8EB\a\xAD\x2"+
		"\x2\x8E9\x8EB\a\xAC\x2\x2\x8EA\x8E8\x3\x2\x2\x2\x8EA\x8E9\x3\x2\x2\x2"+
		"\x8EB\x8EC\x3\x2\x2\x2\x8EC\x8ED\a(\x2\x2\x8ED\x8EE\x5\x2D8\x16D\x2\x8EE"+
		"\xDD\x3\x2\x2\x2\x8EF\x8F3\a\x1A5\x2\x2\x8F0\x8F1\a\x1A6\x2\x2\x8F1\x8F3"+
		"\a\xE\x2\x2\x8F2\x8EF\x3\x2\x2\x2\x8F2\x8F0\x3\x2\x2\x2\x8F3\x8F4\x3\x2"+
		"\x2\x2\x8F4\x8F5\a\x1F5\x2\x2\x8F5\x8F6\x5\x1F2\xFA\x2\x8F6\x8F7\a\x1F6"+
		"\x2\x2\x8F7\x8F8\a\x104\x2\x2\x8F8\x8FB\x5\x2D8\x16D\x2\x8F9\x8FA\a\xFC"+
		"\x2\x2\x8FA\x8FC\a\xFE\x2\x2\x8FB\x8F9\x3\x2\x2\x2\x8FB\x8FC\x3\x2\x2"+
		"\x2\x8FC\xDF\x3\x2\x2\x2\x8FD\x8FE\x5\xE4s\x2\x8FE\x8FF\t\x17\x2\x2\x8FF"+
		"\x902\x3\x2\x2\x2\x900\x902\x5\xE2r\x2\x901\x8FD\x3\x2\x2\x2\x901\x900"+
		"\x3\x2\x2\x2\x902\x903\x3\x2\x2\x2\x903\x901\x3\x2\x2\x2\x903\x904\x3"+
		"\x2\x2\x2\x904\xE1\x3\x2\x2\x2\x905\x906\a\x203\x2\x2\x906\x907\a\x203"+
		"\x2\x2\x907\x908\x5\x2AC\x157\x2\x908\x909\a\x209\x2\x2\x909\x90A\a\x209"+
		"\x2\x2\x90A\xE3\x3\x2\x2\x2\x90B\x90C\aP\x2\x2\x90C\x926\x5\x2\x2\x2\x90D"+
		"\x90E\a\n\x2\x2\x90E\x926\x5\x2\x2\x2\x90F\x911\a\x9D\x2\x2\x910\x912"+
		"\a\t\x2\x2\x911\x910\x3\x2\x2\x2\x911\x912\x3\x2\x2\x2\x912\x913\x3\x2"+
		"\x2\x2\x913\x926\x5\x2\x2\x2\x914\x915\a\x190\x2\x2\x915\x926\x5\x2\x2"+
		"\x2\x916\x926\x5\x10A\x86\x2\x917\x926\x5\x110\x89\x2\x918\x926\x5\xE6"+
		"t\x2\x919\x926\x5\xE8u\x2\x91A\x926\x5\xEAv\x2\x91B\x926\x5\xECw\x2\x91C"+
		"\x926\x5\xEEx\x2\x91D\x926\x5\xF4{\x2\x91E\x926\x5\xF8}\x2\x91F\x926\x5"+
		"\x102\x82\x2\x920\x926\x5\x104\x83\x2\x921\x926\x5\x106\x84\x2\x922\x926"+
		"\x5\x226\x114\x2\x923\x926\x5\x112\x8A\x2\x924\x926\x5\x108\x85\x2\x925"+
		"\x90B\x3\x2\x2\x2\x925\x90D\x3\x2\x2\x2\x925\x90F\x3\x2\x2\x2\x925\x914"+
		"\x3\x2\x2\x2\x925\x916\x3\x2\x2\x2\x925\x917\x3\x2\x2\x2\x925\x918\x3"+
		"\x2\x2\x2\x925\x919\x3\x2\x2\x2\x925\x91A\x3\x2\x2\x2\x925\x91B\x3\x2"+
		"\x2\x2\x925\x91C\x3\x2\x2\x2\x925\x91D\x3\x2\x2\x2\x925\x91E\x3\x2\x2"+
		"\x2\x925\x91F\x3\x2\x2\x2\x925\x920\x3\x2\x2\x2\x925\x921\x3\x2\x2\x2"+
		"\x925\x922\x3\x2\x2\x2\x925\x923\x3\x2\x2\x2\x925\x924\x3\x2\x2\x2\x926"+
		"\xE5\x3\x2\x2\x2\x927\x92A\x5\x2E2\x172\x2\x928\x92A\x5\x2E0\x171\x2\x929"+
		"\x927\x3\x2\x2\x2\x929\x928\x3\x2\x2\x2\x92A\x92B\x3\x2\x2\x2\x92B\x92C"+
		"\a\x1FE\x2\x2\x92C\x92D\x5\x1F2\xFA\x2\x92D\xE7\x3\x2\x2\x2\x92E\x930"+
		"\aJ\x2\x2\x92F\x931\x5\x2AC\x157\x2\x930\x92F\x3\x2\x2\x2\x930\x931\x3"+
		"\x2\x2\x2\x931\x934\x3\x2\x2\x2\x932\x933\a\x1AC\x2\x2\x933\x935\x5\x1F0"+
		"\xF9\x2\x934\x932\x3\x2\x2\x2\x934\x935\x3\x2\x2\x2\x935\xE9\x3\x2\x2"+
		"\x2\x936\x938\a\x89\x2\x2\x937\x939\x5\x2AC\x157\x2\x938\x937\x3\x2\x2"+
		"\x2\x938\x939\x3\x2\x2\x2\x939\x93C\x3\x2\x2\x2\x93A\x93B\a\x1AC\x2\x2"+
		"\x93B\x93D\x5\x1F0\xF9\x2\x93C\x93A\x3\x2\x2\x2\x93C\x93D\x3\x2\x2\x2"+
		"\x93D\xEB\x3\x2\x2\x2\x93E\x93F\a\x9C\x2\x2\x93F\x940\x5\x2AC\x157\x2"+
		"\x940\xED\x3\x2\x2\x2\x941\x942\a\xA4\x2\x2\x942\x943\x5\x1F0\xF9\x2\x943"+
		"\x944\a\x17F\x2\x2\x944\x948\x5\xE0q\x2\x945\x947\x5\xF0y\x2\x946\x945"+
		"\x3\x2\x2\x2\x947\x94A\x3\x2\x2\x2\x948\x946\x3\x2\x2\x2\x948\x949\x3"+
		"\x2\x2\x2\x949\x94C\x3\x2\x2\x2\x94A\x948\x3\x2\x2\x2\x94B\x94D\x5\xF2"+
		"z\x2\x94C\x94B\x3\x2\x2\x2\x94C\x94D\x3\x2\x2\x2\x94D\x94E\x3\x2\x2\x2"+
		"\x94E\x94F\a|\x2\x2\x94F\x950\a\xA4\x2\x2\x950\xEF\x3\x2\x2\x2\x951\x952"+
		"\ax\x2\x2\x952\x953\x5\x1F0\xF9\x2\x953\x954\a\x17F\x2\x2\x954\x955\x5"+
		"\xE0q\x2\x955\xF1\x3\x2\x2\x2\x956\x957\aw\x2\x2\x957\x958\x5\xE0q\x2"+
		"\x958\xF3\x3\x2\x2\x2\x959\x95B\x5\x2AC\x157\x2\x95A\x959\x3\x2\x2\x2"+
		"\x95A\x95B\x3\x2\x2\x2\x95B\x960\x3\x2\x2\x2\x95C\x95D\a\x1AF\x2\x2\x95D"+
		"\x961\x5\x1F0\xF9\x2\x95E\x95F\a\x96\x2\x2\x95F\x961\x5\xF6|\x2\x960\x95C"+
		"\x3\x2\x2\x2\x960\x95E\x3\x2\x2\x2\x960\x961\x3\x2\x2\x2\x961\x962\x3"+
		"\x2\x2\x2\x962\x963\a\xD6\x2\x2\x963\x964\x5\xE0q\x2\x964\x965\a|\x2\x2"+
		"\x965\x967\a\xD6\x2\x2\x966\x968\x5\x2AC\x157\x2\x967\x966\x3\x2\x2\x2"+
		"\x967\x968\x3\x2\x2\x2\x968\xF5\x3\x2\x2\x2\x969\x96A\x5\x2BC\x15F\x2"+
		"\x96A\x96C\a\xA7\x2\x2\x96B\x96D\a\x142\x2\x2\x96C\x96B\x3\x2\x2\x2\x96C"+
		"\x96D\x3\x2\x2\x2\x96D\x96E\x3\x2\x2\x2\x96E\x96F\x5\xFE\x80\x2\x96F\x970"+
		"\a\x3\x2\x2\x970\x971\x5\x100\x81\x2\x971\x97F\x3\x2\x2\x2\x972\x973\x5"+
		"\x2C0\x161\x2\x973\x97C\a\xA7\x2\x2\x974\x976\x5\x2BE\x160\x2\x975\x977"+
		"\x5\x1EE\xF8\x2\x976\x975\x3\x2\x2\x2\x976\x977\x3\x2\x2\x2\x977\x97D"+
		"\x3\x2\x2\x2\x978\x979\a\x1F5\x2\x2\x979\x97A\x5\x134\x9B\x2\x97A\x97B"+
		"\a\x1F6\x2\x2\x97B\x97D\x3\x2\x2\x2\x97C\x974\x3\x2\x2\x2\x97C\x978\x3"+
		"\x2\x2\x2\x97D\x97F\x3\x2\x2\x2\x97E\x969\x3\x2\x2\x2\x97E\x972\x3\x2"+
		"\x2\x2\x97F\xF7\x3\x2\x2\x2\x980\x981\a\x97\x2\x2\x981\x982\x5\x2BC\x15F"+
		"\x2\x982\x983\a\xA7\x2\x2\x983\x984\x5\xFA~\x2\x984\x987\x5\x112\x8A\x2"+
		"\x985\x986\a\x14C\x2\x2\x986\x988\a\x84\x2\x2\x987\x985\x3\x2\x2\x2\x987"+
		"\x988\x3\x2\x2\x2\x988\xF9\x3\x2\x2\x2\x989\x98A\x5\xFE\x80\x2\x98A\x98B"+
		"\a\x3\x2\x2\x98B\x98C\x5\x100\x81\x2\x98C\x997\x3\x2\x2\x2\x98D\x98E\a"+
		"\xAF\x2\x2\x98E\x98F\a\x104\x2\x2\x98F\x991\x5\x2C2\x162\x2\x990\x992"+
		"\x5\xFC\x7F\x2\x991\x990\x3\x2\x2\x2\x991\x992\x3\x2\x2\x2\x992\x997\x3"+
		"\x2\x2\x2\x993\x994\a\x1A1\x2\x2\x994\x995\a\x104\x2\x2\x995\x997\x5\x2BC"+
		"\x15F\x2\x996\x989\x3\x2\x2\x2\x996\x98D\x3\x2\x2\x2\x996\x993\x3\x2\x2"+
		"\x2\x997\xFB\x3\x2\x2\x2\x998\x999\a\x1C\x2\x2\x999\x99A\x5\xFE\x80\x2"+
		"\x99A\x99B\a\f\x2\x2\x99B\x99C\x5\x100\x81\x2\x99C\xFD\x3\x2\x2\x2\x99D"+
		"\x99E\x5\x20E\x108\x2\x99E\xFF\x3\x2\x2\x2\x99F\x9A0\x5\x20E\x108\x2\x9A0"+
		"\x101\x3\x2\x2\x2\x9A1\x9A2\a\xFE\x2\x2\x9A2\x103\x3\x2\x2\x2\x9A3\x9A5"+
		"\a\x12E\x2\x2\x9A4\x9A6\x5\x2B2\x15A\x2\x9A5\x9A4\x3\x2\x2\x2\x9A5\x9A6"+
		"\x3\x2\x2\x2\x9A6\x105\x3\x2\x2\x2\x9A7\x9A9\a\x13F\x2\x2\x9A8\x9AA\x5"+
		"\x1F2\xFA\x2\x9A9\x9A8\x3\x2\x2\x2\x9A9\x9AA\x3\x2\x2\x2\x9AA\x107\x3"+
		"\x2\x2\x2\x9AB\x9AD\a,\x2\x2\x9AC\x9AB\x3\x2\x2\x2\x9AC\x9AD\x3\x2\x2"+
		"\x2\x9AD\x9AE\x3\x2\x2\x2\x9AE\x9B0\x5\x29A\x14E\x2\x9AF\x9B1\x5\x2CE"+
		"\x168\x2\x9B0\x9AF\x3\x2\x2\x2\x9B0\x9B1\x3\x2\x2\x2\x9B1\x109\x3\x2\x2"+
		"\x2\x9B2\x9B3\a\x1B\x2\x2\x9B3\x9BA\x5\xE0q\x2\x9B4\x9B6\a\x82\x2\x2\x9B5"+
		"\x9B7\x5\x10C\x87\x2\x9B6\x9B5\x3\x2\x2\x2\x9B7\x9B8\x3\x2\x2\x2\x9B8"+
		"\x9B6\x3\x2\x2\x2\x9B8\x9B9\x3\x2\x2\x2\x9B9\x9BB\x3\x2\x2\x2\x9BA\x9B4"+
		"\x3\x2\x2\x2\x9BA\x9BB\x3\x2\x2\x2\x9BB\x9BC\x3\x2\x2\x2\x9BC\x9BE\a|"+
		"\x2\x2\x9BD\x9BF\x5\x2AC\x157\x2\x9BE\x9BD\x3\x2\x2\x2\x9BE\x9BF\x3\x2"+
		"\x2\x2\x9BF\x10B\x3\x2\x2\x2\x9C0\x9C1\a\x1AC\x2\x2\x9C1\x9C6\x5\x2B2"+
		"\x15A\x2\x9C2\x9C3\a\x10C\x2\x2\x9C3\x9C5\x5\x2B2\x15A\x2\x9C4\x9C2\x3"+
		"\x2\x2\x2\x9C5\x9C8\x3\x2\x2\x2\x9C6\x9C4\x3\x2\x2\x2\x9C6\x9C7\x3\x2"+
		"\x2\x2\x9C7\x9C9\x3\x2\x2\x2\x9C8\x9C6\x3\x2\x2\x2\x9C9\x9CA\a\x17F\x2"+
		"\x2\x9CA\x9CB\x5\xE0q\x2\x9CB\x10D\x3\x2\x2\x2\x9CC\x9CE\a\x62\x2\x2\x9CD"+
		"\x9CC\x3\x2\x2\x2\x9CD\x9CE\x3\x2\x2\x2\x9CE\x9D0\x3\x2\x2\x2\x9CF\x9D1"+
		"\x5\xC4\x63\x2\x9D0\x9CF\x3\x2\x2\x2\x9D1\x9D2\x3\x2\x2\x2\x9D2\x9D0\x3"+
		"\x2\x2\x2\x9D2\x9D3\x3\x2\x2\x2\x9D3\x9D5\x3\x2\x2\x2\x9D4\x9CD\x3\x2"+
		"\x2\x2\x9D4\x9D5\x3\x2\x2\x2\x9D5\x9D6\x3\x2\x2\x2\x9D6\x9D7\x5\x10A\x86"+
		"\x2\x9D7\x10F\x3\x2\x2\x2\x9D8\x9DA\a\x62\x2\x2\x9D9\x9D8\x3\x2\x2\x2"+
		"\x9D9\x9DA\x3\x2\x2\x2\x9DA\x9DC\x3\x2\x2\x2\x9DB\x9DD\x5\xC4\x63\x2\x9DC"+
		"\x9DB\x3\x2\x2\x2\x9DD\x9DE\x3\x2\x2\x2\x9DE\x9DC\x3\x2\x2\x2\x9DE\x9DF"+
		"\x3\x2\x2\x2\x9DF\x9E0\x3\x2\x2\x2\x9E0\x9E1\x5\x10A\x86\x2\x9E1\x111"+
		"\x3\x2\x2\x2\x9E2\x9E7\x5\x114\x8B\x2\x9E3\x9E7\x5\x118\x8D\x2\x9E4\x9E7"+
		"\x5\x11A\x8E\x2\x9E5\x9E7\x5\x124\x93\x2\x9E6\x9E2\x3\x2\x2\x2\x9E6\x9E3"+
		"\x3\x2\x2\x2\x9E6\x9E4\x3\x2\x2\x2\x9E6\x9E5\x3\x2\x2\x2\x9E7\x113\x3"+
		"\x2\x2\x2\x9E8\x9E9\a\x87\x2\x2\x9E9\x9EA\a\xA6\x2\x2\x9EA\x9F4\x5\x1F2"+
		"\xFA\x2\x9EB\x9ED\x5\x28A\x146\x2\x9EC\x9EE\x5\x252\x12A\x2\x9ED\x9EC"+
		"\x3\x2\x2\x2\x9ED\x9EE\x3\x2\x2\x2\x9EE\x9F5\x3\x2\x2\x2\x9EF\x9F1\x5"+
		"\x252\x12A\x2\x9F0\x9F2\x5\x116\x8C\x2\x9F1\x9F0\x3\x2\x2\x2\x9F1\x9F2"+
		"\x3\x2\x2\x2\x9F2\x9F5\x3\x2\x2\x2\x9F3\x9F5\x5\x116\x8C\x2\x9F4\x9EB"+
		"\x3\x2\x2\x2\x9F4\x9EF\x3\x2\x2\x2\x9F4\x9F3\x3\x2\x2\x2\x9F4\x9F5\x3"+
		"\x2\x2\x2\x9F5\x115\x3\x2\x2\x2\x9F6\x9F7\t\x18\x2\x2\x9F7\x9F8\x5\x28A"+
		"\x146\x2\x9F8\x117\x3\x2\x2\x2\x9F9\xA01\x5\x1C4\xE3\x2\x9FA\xA01\x5\x1D0"+
		"\xE9\x2\x9FB\xA01\x5\x134\x9B\x2\x9FC\xA01\x5\x1AA\xD6\x2\x9FD\xA01\x5"+
		"\x1B0\xD9\x2\x9FE\xA01\x5\x1B2\xDA\x2\x9FF\xA01\x5\x132\x9A\x2\xA00\x9F9"+
		"\x3\x2\x2\x2\xA00\x9FA\x3\x2\x2\x2\xA00\x9FB\x3\x2\x2\x2\xA00\x9FC\x3"+
		"\x2\x2\x2\xA00\x9FD\x3\x2\x2\x2\xA00\x9FE\x3\x2\x2\x2\xA00\x9FF\x3\x2"+
		"\x2\x2\xA01\x119\x3\x2\x2\x2\xA02\xA07\x5\x11C\x8F\x2\xA03\xA07\x5\x11E"+
		"\x90\x2\xA04\xA07\x5\x120\x91\x2\xA05\xA07\x5\x122\x92\x2\xA06\xA02\x3"+
		"\x2\x2\x2\xA06\xA03\x3\x2\x2\x2\xA06\xA04\x3\x2\x2\x2\xA06\xA05\x3\x2"+
		"\x2\x2\xA07\x11B\x3\x2\x2\x2\xA08\xA09\a\x37\x2\x2\xA09\xA0A\x5\x2BE\x160"+
		"\x2\xA0A\x11D\x3\x2\x2\x2\xA0B\xA0C\a\x10A\x2\x2\xA0C\xA0E\x5\x2BE\x160"+
		"\x2\xA0D\xA0F\x5\x1EE\xF8\x2\xA0E\xA0D\x3\x2\x2\x2\xA0E\xA0F\x3\x2\x2"+
		"\x2\xA0F\x11F\x3\x2\x2\x2\xA10\xA11\a\x8F\x2\x2\xA11\xA26\x5\x2BE\x160"+
		"\x2\xA12\xA13\a\xBB\x2\x2\xA13\xA18\x5\x2BA\x15E\x2\xA14\xA15\a\x1FB\x2"+
		"\x2\xA15\xA17\x5\x2BA\x15E\x2\xA16\xA14\x3\x2\x2\x2\xA17\xA1A\x3\x2\x2"+
		"\x2\xA18\xA16\x3\x2\x2\x2\xA18\xA19\x3\x2\x2\x2\xA19\xA27\x3\x2\x2\x2"+
		"\xA1A\xA18\x3\x2\x2\x2\xA1B\xA1C\a\'\x2\x2\xA1C\xA1D\a:\x2\x2\xA1D\xA1E"+
		"\a\xBB\x2\x2\xA1E\xA23\x5\x2BA\x15E\x2\xA1F\xA20\a\x1FB\x2\x2\xA20\xA22"+
		"\x5\x2BA\x15E\x2\xA21\xA1F\x3\x2\x2\x2\xA22\xA25\x3\x2\x2\x2\xA23\xA21"+
		"\x3\x2\x2\x2\xA23\xA24\x3\x2\x2\x2\xA24\xA27\x3\x2\x2\x2\xA25\xA23\x3"+
		"\x2\x2\x2\xA26\xA12\x3\x2\x2\x2\xA26\xA1B\x3\x2\x2\x2\xA27\x121\x3\x2"+
		"\x2\x2\xA28\xA29\a\x10A\x2\x2\xA29\xA2A\x5\x2BA\x15E\x2\xA2A\xA2D\a\x96"+
		"\x2\x2\xA2B\xA2E\x5\x134\x9B\x2\xA2C\xA2E\x5\x1F2\xFA\x2\xA2D\xA2B\x3"+
		"\x2\x2\x2\xA2D\xA2C\x3\x2\x2\x2\xA2E\xA30\x3\x2\x2\x2\xA2F\xA31\x5\x252"+
		"\x12A\x2\xA30\xA2F\x3\x2\x2\x2\xA30\xA31\x3\x2\x2\x2\xA31\x123\x3\x2\x2"+
		"\x2\xA32\xA38\x5\x126\x94\x2\xA33\xA38\x5\x128\x95\x2\xA34\xA38\x5\x12A"+
		"\x96\x2\xA35\xA38\x5\x12E\x98\x2\xA36\xA38\x5\x130\x99\x2\xA37\xA32\x3"+
		"\x2\x2\x2\xA37\xA33\x3\x2\x2\x2\xA37\xA34\x3\x2\x2\x2\xA37\xA35\x3\x2"+
		"\x2\x2\xA37\xA36\x3\x2\x2\x2\xA38\x125\x3\x2\x2\x2\xA39\xA3A\a\x15D\x2"+
		"\x2\xA3A\xA48\a\x18B\x2\x2\xA3B\xA3C\a\x131\x2\x2\xA3C\xA49\t\x19\x2\x2"+
		"\xA3D\xA3E\a\xBE\x2\x2\xA3E\xA42\a\xC8\x2\x2\xA3F\xA43\a\x159\x2\x2\xA40"+
		"\xA41\a\x131\x2\x2\xA41\xA43\a>\x2\x2\xA42\xA3F\x3\x2\x2\x2\xA42\xA40"+
		"\x3\x2\x2\x2\xA43\xA49\x3\x2\x2\x2\xA44\xA45\a\x19D\x2\x2\xA45\xA46\a"+
		"\x145\x2\x2\xA46\xA47\a\x154\x2\x2\xA47\xA49\x5\x294\x14B\x2\xA48\xA3B"+
		"\x3\x2\x2\x2\xA48\xA3D\x3\x2\x2\x2\xA48\xA44\x3\x2\x2\x2\xA48\xA49\x3"+
		"\x2\x2\x2\xA49\xA4C\x3\x2\x2\x2\xA4A\xA4B\a\xE7\x2\x2\xA4B\xA4D\x5\x2EE"+
		"\x178\x2\xA4C\xA4A\x3\x2\x2\x2\xA4C\xA4D\x3\x2\x2\x2\xA4D\x127\x3\x2\x2"+
		"\x2\xA4E\xA4F\a\x15D\x2\x2\xA4F\xA59\t\x1A\x2\x2\xA50\xA5A\a\t\x2\x2\xA51"+
		"\xA56\x5\x2AA\x156\x2\xA52\xA53\a\x1FB\x2\x2\xA53\xA55\x5\x2AA\x156\x2"+
		"\xA54\xA52\x3\x2\x2\x2\xA55\xA58\x3\x2\x2\x2\xA56\xA54\x3\x2\x2\x2\xA56"+
		"\xA57\x3\x2\x2\x2\xA57\xA5A\x3\x2\x2\x2\xA58\xA56\x3\x2\x2\x2\xA59\xA50"+
		"\x3\x2\x2\x2\xA59\xA51\x3\x2\x2\x2\xA5A\xA5B\x3\x2\x2\x2\xA5B\xA5C\t\x1B"+
		"\x2\x2\xA5C\x129\x3\x2\x2\x2\xA5D\xA5F\a=\x2\x2\xA5E\xA60\a\x1B2\x2\x2"+
		"\xA5F\xA5E\x3\x2\x2\x2\xA5F\xA60\x3\x2\x2\x2\xA60\xA6E\x3\x2\x2\x2\xA61"+
		"\xA62\a<\x2\x2\xA62\xA6F\x5\x1F2\xFA\x2\xA63\xA6C\a\x98\x2\x2\xA64\xA65"+
		"\aL\x2\x2\xA65\xA6D\x5\x1F2\xFA\x2\xA66\xA6D\aM\x2\x2\xA67\xA6A\x5\x1F2"+
		"\xFA\x2\xA68\xA69\a\x1FB\x2\x2\xA69\xA6B\x5\x1F2\xFA\x2\xA6A\xA68\x3\x2"+
		"\x2\x2\xA6A\xA6B\x3\x2\x2\x2\xA6B\xA6D\x3\x2\x2\x2\xA6C\xA64\x3\x2\x2"+
		"\x2\xA6C\xA66\x3\x2\x2\x2\xA6C\xA67\x3\x2\x2\x2\xA6D\xA6F\x3\x2\x2\x2"+
		"\xA6E\xA61\x3\x2\x2\x2\xA6E\xA63\x3\x2\x2\x2\xA6E\xA6F\x3\x2\x2\x2\xA6F"+
		"\xA71\x3\x2\x2\x2\xA70\xA72\x5\x12C\x97\x2\xA71\xA70\x3\x2\x2\x2\xA71"+
		"\xA72\x3\x2\x2\x2\xA72\x12B\x3\x2\x2\x2\xA73\xA75\a\x1B3\x2\x2\xA74\xA76"+
		"\t\x1C\x2\x2\xA75\xA74\x3\x2\x2\x2\xA75\xA76\x3\x2\x2\x2\xA76\xA78\x3"+
		"\x2\x2\x2\xA77\xA79\t\x1D\x2\x2\xA78\xA77\x3\x2\x2\x2\xA78\xA79\x3\x2"+
		"\x2\x2\xA79\x12D\x3\x2\x2\x2\xA7A\xA7C\a\x145\x2\x2\xA7B\xA7D\a\x1B2\x2"+
		"\x2\xA7C\xA7B\x3\x2\x2\x2\xA7C\xA7D\x3\x2\x2\x2\xA7D\xA85\x3\x2\x2\x2"+
		"\xA7E\xA80\a\x189\x2\x2\xA7F\xA81\a\x14D\x2\x2\xA80\xA7F\x3\x2\x2\x2\xA80"+
		"\xA81\x3\x2\x2\x2\xA81\xA82\x3\x2\x2\x2\xA82\xA86\x5\x292\x14A\x2\xA83"+
		"\xA84\a\x98\x2\x2\xA84\xA86\x5\x2EE\x178\x2\xA85\xA7E\x3\x2\x2\x2\xA85"+
		"\xA83\x3\x2\x2\x2\xA85\xA86\x3\x2\x2\x2\xA86\x12F\x3\x2\x2\x2\xA87\xA88"+
		"\a\x14D\x2\x2\xA88\xA89\x5\x292\x14A\x2\xA89\x131\x3\x2\x2\x2\xA8A\xA8B"+
		"\a\x8A\x2\x2\xA8B\xA90\a\x124\x2\x2\xA8C\xA8D\a\x15D\x2\x2\xA8D\xA8E\a"+
		"\x173\x2\x2\xA8E\xA8F\a\x20C\x2\x2\xA8F\xA91\x5\x2EE\x178\x2\xA90\xA8C"+
		"\x3\x2\x2\x2\xA90\xA91\x3\x2\x2\x2\xA91\xA94\x3\x2\x2\x2\xA92\xA93\a\xBB"+
		"\x2\x2\xA93\xA95\x5\x2C8\x165\x2\xA94\xA92\x3\x2\x2\x2\xA94\xA95\x3\x2"+
		"\x2\x2\xA95\xA96\x3\x2\x2\x2\xA96\xA9C\a\x96\x2\x2\xA97\xA9D\x5\x134\x9B"+
		"\x2\xA98\xA9D\x5\x1AA\xD6\x2\xA99\xA9D\x5\x1B0\xD9\x2\xA9A\xA9D\x5\x1B2"+
		"\xDA\x2\xA9B\xA9D\x5\x1C4\xE3\x2\xA9C\xA97\x3\x2\x2\x2\xA9C\xA98\x3\x2"+
		"\x2\x2\xA9C\xA99\x3\x2\x2\x2\xA9C\xA9A\x3\x2\x2\x2\xA9C\xA9B\x3\x2\x2"+
		"\x2\xA9D\x133\x3\x2\x2\x2\xA9E\xAA0\x5\x136\x9C\x2\xA9F\xA9E\x3\x2\x2"+
		"\x2\xA9F\xAA0\x3\x2\x2\x2\xAA0\xAA1\x3\x2\x2\x2\xAA1\xAA6\x5\x13E\xA0"+
		"\x2\xAA2\xAA5\x5\x1A4\xD3\x2\xAA3\xAA5\x5\x1A0\xD1\x2\xAA4\xAA2\x3\x2"+
		"\x2\x2\xAA4\xAA3\x3\x2\x2\x2\xAA5\xAA8\x3\x2\x2\x2\xAA6\xAA4\x3\x2\x2"+
		"\x2\xAA6\xAA7\x3\x2\x2\x2\xAA7\x135\x3\x2\x2\x2\xAA8\xAA6\x3\x2\x2\x2"+
		"\xAA9\xAAA\a\x1B0\x2\x2\xAAA\xAAF\x5\x138\x9D\x2\xAAB\xAAC\a\x1FB\x2\x2"+
		"\xAAC\xAAE\x5\x138\x9D\x2\xAAD\xAAB\x3\x2\x2\x2\xAAE\xAB1\x3\x2\x2\x2"+
		"\xAAF\xAAD\x3\x2\x2\x2\xAAF\xAB0\x3\x2\x2\x2\xAB0\x137\x3\x2\x2\x2\xAB1"+
		"\xAAF\x3\x2\x2\x2\xAB2\xABE\x5\x2A8\x155\x2\xAB3\xAB4\a\x1F5\x2\x2\xAB4"+
		"\xAB9\x5\x2C6\x164\x2\xAB5\xAB6\a\x1FB\x2\x2\xAB6\xAB8\x5\x2C6\x164\x2"+
		"\xAB7\xAB5\x3\x2\x2\x2\xAB8\xABB\x3\x2\x2\x2\xAB9\xAB7\x3\x2\x2\x2\xAB9"+
		"\xABA\x3\x2\x2\x2\xABA\xABC\x3\x2\x2\x2\xABB\xAB9\x3\x2\x2\x2\xABC\xABD"+
		"\a\x1F6\x2\x2\xABD\xABF\x3\x2\x2\x2\xABE\xAB3\x3\x2\x2\x2\xABE\xABF\x3"+
		"\x2\x2\x2\xABF\xAC0\x3\x2\x2\x2\xAC0\xAC1\a\xF\x2\x2\xAC1\xAC2\a\x1F5"+
		"\x2\x2\xAC2\xAC4\x5\x13E\xA0\x2\xAC3\xAC5\x5\x1A0\xD1\x2\xAC4\xAC3\x3"+
		"\x2\x2\x2\xAC4\xAC5\x3\x2\x2\x2\xAC5\xAC6\x3\x2\x2\x2\xAC6\xAC8\a\x1F6"+
		"\x2\x2\xAC7\xAC9\x5\x13A\x9E\x2\xAC8\xAC7\x3\x2\x2\x2\xAC8\xAC9\x3\x2"+
		"\x2\x2\xAC9\xACB\x3\x2\x2\x2\xACA\xACC\x5\x13C\x9F\x2\xACB\xACA\x3\x2"+
		"\x2\x2\xACB\xACC\x3\x2\x2\x2\xACC\x139\x3\x2\x2\x2\xACD\xACE\a\x151\x2"+
		"\x2\xACE\xACF\t\x1E\x2\x2\xACF\xAD0\a\x91\x2\x2\xAD0\xAD1\a(\x2\x2\xAD1"+
		"\xAD3\x5\x2C6\x164\x2\xAD2\xAD4\a\x10\x2\x2\xAD3\xAD2\x3\x2\x2\x2\xAD3"+
		"\xAD4\x3\x2\x2\x2\xAD4\xAD6\x3\x2\x2\x2\xAD5\xAD7\ak\x2\x2\xAD6\xAD5\x3"+
		"\x2\x2\x2\xAD6\xAD7\x3\x2\x2\x2\xAD7\xADA\x3\x2\x2\x2\xAD8\xAD9\a\xFF"+
		"\x2\x2\xAD9\xADB\a\x91\x2\x2\xADA\xAD8\x3\x2\x2\x2\xADA\xADB\x3\x2\x2"+
		"\x2\xADB\xADE\x3\x2\x2\x2\xADC\xADD\a\xFF\x2\x2\xADD\xADF\a\xC4\x2\x2"+
		"\xADE\xADC\x3\x2\x2\x2\xADE\xADF\x3\x2\x2\x2\xADF\xAF2\x3\x2\x2\x2\xAE0"+
		"\xAE1\a\x1FB\x2\x2\xAE1\xAE3\x5\x2C6\x164\x2\xAE2\xAE4\a\x10\x2\x2\xAE3"+
		"\xAE2\x3\x2\x2\x2\xAE3\xAE4\x3\x2\x2\x2\xAE4\xAE6\x3\x2\x2\x2\xAE5\xAE7"+
		"\ak\x2\x2\xAE6\xAE5\x3\x2\x2\x2\xAE6\xAE7\x3\x2\x2\x2\xAE7\xAEA\x3\x2"+
		"\x2\x2\xAE8\xAE9\a\xFF\x2\x2\xAE9\xAEB\a\x91\x2\x2\xAEA\xAE8\x3\x2\x2"+
		"\x2\xAEA\xAEB\x3\x2\x2\x2\xAEB\xAEE\x3\x2\x2\x2\xAEC\xAED\a\xFF\x2\x2"+
		"\xAED\xAEF\a\xC4\x2\x2\xAEE\xAEC\x3\x2\x2\x2\xAEE\xAEF\x3\x2\x2\x2\xAEF"+
		"\xAF1\x3\x2\x2\x2\xAF0\xAE0\x3\x2\x2\x2\xAF1\xAF4\x3\x2\x2\x2\xAF2\xAF0"+
		"\x3\x2\x2\x2\xAF2\xAF3\x3\x2\x2\x2\xAF3\xAF5\x3\x2\x2\x2\xAF4\xAF2\x3"+
		"\x2\x2\x2\xAF5\xAF6\a\x15D\x2\x2\xAF6\xAF7\x5\x2C6\x164\x2\xAF7\x13B\x3"+
		"\x2\x2\x2\xAF8\xAF9\aW\x2\x2\xAF9\xAFE\x5\x2C6\x164\x2\xAFA\xAFB\a\x1FB"+
		"\x2\x2\xAFB\xAFD\x5\x2C6\x164\x2\xAFC\xAFA\x3\x2\x2\x2\xAFD\xB00\x3\x2"+
		"\x2\x2\xAFE\xAFC\x3\x2\x2\x2\xAFE\xAFF\x3\x2\x2\x2\xAFF\xB01\x3\x2\x2"+
		"\x2\xB00\xAFE\x3\x2\x2\x2\xB01\xB02\a\x15D\x2\x2\xB02\xB03\x5\x2C6\x164"+
		"\x2\xB03\xB04\a\x189\x2\x2\xB04\xB05\x5\x1F2\xFA\x2\xB05\xB06\a\x65\x2"+
		"\x2\xB06\xB07\x5\x1F2\xFA\x2\xB07\x13D\x3\x2\x2\x2\xB08\xB0C\x5\x142\xA2"+
		"\x2\xB09\xB0B\x5\x140\xA1\x2\xB0A\xB09\x3\x2\x2\x2\xB0B\xB0E\x3\x2\x2"+
		"\x2\xB0C\xB0A\x3\x2\x2\x2\xB0C\xB0D\x3\x2\x2\x2\xB0D\x13F\x3\x2\x2\x2"+
		"\xB0E\xB0C\x3\x2\x2\x2\xB0F\xB11\a\x194\x2\x2\xB10\xB12\a\t\x2\x2\xB11"+
		"\xB10\x3\x2\x2\x2\xB11\xB12\x3\x2\x2\x2\xB12\xB16\x3\x2\x2\x2\xB13\xB16"+
		"\a\xB9\x2\x2\xB14\xB16\a\xDE\x2\x2\xB15\xB0F\x3\x2\x2\x2\xB15\xB13\x3"+
		"\x2\x2\x2\xB15\xB14\x3\x2\x2\x2\xB16\xB17\x3\x2\x2\x2\xB17\xB18\x5\x142"+
		"\xA2\x2\xB18\x141\x3\x2\x2\x2\xB19\xB1F\x5\x144\xA3\x2\xB1A\xB1B\a\x1F5"+
		"\x2\x2\xB1B\xB1C\x5\x13E\xA0\x2\xB1C\xB1D\a\x1F6\x2\x2\xB1D\xB1F\x3\x2"+
		"\x2\x2\xB1E\xB19\x3\x2\x2\x2\xB1E\xB1A\x3\x2\x2\x2\xB1F\x143\x3\x2\x2"+
		"\x2\xB20\xB22\a\x155\x2\x2\xB21\xB23\t\x1F\x2\x2\xB22\xB21\x3\x2\x2\x2"+
		"\xB22\xB23\x3\x2\x2\x2\xB23\xB2D\x3\x2\x2\x2\xB24\xB2E\a\x1F8\x2\x2\xB25"+
		"\xB2A\x5\x146\xA4\x2\xB26\xB27\a\x1FB\x2\x2\xB27\xB29\x5\x146\xA4\x2\xB28"+
		"\xB26\x3\x2\x2\x2\xB29\xB2C\x3\x2\x2\x2\xB2A\xB28\x3\x2\x2\x2\xB2A\xB2B"+
		"\x3\x2\x2\x2\xB2B\xB2E\x3\x2\x2\x2\xB2C\xB2A\x3\x2\x2\x2\xB2D\xB24\x3"+
		"\x2\x2\x2\xB2D\xB25\x3\x2\x2\x2\xB2E\xB30\x3\x2\x2\x2\xB2F\xB31\x5\x28A"+
		"\x146\x2\xB30\xB2F\x3\x2\x2\x2\xB30\xB31\x3\x2\x2\x2\xB31\xB32\x3\x2\x2"+
		"\x2\xB32\xB34\x5\x148\xA5\x2\xB33\xB35\x5\x286\x144\x2\xB34\xB33\x3\x2"+
		"\x2\x2\xB34\xB35\x3\x2\x2\x2\xB35\xB37\x3\x2\x2\x2\xB36\xB38\x5\x172\xBA"+
		"\x2\xB37\xB36\x3\x2\x2\x2\xB37\xB38\x3\x2\x2\x2\xB38\xB3A\x3\x2\x2\x2"+
		"\xB39\xB3B\x5\x176\xBC\x2\xB3A\xB39\x3\x2\x2\x2\xB3A\xB3B\x3\x2\x2\x2"+
		"\xB3B\xB3D\x3\x2\x2\x2\xB3C\xB3E\x5\x182\xC2\x2\xB3D\xB3C\x3\x2\x2\x2"+
		"\xB3D\xB3E\x3\x2\x2\x2\xB3E\x145\x3\x2\x2\x2\xB3F\xB41\x5\x14A\xA6\x2"+
		"\xB40\xB42\x5\x280\x141\x2\xB41\xB40\x3\x2\x2\x2\xB41\xB42\x3\x2\x2\x2"+
		"\xB42\x147\x3\x2\x2\x2\xB43\xB44\a\x99\x2\x2\xB44\xB45\x5\x14C\xA7\x2"+
		"\xB45\x149\x3\x2\x2\x2\xB46\xB47\x5\x2C8\x165\x2\xB47\xB48\a\x1EE\x2\x2"+
		"\xB48\xB49\a\x1F8\x2\x2\xB49\xB4C\x3\x2\x2\x2\xB4A\xB4C\x5\x1F2\xFA\x2"+
		"\xB4B\xB46\x3\x2\x2\x2\xB4B\xB4A\x3\x2\x2\x2\xB4C\x14B\x3\x2\x2\x2\xB4D"+
		"\xB52\x5\x14E\xA8\x2\xB4E\xB4F\a\x1FB\x2\x2\xB4F\xB51\x5\x14E\xA8\x2\xB50"+
		"\xB4E\x3\x2\x2\x2\xB51\xB54\x3\x2\x2\x2\xB52\xB50\x3\x2\x2\x2\xB52\xB53"+
		"\x3\x2\x2\x2\xB53\x14D\x3\x2\x2\x2\xB54\xB52\x3\x2\x2\x2\xB55\xB59\x5"+
		"\x150\xA9\x2\xB56\xB58\x5\x154\xAB\x2\xB57\xB56\x3\x2\x2\x2\xB58\xB5B"+
		"\x3\x2\x2\x2\xB59\xB57\x3\x2\x2\x2\xB59\xB5A\x3\x2\x2\x2\xB5A\xB5E\x3"+
		"\x2\x2\x2\xB5B\xB59\x3\x2\x2\x2\xB5C\xB5F\x5\x160\xB1\x2\xB5D\xB5F\x5"+
		"\x16C\xB7\x2\xB5E\xB5C\x3\x2\x2\x2\xB5E\xB5D\x3\x2\x2\x2\xB5E\xB5F\x3"+
		"\x2\x2\x2\xB5F\x14F\x3\x2\x2\x2\xB60\xB64\x5\x152\xAA\x2\xB61\xB63\x5"+
		"\x15E\xB0\x2\xB62\xB61\x3\x2\x2\x2\xB63\xB66\x3\x2\x2\x2\xB64\xB62\x3"+
		"\x2\x2\x2\xB64\xB65\x3\x2\x2\x2\xB65\xB68\x3\x2\x2\x2\xB66\xB64\x3\x2"+
		"\x2\x2\xB67\xB69\x5\x282\x142\x2\xB68\xB67\x3\x2\x2\x2\xB68\xB69\x3\x2"+
		"\x2\x2\xB69\x151\x3\x2\x2\x2\xB6A\xB6D\x5\x1E2\xF2\x2\xB6B\xB6E\x5\x160"+
		"\xB1\x2\xB6C\xB6E\x5\x16C\xB7\x2\xB6D\xB6B\x3\x2\x2\x2\xB6D\xB6C\x3\x2"+
		"\x2\x2\xB6D\xB6E\x3\x2\x2\x2\xB6E\xB82\x3\x2\x2\x2\xB6F\xB70\a\x1F5\x2"+
		"\x2\xB70\xB74\x5\x14E\xA8\x2\xB71\xB73\x5\x140\xA1\x2\xB72\xB71\x3\x2"+
		"\x2\x2\xB73\xB76\x3\x2\x2\x2\xB74\xB72\x3\x2\x2\x2\xB74\xB75\x3\x2\x2"+
		"\x2\xB75\xB77\x3\x2\x2\x2\xB76\xB74\x3\x2\x2\x2\xB77\xB7A\a\x1F6\x2\x2"+
		"\xB78\xB7B\x5\x160\xB1\x2\xB79\xB7B\x5\x16C\xB7\x2\xB7A\xB78\x3\x2\x2"+
		"\x2\xB7A\xB79\x3\x2\x2\x2\xB7A\xB7B\x3\x2\x2\x2\xB7B\xB82\x3\x2\x2\x2"+
		"\xB7C\xB7D\a\x109\x2\x2\xB7D\xB7E\a\x1F5\x2\x2\xB7E\xB7F\x5\x1E2\xF2\x2"+
		"\xB7F\xB80\a\x1F6\x2\x2\xB80\xB82\x3\x2\x2\x2\xB81\xB6A\x3\x2\x2\x2\xB81"+
		"\xB6F\x3\x2\x2\x2\xB81\xB7C\x3\x2\x2\x2\xB82\x153\x3\x2\x2\x2\xB83\xB85"+
		"\x5\x15C\xAF\x2\xB84\xB83\x3\x2\x2\x2\xB84\xB85\x3\x2\x2\x2\xB85\xB87"+
		"\x3\x2\x2\x2\xB86\xB88\t \x2\x2\xB87\xB86\x3\x2\x2\x2\xB87\xB88\x3\x2"+
		"\x2\x2\xB88\xB8B\x3\x2\x2\x2\xB89\xB8C\a\xB2\x2\x2\xB8A\xB8C\x5\x15A\xAE"+
		"\x2\xB8B\xB89\x3\x2\x2\x2\xB8B\xB8A\x3\x2\x2\x2\xB8B\xB8C\x3\x2\x2\x2"+
		"\xB8C\xB8D\x3\x2\x2\x2\xB8D\xB8E\a\xC1\x2\x2\xB8E\xB90\x5\x150\xA9\x2"+
		"\xB8F\xB91\x5\x15C\xAF\x2\xB90\xB8F\x3\x2\x2\x2\xB90\xB91\x3\x2\x2\x2"+
		"\xB91\xB96\x3\x2\x2\x2\xB92\xB95\x5\x156\xAC\x2\xB93\xB95\x5\x158\xAD"+
		"\x2\xB94\xB92\x3\x2\x2\x2\xB94\xB93\x3\x2\x2\x2\xB95\xB98\x3\x2\x2\x2"+
		"\xB96\xB94\x3\x2\x2\x2\xB96\xB97\x3\x2\x2\x2\xB97\x155\x3\x2\x2\x2\xB98"+
		"\xB96\x3\x2\x2\x2\xB99\xB9A\a\x108\x2\x2\xB9A\xB9B\x5\x1F0\xF9\x2\xB9B"+
		"\x157\x3\x2\x2\x2\xB9C\xB9D\a\x19E\x2\x2\xB9D\xB9E\a\x1F5\x2\x2\xB9E\xBA3"+
		"\x5\x2C6\x164\x2\xB9F\xBA0\a\x1FB\x2\x2\xBA0\xBA2\x5\x2C6\x164\x2\xBA1"+
		"\xB9F\x3\x2\x2\x2\xBA2\xBA5\x3\x2\x2\x2\xBA3\xBA1\x3\x2\x2\x2\xBA3\xBA4"+
		"\x3\x2\x2\x2\xBA4\xBA6\x3\x2\x2\x2\xBA5\xBA3\x3\x2\x2\x2\xBA6\xBA7\a\x1F6"+
		"\x2\x2\xBA7\x159\x3\x2\x2\x2\xBA8\xBAA\t!\x2\x2\xBA9\xBAB\a\x112\x2\x2"+
		"\xBAA\xBA9\x3\x2\x2\x2\xBAA\xBAB\x3\x2\x2\x2\xBAB\x15B\x3\x2\x2\x2\xBAC"+
		"\xBAD\a\x119\x2\x2\xBAD\xBBB\a(\x2\x2\xBAE\xBAF\a\x1F5\x2\x2\xBAF\xBB0"+
		"\x5\x13E\xA0\x2\xBB0\xBB1\a\x1F6\x2\x2\xBB1\xBBC\x3\x2\x2\x2\xBB2\xBBC"+
		"\x5\x1EE\xF8\x2\xBB3\xBB8\x5\x1F2\xFA\x2\xBB4\xBB5\a\x1FB\x2\x2\xBB5\xBB7"+
		"\x5\x1F2\xFA\x2\xBB6\xBB4\x3\x2\x2\x2\xBB7\xBBA\x3\x2\x2\x2\xBB8\xBB6"+
		"\x3\x2\x2\x2\xBB8\xBB9\x3\x2\x2\x2\xBB9\xBBC\x3\x2\x2\x2\xBBA\xBB8\x3"+
		"\x2\x2\x2\xBBB\xBAE\x3\x2\x2\x2\xBBB\xBB2\x3\x2\x2\x2\xBBB\xBB3\x3\x2"+
		"\x2\x2\xBBC\x15D\x3\x2\x2\x2\xBBD\xBBE\a\x1A8\x2\x2\xBBE\xBBF\a\x1C\x2"+
		"\x2\xBBF\xBC0\t\"\x2\x2\xBC0\xBC6\x5\x1F2\xFA\x2\xBC1\xBC2\a\xF\x2\x2"+
		"\xBC2\xBC3\a\x104\x2\x2\xBC3\xBC4\t#\x2\x2\xBC4\xBC6\x5\x1F2\xFA\x2\xBC5"+
		"\xBBD\x3\x2\x2\x2\xBC5\xBC1\x3\x2\x2\x2\xBC6\x15F\x3\x2\x2\x2\xBC7\xBC9"+
		"\a\x123\x2\x2\xBC8\xBCA\a\x1B4\x2\x2\xBC9\xBC8\x3\x2\x2\x2\xBC9\xBCA\x3"+
		"\x2\x2\x2\xBCA\xBCB\x3\x2\x2\x2\xBCB\xBCC\a\x1F5\x2\x2\xBCC\xBD1\x5\x162"+
		"\xB2\x2\xBCD\xBCE\a\x1FB\x2\x2\xBCE\xBD0\x5\x162\xB2\x2\xBCF\xBCD\x3\x2"+
		"\x2\x2\xBD0\xBD3\x3\x2\x2\x2\xBD1\xBCF\x3\x2\x2\x2\xBD1\xBD2\x3\x2\x2"+
		"\x2\xBD2\xBD4\x3\x2\x2\x2\xBD3\xBD1\x3\x2\x2\x2\xBD4\xBD5\x5\x164\xB3"+
		"\x2\xBD5\xBD6\x5\x166\xB4\x2\xBD6\xBD7\a\x1F6\x2\x2\xBD7\x161\x3\x2\x2"+
		"\x2\xBD8\xBD9\x5\x2A6\x154\x2\xBD9\xBDA\a\x1F5\x2\x2\xBDA\xBDB\x5\x1F2"+
		"\xFA\x2\xBDB\xBDD\a\x1F6\x2\x2\xBDC\xBDE\x5\x280\x141\x2\xBDD\xBDC\x3"+
		"\x2\x2\x2\xBDD\xBDE\x3\x2\x2\x2\xBDE\x163\x3\x2\x2\x2\xBDF\xBEC\a\x96"+
		"\x2\x2\xBE0\xBED\x5\x2C6\x164\x2\xBE1\xBE2\a\x1F5\x2\x2\xBE2\xBE7\x5\x2C6"+
		"\x164\x2\xBE3\xBE4\a\x1FB\x2\x2\xBE4\xBE6\x5\x2C6\x164\x2\xBE5\xBE3\x3"+
		"\x2\x2\x2\xBE6\xBE9\x3\x2\x2\x2\xBE7\xBE5\x3\x2\x2\x2\xBE7\xBE8\x3\x2"+
		"\x2\x2\xBE8\xBEA\x3\x2\x2\x2\xBE9\xBE7\x3\x2\x2\x2\xBEA\xBEB\a\x1F6\x2"+
		"\x2\xBEB\xBED\x3\x2\x2\x2\xBEC\xBE0\x3\x2\x2\x2\xBEC\xBE1\x3\x2\x2\x2"+
		"\xBED\x165\x3\x2\x2\x2\xBEE\xBEF\a\xA7\x2\x2\xBEF\xC01\a\x1F5\x2\x2\xBF0"+
		"\xC02\x5\x13E\xA0\x2\xBF1\xBF6\a\r\x2\x2\xBF2\xBF3\a\x1FB\x2\x2\xBF3\xBF5"+
		"\a\r\x2\x2\xBF4\xBF2\x3\x2\x2\x2\xBF5\xBF8\x3\x2\x2\x2\xBF6\xBF4\x3\x2"+
		"\x2\x2\xBF6\xBF7\x3\x2\x2\x2\xBF7\xC02\x3\x2\x2\x2\xBF8\xBF6\x3\x2\x2"+
		"\x2\xBF9\xBFE\x5\x168\xB5\x2\xBFA\xBFB\a\x1FB\x2\x2\xBFB\xBFD\x5\x168"+
		"\xB5\x2\xBFC\xBFA\x3\x2\x2\x2\xBFD\xC00\x3\x2\x2\x2\xBFE\xBFC\x3\x2\x2"+
		"\x2\xBFE\xBFF\x3\x2\x2\x2\xBFF\xC02\x3\x2\x2\x2\xC00\xBFE\x3\x2\x2\x2"+
		"\xC01\xBF0\x3\x2\x2\x2\xC01\xBF1\x3\x2\x2\x2\xC01\xBF9\x3\x2\x2\x2\xC02"+
		"\xC03\x3\x2\x2\x2\xC03\xC04\a\x1F6\x2\x2\xC04\x167\x3\x2\x2\x2\xC05\xC07"+
		"\x5\x16A\xB6\x2\xC06\xC08\x5\x280\x141\x2\xC07\xC06\x3\x2\x2\x2\xC07\xC08"+
		"\x3\x2\x2\x2\xC08\x169\x3\x2\x2\x2\xC09\xC0C\x5\x1F2\xFA\x2\xC0A\xC0C"+
		"\x5\x1EE\xF8\x2\xC0B\xC09\x3\x2\x2\x2\xC0B\xC0A\x3\x2\x2\x2\xC0C\x16B"+
		"\x3\x2\x2\x2\xC0D\xC10\a\x197\x2\x2\xC0E\xC0F\t$\x2\x2\xC0F\xC11\a\xFF"+
		"\x2\x2\xC10\xC0E\x3\x2\x2\x2\xC10\xC11\x3\x2\x2\x2\xC11\xC12\x3\x2\x2"+
		"\x2\xC12\xC1F\a\x1F5\x2\x2\xC13\xC20\x5\x2C6\x164\x2\xC14\xC15\a\x1F5"+
		"\x2\x2\xC15\xC1A\x5\x2C6\x164\x2\xC16\xC17\a\x1FB\x2\x2\xC17\xC19\x5\x2C6"+
		"\x164\x2\xC18\xC16\x3\x2\x2\x2\xC19\xC1C\x3\x2\x2\x2\xC1A\xC18\x3\x2\x2"+
		"\x2\xC1A\xC1B\x3\x2\x2\x2\xC1B\xC1D\x3\x2\x2\x2\xC1C\xC1A\x3\x2\x2\x2"+
		"\xC1D\xC1E\a\x1F6\x2\x2\xC1E\xC20\x3\x2\x2\x2\xC1F\xC13\x3\x2\x2\x2\xC1F"+
		"\xC14\x3\x2\x2\x2\xC20\xC21\x3\x2\x2\x2\xC21\xC22\x5\x164\xB3\x2\xC22"+
		"\xC23\x5\x16E\xB8\x2\xC23\xC24\a\x1F6\x2\x2\xC24\x16D\x3\x2\x2\x2\xC25"+
		"\xC26\a\xA7\x2\x2\xC26\xC27\a\x1F5\x2\x2\xC27\xC2C\x5\x170\xB9\x2\xC28"+
		"\xC29\a\x1FB\x2\x2\xC29\xC2B\x5\x170\xB9\x2\xC2A\xC28\x3\x2\x2\x2\xC2B"+
		"\xC2E\x3\x2\x2\x2\xC2C\xC2A\x3\x2\x2\x2\xC2C\xC2D\x3\x2\x2\x2\xC2D\xC2F"+
		"\x3\x2\x2\x2\xC2E\xC2C\x3\x2\x2\x2\xC2F\xC30\a\x1F6\x2\x2\xC30\x16F\x3"+
		"\x2\x2\x2\xC31\xC3E\x5\x2C6\x164\x2\xC32\xC33\a\x1F5\x2\x2\xC33\xC38\x5"+
		"\x2C6\x164\x2\xC34\xC35\a\x1FB\x2\x2\xC35\xC37\x5\x2C6\x164\x2\xC36\xC34"+
		"\x3\x2\x2\x2\xC37\xC3A\x3\x2\x2\x2\xC38\xC36\x3\x2\x2\x2\xC38\xC39\x3"+
		"\x2\x2\x2\xC39\xC3B\x3\x2\x2\x2\xC3A\xC38\x3\x2\x2\x2\xC3B\xC3C\a\x1F6"+
		"\x2\x2\xC3C\xC3E\x3\x2\x2\x2\xC3D\xC31\x3\x2\x2\x2\xC3D\xC32\x3\x2\x2"+
		"\x2\xC3E\xC4E\x3\x2\x2\x2\xC3F\xC4C\a\xF\x2\x2\xC40\xC4D\x5\x2E8\x175"+
		"\x2\xC41\xC42\a\x1F5\x2\x2\xC42\xC47\x5\x2E8\x175\x2\xC43\xC44\a\x1FB"+
		"\x2\x2\xC44\xC46\x5\x2E8\x175\x2\xC45\xC43\x3\x2\x2\x2\xC46\xC49\x3\x2"+
		"\x2\x2\xC47\xC45\x3\x2\x2\x2\xC47\xC48\x3\x2\x2\x2\xC48\xC4A\x3\x2\x2"+
		"\x2\xC49\xC47\x3\x2\x2\x2\xC4A\xC4B\a\x1F6\x2\x2\xC4B\xC4D\x3\x2\x2\x2"+
		"\xC4C\xC40\x3\x2\x2\x2\xC4C\xC41\x3\x2\x2\x2\xC4D\xC4F\x3\x2\x2\x2\xC4E"+
		"\xC3F\x3\x2\x2\x2\xC4E\xC4F\x3\x2\x2\x2\xC4F\x171\x3\x2\x2\x2\xC50\xC51"+
		"\a\x42\x2\x2\xC51\xC53\a(\x2\x2\xC52\xC54\a\xF5\x2\x2\xC53\xC52\x3\x2"+
		"\x2\x2\xC53\xC54\x3\x2\x2\x2\xC54\xC55\x3\x2\x2\x2\xC55\xC57\x5\x1F0\xF9"+
		"\x2\xC56\xC58\x5\x174\xBB\x2\xC57\xC56\x3\x2\x2\x2\xC57\xC58\x3\x2\x2"+
		"\x2\xC58\xC62\x3\x2\x2\x2\xC59\xC5A\x5\x174\xBB\x2\xC5A\xC5B\a\x42\x2"+
		"\x2\xC5B\xC5D\a(\x2\x2\xC5C\xC5E\a\xF5\x2\x2\xC5D\xC5C\x3\x2\x2\x2\xC5D"+
		"\xC5E\x3\x2\x2\x2\xC5E\xC5F\x3\x2\x2\x2\xC5F\xC60\x5\x1F0\xF9\x2\xC60"+
		"\xC62\x3\x2\x2\x2\xC61\xC50\x3\x2\x2\x2\xC61\xC59\x3\x2\x2\x2\xC62\x173"+
		"\x3\x2\x2\x2\xC63\xC64\a\x170\x2\x2\xC64\xC65\a\x1B0\x2\x2\xC65\xC66\x5"+
		"\x1F0\xF9\x2\xC66\x175\x3\x2\x2\x2\xC67\xC68\a\x9E\x2\x2\xC68\xC69\a("+
		"\x2\x2\xC69\xC6E\x5\x178\xBD\x2\xC6A\xC6B\a\x1FB\x2\x2\xC6B\xC6D\x5\x178"+
		"\xBD\x2\xC6C\xC6A\x3\x2\x2\x2\xC6D\xC70\x3\x2\x2\x2\xC6E\xC6C\x3\x2\x2"+
		"\x2\xC6E\xC6F\x3\x2\x2\x2\xC6F\xC72\x3\x2\x2\x2\xC70\xC6E\x3\x2\x2\x2"+
		"\xC71\xC73\x5\x180\xC1\x2\xC72\xC71\x3\x2\x2\x2\xC72\xC73\x3\x2\x2\x2"+
		"\xC73\xC82\x3\x2\x2\x2\xC74\xC7F\x5\x180\xC1\x2\xC75\xC76\a\x9E\x2\x2"+
		"\xC76\xC77\a(\x2\x2\xC77\xC7C\x5\x178\xBD\x2\xC78\xC79\a\x1FB\x2\x2\xC79"+
		"\xC7B\x5\x178\xBD\x2\xC7A\xC78\x3\x2\x2\x2\xC7B\xC7E\x3\x2\x2\x2\xC7C"+
		"\xC7A\x3\x2\x2\x2\xC7C\xC7D\x3\x2\x2\x2\xC7D\xC80\x3\x2\x2\x2\xC7E\xC7C"+
		"\x3\x2\x2\x2\xC7F\xC75\x3\x2\x2\x2\xC7F\xC80\x3\x2\x2\x2\xC80\xC82\x3"+
		"\x2\x2\x2\xC81\xC67\x3\x2\x2\x2\xC81\xC74\x3\x2\x2\x2\xC82\x177\x3\x2"+
		"\x2\x2\xC83\xC87\x5\x17C\xBF\x2\xC84\xC87\x5\x17A\xBE\x2\xC85\xC87\x5"+
		"\x1F2\xFA\x2\xC86\xC83\x3\x2\x2\x2\xC86\xC84\x3\x2\x2\x2\xC86\xC85\x3"+
		"\x2\x2\x2\xC87\x179\x3\x2\x2\x2\xC88\xC89\t%\x2\x2\xC89\xC8A\a\x1F5\x2"+
		"\x2\xC8A\xC8F\x5\x17E\xC0\x2\xC8B\xC8C\a\x1FB\x2\x2\xC8C\xC8E\x5\x17E"+
		"\xC0\x2\xC8D\xC8B\x3\x2\x2\x2\xC8E\xC91\x3\x2\x2\x2\xC8F\xC8D\x3\x2\x2"+
		"\x2\xC8F\xC90\x3\x2\x2\x2\xC90\xC92\x3\x2\x2\x2\xC91\xC8F\x3\x2\x2\x2"+
		"\xC92\xC93\a\x1F6\x2\x2\xC93\x17B\x3\x2\x2\x2\xC94\xC95\a\x9F\x2\x2\xC95"+
		"\xC96\a\x15E\x2\x2\xC96\xC97\a\x1F5\x2\x2\xC97\xC9C\x5\x17E\xC0\x2\xC98"+
		"\xC99\a\x1FB\x2\x2\xC99\xC9B\x5\x17E\xC0\x2\xC9A\xC98\x3\x2\x2\x2\xC9B"+
		"\xC9E\x3\x2\x2\x2\xC9C\xC9A\x3\x2\x2\x2\xC9C\xC9D\x3\x2\x2\x2\xC9D\xC9F"+
		"\x3\x2\x2\x2\xC9E\xC9C\x3\x2\x2\x2\xC9F\xCA0\a\x1F6\x2\x2\xCA0\x17D\x3"+
		"\x2\x2\x2\xCA1\xCA5\x5\x17A\xBE\x2\xCA2\xCA5\x5\x1EE\xF8\x2\xCA3\xCA5"+
		"\x5\x1F2\xFA\x2\xCA4\xCA1\x3\x2\x2\x2\xCA4\xCA2\x3\x2\x2\x2\xCA4\xCA3"+
		"\x3\x2\x2\x2\xCA5\x17F\x3\x2\x2\x2\xCA6\xCA7\a\xA1\x2\x2\xCA7\xCA8\x5"+
		"\x1F0\xF9\x2\xCA8\x181\x3\x2\x2\x2\xCA9\xCAD\a\xE3\x2\x2\xCAA\xCAC\x5"+
		"\x184\xC3\x2\xCAB\xCAA\x3\x2\x2\x2\xCAC\xCAF\x3\x2\x2\x2\xCAD\xCAB\x3"+
		"\x2\x2\x2\xCAD\xCAE\x3\x2\x2\x2\xCAE\xCB1\x3\x2\x2\x2\xCAF\xCAD\x3\x2"+
		"\x2\x2\xCB0\xCB2\x5\x186\xC4\x2\xCB1\xCB0\x3\x2\x2\x2\xCB1\xCB2\x3\x2"+
		"\x2\x2\xCB2\xCB6\x3\x2\x2\x2\xCB3\xCB5\x5\x188\xC5\x2\xCB4\xCB3\x3\x2"+
		"\x2\x2\xCB5\xCB8\x3\x2\x2\x2\xCB6\xCB4\x3\x2\x2\x2\xCB6\xCB7\x3\x2\x2"+
		"\x2\xCB7\xCB9\x3\x2\x2\x2\xCB8\xCB6\x3\x2\x2\x2\xCB9\xCBA\x5\x18A\xC6"+
		"\x2\xCBA\x183\x3\x2\x2\x2\xCBB\xCBC\t&\x2\x2\xCBC\xCC4\a\xEB\x2\x2\xCBD"+
		"\xCC1\a\x195\x2\x2\xCBE\xCC2\am\x2\x2\xCBF\xCC0\a\x166\x2\x2\xCC0\xCC2"+
		"\a\x135\x2\x2\xCC1\xCBE\x3\x2\x2\x2\xCC1\xCBF\x3\x2\x2\x2\xCC2\xCC4\x3"+
		"\x2\x2\x2\xCC3\xCBB\x3\x2\x2\x2\xCC3\xCBD\x3\x2\x2\x2\xCC4\x185\x3\x2"+
		"\x2\x2\xCC5\xCC6\a\x13F\x2\x2\xCC6\xCC7\t\'\x2\x2\xCC7\xCC8\a\x149\x2"+
		"\x2\xCC8\x187\x3\x2\x2\x2\xCC9\xCCA\a\x135\x2\x2\xCCA\xCCB\x5\x2A2\x152"+
		"\x2\xCCB\xCCC\a\x108\x2\x2\xCCC\xCCD\a\x1F5\x2\x2\xCCD\xCCE\x5\x13E\xA0"+
		"\x2\xCCE\xCCF\a\x1F6\x2\x2\xCCF\xCD3\x5\x18C\xC7\x2\xCD0\xCD2\x5\x184"+
		"\xC3\x2\xCD1\xCD0\x3\x2\x2\x2\xCD2\xCD5\x3\x2\x2\x2\xCD3\xCD1\x3\x2\x2"+
		"\x2\xCD3\xCD4\x3\x2\x2\x2\xCD4\x189\x3\x2\x2\x2\xCD5\xCD3\x3\x2\x2\x2"+
		"\xCD6\xCD7\a\xD7\x2\x2\xCD7\xCD9\x5\x2A4\x153\x2\xCD8\xCD6\x3\x2\x2\x2"+
		"\xCD8\xCD9\x3\x2\x2\x2\xCD9\xCDA\x3\x2\x2\x2\xCDA\xCDE\x5\x18C\xC7\x2"+
		"\xCDB\xCDD\x5\x184\xC3\x2\xCDC\xCDB\x3\x2\x2\x2\xCDD\xCE0\x3\x2\x2\x2"+
		"\xCDE\xCDC\x3\x2\x2\x2\xCDE\xCDF\x3\x2\x2\x2\xCDF\xCE1\x3\x2\x2\x2\xCE0"+
		"\xCDE\x3\x2\x2\x2\xCE1\xCE2\x5\x194\xCB\x2\xCE2\x18B\x3\x2\x2\x2\xCE3"+
		"\xCE5\x5\x18E\xC8\x2\xCE4\xCE3\x3\x2\x2\x2\xCE4\xCE5\x3\x2\x2\x2\xCE5"+
		"\xCE6\x3\x2\x2\x2\xCE6\xCE7\am\x2\x2\xCE7\xCE8\a(\x2\x2\xCE8\xCE9\x5\x190"+
		"\xC9\x2\xCE9\xCEA\a\xDB\x2\x2\xCEA\xCEB\x5\x190\xC9\x2\xCEB\x18D\x3\x2"+
		"\x2\x2\xCEC\xCED\a\x119\x2\x2\xCED\xCEE\a(\x2\x2\xCEE\xCEF\x5\x190\xC9"+
		"\x2\xCEF\x18F\x3\x2\x2\x2\xCF0\xCF1\a\x1F5\x2\x2\xCF1\xCF6\x5\x192\xCA"+
		"\x2\xCF2\xCF3\a\x1FB\x2\x2\xCF3\xCF5\x5\x192\xCA\x2\xCF4\xCF2\x3\x2\x2"+
		"\x2\xCF5\xCF8\x3\x2\x2\x2\xCF6\xCF4\x3\x2\x2\x2\xCF6\xCF7\x3\x2\x2\x2"+
		"\xCF7\xCF9\x3\x2\x2\x2\xCF8\xCF6\x3\x2\x2\x2\xCF9\xCFA\a\x1F6\x2\x2\xCFA"+
		"\x191\x3\x2\x2\x2\xCFB\xCFE\x5\x1F2\xFA\x2\xCFC\xCFE\x5\x144\xA3\x2\xCFD"+
		"\xCFB\x3\x2\x2\x2\xCFD\xCFC\x3\x2\x2\x2\xCFE\xD00\x3\x2\x2\x2\xCFF\xD01"+
		"\x5\x280\x141\x2\xD00\xCFF\x3\x2\x2\x2\xD00\xD01\x3\x2\x2\x2\xD01\x193"+
		"\x3\x2\x2\x2\xD02\xD04\x5\x196\xCC\x2\xD03\xD02\x3\x2\x2\x2\xD03\xD04"+
		"\x3\x2\x2\x2\xD04\xD05\x3\x2\x2\x2\xD05\xD0E\a\x1F5\x2\x2\xD06\xD0B\x5"+
		"\x198\xCD\x2\xD07\xD08\a\x1FB\x2\x2\xD08\xD0A\x5\x198\xCD\x2\xD09\xD07"+
		"\x3\x2\x2\x2\xD0A\xD0D\x3\x2\x2\x2\xD0B\xD09\x3\x2\x2\x2\xD0B\xD0C\x3"+
		"\x2\x2\x2\xD0C\xD0F\x3\x2\x2\x2\xD0D\xD0B\x3\x2\x2\x2\xD0E\xD06\x3\x2"+
		"\x2\x2\xD0E\xD0F\x3\x2\x2\x2\xD0F\xD10\x3\x2\x2\x2\xD10\xD11\a\x1F6\x2"+
		"\x2\xD11\x195\x3\x2\x2\x2\xD12\xD18\a\x14A\x2\x2\xD13\xD19\a\x199\x2\x2"+
		"\xD14\xD16\a\x19B\x2\x2\xD15\xD17\a\t\x2\x2\xD16\xD15\x3\x2\x2\x2\xD16"+
		"\xD17\x3\x2\x2\x2\xD17\xD19\x3\x2\x2\x2\xD18\xD13\x3\x2\x2\x2\xD18\xD14"+
		"\x3\x2\x2\x2\xD18\xD19\x3\x2\x2\x2\xD19\xD1C\x3\x2\x2\x2\xD1A\xD1B\t("+
		"\x2\x2\xD1B\xD1D\a\x10E\x2\x2\xD1C\xD1A\x3\x2\x2\x2\xD1C\xD1D\x3\x2\x2"+
		"\x2\xD1D\xD1F\x3\x2\x2\x2\xD1E\xD20\x5\x19C\xCF\x2\xD1F\xD1E\x3\x2\x2"+
		"\x2\xD1F\xD20\x3\x2\x2\x2\xD20\x197\x3\x2\x2\x2\xD21\xD27\a\x199\x2\x2"+
		"\xD22\xD24\a\x19B\x2\x2\xD23\xD25\a\t\x2\x2\xD24\xD23\x3\x2\x2\x2\xD24"+
		"\xD25\x3\x2\x2\x2\xD25\xD27\x3\x2\x2\x2\xD26\xD21\x3\x2\x2\x2\xD26\xD22"+
		"\x3\x2\x2\x2\xD26\xD27\x3\x2\x2\x2\xD27\xD28\x3\x2\x2\x2\xD28\xD2A\x5"+
		"\x19A\xCE\x2\xD29\xD2B\x5\x1A0\xD1\x2\xD2A\xD29\x3\x2\x2\x2\xD2A\xD2B"+
		"\x3\x2\x2\x2\xD2B\xD2C\x3\x2\x2\x2\xD2C\xD2D\a\x20C\x2\x2\xD2D\xD2E\x5"+
		"\x1F2\xFA\x2\xD2E\x199\x3\x2\x2\x2\xD2F\xD30\x5\x218\x10D\x2\xD30\x19B"+
		"\x3\x2\x2\x2\xD31\xD32\a\xBF\x2\x2\xD32\xD33\a\x1F5\x2\x2\xD33\xD34\x5"+
		"\x1F2\xFA\x2\xD34\xD36\a\x1F6\x2\x2\xD35\xD37\x5\x19E\xD0\x2\xD36\xD35"+
		"\x3\x2\x2\x2\xD36\xD37\x3\x2\x2\x2\xD37\x19D\x3\x2\x2\x2\xD38\xD39\a\x198"+
		"\x2\x2\xD39\xD3A\a\x1F5\x2\x2\xD3A\xD3B\x5\x1F0\xF9\x2\xD3B\xD3C\a\x1F6"+
		"\x2\x2\xD3C\x19F\x3\x2\x2\x2\xD3D\xD3F\a\x10E\x2\x2\xD3E\xD40\a\x163\x2"+
		"\x2\xD3F\xD3E\x3\x2\x2\x2\xD3F\xD40\x3\x2\x2\x2\xD40\xD41\x3\x2\x2\x2"+
		"\xD41\xD42\a(\x2\x2\xD42\xD47\x5\x1A2\xD2\x2\xD43\xD44\a\x1FB\x2\x2\xD44"+
		"\xD46\x5\x1A2\xD2\x2\xD45\xD43\x3\x2\x2\x2\xD46\xD49\x3\x2\x2\x2\xD47"+
		"\xD45\x3\x2\x2\x2\xD47\xD48\x3\x2\x2\x2\xD48\x1A1\x3\x2\x2\x2\xD49\xD47"+
		"\x3\x2\x2\x2\xD4A\xD4C\x5\x1F2\xFA\x2\xD4B\xD4D\t)\x2\x2\xD4C\xD4B\x3"+
		"\x2\x2\x2\xD4C\xD4D\x3\x2\x2\x2\xD4D\xD50\x3\x2\x2\x2\xD4E\xD4F\a\xFF"+
		"\x2\x2\xD4F\xD51\t*\x2\x2\xD50\xD4E\x3\x2\x2\x2\xD50\xD51\x3\x2\x2\x2"+
		"\xD51\x1A3\x3\x2\x2\x2\xD52\xD53\a\x96\x2\x2\xD53\xD55\a\x199\x2\x2\xD54"+
		"\xD56\x5\x1A6\xD4\x2\xD55\xD54\x3\x2\x2\x2\xD55\xD56\x3\x2\x2\x2\xD56"+
		"\xD58\x3\x2\x2\x2\xD57\xD59\x5\x1A8\xD5\x2\xD58\xD57\x3\x2\x2\x2\xD58"+
		"\xD59\x3\x2\x2\x2\xD59\x1A5\x3\x2\x2\x2\xD5A\xD5B\a\x104\x2\x2\xD5B\xD60"+
		"\x5\x2C6\x164\x2\xD5C\xD5D\a\x1FB\x2\x2\xD5D\xD5F\x5\x2C6\x164\x2\xD5E"+
		"\xD5C\x3\x2\x2\x2\xD5F\xD62\x3\x2\x2\x2\xD60\xD5E\x3\x2\x2\x2\xD60\xD61"+
		"\x3\x2\x2\x2\xD61\x1A7\x3\x2\x2\x2\xD62\xD60\x3\x2\x2\x2\xD63\xD64\a\x168"+
		"\x2\x2\xD64\xD69\a\xD1\x2\x2\xD65\xD69\a\xFD\x2\x2\xD66\xD67\a\x1A9\x2"+
		"\x2\xD67\xD69\x5\x1F2\xFA\x2\xD68\xD63\x3\x2\x2\x2\xD68\xD65\x3\x2\x2"+
		"\x2\xD68\xD66\x3\x2\x2\x2\xD69\x1A9\x3\x2\x2\x2\xD6A\xD6B\a\x199\x2\x2"+
		"\xD6B\xD6C\x5\x1D8\xED\x2\xD6C\xD6E\x5\x1AC\xD7\x2\xD6D\xD6F\x5\x286\x144"+
		"\x2\xD6E\xD6D\x3\x2\x2\x2\xD6E\xD6F\x3\x2\x2\x2\xD6F\xD71\x3\x2\x2\x2"+
		"\xD70\xD72\x5\x1DA\xEE\x2\xD71\xD70\x3\x2\x2\x2\xD71\xD72\x3\x2\x2\x2"+
		"\xD72\xD74\x3\x2\x2\x2\xD73\xD75\x5\x1DC\xEF\x2\xD74\xD73\x3\x2\x2\x2"+
		"\xD74\xD75\x3\x2\x2\x2\xD75\x1AB\x3\x2\x2\x2\xD76\xD86\a\x15D\x2\x2\xD77"+
		"\xD7C\x5\x1AE\xD8\x2\xD78\xD79\a\x1FB\x2\x2\xD79\xD7B\x5\x1AE\xD8\x2\xD7A"+
		"\xD78\x3\x2\x2\x2\xD7B\xD7E\x3\x2\x2\x2\xD7C\xD7A\x3\x2\x2\x2\xD7C\xD7D"+
		"\x3\x2\x2\x2\xD7D\xD87\x3\x2\x2\x2\xD7E\xD7C\x3\x2\x2\x2\xD7F\xD80\a\x1A0"+
		"\x2\x2\xD80\xD81\a\x1F5\x2\x2\xD81\xD82\x5\x2F0\x179\x2\xD82\xD83\a\x1F6"+
		"\x2\x2\xD83\xD84\a\x20C\x2\x2\xD84\xD85\x5\x1F2\xFA\x2\xD85\xD87\x3\x2"+
		"\x2\x2\xD86\xD77\x3\x2\x2\x2\xD86\xD7F\x3\x2\x2\x2\xD87\x1AD\x3\x2\x2"+
		"\x2\xD88\xD89\x5\x2C6\x164\x2\xD89\xD8A\a\x20C\x2\x2\xD8A\xD8B\x5\x1F2"+
		"\xFA\x2\xD8B\xD9A\x3\x2\x2\x2\xD8C\xD8D\a\x1F5\x2\x2\xD8D\xD92\x5\x2C6"+
		"\x164\x2\xD8E\xD8F\a\x1FB\x2\x2\xD8F\xD91\x5\x2C6\x164\x2\xD90\xD8E\x3"+
		"\x2\x2\x2\xD91\xD94\x3\x2\x2\x2\xD92\xD90\x3\x2\x2\x2\xD92\xD93\x3\x2"+
		"\x2\x2\xD93\xD95\x3\x2\x2\x2\xD94\xD92\x3\x2\x2\x2\xD95\xD96\a\x1F6\x2"+
		"\x2\xD96\xD97\a\x20C\x2\x2\xD97\xD98\x5\x13E\xA0\x2\xD98\xD9A\x3\x2\x2"+
		"\x2\xD99\xD88\x3\x2\x2\x2\xD99\xD8C\x3\x2\x2\x2\xD9A\x1AF\x3\x2\x2\x2"+
		"\xD9B\xD9D\ai\x2\x2\xD9C\xD9E\a\x99\x2\x2\xD9D\xD9C\x3\x2\x2\x2\xD9D\xD9E"+
		"\x3\x2\x2\x2\xD9E\xD9F\x3\x2\x2\x2\xD9F\xDA1\x5\x1D8\xED\x2\xDA0\xDA2"+
		"\x5\x286\x144\x2\xDA1\xDA0\x3\x2\x2\x2\xDA1\xDA2\x3\x2\x2\x2\xDA2\xDA4"+
		"\x3\x2\x2\x2\xDA3\xDA5\x5\x1DA\xEE\x2\xDA4\xDA3\x3\x2\x2\x2\xDA4\xDA5"+
		"\x3\x2\x2\x2\xDA5\xDA7\x3\x2\x2\x2\xDA6\xDA8\x5\x1DC\xEF\x2\xDA7\xDA6"+
		"\x3\x2\x2\x2\xDA7\xDA8\x3\x2\x2\x2\xDA8\x1B1\x3\x2\x2\x2\xDA9\xDAC\a\xB4"+
		"\x2\x2\xDAA\xDAD\x5\x1B4\xDB\x2\xDAB\xDAD\x5\x1B6\xDC\x2\xDAC\xDAA\x3"+
		"\x2\x2\x2\xDAC\xDAB\x3\x2\x2\x2\xDAD\x1B3\x3\x2\x2\x2\xDAE\xDB4\x5\x1C0"+
		"\xE1\x2\xDAF\xDB1\x5\x1C2\xE2\x2\xDB0\xDB2\x5\x1DA\xEE\x2\xDB1\xDB0\x3"+
		"\x2\x2\x2\xDB1\xDB2\x3\x2\x2\x2\xDB2\xDB5\x3\x2\x2\x2\xDB3\xDB5\x5\x134"+
		"\x9B\x2\xDB4\xDAF\x3\x2\x2\x2\xDB4\xDB3\x3\x2\x2\x2\xDB5\xDB7\x3\x2\x2"+
		"\x2\xDB6\xDB8\x5\x1DC\xEF\x2\xDB7\xDB6\x3\x2\x2\x2\xDB7\xDB8\x3\x2\x2"+
		"\x2\xDB8\x1B5\x3\x2\x2\x2\xDB9\xDBB\a\t\x2\x2\xDBA\xDBC\x5\x1B8\xDD\x2"+
		"\xDBB\xDBA\x3\x2\x2\x2\xDBC\xDBD\x3\x2\x2\x2\xDBD\xDBB\x3\x2\x2\x2\xDBD"+
		"\xDBE\x3\x2\x2\x2\xDBE\xDC1\x3\x2\x2\x2\xDBF\xDC1\x5\x1BA\xDE\x2\xDC0"+
		"\xDB9\x3\x2\x2\x2\xDC0\xDBF\x3\x2\x2\x2\xDC1\xDC2\x3\x2\x2\x2\xDC2\xDC3"+
		"\x5\x134\x9B\x2\xDC3\x1B7\x3\x2\x2\x2\xDC4\xDC6\x5\x1C0\xE1\x2\xDC5\xDC7"+
		"\x5\x1C2\xE2\x2\xDC6\xDC5\x3\x2\x2\x2\xDC6\xDC7\x3\x2\x2\x2\xDC7\xDC9"+
		"\x3\x2\x2\x2\xDC8\xDCA\x5\x1DC\xEF\x2\xDC9\xDC8\x3\x2\x2\x2\xDC9\xDCA"+
		"\x3\x2\x2\x2\xDCA\x1B9\x3\x2\x2\x2\xDCB\xDCD\t+\x2\x2\xDCC\xDCB\x3\x2"+
		"\x2\x2\xDCC\xDCD\x3\x2\x2\x2\xDCD\xDCF\x3\x2\x2\x2\xDCE\xDD0\x5\x1BC\xDF"+
		"\x2\xDCF\xDCE\x3\x2\x2\x2\xDD0\xDD1\x3\x2\x2\x2\xDD1\xDCF\x3\x2\x2\x2"+
		"\xDD1\xDD2\x3\x2\x2\x2\xDD2\xDD4\x3\x2\x2\x2\xDD3\xDD5\x5\x1BE\xE0\x2"+
		"\xDD4\xDD3\x3\x2\x2\x2\xDD4\xDD5\x3\x2\x2\x2\xDD5\x1BB\x3\x2\x2\x2\xDD6"+
		"\xDD7\a\x1AC\x2\x2\xDD7\xDD8\x5\x1F0\xF9\x2\xDD8\xDDA\a\x17F\x2\x2\xDD9"+
		"\xDDB\x5\x1B8\xDD\x2\xDDA\xDD9\x3\x2\x2\x2\xDDB\xDDC\x3\x2\x2\x2\xDDC"+
		"\xDDA\x3\x2\x2\x2\xDDC\xDDD\x3\x2\x2\x2\xDDD\x1BD\x3\x2\x2\x2\xDDE\xDE0"+
		"\aw\x2\x2\xDDF\xDE1\x5\x1B8\xDD\x2\xDE0\xDDF\x3\x2\x2\x2\xDE1\xDE2\x3"+
		"\x2\x2\x2\xDE2\xDE0\x3\x2\x2\x2\xDE2\xDE3\x3\x2\x2\x2\xDE3\x1BF\x3\x2"+
		"\x2\x2\xDE4\xDE5\a\xBB\x2\x2\xDE5\xDF1\x5\x1D8\xED\x2\xDE6\xDE7\a\x1F5"+
		"\x2\x2\xDE7\xDEC\x5\x2C6\x164\x2\xDE8\xDE9\a\x1FB\x2\x2\xDE9\xDEB\x5\x2C6"+
		"\x164\x2\xDEA\xDE8\x3\x2\x2\x2\xDEB\xDEE\x3\x2\x2\x2\xDEC\xDEA\x3\x2\x2"+
		"\x2\xDEC\xDED\x3\x2\x2\x2\xDED\xDEF\x3\x2\x2\x2\xDEE\xDEC\x3\x2\x2\x2"+
		"\xDEF\xDF0\a\x1F6\x2\x2\xDF0\xDF2\x3\x2\x2\x2\xDF1\xDE6\x3\x2\x2\x2\xDF1"+
		"\xDF2\x3\x2\x2\x2\xDF2\x1C1\x3\x2\x2\x2\xDF3\xDF4\a\x1A1\x2\x2\xDF4\xDF5"+
		"\x5\x1EE\xF8\x2\xDF5\x1C3\x3\x2\x2\x2\xDF6\xDF7\a\xDD\x2\x2\xDF7\xDF8"+
		"\a\xBB\x2\x2\xDF8\xDFA\x5\x2C8\x165\x2\xDF9\xDFB\x5\x282\x142\x2\xDFA"+
		"\xDF9\x3\x2\x2\x2\xDFA\xDFB\x3\x2\x2\x2\xDFB\xDFC\x3\x2\x2\x2\xDFC\xDFD"+
		"\a\x19E\x2\x2\xDFD\xDFE\x5\x1CE\xE8\x2\xDFE\xDFF\a\x108\x2\x2\xDFF\xE00"+
		"\a\x1F5\x2\x2\xE00\xE01\x5\x1F0\xF9\x2\xE01\xE0A\a\x1F6\x2\x2\xE02\xE04"+
		"\x5\x1C6\xE4\x2\xE03\xE05\x5\x1CC\xE7\x2\xE04\xE03\x3\x2\x2\x2\xE04\xE05"+
		"\x3\x2\x2\x2\xE05\xE0B\x3\x2\x2\x2\xE06\xE08\x5\x1CC\xE7\x2\xE07\xE09"+
		"\x5\x1C6\xE4\x2\xE08\xE07\x3\x2\x2\x2\xE08\xE09\x3\x2\x2\x2\xE09\xE0B"+
		"\x3\x2\x2\x2\xE0A\xE02\x3\x2\x2\x2\xE0A\xE06\x3\x2\x2\x2\xE0A\xE0B\x3"+
		"\x2\x2\x2\xE0B\xE0D\x3\x2\x2\x2\xE0C\xE0E\x5\x1DC\xEF\x2\xE0D\xE0C\x3"+
		"\x2\x2\x2\xE0D\xE0E\x3\x2\x2\x2\xE0E\x1C5\x3\x2\x2\x2\xE0F\xE10\a\x1AC"+
		"\x2\x2\xE10\xE11\a\xD9\x2\x2\xE11\xE12\a\x17F\x2\x2\xE12\xE13\a\x199\x2"+
		"\x2\xE13\xE14\a\x15D\x2\x2\xE14\xE19\x5\x1C8\xE5\x2\xE15\xE16\a\x1FB\x2"+
		"\x2\xE16\xE18\x5\x1C8\xE5\x2\xE17\xE15\x3\x2\x2\x2\xE18\xE1B\x3\x2\x2"+
		"\x2\xE19\xE17\x3\x2\x2\x2\xE19\xE1A\x3\x2\x2\x2\xE1A\xE1D\x3\x2\x2\x2"+
		"\xE1B\xE19\x3\x2\x2\x2\xE1C\xE1E\x5\x286\x144\x2\xE1D\xE1C\x3\x2\x2\x2"+
		"\xE1D\xE1E\x3\x2\x2\x2\xE1E\xE20\x3\x2\x2\x2\xE1F\xE21\x5\x1CA\xE6\x2"+
		"\xE20\xE1F\x3\x2\x2\x2\xE20\xE21\x3\x2\x2\x2\xE21\x1C7\x3\x2\x2\x2\xE22"+
		"\xE23\x5\x2C6\x164\x2\xE23\xE24\a\x20C\x2\x2\xE24\xE25\x5\x1F2\xFA\x2"+
		"\xE25\x1C9\x3\x2\x2\x2\xE26\xE27\ai\x2\x2\xE27\xE28\x5\x286\x144\x2\xE28"+
		"\x1CB\x3\x2\x2\x2\xE29\xE2A\a\x1AC\x2\x2\xE2A\xE2B\a\xFC\x2\x2\xE2B\xE2C"+
		"\a\xD9\x2\x2\xE2C\xE2D\a\x17F\x2\x2\xE2D\xE39\a\xB4\x2\x2\xE2E\xE2F\a"+
		"\x1F5\x2\x2\xE2F\xE34\x5\x2C6\x164\x2\xE30\xE31\a\x1FB\x2\x2\xE31\xE33"+
		"\x5\x2C6\x164\x2\xE32\xE30\x3\x2\x2\x2\xE33\xE36\x3\x2\x2\x2\xE34\xE32"+
		"\x3\x2\x2\x2\xE34\xE35\x3\x2\x2\x2\xE35\xE37\x3\x2\x2\x2\xE36\xE34\x3"+
		"\x2\x2\x2\xE37\xE38\a\x1F6\x2\x2\xE38\xE3A\x3\x2\x2\x2\xE39\xE2E\x3\x2"+
		"\x2\x2\xE39\xE3A\x3\x2\x2\x2\xE3A\xE3B\x3\x2\x2\x2\xE3B\xE3C\a\x1A1\x2"+
		"\x2\xE3C\xE3E\x5\x1EE\xF8\x2\xE3D\xE3F\x5\x286\x144\x2\xE3E\xE3D\x3\x2"+
		"\x2\x2\xE3E\xE3F\x3\x2\x2\x2\xE3F\x1CD\x3\x2\x2\x2\xE40\xE46\x5\x2C8\x165"+
		"\x2\xE41\xE42\a\x1F5\x2\x2\xE42\xE43\x5\x134\x9B\x2\xE43\xE44\a\x1F6\x2"+
		"\x2\xE44\xE46\x3\x2\x2\x2\xE45\xE40\x3\x2\x2\x2\xE45\xE41\x3\x2\x2\x2"+
		"\xE46\xE48\x3\x2\x2\x2\xE47\xE49\x5\x282\x142\x2\xE48\xE47\x3\x2\x2\x2"+
		"\xE48\xE49\x3\x2\x2\x2\xE49\x1CF\x3\x2\x2\x2\xE4A\xE4B\a\xD0\x2\x2\xE4B"+
		"\xE4C\a\x17D\x2\x2\xE4C\xE51\x5\x1D4\xEB\x2\xE4D\xE4E\a\x1FB\x2\x2\xE4E"+
		"\xE50\x5\x1D4\xEB\x2\xE4F\xE4D\x3\x2\x2\x2\xE50\xE53\x3\x2\x2\x2\xE51"+
		"\xE4F\x3\x2\x2\x2\xE51\xE52\x3\x2\x2\x2\xE52\xE54\x3\x2\x2\x2\xE53\xE51"+
		"\x3\x2\x2\x2\xE54\xE55\a\xA7\x2\x2\xE55\xE56\x5\x1D6\xEC\x2\xE56\xE58"+
		"\a\xE2\x2\x2\xE57\xE59\x5\x1D2\xEA\x2\xE58\xE57\x3\x2\x2\x2\xE58\xE59"+
		"\x3\x2\x2\x2\xE59\x1D1\x3\x2\x2\x2\xE5A\xE5B\a\x1A9\x2\x2\xE5B\xE5E\x5"+
		"\x1F2\xFA\x2\xE5C\xE5E\a\xFD\x2\x2\xE5D\xE5A\x3\x2\x2\x2\xE5D\xE5C\x3"+
		"\x2\x2\x2\xE5E\x1D3\x3\x2\x2\x2\xE5F\xE61\x5\x2C8\x165\x2\xE60\xE62\x5"+
		"\x27E\x140\x2\xE61\xE60\x3\x2\x2\x2\xE61\xE62\x3\x2\x2\x2\xE62\x1D5\x3"+
		"\x2\x2\x2\xE63\xE64\a\x147\x2\x2\xE64\xE70\a\x160\x2\x2\xE65\xE66\a\x147"+
		"\x2\x2\xE66\xE70\a\x86\x2\x2\xE67\xE69\a\x160\x2\x2\xE68\xE6A\a\x199\x2"+
		"\x2\xE69\xE68\x3\x2\x2\x2\xE69\xE6A\x3\x2\x2\x2\xE6A\xE70\x3\x2\x2\x2"+
		"\xE6B\xE6C\a\x160\x2\x2\xE6C\xE6D\a\x147\x2\x2\xE6D\xE70\a\x86\x2\x2\xE6E"+
		"\xE70\a\x86\x2\x2\xE6F\xE63\x3\x2\x2\x2\xE6F\xE65\x3\x2\x2\x2\xE6F\xE67"+
		"\x3\x2\x2\x2\xE6F\xE6B\x3\x2\x2\x2\xE6F\xE6E\x3\x2\x2\x2\xE70\x1D7\x3"+
		"\x2\x2\x2\xE71\xE78\x5\x1E2\xF2\x2\xE72\xE73\a\x109\x2\x2\xE73\xE74\a"+
		"\x1F5\x2\x2\xE74\xE75\x5\x1E2\xF2\x2\xE75\xE76\a\x1F6\x2\x2\xE76\xE78"+
		"\x3\x2\x2\x2\xE77\xE71\x3\x2\x2\x2\xE77\xE72\x3\x2\x2\x2\xE78\xE7A\x3"+
		"\x2\x2\x2\xE79\xE7B\x5\x282\x142\x2\xE7A\xE79\x3\x2\x2\x2\xE7A\xE7B\x3"+
		"\x2\x2\x2\xE7B\x1D9\x3\x2\x2\x2\xE7C\xE7D\t\x18\x2\x2\xE7D\xE82\x5\x1F2"+
		"\xFA\x2\xE7E\xE7F\a\x1FB\x2\x2\xE7F\xE81\x5\x1F2\xFA\x2\xE80\xE7E\x3\x2"+
		"\x2\x2\xE81\xE84\x3\x2\x2\x2\xE82\xE80\x3\x2\x2\x2\xE82\xE83\x3\x2\x2"+
		"\x2\xE83\xE85\x3\x2\x2\x2\xE84\xE82\x3\x2\x2\x2\xE85\xE86\x5\x28A\x146"+
		"\x2\xE86\x1DB\x3\x2\x2\x2\xE87\xE88\a\xD2\x2\x2\xE88\xE8A\a\x7F\x2\x2"+
		"\xE89\xE8B\x5\x1DE\xF0\x2\xE8A\xE89\x3\x2\x2\x2\xE8A\xE8B\x3\x2\x2\x2"+
		"\xE8B\xE8D\x3\x2\x2\x2\xE8C\xE8E\x5\x1F2\xFA\x2\xE8D\xE8C\x3\x2\x2\x2"+
		"\xE8D\xE8E\x3\x2\x2\x2\xE8E\xE90\x3\x2\x2\x2\xE8F\xE91\x5\x1E0\xF1\x2"+
		"\xE90\xE8F\x3\x2\x2\x2\xE90\xE91\x3\x2\x2\x2\xE91\x1DD\x3\x2\x2\x2\xE92"+
		"\xE93\a\xBB\x2\x2\xE93\xE94\x5\x2C8\x165\x2\xE94\x1DF\x3\x2\x2\x2\xE95"+
		"\xE96\a\x137\x2\x2\xE96\xE99\a\xCE\x2\x2\xE97\xE9A\a\x196\x2\x2\xE98\xE9A"+
		"\x5\x1F2\xFA\x2\xE99\xE97\x3\x2\x2\x2\xE99\xE98\x3\x2\x2\x2\xE9A\x1E1"+
		"\x3\x2\x2\x2\xE9B\xEA8\x5\x1E4\xF3\x2\xE9C\xE9D\a\x1F5\x2\x2\xE9D\xE9F"+
		"\x5\x134\x9B\x2\xE9E\xEA0\x5\x1E6\xF4\x2\xE9F\xE9E\x3\x2\x2\x2\xE9F\xEA0"+
		"\x3\x2\x2\x2\xEA0\xEA1\x3\x2\x2\x2\xEA1\xEA2\a\x1F6\x2\x2\xEA2\xEA8\x3"+
		"\x2\x2\x2\xEA3\xEA5\x5\x2C8\x165\x2\xEA4\xEA6\x5\x1E8\xF5\x2\xEA5\xEA4"+
		"\x3\x2\x2\x2\xEA5\xEA6\x3\x2\x2\x2\xEA6\xEA8\x3\x2\x2\x2\xEA7\xE9B\x3"+
		"\x2\x2\x2\xEA7\xE9C\x3\x2\x2\x2\xEA7\xEA3\x3\x2\x2\x2\xEA8\x1E3\x3\x2"+
		"\x2\x2\xEA9\xEB6\t,\x2\x2\xEAA\xEAB\a\x1F5\x2\x2\xEAB\xEAC\x5\x13E\xA0"+
		"\x2\xEAC\xEAD\a\x1F6\x2\x2\xEAD\xEB7\x3\x2\x2\x2\xEAE\xEAF\a\x1F5\x2\x2"+
		"\xEAF\xEB0\x5\x1F2\xFA\x2\xEB0\xEB4\a\x1F6\x2\x2\xEB1\xEB2\a\x1F5\x2\x2"+
		"\xEB2\xEB3\a\x1F9\x2\x2\xEB3\xEB5\a\x1F6\x2\x2\xEB4\xEB1\x3\x2\x2\x2\xEB4"+
		"\xEB5\x3\x2\x2\x2\xEB5\xEB7\x3\x2\x2\x2\xEB6\xEAA\x3\x2\x2\x2\xEB6\xEAE"+
		"\x3\x2\x2\x2\xEB7\x1E5\x3\x2\x2\x2\xEB8\xEC1\a\x1B0\x2\x2\xEB9\xEBA\a"+
		"\x131\x2\x2\xEBA\xEC2\a\x109\x2\x2\xEBB\xEBC\a\x34\x2\x2\xEBC\xEBF\a\x10B"+
		"\x2\x2\xEBD\xEBE\a\x45\x2\x2\xEBE\xEC0\x5\x2AA\x156\x2\xEBF\xEBD\x3\x2"+
		"\x2\x2\xEBF\xEC0\x3\x2\x2\x2\xEC0\xEC2\x3\x2\x2\x2\xEC1\xEB9\x3\x2\x2"+
		"\x2\xEC1\xEBB\x3\x2\x2\x2\xEC2\x1E7\x3\x2\x2\x2\xEC3\xEC5\a\x14B\x2\x2"+
		"\xEC4\xEC6\a\"\x2\x2\xEC5\xEC4\x3\x2\x2\x2\xEC5\xEC6\x3\x2\x2\x2\xEC6"+
		"\xEC7\x3\x2\x2\x2\xEC7\xEC8\a\x1F5\x2\x2\xEC8\xECB\x5\x1F2\xFA\x2\xEC9"+
		"\xECA\a\x1FB\x2\x2\xECA\xECC\x5\x1F2\xFA\x2\xECB\xEC9\x3\x2\x2\x2\xECB"+
		"\xECC\x3\x2\x2\x2\xECC\xECD\x3\x2\x2\x2\xECD\xECF\a\x1F6\x2\x2\xECE\xED0"+
		"\x5\x1EA\xF6\x2\xECF\xECE\x3\x2\x2\x2\xECF\xED0\x3\x2\x2\x2\xED0\x1E9"+
		"\x3\x2\x2\x2\xED1\xED2\a\x153\x2\x2\xED2\xED3\a\x1F5\x2\x2\xED3\xED4\x5"+
		"\x1F2\xFA\x2\xED4\xED5\a\x1F6\x2\x2\xED5\x1EB\x3\x2\x2\x2\xED6\xED7\a"+
		"U\x2\x2\xED7\xED8\a\x1F5\x2\x2\xED8\xED9\x5\x13E\xA0\x2\xED9\xEDA\a\x1F6"+
		"\x2\x2\xEDA\x1ED\x3\x2\x2\x2\xEDB\xEDD\a\x1F5\x2\x2\xEDC\xEDE\x5\x1F2"+
		"\xFA\x2\xEDD\xEDC\x3\x2\x2\x2\xEDD\xEDE\x3\x2\x2\x2\xEDE\xEE3\x3\x2\x2"+
		"\x2\xEDF\xEE0\a\x1FB\x2\x2\xEE0\xEE2\x5\x1F2\xFA\x2\xEE1\xEDF\x3\x2\x2"+
		"\x2\xEE2\xEE5\x3\x2\x2\x2\xEE3\xEE1\x3\x2\x2\x2\xEE3\xEE4\x3\x2\x2\x2"+
		"\xEE4\xEE6\x3\x2\x2\x2\xEE5\xEE3\x3\x2\x2\x2\xEE6\xEE7\a\x1F6\x2\x2\xEE7"+
		"\x1EF\x3\x2\x2\x2\xEE8\xEE9\x5\x1F2\xFA\x2\xEE9\x1F1\x3\x2\x2\x2\xEEA"+
		"\xEED\x5\x1EC\xF7\x2\xEEB\xEED\x5\x1F4\xFB\x2\xEEC\xEEA\x3\x2\x2\x2\xEEC"+
		"\xEEB\x3\x2\x2\x2\xEED\x1F3\x3\x2\x2\x2\xEEE\xEEF\b\xFB\x1\x2\xEEF\xEF0"+
		"\x5\x1F6\xFC\x2\xEF0\xEF6\x3\x2\x2\x2\xEF1\xEF2\f\x3\x2\x2\xEF2\xEF3\a"+
		"\x10C\x2\x2\xEF3\xEF5\x5\x1F6\xFC\x2\xEF4\xEF1\x3\x2\x2\x2\xEF5\xEF8\x3"+
		"\x2\x2\x2\xEF6\xEF4\x3\x2\x2\x2\xEF6\xEF7\x3\x2\x2\x2\xEF7\x1F5\x3\x2"+
		"\x2\x2\xEF8\xEF6\x3\x2\x2\x2\xEF9\xEFA\b\xFC\x1\x2\xEFA\xEFB\x5\x1F8\xFD"+
		"\x2\xEFB\xF01\x3\x2\x2\x2\xEFC\xEFD\f\x3\x2\x2\xEFD\xEFE\a\f\x2\x2\xEFE"+
		"\xF00\x5\x1F8\xFD\x2\xEFF\xEFC\x3\x2\x2\x2\xF00\xF03\x3\x2\x2\x2\xF01"+
		"\xEFF\x3\x2\x2\x2\xF01\xF02\x3\x2\x2\x2\xF02\x1F7\x3\x2\x2\x2\xF03\xF01"+
		"\x3\x2\x2\x2\xF04\xF05\a\xFC\x2\x2\xF05\xF08\x5\x1F8\xFD\x2\xF06\xF08"+
		"\x5\x1FA\xFE\x2\xF07\xF04\x3\x2\x2\x2\xF07\xF06\x3\x2\x2\x2\xF08\x1F9"+
		"\x3\x2\x2\x2\xF09\xF2B\x5\x1FC\xFF\x2\xF0A\xF0C\a\xBD\x2\x2\xF0B\xF0D"+
		"\a\xFC\x2\x2\xF0C\xF0B\x3\x2\x2\x2\xF0C\xF0D\x3\x2\x2\x2\xF0D\xF27\x3"+
		"\x2\x2\x2\xF0E\xF28\a\xFE\x2\x2\xF0F\xF28\a\xE8\x2\x2\xF10\xF28\a\x12B"+
		"\x2\x2\xF11\xF28\a\xB0\x2\x2\xF12\xF13\a\x4\x2\x2\xF13\xF28\a\x15D\x2"+
		"\x2\xF14\xF28\ay\x2\x2\xF15\xF17\a\x104\x2\x2\xF16\xF18\a\x191\x2\x2\xF17"+
		"\xF16\x3\x2\x2\x2\xF17\xF18\x3\x2\x2\x2\xF18\xF19\x3\x2\x2\x2\xF19\xF1B"+
		"\a\x1F5\x2\x2\xF1A\xF1C\a\x109\x2\x2\xF1B\xF1A\x3\x2\x2\x2\xF1B\xF1C\x3"+
		"\x2\x2\x2\xF1C\xF1D\x3\x2\x2\x2\xF1D\xF22\x5\x2D8\x16D\x2\xF1E\xF1F\a"+
		"\x1FB\x2\x2\xF1F\xF21\x5\x2D8\x16D\x2\xF20\xF1E\x3\x2\x2\x2\xF21\xF24"+
		"\x3\x2\x2\x2\xF22\xF20\x3\x2\x2\x2\xF22\xF23\x3\x2\x2\x2\xF23\xF25\x3"+
		"\x2\x2\x2\xF24\xF22\x3\x2\x2\x2\xF25\xF26\a\x1F6\x2\x2\xF26\xF28\x3\x2"+
		"\x2\x2\xF27\xF0E\x3\x2\x2\x2\xF27\xF0F\x3\x2\x2\x2\xF27\xF10\x3\x2\x2"+
		"\x2\xF27\xF11\x3\x2\x2\x2\xF27\xF12\x3\x2\x2\x2\xF27\xF14\x3\x2\x2\x2"+
		"\xF27\xF15\x3\x2\x2\x2\xF28\xF2A\x3\x2\x2\x2\xF29\xF0A\x3\x2\x2\x2\xF2A"+
		"\xF2D\x3\x2\x2\x2\xF2B\xF29\x3\x2\x2\x2\xF2B\xF2C\x3\x2\x2\x2\xF2C\x1FB"+
		"\x3\x2\x2\x2\xF2D\xF2B\x3\x2\x2\x2\xF2E\xF35\x5\x200\x101\x2\xF2F\xF31"+
		"\x5\x1FE\x100\x2\xF30\xF32\a\x104\x2\x2\xF31\xF30\x3\x2\x2\x2\xF31\xF32"+
		"\x3\x2\x2\x2\xF32\xF33\x3\x2\x2\x2\xF33\xF34\x5\x20E\x108\x2\xF34\xF36"+
		"\x3\x2\x2\x2\xF35\xF2F\x3\x2\x2\x2\xF35\xF36\x3\x2\x2\x2\xF36\x1FD\x3"+
		"\x2\x2\x2\xF37\xF38\t-\x2\x2\xF38\x1FF\x3\x2\x2\x2\xF39\xF3A\b\x101\x1"+
		"\x2\xF3A\xF3B\x5\x202\x102\x2\xF3B\xF42\x3\x2\x2\x2\xF3C\xF3D\f\x4\x2"+
		"\x2\xF3D\xF3E\x5\x204\x103\x2\xF3E\xF3F\x5\x200\x101\x5\xF3F\xF41\x3\x2"+
		"\x2\x2\xF40\xF3C\x3\x2\x2\x2\xF41\xF44\x3\x2\x2\x2\xF42\xF40\x3\x2\x2"+
		"\x2\xF42\xF43\x3\x2\x2\x2\xF43\x201\x3\x2\x2\x2\xF44\xF42\x3\x2\x2\x2"+
		"\xF45\xF54\x5\x20E\x108\x2\xF46\xF48\a\xFC\x2\x2\xF47\xF46\x3\x2\x2\x2"+
		"\xF47\xF48\x3\x2\x2\x2\xF48\xF52\x3\x2\x2\x2\xF49\xF4A\a\xA7\x2\x2\xF4A"+
		"\xF53\x5\x20A\x106\x2\xF4B\xF4C\a\x1C\x2\x2\xF4C\xF53\x5\x20C\x107\x2"+
		"\xF4D\xF4E\x5\x206\x104\x2\xF4E\xF50\x5\x20E\x108\x2\xF4F\xF51\x5\x208"+
		"\x105\x2\xF50\xF4F\x3\x2\x2\x2\xF50\xF51\x3\x2\x2\x2\xF51\xF53\x3\x2\x2"+
		"\x2\xF52\xF49\x3\x2\x2\x2\xF52\xF4B\x3\x2\x2\x2\xF52\xF4D\x3\x2\x2\x2"+
		"\xF53\xF55\x3\x2\x2\x2\xF54\xF47\x3\x2\x2\x2\xF54\xF55\x3\x2\x2\x2\xF55"+
		"\x203\x3\x2\x2\x2\xF56\xF5D\a\x20C\x2\x2\xF57\xF5D\x5\x2F4\x17B\x2\xF58"+
		"\xF5D\a\x203\x2\x2\xF59\xF5D\a\x209\x2\x2\xF5A\xF5D\x5\x2F8\x17D\x2\xF5B"+
		"\xF5D\x5\x2F6\x17C\x2\xF5C\xF56\x3\x2\x2\x2\xF5C\xF57\x3\x2\x2\x2\xF5C"+
		"\xF58\x3\x2\x2\x2\xF5C\xF59\x3\x2\x2\x2\xF5C\xF5A\x3\x2\x2\x2\xF5C\xF5B"+
		"\x3\x2\x2\x2\xF5D\x205\x3\x2\x2\x2\xF5E\xF5F\t.\x2\x2\xF5F\x207\x3\x2"+
		"\x2\x2\xF60\xF61\a\x80\x2\x2\xF61\xF62\x5\x20E\x108\x2\xF62\x209\x3\x2"+
		"\x2\x2\xF63\xF64\a\x1F5\x2\x2\xF64\xF65\x5\x13E\xA0\x2\xF65\xF66\a\x1F6"+
		"\x2\x2\xF66\xF76\x3\x2\x2\x2\xF67\xF68\a\x1F5\x2\x2\xF68\xF6D\x5\x20E"+
		"\x108\x2\xF69\xF6A\a\x1FB\x2\x2\xF6A\xF6C\x5\x20E\x108\x2\xF6B\xF69\x3"+
		"\x2\x2\x2\xF6C\xF6F\x3\x2\x2\x2\xF6D\xF6B\x3\x2\x2\x2\xF6D\xF6E\x3\x2"+
		"\x2\x2\xF6E\xF70\x3\x2\x2\x2\xF6F\xF6D\x3\x2\x2\x2\xF70\xF71\a\x1F6\x2"+
		"\x2\xF71\xF76\x3\x2\x2\x2\xF72\xF76\x5\x2E8\x175\x2\xF73\xF76\x5\x2E0"+
		"\x171\x2\xF74\xF76\x5\x2E2\x172\x2\xF75\xF63\x3\x2\x2\x2\xF75\xF67\x3"+
		"\x2\x2\x2\xF75\xF72\x3\x2\x2\x2\xF75\xF73\x3\x2\x2\x2\xF75\xF74\x3\x2"+
		"\x2\x2\xF76\x20B\x3\x2\x2\x2\xF77\xF78\x5\x20E\x108\x2\xF78\xF79\a\f\x2"+
		"\x2\xF79\xF7A\x5\x20E\x108\x2\xF7A\x20D\x3\x2\x2\x2\xF7B\xF81\x5\x210"+
		"\x109\x2\xF7C\xF7D\x5\x2FA\x17E\x2\xF7D\xF7E\x5\x210\x109\x2\xF7E\xF80"+
		"\x3\x2\x2\x2\xF7F\xF7C\x3\x2\x2\x2\xF80\xF83\x3\x2\x2\x2\xF81\xF7F\x3"+
		"\x2\x2\x2\xF81\xF82\x3\x2\x2\x2\xF82\x20F\x3\x2\x2\x2\xF83\xF81\x3\x2"+
		"\x2\x2\xF84\xF89\x5\x212\x10A\x2\xF85\xF86\t/\x2\x2\xF86\xF88\x5\x212"+
		"\x10A\x2\xF87\xF85\x3\x2\x2\x2\xF88\xF8B\x3\x2\x2\x2\xF89\xF87\x3\x2\x2"+
		"\x2\xF89\xF8A\x3\x2\x2\x2\xF8A\x211\x3\x2\x2\x2\xF8B\xF89\x3\x2\x2\x2"+
		"\xF8C\xF91\x5\x214\x10B\x2\xF8D\xF8E\t\x30\x2\x2\xF8E\xF90\x5\x214\x10B"+
		"\x2\xF8F\xF8D\x3\x2\x2\x2\xF90\xF93\x3\x2\x2\x2\xF91\xF8F\x3\x2\x2\x2"+
		"\xF91\xF92\x3\x2\x2\x2\xF92\x213\x3\x2\x2\x2\xF93\xF91\x3\x2\x2\x2\xF94"+
		"\xF9D\x5\x218\x10D\x2\xF95\xF9A\a\x12\x2\x2\xF96\xF9B\a\xCF\x2\x2\xF97"+
		"\xF98\a\x180\x2\x2\xF98\xF99\a\x1C6\x2\x2\xF99\xF9B\x5\x20E\x108\x2\xF9A"+
		"\xF96\x3\x2\x2\x2\xF9A\xF97\x3\x2\x2\x2\xF9B\xF9E\x3\x2\x2\x2\xF9C\xF9E"+
		"\x5\x216\x10C\x2\xF9D\xF95\x3\x2\x2\x2\xF9D\xF9C\x3\x2\x2\x2\xF9D\xF9E"+
		"\x3\x2\x2\x2\xF9E\x215\x3\x2\x2\x2\xF9F\xFA4\a[\x2\x2\xFA0\xFA1\a\x1F5"+
		"\x2\x2\xFA1\xFA2\x5\x20E\x108\x2\xFA2\xFA3\a\x1F6\x2\x2\xFA3\xFA5\x3\x2"+
		"\x2\x2\xFA4\xFA0\x3\x2\x2\x2\xFA4\xFA5\x3\x2\x2\x2\xFA5\xFA6\x3\x2\x2"+
		"\x2\xFA6\xFA7\a\x189\x2\x2\xFA7\xFAC\a\x152\x2\x2\xFA8\xFA9\a\x1F5\x2"+
		"\x2\xFA9\xFAA\x5\x20E\x108\x2\xFAA\xFAB\a\x1F6\x2\x2\xFAB\xFAD\x3\x2\x2"+
		"\x2\xFAC\xFA8\x3\x2\x2\x2\xFAC\xFAD\x3\x2\x2\x2\xFAD\xFB8\x3\x2\x2\x2"+
		"\xFAE\xFB3\a\x1C3\x2\x2\xFAF\xFB0\a\x1F5\x2\x2\xFB0\xFB1\x5\x20E\x108"+
		"\x2\xFB1\xFB2\a\x1F6\x2\x2\xFB2\xFB4\x3\x2\x2\x2\xFB3\xFAF\x3\x2\x2\x2"+
		"\xFB3\xFB4\x3\x2\x2\x2\xFB4\xFB5\x3\x2\x2\x2\xFB5\xFB6\a\x189\x2\x2\xFB6"+
		"\xFB8\a\xE5\x2\x2\xFB7\xF9F\x3\x2\x2\x2\xFB7\xFAE\x3\x2\x2\x2\xFB8\x217"+
		"\x3\x2\x2\x2\xFB9\xFBE\x5\x224\x113\x2\xFBA\xFBB\a\x20D\x2\x2\xFBB\xFBC"+
		"\x5\x21A\x10E\x2\xFBC\xFBD\a\x20E\x2\x2\xFBD\xFBF\x3\x2\x2\x2\xFBE\xFBA"+
		"\x3\x2\x2\x2\xFBE\xFBF\x3\x2\x2\x2\xFBF\x219\x3\x2\x2\x2\xFC0\xFC3\a\r"+
		"\x2\x2\xFC1\xFC3\x5\x1F2\xFA\x2\xFC2\xFC0\x3\x2\x2\x2\xFC2\xFC1\x3\x2"+
		"\x2\x2\xFC3\xFCB\x3\x2\x2\x2\xFC4\xFC7\a\x1FB\x2\x2\xFC5\xFC8\a\r\x2\x2"+
		"\xFC6\xFC8\x5\x1F2\xFA\x2\xFC7\xFC5\x3\x2\x2\x2\xFC7\xFC6\x3\x2\x2\x2"+
		"\xFC8\xFCA\x3\x2\x2\x2\xFC9\xFC4\x3\x2\x2\x2\xFCA\xFCD\x3\x2\x2\x2\xFCB"+
		"\xFC9\x3\x2\x2\x2\xFCB\xFCC\x3\x2\x2\x2\xFCC\xFD8\x3\x2\x2\x2\xFCD\xFCB"+
		"\x3\x2\x2\x2\xFCE\xFD3\x5\x21C\x10F\x2\xFCF\xFD0\a\x1FB\x2\x2\xFD0\xFD2"+
		"\x5\x21C\x10F\x2\xFD1\xFCF\x3\x2\x2\x2\xFD2\xFD5\x3\x2\x2\x2\xFD3\xFD1"+
		"\x3\x2\x2\x2\xFD3\xFD4\x3\x2\x2\x2\xFD4\xFD8\x3\x2\x2\x2\xFD5\xFD3\x3"+
		"\x2\x2\x2\xFD6\xFD8\x5\x222\x112\x2\xFD7\xFC2\x3\x2\x2\x2\xFD7\xFCE\x3"+
		"\x2\x2\x2\xFD7\xFD6\x3\x2\x2\x2\xFD8\x21B\x3\x2\x2\x2\xFD9\xFDA\a\x96"+
		"\x2\x2\xFDA\xFE7\x5\x2C6\x164\x2\xFDB\xFDC\a\xA7\x2\x2\xFDC\xFE8\x5\x1EE"+
		"\xF8\x2\xFDD\xFDF\x5\x21E\x110\x2\xFDE\xFDD\x3\x2\x2\x2\xFDE\xFDF\x3\x2"+
		"\x2\x2\xFDF\xFE0\x3\x2\x2\x2\xFE0\xFE1\a\x99\x2\x2\xFE1\xFE2\x5\x1F2\xFA"+
		"\x2\xFE2\xFE3\a\x189\x2\x2\xFE3\xFE4\x5\x1F2\xFA\x2\xFE4\xFE5\x5\x220"+
		"\x111\x2\xFE5\xFE6\x5\x1F2\xFA\x2\xFE6\xFE8\x3\x2\x2\x2\xFE7\xFDB\x3\x2"+
		"\x2\x2\xFE7\xFDE\x3\x2\x2\x2\xFE8\x21D\x3\x2\x2\x2\xFE9\xFEA\a\xCA\x2"+
		"\x2\xFEA\xFEB\x5\x1F2\xFA\x2\xFEB\x21F\x3\x2\x2\x2\xFEC\xFED\t\x31\x2"+
		"\x2\xFED\x221\x3\x2\x2\x2\xFEE\xFEF\a\x96\x2\x2\xFEF\xFF0\a\x1F5\x2\x2"+
		"\xFF0\xFF5\x5\x2C6\x164\x2\xFF1\xFF2\a\x1FB\x2\x2\xFF2\xFF4\x5\x2C6\x164"+
		"\x2\xFF3\xFF1\x3\x2\x2\x2\xFF4\xFF7\x3\x2\x2\x2\xFF5\xFF3\x3\x2\x2\x2"+
		"\xFF5\xFF6\x3\x2\x2\x2\xFF6\xFF8\x3\x2\x2\x2\xFF7\xFF5\x3\x2\x2\x2\xFF8"+
		"\xFF9\a\x1F6\x2\x2\xFF9\xFFA\a\xA7\x2\x2\xFFA\x1007\a\x1F5\x2\x2\xFFB"+
		"\x1008\x5\x13E\xA0\x2\xFFC\xFFD\a\x1F5\x2\x2\xFFD\x1002\x5\x1EE\xF8\x2"+
		"\xFFE\xFFF\a\x1FB\x2\x2\xFFF\x1001\x5\x1EE\xF8\x2\x1000\xFFE\x3\x2\x2"+
		"\x2\x1001\x1004\x3\x2\x2\x2\x1002\x1000\x3\x2\x2\x2\x1002\x1003\x3\x2"+
		"\x2\x2\x1003\x1005\x3\x2\x2\x2\x1004\x1002\x3\x2\x2\x2\x1005\x1006\a\x1F6"+
		"\x2\x2\x1006\x1008\x3\x2\x2\x2\x1007\xFFB\x3\x2\x2\x2\x1007\xFFC\x3\x2"+
		"\x2\x2\x1008\x1009\x3\x2\x2\x2\x1009\x100A\a\x1F6\x2\x2\x100A\x223\x3"+
		"\x2\x2\x2\x100B\x100C\t/\x2\x2\x100C\x101C\x5\x224\x113\x2\x100D\x100E"+
		"\a\x12C\x2\x2\x100E\x101C\x5\x224\x113\x2\x100F\x1010\a\x43\x2\x2\x1010"+
		"\x101C\x5\x224\x113\x2\x1011\x1012\a\xF0\x2\x2\x1012\x101C\x5\x224\x113"+
		"\x2\x1013\x1014\ap\x2\x2\x1014\x101C\x5\x224\x113\x2\x1015\x1016\a\t\x2"+
		"\x2\x1016\x101C\x5\x224\x113\x2\x1017\x101C\x5\x226\x114\x2\x1018\x101C"+
		"\x5\x238\x11D\x2\x1019\x101C\x5\x23C\x11F\x2\x101A\x101C\x5\x232\x11A"+
		"\x2\x101B\x100B\x3\x2\x2\x2\x101B\x100D\x3\x2\x2\x2\x101B\x100F\x3\x2"+
		"\x2\x2\x101B\x1011\x3\x2\x2\x2\x101B\x1013\x3\x2\x2\x2\x101B\x1015\x3"+
		"\x2\x2\x2\x101B\x1017\x3\x2\x2\x2\x101B\x1018\x3\x2\x2\x2\x101B\x1019"+
		"\x3\x2\x2\x2\x101B\x101A\x3\x2\x2\x2\x101C\x225\x3\x2\x2\x2\x101D\x1020"+
		"\x5\x22C\x117\x2\x101E\x1020\x5\x228\x115\x2\x101F\x101D\x3\x2\x2\x2\x101F"+
		"\x101E\x3\x2\x2\x2\x1020\x227\x3\x2\x2\x2\x1021\x1023\x5\x2AC\x157\x2"+
		"\x1022\x1021\x3\x2\x2\x2\x1022\x1023\x3\x2\x2\x2\x1023\x1024\x3\x2\x2"+
		"\x2\x1024\x1025\a/\x2\x2\x1025\x1027\x5\x232\x11A\x2\x1026\x1028\x5\x22A"+
		"\x116\x2\x1027\x1026\x3\x2\x2\x2\x1028\x1029\x3\x2\x2\x2\x1029\x1027\x3"+
		"\x2\x2\x2\x1029\x102A\x3\x2\x2\x2\x102A\x102C\x3\x2\x2\x2\x102B\x102D"+
		"\x5\x230\x119\x2\x102C\x102B\x3\x2\x2\x2\x102C\x102D\x3\x2\x2\x2\x102D"+
		"\x102E\x3\x2\x2\x2\x102E\x1030\a|\x2\x2\x102F\x1031\a/\x2\x2\x1030\x102F"+
		"\x3\x2\x2\x2\x1030\x1031\x3\x2\x2\x2\x1031\x1033\x3\x2\x2\x2\x1032\x1034"+
		"\x5\x2AC\x157\x2\x1033\x1032\x3\x2\x2\x2\x1033\x1034\x3\x2\x2\x2\x1034"+
		"\x229\x3\x2\x2\x2\x1035\x1036\a\x1AC\x2\x2\x1036\x1037\x5\x1F2\xFA\x2"+
		"\x1037\x103A\a\x17F\x2\x2\x1038\x103B\x5\xE0q\x2\x1039\x103B\x5\x1F2\xFA"+
		"\x2\x103A\x1038\x3\x2\x2\x2\x103A\x1039\x3\x2\x2\x2\x103B\x22B\x3\x2\x2"+
		"\x2\x103C\x103E\x5\x2AC\x157\x2\x103D\x103C\x3\x2\x2\x2\x103D\x103E\x3"+
		"\x2\x2\x2\x103E\x103F\x3\x2\x2\x2\x103F\x1041\a/\x2\x2\x1040\x1042\x5"+
		"\x22E\x118\x2\x1041\x1040\x3\x2\x2\x2\x1042\x1043\x3\x2\x2\x2\x1043\x1041"+
		"\x3\x2\x2\x2\x1043\x1044\x3\x2\x2\x2\x1044\x1046\x3\x2\x2\x2\x1045\x1047"+
		"\x5\x230\x119\x2\x1046\x1045\x3\x2\x2\x2\x1046\x1047\x3\x2\x2\x2\x1047"+
		"\x1048\x3\x2\x2\x2\x1048\x104A\a|\x2\x2\x1049\x104B\a/\x2\x2\x104A\x1049"+
		"\x3\x2\x2\x2\x104A\x104B\x3\x2\x2\x2\x104B\x104D\x3\x2\x2\x2\x104C\x104E"+
		"\x5\x2AC\x157\x2\x104D\x104C\x3\x2\x2\x2\x104D\x104E\x3\x2\x2\x2\x104E"+
		"\x22D\x3\x2\x2\x2\x104F\x1050\a\x1AC\x2\x2\x1050\x1051\x5\x1F2\xFA\x2"+
		"\x1051\x1054\a\x17F\x2\x2\x1052\x1055\x5\xE0q\x2\x1053\x1055\x5\x1F2\xFA"+
		"\x2\x1054\x1052\x3\x2\x2\x2\x1054\x1053\x3\x2\x2\x2\x1055\x22F\x3\x2\x2"+
		"\x2\x1056\x1059\aw\x2\x2\x1057\x105A\x5\xE0q\x2\x1058\x105A\x5\x1F2\xFA"+
		"\x2\x1059\x1057\x3\x2\x2\x2\x1059\x1058\x3\x2\x2\x2\x105A\x231\x3\x2\x2"+
		"\x2\x105B\x105C\x5\x2E6\x174\x2\x105C\x105D\x5\x2FC\x17F\x2\x105D\x1070"+
		"\x3\x2\x2\x2\x105E\x1070\x5\x2E0\x171\x2\x105F\x1070\x5\x2E8\x175\x2\x1060"+
		"\x1070\x5\x2E2\x172\x2\x1061\x106D\a\x1F5\x2\x2\x1062\x1063\x5\x13E\xA0"+
		"\x2\x1063\x1067\a\x1F6\x2\x2\x1064\x1066\x5\x140\xA1\x2\x1065\x1064\x3"+
		"\x2\x2\x2\x1066\x1069\x3\x2\x2\x2\x1067\x1065\x3\x2\x2\x2\x1067\x1068"+
		"\x3\x2\x2\x2\x1068\x106E\x3\x2\x2\x2\x1069\x1067\x3\x2\x2\x2\x106A\x106B"+
		"\x5\x234\x11B\x2\x106B\x106C\a\x1F6\x2\x2\x106C\x106E\x3\x2\x2\x2\x106D"+
		"\x1062\x3\x2\x2\x2\x106D\x106A\x3\x2\x2\x2\x106E\x1070\x3\x2\x2\x2\x106F"+
		"\x105B\x3\x2\x2\x2\x106F\x105E\x3\x2\x2\x2\x106F\x105F\x3\x2\x2\x2\x106F"+
		"\x1060\x3\x2\x2\x2\x106F\x1061\x3\x2\x2\x2\x1070\x233\x3\x2\x2\x2\x1071"+
		"\x1073\x5\x1F2\xFA\x2\x1072\x1074\x5\x236\x11C\x2\x1073\x1072\x3\x2\x2"+
		"\x2\x1073\x1074\x3\x2\x2\x2\x1074\x235\x3\x2\x2\x2\x1075\x1076\a\x1FB"+
		"\x2\x2\x1076\x107B\x5\x1F2\xFA\x2\x1077\x1078\a\x1FB\x2\x2\x1078\x107A"+
		"\x5\x1F2\xFA\x2\x1079\x1077\x3\x2\x2\x2\x107A\x107D\x3\x2\x2\x2\x107B"+
		"\x1079\x3\x2\x2\x2\x107B\x107C\x3\x2\x2\x2\x107C\x237\x3\x2\x2\x2\x107D"+
		"\x107B\x3\x2\x2\x2\x107E\x1087\t\x32\x2\x2\x107F\x1080\a\x1F5\x2\x2\x1080"+
		"\x1081\x5\x13E\xA0\x2\x1081\x1082\a\x1F6\x2\x2\x1082\x1088\x3\x2\x2\x2"+
		"\x1083\x1084\a\x1F5\x2\x2\x1084\x1085\x5\x1F2\xFA\x2\x1085\x1086\a\x1F6"+
		"\x2\x2\x1086\x1088\x3\x2\x2\x2\x1087\x107F\x3\x2\x2\x2\x1087\x1083\x3"+
		"\x2\x2\x2\x1088\x239\x3\x2\x2\x2\x1089\x108A\a\x1E3\x2\x2\x108A\x108B"+
		"\a\x1F5\x2\x2\x108B\x108C\x5\x1F2\xFA\x2\x108C\x108D\a\x1FB\x2\x2\x108D"+
		"\x1090\x5\x1F2\xFA\x2\x108E\x108F\a\x1FB\x2\x2\x108F\x1091\x5\x1F2\xFA"+
		"\x2\x1090\x108E\x3\x2\x2\x2\x1090\x1091\x3\x2\x2\x2\x1091\x1092\x3\x2"+
		"\x2\x2\x1092\x1093\a\x1F6\x2\x2\x1093\x10C9\x3\x2\x2\x2\x1094\x1095\a"+
		"\x1E4\x2\x2\x1095\x1098\a\x1F5\x2\x2\x1096\x1099\x5\x2E6\x174\x2\x1097"+
		"\x1099\x5\x23C\x11F\x2\x1098\x1096\x3\x2\x2\x2\x1098\x1097\x3\x2\x2\x2"+
		"\x1099\x109C\x3\x2\x2\x2\x109A\x109B\a\x1FB\x2\x2\x109B\x109D\x5\x2EE"+
		"\x178\x2\x109C\x109A\x3\x2\x2\x2\x109C\x109D\x3\x2\x2\x2\x109D\x109E\x3"+
		"\x2\x2\x2\x109E\x109F\a\x1F6\x2\x2\x109F\x10C9\x3\x2\x2\x2\x10A0\x10A1"+
		"\a\x1D7\x2\x2\x10A1\x10A2\a\x1F5\x2\x2\x10A2\x10A7\x5\x1F2\xFA\x2\x10A3"+
		"\x10A4\a\x1FB\x2\x2\x10A4\x10A6\x5\x1F2\xFA\x2\x10A5\x10A3\x3\x2\x2\x2"+
		"\x10A6\x10A9\x3\x2\x2\x2\x10A7\x10A5\x3\x2\x2\x2\x10A7\x10A8\x3\x2\x2"+
		"\x2\x10A8\x10AA\x3\x2\x2\x2\x10A9\x10A7\x3\x2\x2\x2\x10AA\x10AB\a\x1F6"+
		"\x2\x2\x10AB\x10C9\x3\x2\x2\x2\x10AC\x10AD\a\x35\x2\x2\x10AD\x10AE\a\x1F5"+
		"\x2\x2\x10AE\x10AF\x5\x20E\x108\x2\x10AF\x10B0\a\x19E\x2\x2\x10B0\x10B1"+
		"\a\xED\x2\x2\x10B1\x10B2\a\x1F6\x2\x2\x10B2\x10C9\x3\x2\x2\x2\x10B3\x10B4"+
		"\a\x1DE\x2\x2\x10B4\x10B5\a\x1F5\x2\x2\x10B5\x10B6\x5\x1F2\xFA\x2\x10B6"+
		"\x10B7\a\x1FB\x2\x2\x10B7\x10B8\x5\x1F2\xFA\x2\x10B8\x10B9\a\x1F6\x2\x2"+
		"\x10B9\x10C9\x3\x2\x2\x2\x10BA\x10BB\a\x1E5\x2\x2\x10BB\x10C3\a\x1F5\x2"+
		"\x2\x10BC\x10BE\t\x33\x2\x2\x10BD\x10BC\x3\x2\x2\x2\x10BD\x10BE\x3\x2"+
		"\x2\x2\x10BE\x10C0\x3\x2\x2\x2\x10BF\x10C1\x5\x2EE\x178\x2\x10C0\x10BF"+
		"\x3\x2\x2\x2\x10C0\x10C1\x3\x2\x2\x2\x10C1\x10C2\x3\x2\x2\x2\x10C2\x10C4"+
		"\a\x99\x2\x2\x10C3\x10BD\x3\x2\x2\x2\x10C3\x10C4\x3\x2\x2\x2\x10C4\x10C5"+
		"\x3\x2\x2\x2\x10C5\x10C6\x5\x20E\x108\x2\x10C6\x10C7\a\x1F6\x2\x2\x10C7"+
		"\x10C9\x3\x2\x2\x2\x10C8\x1089\x3\x2\x2\x2\x10C8\x1094\x3\x2\x2\x2\x10C8"+
		"\x10A0\x3\x2\x2\x2\x10C8\x10AC\x3\x2\x2\x2\x10C8\x10B3\x3\x2\x2\x2\x10C8"+
		"\x10BA\x3\x2\x2\x2\x10C9\x23B\x3\x2\x2\x2\x10CA\x10CE\x5\x23A\x11E\x2"+
		"\x10CB\x10CE\x5\x23E\x120\x2\x10CC\x10CE\x5\x242\x122\x2\x10CD\x10CA\x3"+
		"\x2\x2\x2\x10CD\x10CB\x3\x2\x2\x2\x10CD\x10CC\x3\x2\x2\x2\x10CE\x23D\x3"+
		"\x2\x2\x2\x10CF\x10D2\x5\x240\x121\x2\x10D0\x10D3\x5\x21C\x10F\x2\x10D1"+
		"\x10D3\x5\x222\x112\x2\x10D2\x10D0\x3\x2\x2\x2\x10D2\x10D1\x3\x2\x2\x2"+
		"\x10D2\x10D3\x3\x2\x2\x2\x10D3\x23F\x3\x2\x2\x2\x10D4\x10D5\a\x1E6\x2"+
		"\x2\x10D5\x10D7\a\x1F5\x2\x2\x10D6\x10D8\t\x34\x2\x2\x10D7\x10D6\x3\x2"+
		"\x2\x2\x10D7\x10D8\x3\x2\x2\x2\x10D8\x10D9\x3\x2\x2\x2\x10D9\x10DA\x5"+
		"\x1F2\xFA\x2\x10DA\x10DB\a\x1F6\x2\x2\x10DB\x1105\x3\x2\x2\x2\x10DC\x10DD"+
		"\aO\x2\x2\x10DD\x10E5\a\x1F5\x2\x2\x10DE\x10E6\a\x1F8\x2\x2\x10DF\x10E1"+
		"\t\x1F\x2\x2\x10E0\x10DF\x3\x2\x2\x2\x10E0\x10E1\x3\x2\x2\x2\x10E1\x10E2"+
		"\x3\x2\x2\x2\x10E2\x10E4\x5\x20E\x108\x2\x10E3\x10E0\x3\x2\x2\x2\x10E3"+
		"\x10E4\x3\x2\x2\x2\x10E4\x10E6\x3\x2\x2\x2\x10E5\x10DE\x3\x2\x2\x2\x10E5"+
		"\x10E3\x3\x2\x2\x2\x10E6\x10E7\x3\x2\x2\x2\x10E7\x10E9\a\x1F6\x2\x2\x10E8"+
		"\x10EA\x5\x24A\x126\x2\x10E9\x10E8\x3\x2\x2\x2\x10E9\x10EA\x3\x2\x2\x2"+
		"\x10EA\x1105\x3\x2\x2\x2\x10EB\x10EC\a\x1E1\x2\x2\x10EC\x10ED\a\x1F5\x2"+
		"\x2\x10ED\x10F0\x5\x1F2\xFA\x2\x10EE\x10EF\a\x1FB\x2\x2\x10EF\x10F1\a"+
		"\x1EF\x2\x2\x10F0\x10EE\x3\x2\x2\x2\x10F0\x10F1\x3\x2\x2\x2\x10F1\x10F2"+
		"\x3\x2\x2\x2\x10F2\x10F3\a\x1F6\x2\x2\x10F3\x1105\x3\x2\x2\x2\x10F4\x10F5"+
		"\a\x1D4\x2\x2\x10F5\x10F7\a\x1F5\x2\x2\x10F6\x10F8\t\x34\x2\x2\x10F7\x10F6"+
		"\x3\x2\x2\x2\x10F7\x10F8\x3\x2\x2\x2\x10F8\x10F9\x3\x2\x2\x2\x10F9\x10FA"+
		"\x5\x1F2\xFA\x2\x10FA\x10FB\a\x1F6\x2\x2\x10FB\x1105\x3\x2\x2\x2\x10FC"+
		"\x10FD\a\x1DA\x2\x2\x10FD\x10FF\a\x1F5\x2\x2\x10FE\x1100\t\x34\x2\x2\x10FF"+
		"\x10FE\x3\x2\x2\x2\x10FF\x1100\x3\x2\x2\x2\x1100\x1101\x3\x2\x2\x2\x1101"+
		"\x1102\x5\x1F2\xFA\x2\x1102\x1103\a\x1F6\x2\x2\x1103\x1105\x3\x2\x2\x2"+
		"\x1104\x10D4\x3\x2\x2\x2\x1104\x10DC\x3\x2\x2\x2\x1104\x10EB\x3\x2\x2"+
		"\x2\x1104\x10F4\x3\x2\x2\x2\x1104\x10FC\x3\x2\x2\x2\x1105\x241\x3\x2\x2"+
		"\x2\x1106\x1107\x5\x244\x123\x2\x1107\x1109\x5\x2D0\x169\x2\x1108\x110A"+
		"\x5\x24A\x126\x2\x1109\x1108\x3\x2\x2\x2\x1109\x110A\x3\x2\x2\x2\x110A"+
		"\x1249\x3\x2\x2\x2\x110B\x110C\x5\x2FE\x180\x2\x110C\x110E\x5\x2D2\x16A"+
		"\x2\x110D\x110F\x5\x252\x12A\x2\x110E\x110D\x3\x2\x2\x2\x110E\x110F\x3"+
		"\x2\x2\x2\x110F\x1249\x3\x2\x2\x2\x1110\x1111\aO\x2\x2\x1111\x1117\a\x1F5"+
		"\x2\x2\x1112\x1118\a\x1F8\x2\x2\x1113\x1115\t\x1F\x2\x2\x1114\x1113\x3"+
		"\x2\x2\x2\x1114\x1115\x3\x2\x2\x2\x1115\x1116\x3\x2\x2\x2\x1116\x1118"+
		"\x5\x20E\x108\x2\x1117\x1112\x3\x2\x2\x2\x1117\x1114\x3\x2\x2\x2\x1118"+
		"\x1119\x3\x2\x2\x2\x1119\x111B\a\x1F6\x2\x2\x111A\x111C\x5\x24A\x126\x2"+
		"\x111B\x111A\x3\x2\x2\x2\x111B\x111C\x3\x2\x2\x2\x111C\x1249\x3\x2\x2"+
		"\x2\x111D\x111E\t\x35\x2\x2\x111E\x1125\a\x1F5\x2\x2\x111F\x1120\a\xE6"+
		"\x2\x2\x1120\x1121\a\x1F5\x2\x2\x1121\x1122\x5\x13E\xA0\x2\x1122\x1123"+
		"\a\x1F6\x2\x2\x1123\x1126\x3\x2\x2\x2\x1124\x1126\x5\x20E\x108\x2\x1125"+
		"\x111F\x3\x2\x2\x2\x1125\x1124\x3\x2\x2\x2\x1126\x1127\x3\x2\x2\x2\x1127"+
		"\x1128\a\xF\x2\x2\x1128\x1129\x5\x2D8\x16D\x2\x1129\x112A\a\x1F6\x2\x2"+
		"\x112A\x1249\x3\x2\x2\x2\x112B\x112C\a\x39\x2\x2\x112C\x112D\a\x1F5\x2"+
		"\x2\x112D\x1133\x5\x2E6\x174\x2\x112E\x1131\a\x1FB\x2\x2\x112F\x1132\x5"+
		"\x2EA\x176\x2\x1130\x1132\x5\x2EE\x178\x2\x1131\x112F\x3\x2\x2\x2\x1131"+
		"\x1130\x3\x2\x2\x2\x1132\x1134\x3\x2\x2\x2\x1133\x112E\x3\x2\x2\x2\x1133"+
		"\x1134\x3\x2\x2\x2\x1134\x1135\x3\x2\x2\x2\x1135\x1136\a\x1F6\x2\x2\x1136"+
		"\x1249\x3\x2\x2\x2\x1137\x1138\a:\x2\x2\x1138\x113A\a\x1F5\x2\x2\x1139"+
		"\x113B\t\x36\x2\x2\x113A\x1139\x3\x2\x2\x2\x113A\x113B\x3\x2\x2\x2\x113B"+
		"\x113C\x3\x2\x2\x2\x113C\x113E\x5\x20E\x108\x2\x113D\x113F\x5\x256\x12C"+
		"\x2\x113E\x113D\x3\x2\x2\x2\x113E\x113F\x3\x2\x2\x2\x113F\x1140\x3\x2"+
		"\x2\x2\x1140\x1141\a\x1F6\x2\x2\x1141\x1249\x3\x2\x2\x2\x1142\x1143\x5"+
		"\x246\x124\x2\x1143\x1145\x5\x2CE\x168\x2\x1144\x1146\x5\x258\x12D\x2"+
		"\x1145\x1144\x3\x2\x2\x2\x1146\x1147\x3\x2\x2\x2\x1147\x1145\x3\x2\x2"+
		"\x2\x1147\x1148\x3\x2\x2\x2\x1148\x1249\x3\x2\x2\x2\x1149\x114A\x5\x2BE"+
		"\x160\x2\x114A\x114B\t\x37\x2\x2\x114B\x1249\x3\x2\x2\x2\x114C\x114D\a"+
		"\x63\x2\x2\x114D\x114E\a\x1F5\x2\x2\x114E\x1150\x5\x20E\x108\x2\x114F"+
		"\x1151\t\x38\x2\x2\x1150\x114F\x3\x2\x2\x2\x1150\x1151\x3\x2\x2\x2\x1151"+
		"\x1152\x3\x2\x2\x2\x1152\x1153\a\x1F6\x2\x2\x1153\x1249\x3\x2\x2\x2\x1154"+
		"\x1155\a\x8C\x2\x2\x1155\x1156\a\x1F5\x2\x2\x1156\x1157\x5\x2FE\x180\x2"+
		"\x1157\x1158\a\x99\x2\x2\x1158\x1159\x5\x20E\x108\x2\x1159\x115A\a\x1F6"+
		"\x2\x2\x115A\x1249\x3\x2\x2\x2\x115B\x115C\t\x39\x2\x2\x115C\x115E\x5"+
		"\x2D0\x169\x2\x115D\x115F\x5\x2D4\x16B\x2\x115E\x115D\x3\x2\x2\x2\x115E"+
		"\x115F\x3\x2\x2\x2\x115F\x1160\x3\x2\x2\x2\x1160\x1161\x5\x24A\x126\x2"+
		"\x1161\x1249\x3\x2\x2\x2\x1162\x1163\x5\x248\x125\x2\x1163\x1164\a\x1F5"+
		"\x2\x2\x1164\x1169\x5\x1F2\xFA\x2\x1165\x1166\a\x1FB\x2\x2\x1166\x1168"+
		"\x5\x1F2\xFA\x2\x1167\x1165\x3\x2\x2\x2\x1168\x116B\x3\x2\x2\x2\x1169"+
		"\x1167\x3\x2\x2\x2\x1169\x116A\x3\x2\x2\x2\x116A\x116D\x3\x2\x2\x2\x116B"+
		"\x1169\x3\x2\x2\x2\x116C\x116E\x5\x25A\x12E\x2\x116D\x116C\x3\x2\x2\x2"+
		"\x116D\x116E\x3\x2\x2\x2\x116E\x1170\x3\x2\x2\x2\x116F\x1171\x5\x252\x12A"+
		"\x2\x1170\x116F\x3\x2\x2\x2\x1170\x1171\x3\x2\x2\x2\x1171\x1172\x3\x2"+
		"\x2\x2\x1172\x1173\a\x1F6\x2\x2\x1173\x1249\x3\x2\x2\x2\x1174\x1175\a"+
		"\x18C\x2\x2\x1175\x1176\a\x1F5\x2\x2\x1176\x1179\x5\x1F2\xFA\x2\x1177"+
		"\x1178\a\x19E\x2\x2\x1178\x117A\t:\x2\x2\x1179\x1177\x3\x2\x2\x2\x1179"+
		"\x117A\x3\x2\x2\x2\x117A\x117F\x3\x2\x2\x2\x117B\x117C\a\x1FB\x2\x2\x117C"+
		"\x117E\x5\x1F2\xFA\x2\x117D\x117B\x3\x2\x2\x2\x117E\x1181\x3\x2\x2\x2"+
		"\x117F\x117D\x3\x2\x2\x2\x117F\x1180\x3\x2\x2\x2\x1180\x1182\x3\x2\x2"+
		"\x2\x1181\x117F\x3\x2\x2\x2\x1182\x1183\a\x1F6\x2\x2\x1183\x1249\x3\x2"+
		"\x2\x2\x1184\x1185\a\x18D\x2\x2\x1185\x1186\a\x1F5\x2\x2\x1186\x1187\x5"+
		"\x1F2\xFA\x2\x1187\x1189\a\xF\x2\x2\x1188\x118A\a\x134\x2\x2\x1189\x1188"+
		"\x3\x2\x2\x2\x1189\x118A\x3\x2\x2\x2\x118A\x118B\x3\x2\x2\x2\x118B\x118C"+
		"\x5\x2D8\x16D\x2\x118C\x118D\a\x1F6\x2\x2\x118D\x1249\x3\x2\x2\x2\x118E"+
		"\x118F\a\x1E5\x2\x2\x118F\x1197\a\x1F5\x2\x2\x1190\x1192\t\x33\x2\x2\x1191"+
		"\x1190\x3\x2\x2\x2\x1191\x1192\x3\x2\x2\x2\x1192\x1194\x3\x2\x2\x2\x1193"+
		"\x1195\x5\x2EE\x178\x2\x1194\x1193\x3\x2\x2\x2\x1194\x1195\x3\x2\x2\x2"+
		"\x1195\x1196\x3\x2\x2\x2\x1196\x1198\a\x99\x2\x2\x1197\x1191\x3\x2\x2"+
		"\x2\x1197\x1198\x3\x2\x2\x2\x1198\x1199\x3\x2\x2\x2\x1199\x119A\x5\x20E"+
		"\x108\x2\x119A\x119B\a\x1F6\x2\x2\x119B\x1249\x3\x2\x2\x2\x119C\x119D"+
		"\a\x1B5\x2\x2\x119D\x119E\a\x1F5\x2\x2\x119E\x11A0\x5\x1F2\xFA\x2\x119F"+
		"\x11A1\x5\x1A0\xD1\x2\x11A0\x119F\x3\x2\x2\x2\x11A0\x11A1\x3\x2\x2\x2"+
		"\x11A1\x11A2\x3\x2\x2\x2\x11A2\x11A5\a\x1F6\x2\x2\x11A3\x11A4\a\x1EE\x2"+
		"\x2\x11A4\x11A6\x5\x2E4\x173\x2\x11A5\x11A3\x3\x2\x2\x2\x11A5\x11A6\x3"+
		"\x2\x2\x2\x11A6\x1249\x3\x2\x2\x2\x11A7\x11A8\t;\x2\x2\x11A8\x11A9\a\x1F5"+
		"\x2\x2\x11A9\x11AE\x5\x266\x134\x2\x11AA\x11AB\a\x1FB\x2\x2\x11AB\x11AD"+
		"\x5\x266\x134\x2\x11AC\x11AA\x3\x2\x2\x2\x11AD\x11B0\x3\x2\x2\x2\x11AE"+
		"\x11AC\x3\x2\x2\x2\x11AE\x11AF\x3\x2\x2\x2\x11AF\x11B1\x3\x2\x2\x2\x11B0"+
		"\x11AE\x3\x2\x2\x2\x11B1\x11B4\a\x1F6\x2\x2\x11B2\x11B3\a\x1EE\x2\x2\x11B3"+
		"\x11B5\x5\x2E4\x173\x2\x11B4\x11B2\x3\x2\x2\x2\x11B4\x11B5\x3\x2\x2\x2"+
		"\x11B5\x1249\x3\x2\x2\x2\x11B6\x11B7\a\x1B9\x2\x2\x11B7\x11B9\a\x1F5\x2"+
		"\x2\x11B8\x11BA\t<\x2\x2\x11B9\x11B8\x3\x2\x2\x2\x11B9\x11BA\x3\x2\x2"+
		"\x2\x11BA\x11BC\x3\x2\x2\x2\x11BB\x11BD\t=\x2\x2\x11BC\x11BB\x3\x2\x2"+
		"\x2\x11BC\x11BD\x3\x2\x2\x2\x11BD\x11BE\x3\x2\x2\x2\x11BE\x11C1\x5\x1F2"+
		"\xFA\x2\x11BF\x11C0\a\x1FB\x2\x2\x11C0\x11C2\x5\x25E\x130\x2\x11C1\x11BF"+
		"\x3\x2\x2\x2\x11C1\x11C2\x3\x2\x2\x2\x11C2\x11CA\x3\x2\x2\x2\x11C3\x11C4"+
		"\a\x1FB\x2\x2\x11C4\x11C6\x5\x1F2\xFA\x2\x11C5\x11C7\x5\x280\x141\x2\x11C6"+
		"\x11C5\x3\x2\x2\x2\x11C6\x11C7\x3\x2\x2\x2\x11C7\x11C9\x3\x2\x2\x2\x11C8"+
		"\x11C3\x3\x2\x2\x2\x11C9\x11CC\x3\x2\x2\x2\x11CA\x11C8\x3\x2\x2\x2\x11CA"+
		"\x11CB\x3\x2\x2\x2\x11CB\x11CD\x3\x2\x2\x2\x11CC\x11CA\x3\x2\x2\x2\x11CD"+
		"\x11D0\a\x1F6\x2\x2\x11CE\x11CF\a\x1EE\x2\x2\x11CF\x11D1\x5\x2E4\x173"+
		"\x2\x11D0\x11CE\x3\x2\x2\x2\x11D0\x11D1\x3\x2\x2\x2\x11D1\x1249\x3\x2"+
		"\x2\x2\x11D2\x11D3\a\x1BA\x2\x2\x11D3\x11D4\a\x1F5\x2\x2\x11D4\x11D6\x5"+
		"\x1F2\xFA\x2\x11D5\x11D7\x5\x25C\x12F\x2\x11D6\x11D5\x3\x2\x2\x2\x11D6"+
		"\x11D7\x3\x2\x2\x2\x11D7\x11D8\x3\x2\x2\x2\x11D8\x11D9\a\x1F6\x2\x2\x11D9"+
		"\x1249\x3\x2\x2\x2\x11DA\x11DB\a\x1BD\x2\x2\x11DB\x11DC\a\x1F5\x2\x2\x11DC"+
		"\x11DD\t>\x2\x2\x11DD\x11DF\x5\x20E\x108\x2\x11DE\x11E0\a\x1AB\x2\x2\x11DF"+
		"\x11DE\x3\x2\x2\x2\x11DF\x11E0\x3\x2\x2\x2\x11E0\x11E1\x3\x2\x2\x2\x11E1"+
		"\x11E4\a\x1F6\x2\x2\x11E2\x11E3\a\x1EE\x2\x2\x11E3\x11E5\x5\x2E4\x173"+
		"\x2\x11E4\x11E2\x3\x2\x2\x2\x11E4\x11E5\x3\x2\x2\x2\x11E5\x1249\x3\x2"+
		"\x2\x2\x11E6\x11E7\a\x1BE\x2\x2\x11E7\x11EC\a\x1F5\x2\x2\x11E8\x11E9\a"+
		"\xE7\x2\x2\x11E9\x11ED\x5\x2F0\x179\x2\x11EA\x11EB\a\x81\x2\x2\x11EB\x11ED"+
		"\x5\x20E\x108\x2\x11EC\x11E8\x3\x2\x2\x2\x11EC\x11EA\x3\x2\x2\x2\x11ED"+
		"\x11F0\x3\x2\x2\x2\x11EE\x11EF\a\x1FB\x2\x2\x11EF\x11F1\x5\x20E\x108\x2"+
		"\x11F0\x11EE\x3\x2\x2\x2\x11F0\x11F1\x3\x2\x2\x2\x11F1\x11F2\x3\x2\x2"+
		"\x2\x11F2\x11F5\a\x1F6\x2\x2\x11F3\x11F4\a\x1EE\x2\x2\x11F4\x11F6\x5\x2E4"+
		"\x173\x2\x11F5\x11F3\x3\x2\x2\x2\x11F5\x11F6\x3\x2\x2\x2\x11F6\x1249\x3"+
		"\x2\x2\x2\x11F7\x11F8\a\x1BF\x2\x2\x11F8\x11F9\a\x1F5\x2\x2\x11F9\x11FB"+
		"\x5\x20E\x108\x2\x11FA\x11FC\x5\x25C\x12F\x2\x11FB\x11FA\x3\x2\x2\x2\x11FB"+
		"\x11FC\x3\x2\x2\x2\x11FC\x11FD\x3\x2\x2\x2\x11FD\x11FE\a\x140\x2\x2\x11FE"+
		"\x1202\aH\x2\x2\x11FF\x1200\a\xFE\x2\x2\x1200\x1201\a\x108\x2\x2\x1201"+
		"\x1203\ay\x2\x2\x1202\x11FF\x3\x2\x2\x2\x1202\x1203\x3\x2\x2\x2\x1203"+
		"\x1204\x3\x2\x2\x2\x1204\x1207\a\x1F6\x2\x2\x1205\x1206\a\x1EE\x2\x2\x1206"+
		"\x1208\x5\x2E4\x173\x2\x1207\x1205\x3\x2\x2\x2\x1207\x1208\x3\x2\x2\x2"+
		"\x1208\x1249\x3\x2\x2\x2\x1209\x120A\a\x1C0\x2\x2\x120A\x120B\a\x1F5\x2"+
		"\x2\x120B\x120E\x5\x20E\x108\x2\x120C\x120D\a\x1FB\x2\x2\x120D\x120F\x5"+
		"\x268\x135\x2\x120E\x120C\x3\x2\x2\x2\x120E\x120F\x3\x2\x2\x2\x120F\x1212"+
		"\x3\x2\x2\x2\x1210\x1211\a\x1FB\x2\x2\x1211\x1213\x5\x26A\x136\x2\x1212"+
		"\x1210\x3\x2\x2\x2\x1212\x1213\x3\x2\x2\x2\x1213\x1214\x3\x2\x2\x2\x1214"+
		"\x1217\a\x1F6\x2\x2\x1215\x1216\a\x1EE\x2\x2\x1216\x1218\x5\x2E4\x173"+
		"\x2\x1217\x1215\x3\x2\x2\x2\x1217\x1218\x3\x2\x2\x2\x1218\x1249\x3\x2"+
		"\x2\x2\x1219\x121A\a\x1C1\x2\x2\x121A\x121B\a\x1F5\x2\x2\x121B\x121C\t"+
		">\x2\x2\x121C\x121F\x5\x20E\x108\x2\x121D\x121E\a\xF\x2\x2\x121E\x1220"+
		"\x5\x2D8\x16D\x2\x121F\x121D\x3\x2\x2\x2\x121F\x1220\x3\x2\x2\x2\x1220"+
		"\x1222\x3\x2\x2\x2\x1221\x1223\x5\x26C\x137\x2\x1222\x1221\x3\x2\x2\x2"+
		"\x1222\x1223\x3\x2\x2\x2\x1223\x1225\x3\x2\x2\x2\x1224\x1226\x5\x26E\x138"+
		"\x2\x1225\x1224\x3\x2\x2\x2\x1225\x1226\x3\x2\x2\x2\x1226\x1228\x3\x2"+
		"\x2\x2\x1227\x1229\x5\x270\x139\x2\x1228\x1227\x3\x2\x2\x2\x1228\x1229"+
		"\x3\x2\x2\x2\x1229\x122C\x3\x2\x2\x2\x122A\x122B\t?\x2\x2\x122B\x122D"+
		"\a\x66\x2\x2\x122C\x122A\x3\x2\x2\x2\x122C\x122D\x3\x2\x2\x2\x122D\x122E"+
		"\x3\x2\x2\x2\x122E\x1231\a\x1F6\x2\x2\x122F\x1230\a\x1EE\x2\x2\x1230\x1232"+
		"\x5\x2E4\x173\x2\x1231\x122F\x3\x2\x2\x2\x1231\x1232\x3\x2\x2\x2\x1232"+
		"\x1249\x3\x2\x2\x2\x1233\x1234\a\x1C2\x2\x2\x1234\x1236\a\x1F5\x2\x2\x1235"+
		"\x1237\x5\x260\x131\x2\x1236\x1235\x3\x2\x2\x2\x1236\x1237\x3\x2\x2\x2"+
		"\x1237\x1238\x3\x2\x2\x2\x1238\x123A\x5\x20E\x108\x2\x1239\x123B\x5\x25C"+
		"\x12F\x2\x123A\x1239\x3\x2\x2\x2\x123A\x123B\x3\x2\x2\x2\x123B\x1241\x3"+
		"\x2\x2\x2\x123C\x123D\a;\x2\x2\x123D\x123E\x5\x262\x132\x2\x123E\x123F"+
		"\a\x1FB\x2\x2\x123F\x1240\x5\x262\x132\x2\x1240\x1242\x3\x2\x2\x2\x1241"+
		"\x123C\x3\x2\x2\x2\x1241\x1242\x3\x2\x2\x2\x1242\x1243\x3\x2\x2\x2\x1243"+
		"\x1246\a\x1F6\x2\x2\x1244\x1245\a\x1EE\x2\x2\x1245\x1247\x5\x2E4\x173"+
		"\x2\x1246\x1244\x3\x2\x2\x2\x1246\x1247\x3\x2\x2\x2\x1247\x1249\x3\x2"+
		"\x2\x2\x1248\x1106\x3\x2\x2\x2\x1248\x110B\x3\x2\x2\x2\x1248\x1110\x3"+
		"\x2\x2\x2\x1248\x111D\x3\x2\x2\x2\x1248\x112B\x3\x2\x2\x2\x1248\x1137"+
		"\x3\x2\x2\x2\x1248\x1142\x3\x2\x2\x2\x1248\x1149\x3\x2\x2\x2\x1248\x114C"+
		"\x3\x2\x2\x2\x1248\x1154\x3\x2\x2\x2\x1248\x115B\x3\x2\x2\x2\x1248\x1162"+
		"\x3\x2\x2\x2\x1248\x1174\x3\x2\x2\x2\x1248\x1184\x3\x2\x2\x2\x1248\x118E"+
		"\x3\x2\x2\x2\x1248\x119C\x3\x2\x2\x2\x1248\x11A7\x3\x2\x2\x2\x1248\x11B6"+
		"\x3\x2\x2\x2\x1248\x11D2\x3\x2\x2\x2\x1248\x11DA\x3\x2\x2\x2\x1248\x11E6"+
		"\x3\x2\x2\x2\x1248\x11F7\x3\x2\x2\x2\x1248\x1209\x3\x2\x2\x2\x1248\x1219"+
		"\x3\x2\x2\x2\x1248\x1233\x3\x2\x2\x2\x1249\x243\x3\x2\x2\x2\x124A\x124B"+
		"\t@\x2\x2\x124B\x245\x3\x2\x2\x2\x124C\x124D\t\x41\x2\x2\x124D\x247\x3"+
		"\x2\x2\x2\x124E\x124F\t\x42\x2\x2\x124F\x249\x3\x2\x2\x2\x1250\x1251\a"+
		"\x113\x2\x2\x1251\x1253\a\x1F5\x2\x2\x1252\x1254\x5\x15C\xAF\x2\x1253"+
		"\x1252\x3\x2\x2\x2\x1253\x1254\x3\x2\x2\x2\x1254\x1259\x3\x2\x2\x2\x1255"+
		"\x1257\x5\x1A0\xD1\x2\x1256\x1258\x5\x24C\x127\x2\x1257\x1256\x3\x2\x2"+
		"\x2\x1257\x1258\x3\x2\x2\x2\x1258\x125A\x3\x2\x2\x2\x1259\x1255\x3\x2"+
		"\x2\x2\x1259\x125A\x3\x2\x2\x2\x125A\x125B\x3\x2\x2\x2\x125B\x125C\a\x1F6"+
		"\x2\x2\x125C\x24B\x3\x2\x2\x2\x125D\x1264\x5\x24E\x128\x2\x125E\x125F"+
		"\a\x1C\x2\x2\x125F\x1260\x5\x250\x129\x2\x1260\x1261\a\f\x2\x2\x1261\x1262"+
		"\x5\x250\x129\x2\x1262\x1265\x3\x2\x2\x2\x1263\x1265\x5\x250\x129\x2\x1264"+
		"\x125E\x3\x2\x2\x2\x1264\x1263\x3\x2\x2\x2\x1265\x24D\x3\x2\x2\x2\x1266"+
		"\x1267\t\x43\x2\x2\x1267\x24F\x3\x2\x2\x2\x1268\x1269\a\x192\x2\x2\x1269"+
		"\x1270\a\x129\x2\x2\x126A\x126B\aS\x2\x2\x126B\x1270\a\x147\x2\x2\x126C"+
		"\x126D\x5\x20E\x108\x2\x126D\x126E\t\x44\x2\x2\x126E\x1270\x3\x2\x2\x2"+
		"\x126F\x1268\x3\x2\x2\x2\x126F\x126A\x3\x2\x2\x2\x126F\x126C\x3\x2\x2"+
		"\x2\x1270\x251\x3\x2\x2\x2\x1271\x127B\a\x19E\x2\x2\x1272\x127C\a\x1F8"+
		"\x2\x2\x1273\x1278\x5\x254\x12B\x2\x1274\x1275\a\x1FB\x2\x2\x1275\x1277"+
		"\x5\x254\x12B\x2\x1276\x1274\x3\x2\x2\x2\x1277\x127A\x3\x2\x2\x2\x1278"+
		"\x1276\x3\x2\x2\x2\x1278\x1279\x3\x2\x2\x2\x1279\x127C\x3\x2\x2\x2\x127A"+
		"\x1278\x3\x2\x2\x2\x127B\x1272\x3\x2\x2\x2\x127B\x1273\x3\x2\x2\x2\x127C"+
		"\x253\x3\x2\x2\x2\x127D\x127F\a\xA7\x2\x2\x127E\x1280\a\x111\x2\x2\x127F"+
		"\x127E\x3\x2\x2\x2\x127F\x1280\x3\x2\x2\x2\x1280\x1283\x3\x2\x2\x2\x1281"+
		"\x1283\a\x111\x2\x2\x1282\x127D\x3\x2\x2\x2\x1282\x1281\x3\x2\x2\x2\x1282"+
		"\x1283\x3\x2\x2\x2\x1283\x1284\x3\x2\x2\x2\x1284\x1286\x5\x14A\xA6\x2"+
		"\x1285\x1287\x5\x280\x141\x2\x1286\x1285\x3\x2\x2\x2\x1286\x1287\x3\x2"+
		"\x2\x2\x1287\x255\x3\x2\x2\x2\x1288\x1289\a\x10E\x2\x2\x1289\x128A\a("+
		"\x2\x2\x128A\x128B\x5\x20E\x108\x2\x128B\x257\x3\x2\x2\x2\x128C\x128D"+
		"\a\x1B1\x2\x2\x128D\x128E\a\x9E\x2\x2\x128E\x128F\a\x1F5\x2\x2\x128F\x1290"+
		"\x5\x1A0\xD1\x2\x1290\x1291\a\x1F6\x2\x2\x1291\x1294\x3\x2\x2\x2\x1292"+
		"\x1294\x5\x24A\x126\x2\x1293\x128C\x3\x2\x2\x2\x1293\x1292\x3\x2\x2\x2"+
		"\x1294\x259\x3\x2\x2\x2\x1295\x12A7\aN\x2\x2\x1296\x1298\a\xE3\x2\x2\x1297"+
		"\x1299\a\x16\x2\x2\x1298\x1297\x3\x2\x2\x2\x1298\x1299\x3\x2\x2\x2\x1299"+
		"\x12A8\x3\x2\x2\x2\x129A\x129B\a\x1F5\x2\x2\x129B\x12A0\x5\x28E\x148\x2"+
		"\x129C\x129D\a\x1FB\x2\x2\x129D\x129F\x5\x28E\x148\x2\x129E\x129C\x3\x2"+
		"\x2\x2\x129F\x12A2\x3\x2\x2\x2\x12A0\x129E\x3\x2\x2\x2\x12A0\x12A1\x3"+
		"\x2\x2\x2\x12A1\x12A3\x3\x2\x2\x2\x12A2\x12A0\x3\x2\x2\x2\x12A3\x12A4"+
		"\a\x1F6\x2\x2\x12A4\x12A5\a\x1A1\x2\x2\x12A5\x12A6\x5\x1EE\xF8\x2\x12A6"+
		"\x12A8\x3\x2\x2\x2\x12A7\x1296\x3\x2\x2\x2\x12A7\x129A\x3\x2\x2\x2\x12A8"+
		"\x25B\x3\x2\x2\x2\x12A9\x12AC\a\x11A\x2\x2\x12AA\x12AB\a(\x2\x2\x12AB"+
		"\x12AD\a\x1A0\x2\x2\x12AC\x12AA\x3\x2\x2\x2\x12AC\x12AD\x3\x2\x2\x2\x12AD"+
		"\x12AE\x3\x2\x2\x2\x12AE\x12B0\x5\x1F2\xFA\x2\x12AF\x12B1\x5\x280\x141"+
		"\x2\x12B0\x12AF\x3\x2\x2\x2\x12B0\x12B1\x3\x2\x2\x2\x12B1\x12B2\x3\x2"+
		"\x2\x2\x12B2\x12B3\a\x1FB\x2\x2\x12B3\x12B5\x5\x1F2\xFA\x2\x12B4\x12B6"+
		"\x5\x280\x141\x2\x12B5\x12B4\x3\x2\x2\x2\x12B5\x12B6\x3\x2\x2\x2\x12B6"+
		"\x25D\x3\x2\x2\x2\x12B7\x12B8\a\x1B6\x2\x2\x12B8\x12BA\a\x1F5\x2\x2\x12B9"+
		"\x12BB\t<\x2\x2\x12BA\x12B9\x3\x2\x2\x2\x12BA\x12BB\x3\x2\x2\x2\x12BB"+
		"\x12BD\x3\x2\x2\x2\x12BC\x12BE\t\x45\x2\x2\x12BD\x12BC\x3\x2\x2\x2\x12BD"+
		"\x12BE\x3\x2\x2\x2\x12BE\x12BF\x3\x2\x2\x2\x12BF\x12C4\x5\x266\x134\x2"+
		"\x12C0\x12C1\a\x1FB\x2\x2\x12C1\x12C3\x5\x266\x134\x2\x12C2\x12C0\x3\x2"+
		"\x2\x2\x12C3\x12C6\x3\x2\x2\x2\x12C4\x12C2\x3\x2\x2\x2\x12C4\x12C5\x3"+
		"\x2\x2\x2\x12C5\x12C7\x3\x2\x2\x2\x12C6\x12C4\x3\x2\x2\x2\x12C7\x12C8"+
		"\a\x1F6\x2\x2\x12C8\x25F\x3\x2\x2\x2\x12C9\x12CA\a\x1BC\x2\x2\x12CA\x12CE"+
		"\a\x1F5\x2\x2\x12CB\x12CC\x5\x20E\x108\x2\x12CC\x12CD\x5\x280\x141\x2"+
		"\x12CD\x12CF\x3\x2\x2\x2\x12CE\x12CB\x3\x2\x2\x2\x12CE\x12CF\x3\x2\x2"+
		"\x2\x12CF\x12D6\x3\x2\x2\x2\x12D0\x12D1\a\x1FB\x2\x2\x12D1\x12D2\x5\x20E"+
		"\x108\x2\x12D2\x12D3\x5\x280\x141\x2\x12D3\x12D5\x3\x2\x2\x2\x12D4\x12D0"+
		"\x3\x2\x2\x2\x12D5\x12D8\x3\x2\x2\x2\x12D6\x12D4\x3\x2\x2\x2\x12D6\x12D7"+
		"\x3\x2\x2\x2\x12D7\x12DA\x3\x2\x2\x2\x12D8\x12D6\x3\x2\x2\x2\x12D9\x12DB"+
		"\x5\x264\x133\x2\x12DA\x12D9\x3\x2\x2\x2\x12DA\x12DB\x3\x2\x2\x2\x12DB"+
		"\x12DC\x3\x2\x2\x2\x12DC\x12DD\a\x1F6\x2\x2\x12DD\x261\x3\x2\x2\x2\x12DE"+
		"\x12E9\x5\x28C\x147\x2\x12DF\x12E0\a\x96\x2\x2\x12E0\x12EA\a\x10F\x2\x2"+
		"\x12E1\x12E4\x5\x2D8\x16D\x2\x12E2\x12E3\a\x11B\x2\x2\x12E3\x12E5\x5\x20E"+
		"\x108\x2\x12E4\x12E2\x3\x2\x2\x2\x12E4\x12E5\x3\x2\x2\x2\x12E5\x12E7\x3"+
		"\x2\x2\x2\x12E6\x12E8\x5\x264\x133\x2\x12E7\x12E6\x3\x2\x2\x2\x12E7\x12E8"+
		"\x3\x2\x2\x2\x12E8\x12EA\x3\x2\x2\x2\x12E9\x12DF\x3\x2\x2\x2\x12E9\x12E1"+
		"\x3\x2\x2\x2\x12EA\x263\x3\x2\x2\x2\x12EB\x12EC\a\x65\x2\x2\x12EC\x12ED"+
		"\x5\x20E\x108\x2\x12ED\x265\x3\x2\x2\x2\x12EE\x12F5\x5\x1F2\xFA\x2\x12EF"+
		"\x12F3\a\xF\x2\x2\x12F0\x12F4\x5\x2F2\x17A\x2\x12F1\x12F2\a\x81\x2\x2"+
		"\x12F2\x12F4\x5\x20E\x108\x2\x12F3\x12F0\x3\x2\x2\x2\x12F3\x12F1\x3\x2"+
		"\x2\x2\x12F4\x12F6\x3\x2\x2\x2\x12F5\x12EF\x3\x2\x2\x2\x12F5\x12F6\x3"+
		"\x2\x2\x2\x12F6\x267\x3\x2\x2\x2\x12F7\x12FB\a\x1A7\x2\x2\x12F8\x12F9"+
		"\a\xF1\x2\x2\x12F9\x12FC\a\x1A0\x2\x2\x12FA\x12FC\x5\x1F2\xFA\x2\x12FB"+
		"\x12F8\x3\x2\x2\x2\x12FB\x12FA\x3\x2\x2\x2\x12FC\x269\x3\x2\x2\x2\x12FD"+
		"\x1303\a\x16F\x2\x2\x12FE\x1304\a\x1C4\x2\x2\x12FF\x1301\a\xF1\x2\x2\x1300"+
		"\x1302\a\x1A0\x2\x2\x1301\x1300\x3\x2\x2\x2\x1301\x1302\x3\x2\x2\x2\x1302"+
		"\x1304\x3\x2\x2\x2\x1303\x12FE\x3\x2\x2\x2\x1303\x12FF\x3\x2\x2\x2\x1304"+
		"\x26B\x3\x2\x2\x2\x1305\x1306\a{\x2\x2\x1306\x1307\x5\x20E\x108\x2\x1307"+
		"\x26D\x3\x2\x2\x2\x1308\x1309\a\x1A7\x2\x2\x1309\x130A\x5\x20E\x108\x2"+
		"\x130A\x26F\x3\x2\x2\x2\x130B\x130C\a\xF1\x2\x2\x130C\x1314\a\xAB\x2\x2"+
		"\x130D\x1311\a\xAB\x2\x2\x130E\x130F\a\x167\x2\x2\x130F\x1310\a\x20C\x2"+
		"\x2\x1310\x1312\x5\x20E\x108\x2\x1311\x130E\x3\x2\x2\x2\x1311\x1312\x3"+
		"\x2\x2\x2\x1312\x1314\x3\x2\x2\x2\x1313\x130B\x3\x2\x2\x2\x1313\x130D"+
		"\x3\x2\x2\x2\x1314\x271\x3\x2\x2\x2\x1315\x131C\a\x1FC\x2\x2\x1316\x131C"+
		"\x5\x274\x13B\x2\x1317\x131C\x5\x278\x13D\x2\x1318\x131C\x5\x27A\x13E"+
		"\x2\x1319\x131C\x5\x276\x13C\x2\x131A\x131C\x5\x27C\x13F\x2\x131B\x1315"+
		"\x3\x2\x2\x2\x131B\x1316\x3\x2\x2\x2\x131B\x1317\x3\x2\x2\x2\x131B\x1318"+
		"\x3\x2\x2\x2\x131B\x1319\x3\x2\x2\x2\x131B\x131A\x3\x2\x2\x2\x131C\x131E"+
		"\x3\x2\x2\x2\x131D\x131F\a\x201\x2\x2\x131E\x131D\x3\x2\x2\x2\x131E\x131F"+
		"\x3\x2\x2\x2\x131F\x273\x3\x2\x2\x2\x1320\x1321\a\x1AD\x2\x2\x1321\x1327"+
		"\t\x46\x2\x2\x1322\x1323\a\x89\x2\x2\x1323\x1324\tG\x2\x2\x1324\x1328"+
		"\tH\x2\x2\x1325\x1326\aJ\x2\x2\x1326\x1328\tI\x2\x2\x1327\x1322\x3\x2"+
		"\x2\x2\x1327\x1325\x3\x2\x2\x2\x1328\x275\x3\x2\x2\x2\x1329\x132A\a\x15D"+
		"\x2\x2\x132A\x1330\x5\x2FE\x180\x2\x132B\x1331\a\x1F1\x2\x2\x132C\x1331"+
		"\a\x108\x2\x2\x132D\x1331\a\x105\x2\x2\x132E\x1331\x5\x2EA\x176\x2\x132F"+
		"\x1331\x5\x2FE\x180\x2\x1330\x132B\x3\x2\x2\x2\x1330\x132C\x3\x2\x2\x2"+
		"\x1330\x132D\x3\x2\x2\x2\x1330\x132E\x3\x2\x2\x2\x1330\x132F\x3\x2\x2"+
		"\x2\x1331\x277\x3\x2\x2\x2\x1332\x1333\a\x89\x2\x2\x1333\x279\x3\x2\x2"+
		"\x2\x1334\x1335\a\x213\x2\x2\x1335\x27B\x3\x2\x2\x2\x1336\x1337\a\x161"+
		"\x2\x2\x1337\x133B\a~\x2\x2\x1338\x1339\a\x161\x2\x2\x1339\x133B\a\x7F"+
		"\x2\x2\x133A\x1336\x3\x2\x2\x2\x133A\x1338\x3\x2\x2\x2\x133B\x27D\x3\x2"+
		"\x2\x2\x133C\x133E\tJ\x2\x2\x133D\x133F\a\x96\x2\x2\x133E\x133D\x3\x2"+
		"\x2\x2\x133E\x133F\x3\x2\x2\x2\x133F\x1340\x3\x2\x2\x2\x1340\x1341\x5"+
		"\x1EE\xF8\x2\x1341\x27F\x3\x2\x2\x2\x1342\x1344\a\xF\x2\x2\x1343\x1342"+
		"\x3\x2\x2\x2\x1343\x1344\x3\x2\x2\x2\x1344\x1347\x3\x2\x2\x2\x1345\x1348"+
		"\x5\x2F0\x179\x2\x1346\x1348\x5\x284\x143\x2\x1347\x1345\x3\x2\x2\x2\x1347"+
		"\x1346\x3\x2\x2\x2\x1348\x134B\x3\x2\x2\x2\x1349\x134B\a\xF\x2\x2\x134A"+
		"\x1343\x3\x2\x2\x2\x134A\x1349\x3\x2\x2\x2\x134B\x281\x3\x2\x2\x2\x134C"+
		"\x134F\x5\x2F0\x179\x2\x134D\x134F\x5\x284\x143\x2\x134E\x134C\x3\x2\x2"+
		"\x2\x134E\x134D\x3\x2\x2\x2\x134F\x283\x3\x2\x2\x2\x1350\x1351\x5\x2EE"+
		"\x178\x2\x1351\x285\x3\x2\x2\x2\x1352\x1355\a\x1AE\x2\x2\x1353\x1356\x5"+
		"\x288\x145\x2\x1354\x1356\x5\x1F2\xFA\x2\x1355\x1353\x3\x2\x2\x2\x1355"+
		"\x1354\x3\x2\x2\x2\x1356\x287\x3\x2\x2\x2\x1357\x1358\aS\x2\x2\x1358\x1359"+
		"\a\x104\x2\x2\x1359\x135A\x5\x2BE\x160\x2\x135A\x289\x3\x2\x2\x2\x135B"+
		"\x135C\a\xBB\x2\x2\x135C\x1361\x5\x2BA\x15E\x2\x135D\x135E\a\x1FB\x2\x2"+
		"\x135E\x1360\x5\x2BA\x15E\x2\x135F\x135D\x3\x2\x2\x2\x1360\x1363\x3\x2"+
		"\x2\x2\x1361\x135F\x3\x2\x2\x2\x1361\x1362\x3\x2\x2\x2\x1362\x1370\x3"+
		"\x2\x2\x2\x1363\x1361\x3\x2\x2\x2\x1364\x1365\a\'\x2\x2\x1365\x1366\a"+
		":\x2\x2\x1366\x1367\a\xBB\x2\x2\x1367\x136C\x5\x2BA\x15E\x2\x1368\x1369"+
		"\a\x1FB\x2\x2\x1369\x136B\x5\x2BA\x15E\x2\x136A\x1368\x3\x2\x2\x2\x136B"+
		"\x136E\x3\x2\x2\x2\x136C\x136A\x3\x2\x2\x2\x136C\x136D\x3\x2\x2\x2\x136D"+
		"\x1370\x3\x2\x2\x2\x136E\x136C\x3\x2\x2\x2\x136F\x135B\x3\x2\x2\x2\x136F"+
		"\x1364\x3\x2\x2\x2\x1370\x28B\x3\x2\x2\x2\x1371\x1374\x5\x2F0\x179\x2"+
		"\x1372\x1374\x5\x2EE\x178\x2\x1373\x1371\x3\x2\x2\x2\x1373\x1372\x3\x2"+
		"\x2\x2\x1374\x28D\x3\x2\x2\x2\x1375\x1376\x5\x2F0\x179\x2\x1376\x28F\x3"+
		"\x2\x2\x2\x1377\x1378\x5\x2F0\x179\x2\x1378\x291\x3\x2\x2\x2\x1379\x137A"+
		"\x5\x2F0\x179\x2\x137A\x293\x3\x2\x2\x2\x137B\x137C\x5\x2F0\x179\x2\x137C"+
		"\x295\x3\x2\x2\x2\x137D\x137E\x5\x2F0\x179\x2\x137E\x297\x3\x2\x2\x2\x137F"+
		"\x1380\x5\x2F0\x179\x2\x1380\x299\x3\x2\x2\x2\x1381\x1386\x5\x2F0\x179"+
		"\x2\x1382\x1383\a\x1EE\x2\x2\x1383\x1385\x5\x2F2\x17A\x2\x1384\x1382\x3"+
		"\x2\x2\x2\x1385\x1388\x3\x2\x2\x2\x1386\x1384\x3\x2\x2\x2\x1386\x1387"+
		"\x3\x2\x2\x2\x1387\x138B\x3\x2\x2\x2\x1388\x1386\x3\x2\x2\x2\x1389\x138A"+
		"\a\x1FD\x2\x2\x138A\x138C\x5\x2C4\x163\x2\x138B\x1389\x3\x2\x2\x2\x138B"+
		"\x138C\x3\x2\x2\x2\x138C\x29B\x3\x2\x2\x2\x138D\x138E\x5\x2F0\x179\x2"+
		"\x138E\x29D\x3\x2\x2\x2\x138F\x1392\x5\x2F0\x179\x2\x1390\x1391\a\x1EE"+
		"\x2\x2\x1391\x1393\x5\x2F2\x17A\x2\x1392\x1390\x3\x2\x2\x2\x1392\x1393"+
		"\x3\x2\x2\x2\x1393\x29F\x3\x2\x2\x2\x1394\x1395\x5\x2F0\x179\x2\x1395"+
		"\x2A1\x3\x2\x2\x2\x1396\x1397\x5\x2F0\x179\x2\x1397\x2A3\x3\x2\x2\x2\x1398"+
		"\x1399\x5\x2F0\x179\x2\x1399\x2A5\x3\x2\x2\x2\x139A\x139F\x5\x2F0\x179"+
		"\x2\x139B\x139C\a\x1EE\x2\x2\x139C\x139E\x5\x2F2\x17A\x2\x139D\x139B\x3"+
		"\x2\x2\x2\x139E\x13A1\x3\x2\x2\x2\x139F\x139D\x3\x2\x2\x2\x139F\x13A0"+
		"\x3\x2\x2\x2\x13A0\x2A7\x3\x2\x2\x2\x13A1\x139F\x3\x2\x2\x2\x13A2\x13A3"+
		"\x5\x2F0\x179\x2\x13A3\x2A9\x3\x2\x2\x2\x13A4\x13A9\x5\x2F0\x179\x2\x13A5"+
		"\x13A6\a\x1EE\x2\x2\x13A6\x13A8\x5\x2F2\x17A\x2\x13A7\x13A5\x3\x2\x2\x2"+
		"\x13A8\x13AB\x3\x2\x2\x2\x13A9\x13A7\x3\x2\x2\x2\x13A9\x13AA\x3\x2\x2"+
		"\x2\x13AA\x13AE\x3\x2\x2\x2\x13AB\x13A9\x3\x2\x2\x2\x13AC\x13AD\a\x1FD"+
		"\x2\x2\x13AD\x13AF\x5\x2C4\x163\x2\x13AE\x13AC\x3\x2\x2\x2\x13AE\x13AF"+
		"\x3\x2\x2\x2\x13AF\x2AB\x3\x2\x2\x2\x13B0\x13B1\x5\x2F2\x17A\x2\x13B1"+
		"\x2AD\x3\x2\x2\x2\x13B2\x13B7\x5\x2F2\x17A\x2\x13B3\x13B4\a\x1EE\x2\x2"+
		"\x13B4\x13B6\x5\x2F2\x17A\x2\x13B5\x13B3\x3\x2\x2\x2\x13B6\x13B9\x3\x2"+
		"\x2\x2\x13B7\x13B5\x3\x2\x2\x2\x13B7\x13B8\x3\x2\x2\x2\x13B8\x2AF\x3\x2"+
		"\x2\x2\x13B9\x13B7\x3\x2\x2\x2\x13BA\x13BF\x5\x2F2\x17A\x2\x13BB\x13BC"+
		"\a\x1EE\x2\x2\x13BC\x13BE\x5\x2F2\x17A\x2\x13BD\x13BB\x3\x2\x2\x2\x13BE"+
		"\x13C1\x3\x2\x2\x2\x13BF\x13BD\x3\x2\x2\x2\x13BF\x13C0\x3\x2\x2\x2\x13C0"+
		"\x2B1\x3\x2\x2\x2\x13C1\x13BF\x3\x2\x2\x2\x13C2\x13C7\x5\x2F0\x179\x2"+
		"\x13C3\x13C4\a\x1EE\x2\x2\x13C4\x13C6\x5\x2F2\x17A\x2\x13C5\x13C3\x3\x2"+
		"\x2\x2\x13C6\x13C9\x3\x2\x2\x2\x13C7\x13C5\x3\x2\x2\x2\x13C7\x13C8\x3"+
		"\x2\x2\x2\x13C8\x2B3\x3\x2\x2\x2\x13C9\x13C7\x3\x2\x2\x2\x13CA\x13CD\x5"+
		"\x2F0\x179\x2\x13CB\x13CC\a\x1EE\x2\x2\x13CC\x13CE\x5\x2F2\x17A\x2\x13CD"+
		"\x13CB\x3\x2\x2\x2\x13CD\x13CE\x3\x2\x2\x2\x13CE\x2B5\x3\x2\x2\x2\x13CF"+
		"\x13D2\x5\x2F0\x179\x2\x13D0\x13D1\a\x1EE\x2\x2\x13D1\x13D3\x5\x2F2\x17A"+
		"\x2\x13D2\x13D0\x3\x2\x2\x2\x13D2\x13D3\x3\x2\x2\x2\x13D3\x2B7\x3\x2\x2"+
		"\x2\x13D4\x13D7\x5\x2F0\x179\x2\x13D5\x13D6\a\x1EE\x2\x2\x13D6\x13D8\x5"+
		"\x2F2\x17A\x2\x13D7\x13D5\x3\x2\x2\x2\x13D7\x13D8\x3\x2\x2\x2\x13D8\x2B9"+
		"\x3\x2\x2\x2\x13D9\x13DA\a\x20F\x2\x2\x13DA\x13DC\x5\x2CA\x166\x2\x13DB"+
		"\x13D9\x3\x2\x2\x2\x13DB\x13DC\x3\x2\x2\x2\x13DC\x13DD\x3\x2\x2\x2\x13DD"+
		"\x13E0\x5\x2F2\x17A\x2\x13DE\x13DF\a\x1EE\x2\x2\x13DF\x13E1\x5\x2F2\x17A"+
		"\x2\x13E0\x13DE\x3\x2\x2\x2\x13E0\x13E1\x3\x2\x2\x2\x13E1\x13E4\x3\x2"+
		"\x2\x2\x13E2\x13E4\x5\x2E0\x171\x2\x13E3\x13DB\x3\x2\x2\x2\x13E3\x13E2"+
		"\x3\x2\x2\x2\x13E4\x2BB\x3\x2\x2\x2\x13E5\x13E6\x5\x2F0\x179\x2\x13E6"+
		"\x2BD\x3\x2\x2\x2\x13E7\x13EA\x5\x2F0\x179\x2\x13E8\x13EA\x5\x2E0\x171"+
		"\x2\x13E9\x13E7\x3\x2\x2\x2\x13E9\x13E8\x3\x2\x2\x2\x13EA\x2BF\x3\x2\x2"+
		"\x2\x13EB\x13EE\x5\x2F0\x179\x2\x13EC\x13EE\x5\x2E0\x171\x2\x13ED\x13EB"+
		"\x3\x2\x2\x2\x13ED\x13EC\x3\x2\x2\x2\x13EE\x2C1\x3\x2\x2\x2\x13EF\x13F2"+
		"\x5\x2F0\x179\x2\x13F0\x13F1\a\x1EE\x2\x2\x13F1\x13F3\x5\x2F2\x17A\x2"+
		"\x13F2\x13F0\x3\x2\x2\x2\x13F2\x13F3\x3\x2\x2\x2\x13F3\x2C3\x3\x2\x2\x2"+
		"\x13F4\x13F5\x5\x2F0\x179\x2\x13F5\x2C5\x3\x2\x2\x2\x13F6\x13FB\x5\x2F0"+
		"\x179\x2\x13F7\x13F8\a\x1EE\x2\x2\x13F8\x13FA\x5\x2F2\x17A\x2\x13F9\x13F7"+
		"\x3\x2\x2\x2\x13FA\x13FD\x3\x2\x2\x2\x13FB\x13F9\x3\x2\x2\x2\x13FB\x13FC"+
		"\x3\x2\x2\x2\x13FC\x2C7\x3\x2\x2\x2\x13FD\x13FB\x3\x2\x2\x2\x13FE\x1401"+
		"\x5\x2F0\x179\x2\x13FF\x1400\a\x1EE\x2\x2\x1400\x1402\x5\x2F2\x17A\x2"+
		"\x1401\x13FF\x3\x2\x2\x2\x1401\x1402\x3\x2\x2\x2\x1402\x1406\x3\x2\x2"+
		"\x2\x1403\x1404\a\x1FD\x2\x2\x1404\x1407\x5\x2C4\x163\x2\x1405\x1407\x5"+
		"\x27E\x140\x2\x1406\x1403\x3\x2\x2\x2\x1406\x1405\x3\x2\x2\x2\x1406\x1407"+
		"\x3\x2\x2\x2\x1407\x2C9\x3\x2\x2\x2\x1408\x140D\x5\x2F2\x17A\x2\x1409"+
		"\x140A\a\x1EE\x2\x2\x140A\x140C\x5\x2F2\x17A\x2\x140B\x1409\x3\x2\x2\x2"+
		"\x140C\x140F\x3\x2\x2\x2\x140D\x140B\x3\x2\x2\x2\x140D\x140E\x3\x2\x2"+
		"\x2\x140E\x2CB\x3\x2\x2\x2\x140F\x140D\x3\x2\x2\x2\x1410\x1411\a\xC2\x2"+
		"\x2\x1411\x1412\a\x1F5\x2\x2\x1412\x1413\a\x1CE\x2\x2\x1413\x1414\t*\x2"+
		"\x2\x1414\x1415\x5\x1A0\xD1\x2\x1415\x1417\a\x1F6\x2\x2\x1416\x1418\x5"+
		"\x24A\x126\x2\x1417\x1416\x3\x2\x2\x2\x1417\x1418\x3\x2\x2\x2\x1418\x2CD"+
		"\x3\x2\x2\x2\x1419\x141B\a\x1F5\x2\x2\x141A\x141C\x5\x2D6\x16C\x2\x141B"+
		"\x141A\x3\x2\x2\x2\x141B\x141C\x3\x2\x2\x2\x141C\x1421\x3\x2\x2\x2\x141D"+
		"\x141E\a\x1FB\x2\x2\x141E\x1420\x5\x2D6\x16C\x2\x141F\x141D\x3\x2\x2\x2"+
		"\x1420\x1423\x3\x2\x2\x2\x1421\x141F\x3\x2\x2\x2\x1421\x1422\x3\x2\x2"+
		"\x2\x1422\x1424\x3\x2\x2\x2\x1423\x1421\x3\x2\x2\x2\x1424\x1426\a\x1F6"+
		"\x2\x2\x1425\x1427\x5\x2CC\x167\x2\x1426\x1425\x3\x2\x2\x2\x1426\x1427"+
		"\x3\x2\x2\x2\x1427\x2CF\x3\x2\x2\x2\x1428\x142D\a\x1F5\x2\x2\x1429\x142B"+
		"\x5\x2D6\x16C\x2\x142A\x142C\x5\x2D4\x16B\x2\x142B\x142A\x3\x2\x2\x2\x142B"+
		"\x142C\x3\x2\x2\x2\x142C\x142E\x3\x2\x2\x2\x142D\x1429\x3\x2\x2\x2\x142D"+
		"\x142E\x3\x2\x2\x2\x142E\x1436\x3\x2\x2\x2\x142F\x1430\a\x1FB\x2\x2\x1430"+
		"\x1432\x5\x2D6\x16C\x2\x1431\x1433\x5\x2D4\x16B\x2\x1432\x1431\x3\x2\x2"+
		"\x2\x1432\x1433\x3\x2\x2\x2\x1433\x1435\x3\x2\x2\x2\x1434\x142F\x3\x2"+
		"\x2\x2\x1435\x1438\x3\x2\x2\x2\x1436\x1434\x3\x2\x2\x2\x1436\x1437\x3"+
		"\x2\x2\x2\x1437\x1439\x3\x2\x2\x2\x1438\x1436\x3\x2\x2\x2\x1439\x143B"+
		"\a\x1F6\x2\x2\x143A\x143C\x5\x2CC\x167\x2\x143B\x143A\x3\x2\x2\x2\x143B"+
		"\x143C\x3\x2\x2\x2\x143C\x2D1\x3\x2\x2\x2\x143D\x143E\a\x1F5\x2\x2\x143E"+
		"\x144B\x5\x2C6\x164\x2\x143F\x1442\a\x1FB\x2\x2\x1440\x1443\x5\x2EA\x176"+
		"\x2\x1441\x1443\a\xFE\x2\x2\x1442\x1440\x3\x2\x2\x2\x1442\x1441\x3\x2"+
		"\x2\x2\x1443\x1449\x3\x2\x2\x2\x1444\x1447\a\x1FB\x2\x2\x1445\x1448\x5"+
		"\x2EA\x176\x2\x1446\x1448\a\xFE\x2\x2\x1447\x1445\x3\x2\x2\x2\x1447\x1446"+
		"\x3\x2\x2\x2\x1448\x144A\x3\x2\x2\x2\x1449\x1444\x3\x2\x2\x2\x1449\x144A"+
		"\x3\x2\x2\x2\x144A\x144C\x3\x2\x2\x2\x144B\x143F\x3\x2\x2\x2\x144B\x144C"+
		"\x3\x2\x2\x2\x144C\x144D\x3\x2\x2\x2\x144D\x1461\a\x19E\x2\x2\x144E\x144F"+
		"\x5\x2C8\x165\x2\x144F\x1450\a\x1EE\x2\x2\x1450\x1451\a\x1F8\x2\x2\x1451"+
		"\x1462\x3\x2\x2\x2\x1452\x1462\a\x1F8\x2\x2\x1453\x1455\x5\x1F2\xFA\x2"+
		"\x1454\x1456\x5\x280\x141\x2\x1455\x1454\x3\x2\x2\x2\x1455\x1456\x3\x2"+
		"\x2\x2\x1456\x145E\x3\x2\x2\x2\x1457\x1458\a\x1FB\x2\x2\x1458\x145A\x5"+
		"\x1F2\xFA\x2\x1459\x145B\x5\x280\x141\x2\x145A\x1459\x3\x2\x2\x2\x145A"+
		"\x145B\x3\x2\x2\x2\x145B\x145D\x3\x2\x2\x2\x145C\x1457\x3\x2\x2\x2\x145D"+
		"\x1460\x3\x2\x2\x2\x145E\x145C\x3\x2\x2\x2\x145E\x145F\x3\x2\x2\x2\x145F"+
		"\x1462\x3\x2\x2\x2\x1460\x145E\x3\x2\x2\x2\x1461\x144E\x3\x2\x2\x2\x1461"+
		"\x1452\x3\x2\x2\x2\x1461\x1453\x3\x2\x2\x2\x1462\x1463\x3\x2\x2\x2\x1463"+
		"\x1465\a\x1F6\x2\x2\x1464\x1466\x5\x2CC\x167\x2\x1465\x1464\x3\x2\x2\x2"+
		"\x1465\x1466\x3\x2\x2\x2\x1466\x2D3\x3\x2\x2\x2\x1467\x1468\tK\x2\x2\x1468"+
		"\x1469\a\xFF\x2\x2\x1469\x2D5\x3\x2\x2\x2\x146A\x146B\x5\x2F0\x179\x2"+
		"\x146B\x146C\a\x20C\x2\x2\x146C\x146D\a\x209\x2\x2\x146D\x146F\x3\x2\x2"+
		"\x2\x146E\x146A\x3\x2\x2\x2\x146E\x146F\x3\x2\x2\x2\x146F\x1470\x3\x2"+
		"\x2\x2\x1470\x1471\x5\x1F2\xFA\x2\x1471\x2D7\x3\x2\x2\x2\x1472\x147B\x5"+
		"\x2DA\x16E\x2\x1473\x1475\a\x134\x2\x2\x1474\x1473\x3\x2\x2\x2\x1474\x1475"+
		"\x3\x2\x2\x2\x1475\x1476\x3\x2\x2\x2\x1476\x1478\x5\x2AE\x158\x2\x1477"+
		"\x1479\tL\x2\x2\x1478\x1477\x3\x2\x2\x2\x1478\x1479\x3\x2\x2\x2\x1479"+
		"\x147B\x3\x2\x2\x2\x147A\x1472\x3\x2\x2\x2\x147A\x1474\x3\x2\x2\x2\x147B"+
		"\x2D9\x3\x2\x2\x2\x147C\x147E\x5\x2DE\x170\x2\x147D\x147F\x5\x2DC\x16F"+
		"\x2\x147E\x147D\x3\x2\x2\x2\x147E\x147F\x3\x2\x2\x2\x147F\x1486\x3\x2"+
		"\x2\x2\x1480\x1482\a\x1B0\x2\x2\x1481\x1483\a\xCF\x2\x2\x1482\x1481\x3"+
		"\x2\x2\x2\x1482\x1483\x3\x2\x2\x2\x1483\x1484\x3\x2\x2\x2\x1484\x1485"+
		"\a\x180\x2\x2\x1485\x1487\a\x1C6\x2\x2\x1486\x1480\x3\x2\x2\x2\x1486\x1487"+
		"\x3\x2\x2\x2\x1487\x1499\x3\x2\x2\x2\x1488\x1489\a\xBA\x2\x2\x1489\x148E"+
		"\tM\x2\x2\x148A\x148B\a\x1F5\x2\x2\x148B\x148C\x5\x1F2\xFA\x2\x148C\x148D"+
		"\a\x1F6\x2\x2\x148D\x148F\x3\x2\x2\x2\x148E\x148A\x3\x2\x2\x2\x148E\x148F"+
		"\x3\x2\x2\x2\x148F\x1490\x3\x2\x2\x2\x1490\x1491\a\x189\x2\x2\x1491\x1496"+
		"\tN\x2\x2\x1492\x1493\a\x1F5\x2\x2\x1493\x1494\x5\x1F2\xFA\x2\x1494\x1495"+
		"\a\x1F6\x2\x2\x1495\x1497\x3\x2\x2\x2\x1496\x1492\x3\x2\x2\x2\x1496\x1497"+
		"\x3\x2\x2\x2\x1497\x1499\x3\x2\x2\x2\x1498\x147C\x3\x2\x2\x2\x1498\x1488"+
		"\x3\x2\x2\x2\x1499\x2DB\x3\x2\x2\x2\x149A\x149B\a\x1F5\x2\x2\x149B\x149E"+
		"\x5\x2EA\x176\x2\x149C\x149D\a\x1FB\x2\x2\x149D\x149F\x5\x2EA\x176\x2"+
		"\x149E\x149C\x3\x2\x2\x2\x149E\x149F\x3\x2\x2\x2\x149F\x14A1\x3\x2\x2"+
		"\x2\x14A0\x14A2\tO\x2\x2\x14A1\x14A0\x3\x2\x2\x2\x14A1\x14A2\x3\x2\x2"+
		"\x2\x14A2\x14A3\x3\x2\x2\x2\x14A3\x14A4\a\x1F6\x2\x2\x14A4\x2DD\x3\x2"+
		"\x2\x2\x14A5\x14E2\a \x2\x2\x14A6\x14E2\a\x125\x2\x2\x14A7\x14E2\a\xE9"+
		"\x2\x2\x14A8\x14E2\a\x1F\x2\x2\x14A9\x14E2\a\x1E\x2\x2\x14AA\x14E2\a\xEA"+
		"\x2\x2\x14AB\x14E2\a\x126\x2\x2\x14AC\x14E2\a\x127\x2\x2\x14AD\x14E2\a"+
		"\x164\x2\x2\x14AE\x14E2\a\x165\x2\x2\x14AF\x14E2\a\x102\x2\x2\x14B0\x14E2"+
		"\a`\x2\x2\x14B1\x14E2\a\xB8\x2\x2\x14B2\x14E2\a\xB7\x2\x2\x14B3\x14E2"+
		"\a\x101\x2\x2\x14B4\x14E2\a\x169\x2\x2\x14B5\x14E2\a\x100\x2\x2\x14B6"+
		"\x14E2\a\x61\x2\x2\x14B7\x14B9\ar\x2\x2\x14B8\x14BA\a\x12A\x2\x2\x14B9"+
		"\x14B8\x3\x2\x2\x2\x14B9\x14BA\x3\x2\x2\x2\x14BA\x14E2\x3\x2\x2\x2\x14BB"+
		"\x14E2\a\x93\x2\x2\x14BC\x14E2\a\x132\x2\x2\x14BD\x14E2\a\xEC\x2\x2\x14BE"+
		"\x14C0\a\xD5\x2\x2\x14BF\x14C1\a\x130\x2\x2\x14C0\x14BF\x3\x2\x2\x2\x14C0"+
		"\x14C1\x3\x2\x2\x2\x14C1\x14E2\x3\x2\x2\x2\x14C2\x14E2\a\x31\x2\x2\x14C3"+
		"\x14E2\a\x33\x2\x2\x14C4\x14E2\a\x1A3\x2\x2\x14C5\x14E2\a\x1A2\x2\x2\x14C6"+
		"\x14E2\a\x176\x2\x2\x14C7\x14E2\a\x130\x2\x2\x14C8\x14E2\a$\x2\x2\x14C9"+
		"\x14E2\aZ\x2\x2\x14CA\x14E2\a\x148\x2\x2\x14CB\x14E2\a\x19C\x2\x2\x14CC"+
		"\x14E2\a\x1C3\x2\x2\x14CD\x14E2\a\xE5\x2\x2\x14CE\x14E2\a[\x2\x2\x14CF"+
		"\x14E2\a\xA3\x2\x2\x14D0\x14E2\a\xDF\x2\x2\x14D1\x14E2\a\x152\x2\x2\x14D2"+
		"\x14E2\a\x186\x2\x2\x14D3\x14E2\a\x187\x2\x2\x14D4\x14E2\a\x188\x2\x2"+
		"\x14D5\x14E2\a\x185\x2\x2\x14D6\x14E2\a\x181\x2\x2\x14D7\x14E2\a\x184"+
		"\x2\x2\x14D8\x14E2\a\x183\x2\x2\x14D9\x14E2\a\x182\x2\x2\x14DA\x14E2\a"+
		"\x1C5\x2\x2\x14DB\x14E2\at\x2\x2\x14DC\x14E2\a\x1D\x2\x2\x14DD\x14E2\a"+
		"!\x2\x2\x14DE\x14E2\a\x36\x2\x2\x14DF\x14E2\a\xEE\x2\x2\x14E0\x14E2\a"+
		"\xE1\x2\x2\x14E1\x14A5\x3\x2\x2\x2\x14E1\x14A6\x3\x2\x2\x2\x14E1\x14A7"+
		"\x3\x2\x2\x2\x14E1\x14A8\x3\x2\x2\x2\x14E1\x14A9\x3\x2\x2\x2\x14E1\x14AA"+
		"\x3\x2\x2\x2\x14E1\x14AB\x3\x2\x2\x2\x14E1\x14AC\x3\x2\x2\x2\x14E1\x14AD"+
		"\x3\x2\x2\x2\x14E1\x14AE\x3\x2\x2\x2\x14E1\x14AF\x3\x2\x2\x2\x14E1\x14B0"+
		"\x3\x2\x2\x2\x14E1\x14B1\x3\x2\x2\x2\x14E1\x14B2\x3\x2\x2\x2\x14E1\x14B3"+
		"\x3\x2\x2\x2\x14E1\x14B4\x3\x2\x2\x2\x14E1\x14B5\x3\x2\x2\x2\x14E1\x14B6"+
		"\x3\x2\x2\x2\x14E1\x14B7\x3\x2\x2\x2\x14E1\x14BB\x3\x2\x2\x2\x14E1\x14BC"+
		"\x3\x2\x2\x2\x14E1\x14BD\x3\x2\x2\x2\x14E1\x14BE\x3\x2\x2\x2\x14E1\x14C2"+
		"\x3\x2\x2\x2\x14E1\x14C3\x3\x2\x2\x2\x14E1\x14C4\x3\x2\x2\x2\x14E1\x14C5"+
		"\x3\x2\x2\x2\x14E1\x14C6\x3\x2\x2\x2\x14E1\x14C7\x3\x2\x2\x2\x14E1\x14C8"+
		"\x3\x2\x2\x2\x14E1\x14C9\x3\x2\x2\x2\x14E1\x14CA\x3\x2\x2\x2\x14E1\x14CB"+
		"\x3\x2\x2\x2\x14E1\x14CC\x3\x2\x2\x2\x14E1\x14CD\x3\x2\x2\x2\x14E1\x14CE"+
		"\x3\x2\x2\x2\x14E1\x14CF\x3\x2\x2\x2\x14E1\x14D0\x3\x2\x2\x2\x14E1\x14D1"+
		"\x3\x2\x2\x2\x14E1\x14D2\x3\x2\x2\x2\x14E1\x14D3\x3\x2\x2\x2\x14E1\x14D4"+
		"\x3\x2\x2\x2\x14E1\x14D5\x3\x2\x2\x2\x14E1\x14D6\x3\x2\x2\x2\x14E1\x14D7"+
		"\x3\x2\x2\x2\x14E1\x14D8\x3\x2\x2\x2\x14E1\x14D9\x3\x2\x2\x2\x14E1\x14DA"+
		"\x3\x2\x2\x2\x14E1\x14DB\x3\x2\x2\x2\x14E1\x14DC\x3\x2\x2\x2\x14E1\x14DD"+
		"\x3\x2\x2\x2\x14E1\x14DE\x3\x2\x2\x2\x14E1\x14DF\x3\x2\x2\x2\x14E1\x14E0"+
		"\x3\x2\x2\x2\x14E2\x2DF\x3\x2\x2\x2\x14E3\x14E7\a\x1FF\x2\x2\x14E4\x14E5"+
		"\a\x200\x2\x2\x14E5\x14E7\a\x1EF\x2\x2\x14E6\x14E3\x3\x2\x2\x2\x14E6\x14E4"+
		"\x3\x2\x2\x2\x14E7\x14F0\x3\x2\x2\x2\x14E8\x14EA\a\xAE\x2\x2\x14E9\x14E8"+
		"\x3\x2\x2\x2\x14E9\x14EA\x3\x2\x2\x2\x14EA\x14EE\x3\x2\x2\x2\x14EB\x14EF"+
		"\a\x1FF\x2\x2\x14EC\x14ED\a\x200\x2\x2\x14ED\x14EF\a\x1EF\x2\x2\x14EE"+
		"\x14EB\x3\x2\x2\x2\x14EE\x14EC\x3\x2\x2\x2\x14EF\x14F1\x3\x2\x2\x2\x14F0"+
		"\x14E9\x3\x2\x2\x2\x14F0\x14F1\x3\x2\x2\x2\x14F1\x14F6\x3\x2\x2\x2\x14F2"+
		"\x14F3\a\x1EE\x2\x2\x14F3\x14F5\x5\x2E4\x173\x2\x14F4\x14F2\x3\x2\x2\x2"+
		"\x14F5\x14F8\x3\x2\x2\x2\x14F6\x14F4\x3\x2\x2\x2\x14F6\x14F7\x3\x2\x2"+
		"\x2\x14F7\x2E1\x3\x2\x2\x2\x14F8\x14F6\x3\x2\x2\x2\x14F9\x14FE\x5\x2E4"+
		"\x173\x2\x14FA\x14FB\a\x1EE\x2\x2\x14FB\x14FD\x5\x2E4\x173\x2\x14FC\x14FA"+
		"\x3\x2\x2\x2\x14FD\x1500\x3\x2\x2\x2\x14FE\x14FC\x3\x2\x2\x2\x14FE\x14FF"+
		"\x3\x2\x2\x2\x14FF\x2E3\x3\x2\x2\x2\x1500\x14FE\x3\x2\x2\x2\x1501\x1502"+
		"\a\x20F\x2\x2\x1502\x1504\x5\x2CA\x166\x2\x1503\x1501\x3\x2\x2\x2\x1503"+
		"\x1504\x3\x2\x2\x2\x1504\x1505\x3\x2\x2\x2\x1505\x150A\x5\x2F2\x17A\x2"+
		"\x1506\x1507\a\x1EE\x2\x2\x1507\x1509\x5\x2F2\x17A\x2\x1508\x1506\x3\x2"+
		"\x2\x2\x1509\x150C\x3\x2\x2\x2\x150A\x1508\x3\x2\x2\x2\x150A\x150B\x3"+
		"\x2\x2\x2\x150B\x150E\x3\x2\x2\x2\x150C\x150A\x3\x2\x2\x2\x150D\x150F"+
		"\x5\x2CE\x168\x2\x150E\x150D\x3\x2\x2\x2\x150E\x150F\x3\x2\x2\x2\x150F"+
		"\x2E5\x3\x2\x2\x2\x1510\x1511\a\x20F\x2\x2\x1511\x1513\x5\x2CA\x166\x2"+
		"\x1512\x1510\x3\x2\x2\x2\x1512\x1513\x3\x2\x2\x2\x1513\x1514\x3\x2\x2"+
		"\x2\x1514\x1519\x5\x2F2\x17A\x2\x1515\x1516\a\x1EE\x2\x2\x1516\x1518\x5"+
		"\x2F2\x17A\x2\x1517\x1515\x3\x2\x2\x2\x1518\x151B\x3\x2\x2\x2\x1519\x1517"+
		"\x3\x2\x2\x2\x1519\x151A\x3\x2\x2\x2\x151A\x2E7\x3\x2\x2\x2\x151B\x1519"+
		"\x3\x2\x2\x2\x151C\x151F\a\x181\x2\x2\x151D\x1520\x5\x2EE\x178\x2\x151E"+
		"\x1520\x5\x2E0\x171\x2\x151F\x151D\x3\x2\x2\x2\x151F\x151E\x3\x2\x2\x2"+
		"\x1520\x1525\x3\x2\x2\x2\x1521\x1522\a\x12\x2\x2\x1522\x1523\a\x180\x2"+
		"\x2\x1523\x1524\a\x1C6\x2\x2\x1524\x1526\x5\x2EE\x178\x2\x1525\x1521\x3"+
		"\x2\x2\x2\x1525\x1526\x3\x2\x2\x2\x1526\x155B\x3\x2\x2\x2\x1527\x152B"+
		"\a\xBA\x2\x2\x1528\x152C\x5\x2EE\x178\x2\x1529\x152C\x5\x2E0\x171\x2\x152A"+
		"\x152C\x5\x2E4\x173\x2\x152B\x1528\x3\x2\x2\x2\x152B\x1529\x3\x2\x2\x2"+
		"\x152B\x152A\x3\x2\x2\x2\x152C\x152D\x3\x2\x2\x2\x152D\x153B\tP\x2\x2"+
		"\x152E\x1531\a\x1F5\x2\x2\x152F\x1532\a\x1EF\x2\x2\x1530\x1532\x5\x2E0"+
		"\x171\x2\x1531\x152F\x3\x2\x2\x2\x1531\x1530\x3\x2\x2\x2\x1532\x1538\x3"+
		"\x2\x2\x2\x1533\x1536\a\x1FB\x2\x2\x1534\x1537\a\x1EF\x2\x2\x1535\x1537"+
		"\x5\x2E0\x171\x2\x1536\x1534\x3\x2\x2\x2\x1536\x1535\x3\x2\x2\x2\x1537"+
		"\x1539\x3\x2\x2\x2\x1538\x1533\x3\x2\x2\x2\x1538\x1539\x3\x2\x2\x2\x1539"+
		"\x153A\x3\x2\x2\x2\x153A\x153C\a\x1F6\x2\x2\x153B\x152E\x3\x2\x2\x2\x153B"+
		"\x153C\x3\x2\x2\x2\x153C\x154C\x3\x2\x2\x2\x153D\x154A\a\x189\x2\x2\x153E"+
		"\x154B\a[\x2\x2\x153F\x154B\a\xA3\x2\x2\x1540\x154B\a\xDF\x2\x2\x1541"+
		"\x1548\a\x152\x2\x2\x1542\x1545\a\x1F5\x2\x2\x1543\x1546\a\x1EF\x2\x2"+
		"\x1544\x1546\x5\x2E0\x171\x2\x1545\x1543\x3\x2\x2\x2\x1545\x1544\x3\x2"+
		"\x2\x2\x1546\x1547\x3\x2\x2\x2\x1547\x1549\a\x1F6\x2\x2\x1548\x1542\x3"+
		"\x2\x2\x2\x1548\x1549\x3\x2\x2\x2\x1549\x154B\x3\x2\x2\x2\x154A\x153E"+
		"\x3\x2\x2\x2\x154A\x153F\x3\x2\x2\x2\x154A\x1540\x3\x2\x2\x2\x154A\x1541"+
		"\x3\x2\x2\x2\x154B\x154D\x3\x2\x2\x2\x154C\x153D\x3\x2\x2\x2\x154C\x154D"+
		"\x3\x2\x2\x2\x154D\x155B\x3\x2\x2\x2\x154E\x155B\x5\x2EA\x176\x2\x154F"+
		"\x1550\aZ\x2\x2\x1550\x155B\x5\x2EE\x178\x2\x1551\x155B\x5\x2EE\x178\x2"+
		"\x1552\x155B\a\xFE\x2\x2\x1553\x155B\a\x18F\x2\x2\x1554\x155B\a\x8E\x2"+
		"\x2\x1555\x155B\a]\x2\x2\x1556\x155B\a\x15C\x2\x2\x1557\x155B\a\xE0\x2"+
		"\x2\x1558\x155B\a\xDA\x2\x2\x1559\x155B\a\x65\x2\x2\x155A\x151C\x3\x2"+
		"\x2\x2\x155A\x1527\x3\x2\x2\x2\x155A\x154E\x3\x2\x2\x2\x155A\x154F\x3"+
		"\x2\x2\x2\x155A\x1551\x3\x2\x2\x2\x155A\x1552\x3\x2\x2\x2\x155A\x1553"+
		"\x3\x2\x2\x2\x155A\x1554\x3\x2\x2\x2\x155A\x1555\x3\x2\x2\x2\x155A\x1556"+
		"\x3\x2\x2\x2\x155A\x1557\x3\x2\x2\x2\x155A\x1558\x3\x2\x2\x2\x155A\x1559"+
		"\x3\x2\x2\x2\x155B\x2E9\x3\x2\x2\x2\x155C\x155D\tQ\x2\x2\x155D\x2EB\x3"+
		"\x2\x2\x2\x155E\x155F\a\x1FA\x2\x2\x155F\x1560\x5\x2EA\x176\x2\x1560\x2ED"+
		"\x3\x2\x2\x2\x1561\x1562\tR\x2\x2\x1562\x2EF\x3\x2\x2\x2\x1563\x1564\a"+
		"\x20F\x2\x2\x1564\x1566\x5\x2CA\x166\x2\x1565\x1563\x3\x2\x2\x2\x1565"+
		"\x1566\x3\x2\x2\x2\x1566\x1567\x3\x2\x2\x2\x1567\x1568\x5\x2F2\x17A\x2"+
		"\x1568\x2F1\x3\x2\x2\x2\x1569\x156C\x5\x2FE\x180\x2\x156A\x156C\a\x1F2"+
		"\x2\x2\x156B\x1569\x3\x2\x2\x2\x156B\x156A\x3\x2\x2\x2\x156C\x2F3\x3\x2"+
		"\x2\x2\x156D\x1575\a\x205\x2\x2\x156E\x156F\a\x203\x2\x2\x156F\x1575\a"+
		"\x209\x2\x2\x1570\x1571\a\x208\x2\x2\x1571\x1575\a\x20C\x2\x2\x1572\x1573"+
		"\a\x206\x2\x2\x1573\x1575\a\x20C\x2\x2\x1574\x156D\x3\x2\x2\x2\x1574\x156E"+
		"\x3\x2\x2\x2\x1574\x1570\x3\x2\x2\x2\x1574\x1572\x3\x2\x2\x2\x1575\x2F5"+
		"\x3\x2\x2\x2\x1576\x157A\a\x204\x2\x2\x1577\x1578\a\x209\x2\x2\x1578\x157A"+
		"\a\x20C\x2\x2\x1579\x1576\x3\x2\x2\x2\x1579\x1577\x3\x2\x2\x2\x157A\x2F7"+
		"\x3\x2\x2\x2\x157B\x157F\a\x202\x2\x2\x157C\x157D\a\x203\x2\x2\x157D\x157F"+
		"\a\x20C\x2\x2\x157E\x157B\x3\x2\x2\x2\x157E\x157C\x3\x2\x2\x2\x157F\x2F9"+
		"\x3\x2\x2\x2\x1580\x1584\a\x20A\x2\x2\x1581\x1582\a\x20B\x2\x2\x1582\x1584"+
		"\a\x20B\x2\x2\x1583\x1580\x3\x2\x2\x2\x1583\x1581\x3\x2\x2\x2\x1584\x2FB"+
		"\x3\x2\x2\x2\x1585\x1586\a\x1F5\x2\x2\x1586\x1587\a\x1F9\x2\x2\x1587\x1588"+
		"\a\x1F6\x2\x2\x1588\x2FD\x3\x2\x2\x2\x1589\x158A\tS\x2\x2\x158A\x2FF\x3"+
		"\x2\x2\x2\x158B\x158C\tT\x2\x2\x158C\x301\x3\x2\x2\x2\x158D\x158E\tU\x2"+
		"\x2\x158E\x303\x3\x2\x2\x2\x2DC\x307\x30C\x313\x315\x31D\x324\x329\x32F"+
		"\x346\x352\x357\x35C\x363\x36D\x372\x37A\x37C\x380\x384\x389\x38E\x393"+
		"\x399\x3A7\x3AC\x3AF\x3B5\x3BE\x3CC\x3D4\x3DE\x3E1\x3E6\x3EB\x3F2\x3F7"+
		"\x3FD\x402\x409\x412\x419\x41B\x427\x431\x436\x442\x447\x44C\x44F\x45C"+
		"\x468\x46D\x472\x47E\x483\x48B\x48D\x491\x495\x49A\x49F\x4A4\x4B0\x4B5"+
		"\x4B9\x4BE\x4C4\x4CB\x4D5\x4DA\x4DD\x4E1\x4E6\x4EC\x4FE\x503\x508\x50A"+
		"\x511\x518\x51B\x51E\x521\x52C\x538\x53C\x53F\x548\x550\x558\x55B\x562"+
		"\x566\x56D\x573\x59C\x5B8\x5BF\x5C4\x5CF\x5D2\x5DD\x5E5\x5E9\x5F5\x5F8"+
		"\x5FE\x601\x606\x60B\x60F\x619\x623\x629\x634\x639\x63D\x645\x64D\x652"+
		"\x655\x657\x65A\x663\x668\x66F\x672\x675\x679\x67C\x684\x689\x68E\x695"+
		"\x69F\x6AF\x6B5\x6BF\x6C9\x6D0\x6D5\x6DB\x6E5\x6EA\x6F1\x6F6\x6FC\x6FF"+
		"\x702\x713\x718\x721\x726\x72C\x72F\x736\x739\x740\x745\x749\x74E\x753"+
		"\x75D\x763\x76D\x772\x779\x77F\x783\x786\x789\x79A\x79F\x7A7\x7B5\x7BC"+
		"\x7CC\x7D5\x7D7\x7EC\x7FC\x805\x80A\x80E\x811\x81B\x827\x82D\x835\x839"+
		"\x83C\x84B\x84F\x854\x857\x864\x868\x874\x879\x87D\x881\x887\x88A\x88D"+
		"\x8A8\x8AE\x8B2\x8BD\x8C4\x8C8\x8CB\x8D1\x8DA\x8E2\x8E6\x8EA\x8F2\x8FB"+
		"\x901\x903\x911\x925\x929\x930\x934\x938\x93C\x948\x94C\x95A\x960\x967"+
		"\x96C\x976\x97C\x97E\x987\x991\x996\x9A5\x9A9\x9AC\x9B0\x9B8\x9BA\x9BE"+
		"\x9C6\x9CD\x9D2\x9D4\x9D9\x9DE\x9E6\x9ED\x9F1\x9F4\xA00\xA06\xA0E\xA18"+
		"\xA23\xA26\xA2D\xA30\xA37\xA42\xA48\xA4C\xA56\xA59\xA5F\xA6A\xA6C\xA6E"+
		"\xA71\xA75\xA78\xA7C\xA80\xA85\xA90\xA94\xA9C\xA9F\xAA4\xAA6\xAAF\xAB9"+
		"\xABE\xAC4\xAC8\xACB\xAD3\xAD6\xADA\xADE\xAE3\xAE6\xAEA\xAEE\xAF2\xAFE"+
		"\xB0C\xB11\xB15\xB1E\xB22\xB2A\xB2D\xB30\xB34\xB37\xB3A\xB3D\xB41\xB4B"+
		"\xB52\xB59\xB5E\xB64\xB68\xB6D\xB74\xB7A\xB81\xB84\xB87\xB8B\xB90\xB94"+
		"\xB96\xBA3\xBAA\xBB8\xBBB\xBC5\xBC9\xBD1\xBDD\xBE7\xBEC\xBF6\xBFE\xC01"+
		"\xC07\xC0B\xC10\xC1A\xC1F\xC2C\xC38\xC3D\xC47\xC4C\xC4E\xC53\xC57\xC5D"+
		"\xC61\xC6E\xC72\xC7C\xC7F\xC81\xC86\xC8F\xC9C\xCA4\xCAD\xCB1\xCB6\xCC1"+
		"\xCC3\xCD3\xCD8\xCDE\xCE4\xCF6\xCFD\xD00\xD03\xD0B\xD0E\xD16\xD18\xD1C"+
		"\xD1F\xD24\xD26\xD2A\xD36\xD3F\xD47\xD4C\xD50\xD55\xD58\xD60\xD68\xD6E"+
		"\xD71\xD74\xD7C\xD86\xD92\xD99\xD9D\xDA1\xDA4\xDA7\xDAC\xDB1\xDB4\xDB7"+
		"\xDBD\xDC0\xDC6\xDC9\xDCC\xDD1\xDD4\xDDC\xDE2\xDEC\xDF1\xDFA\xE04\xE08"+
		"\xE0A\xE0D\xE19\xE1D\xE20\xE34\xE39\xE3E\xE45\xE48\xE51\xE58\xE5D\xE61"+
		"\xE69\xE6F\xE77\xE7A\xE82\xE8A\xE8D\xE90\xE99\xE9F\xEA5\xEA7\xEB4\xEB6"+
		"\xEBF\xEC1\xEC5\xECB\xECF\xEDD\xEE3\xEEC\xEF6\xF01\xF07\xF0C\xF17\xF1B"+
		"\xF22\xF27\xF2B\xF31\xF35\xF42\xF47\xF50\xF52\xF54\xF5C\xF6D\xF75\xF81"+
		"\xF89\xF91\xF9A\xF9D\xFA4\xFAC\xFB3\xFB7\xFBE\xFC2\xFC7\xFCB\xFD3\xFD7"+
		"\xFDE\xFE7\xFF5\x1002\x1007\x101B\x101F\x1022\x1029\x102C\x1030\x1033"+
		"\x103A\x103D\x1043\x1046\x104A\x104D\x1054\x1059\x1067\x106D\x106F\x1073"+
		"\x107B\x1087\x1090\x1098\x109C\x10A7\x10BD\x10C0\x10C3\x10C8\x10CD\x10D2"+
		"\x10D7\x10E0\x10E3\x10E5\x10E9\x10F0\x10F7\x10FF\x1104\x1109\x110E\x1114"+
		"\x1117\x111B\x1125\x1131\x1133\x113A\x113E\x1147\x1150\x115E\x1169\x116D"+
		"\x1170\x1179\x117F\x1189\x1191\x1194\x1197\x11A0\x11A5\x11AE\x11B4\x11B9"+
		"\x11BC\x11C1\x11C6\x11CA\x11D0\x11D6\x11DF\x11E4\x11EC\x11F0\x11F5\x11FB"+
		"\x1202\x1207\x120E\x1212\x1217\x121F\x1222\x1225\x1228\x122C\x1231\x1236"+
		"\x123A\x1241\x1246\x1248\x1253\x1257\x1259\x1264\x126F\x1278\x127B\x127F"+
		"\x1282\x1286\x1293\x1298\x12A0\x12A7\x12AC\x12B0\x12B5\x12BA\x12BD\x12C4"+
		"\x12CE\x12D6\x12DA\x12E4\x12E7\x12E9\x12F3\x12F5\x12FB\x1301\x1303\x1311"+
		"\x1313\x131B\x131E\x1327\x1330\x133A\x133E\x1343\x1347\x134A\x134E\x1355"+
		"\x1361\x136C\x136F\x1373\x1386\x138B\x1392\x139F\x13A9\x13AE\x13B7\x13BF"+
		"\x13C7\x13CD\x13D2\x13D7\x13DB\x13E0\x13E3\x13E9\x13ED\x13F2\x13FB\x1401"+
		"\x1406\x140D\x1417\x141B\x1421\x1426\x142B\x142D\x1432\x1436\x143B\x1442"+
		"\x1447\x1449\x144B\x1455\x145A\x145E\x1461\x1465\x146E\x1474\x1478\x147A"+
		"\x147E\x1482\x1486\x148E\x1496\x1498\x149E\x14A1\x14B9\x14C0\x14E1\x14E6"+
		"\x14E9\x14EE\x14F0\x14F6\x14FE\x1503\x150A\x150E\x1512\x1519\x151F\x1525"+
		"\x152B\x1531\x1536\x1538\x153B\x1545\x1548\x154A\x154C\x155A\x1565\x156B"+
		"\x1574\x1579\x157E\x1583";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
} // namespace MasudaManager.Utility
